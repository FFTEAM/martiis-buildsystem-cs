From 427b23554a8d82177a5d86c755630566f7975286 Mon Sep 17 00:00:00 2001
From: Schischu <schischu@duckbox>
Date: Fri, 31 May 2013 11:30:50 +0200
Subject: [PATCH] [aio-grab] add st support

---
 ...dbef3aab36113d5c6fc34bb11b-ADD_ST_SUPPORT.patch |  303 ++++++++++++++++++++
 .../series                                         |    1 +
 2 files changed, 304 insertions(+)
 create mode 100644 patches/aio-grab-47983a78821c0fdbef3aab36113d5c6fc34bb11b/aio-grab-47983a78821c0fdbef3aab36113d5c6fc34bb11b-ADD_ST_SUPPORT.patch
 create mode 100644 patches/aio-grab-47983a78821c0fdbef3aab36113d5c6fc34bb11b/series

diff --git a/patches/aio-grab-47983a78821c0fdbef3aab36113d5c6fc34bb11b/aio-grab-47983a78821c0fdbef3aab36113d5c6fc34bb11b-ADD_ST_SUPPORT.patch b/patches/aio-grab-47983a78821c0fdbef3aab36113d5c6fc34bb11b/aio-grab-47983a78821c0fdbef3aab36113d5c6fc34bb11b-ADD_ST_SUPPORT.patch
new file mode 100644
index 0000000..10ebcd6
--- /dev/null
+++ b/patches/aio-grab-47983a78821c0fdbef3aab36113d5c6fc34bb11b/aio-grab-47983a78821c0fdbef3aab36113d5c6fc34bb11b-ADD_ST_SUPPORT.patch
@@ -0,0 +1,303 @@
+--- aio-grab-47983a78821c0fdbef3aab36113d5c6fc34bb11b/main.c.org	2013-05-26 13:32:36.000000000 +0200
++++ aio-grab-47983a78821c0fdbef3aab36113d5c6fc34bb11b/main.c	2013-05-31 11:26:31.199745006 +0200
+@@ -37,9 +37,93 @@
+ #include <sys/mman.h>
+ #include <linux/types.h>
+ #include <linux/fb.h>
++#include <bpamem.h>
+ #include "png.h"
+ #include "jpeglib.h"
+ 
++#define OUT(x) \
++	out[outiter]=(unsigned char)*(decode_surface + x)&0xFF; \
++	outiter+=outinc;
++
++#define OUT4(x) \
++	OUT(x + 0x03); \
++	OUT(x + 0x02); \
++	OUT(x + 0x01); \
++	OUT(x + 0x00);
++
++#define OUT8(x) \
++	OUT4(x + 0x04); \
++	OUT4(x + 0x00);
++
++#define OUT16A(x) \
++	OUT8(x); \
++	OUT8(x + 0x40);
++
++#define OUT16A_C(x) \
++	OUT4(x); \
++	OUT4(x + 0x20); \
++	OUT4(x + 0x80); \
++	OUT4(x + 0xA0);
++
++//x: macroblock address
++//l: line 0-15
++#define OUT16(x,l) \
++	OUT16A(x + (l/4) * 0x10 + (l%2) * 0x80 + ((l/2)%2?0x00:0x08));
++
++//x: macroblock address
++//l: line 0-7
++//b: 0=cr 1=cb
++#define OUT16_C(x,l,b) \
++	OUT16A_C(x + (l/4) * 0x10 + (l%2) * 0x40 + ((l/2)%2?0x00:0x08) + (b?0x04:0x00));
++
++//x: first macroblock address
++//l: line 0-15 of macroblock line
++//s: stride by factor 16, e.g. 1280=80
++#define OUTL(x,l,s) \
++	{ \
++		int iMacro; \
++		for(iMacro = 0; iMacro < s; iMacro++) \
++		{ \
++			OUT16(x + iMacro*0x200, l); \
++		} \
++	}
++
++//x: first macroblock address
++//l: line 0-7
++//s: stride by factor 16, e.g. 1280=80
++//b: 0=cr 1=cb
++#define OUTL_C(x,l,s, b) \
++	{ \
++		int iMacro; \
++		for(iMacro = 0; iMacro < s; iMacro++) \
++		{ \
++			OUT16_C(x + iMacro*0x200, l, b); \
++		} \
++	}
++
++//x: first macroblock address
++//s: stride by factor 16, e.g. 1280=80
++#define OUTL_16(x,s) \
++	{ \
++		int l; \
++		for(l = 0; l < 16; l++) \
++		{ \
++			OUTL(x, l, s); \
++		} \
++	}
++
++//x: first macroblock address
++//s: stride by factor 16, e.g. 1280=80
++//b: 0=cr 1=cb
++#define OUTL_16_C(x,s,b) \
++	{ \
++		int l; \
++		for(l = 0; l < 8; l++) \
++		{ \
++			OUTL_C(x, l, s, b); \
++		} \
++	}
++
+ #define CLAMP(x)    ((x < 0) ? 0 : ((x > 255) ? 255 : x))
+ #define SWAP(x,y)	{ x ^= y; y ^= x; x ^= y; }
+ 
+@@ -82,8 +166,8 @@
+ void (*resize)(const unsigned char *source, unsigned char *dest, int xsource, int ysource, int xdest, int ydest, int colors);
+ void combine(unsigned char *output, const unsigned char *video, const unsigned char *osd, int vleft, int vtop, int vwidth, int vheight, int xres, int yres);
+ 
+-enum {UNKNOWN,PALLAS,VULCAN,XILLEON,BRCM7400,BRCM7401,BRCM7405,BRCM7335,BRCM7358};
+-char *stb_name[]={"unknown","Pallas","Vulcan","Xilleon","Brcm7400","Brcm7401","Brcm7405","Brcm7335","Brcm7358"};
++enum {UNKNOWN,PALLAS,VULCAN,XILLEON,BRCM7400,BRCM7401,BRCM7405,BRCM7335,BRCM7358,ST};
++char *stb_name[]={"unknown","Pallas","Vulcan","Xilleon","Brcm7400","Brcm7401","Brcm7405","Brcm7335","Brcm7358","ST"};
+ int stb_type=UNKNOWN;
+ 
+ // main program
+@@ -124,6 +208,7 @@
+ 		if (strcasestr(buf,"PALLAS")) stb_type=PALLAS;
+ 		if (strcasestr(buf,"XILLEON")) stb_type=XILLEON;
+ 		if (strcasestr(buf,"BCM7401") || strcasestr(buf,"BCMFB")) stb_type=BRCM7401;
++		if (strcasestr(buf,"STi")) stb_type=ST;
+ 	}
+ 	pclose(pipe);
+ 
+@@ -645,7 +730,156 @@
+ 	char buf[256];
+ 	FILE *pipe;
+ 
+-	if (stb_type == BRCM7401 || stb_type == BRCM7400 || stb_type == BRCM7405 || stb_type == BRCM7335 || stb_type == BRCM7358)
++	if (stb_type == ST)
++	{
++		int yblock, xblock, iyblock, yblockoffset, offset, outiter, outoffset, outinc;
++		unsigned char *out;
++		int fd_bpa;
++		int ioctlres;
++		BPAMemMapMemData bpa_data;
++		char bpa_mem_device[30];
++		char *decode_surface;
++	
++		pipe = fopen("/proc/stb/vmpeg/0/xres","r");
++		if (pipe)
++		{
++			while (fgets(buf,sizeof(buf),pipe))
++			{
++				sscanf(buf,"%x",&stride);
++			}
++			fclose(pipe);
++		}
++		pipe = fopen("/proc/stb/vmpeg/0/yres","r");
++		if (pipe)
++		{
++			while (fgets(buf,sizeof(buf),pipe))
++			{
++				sscanf(buf,"%x",&res);
++			}
++			fclose(pipe);
++		}
++
++		//if stride and res is zero than this is most probably a stillpicture
++		if(stride == 0) stride = 1280;
++		if(res == 0) res = 720;
++
++		luma   = (unsigned char *)malloc(stride * res);
++		chroma = (unsigned char *)malloc(stride * res / 2);
++
++		fd_bpa = open("/dev/bpamem0", O_RDWR);
++	
++		if(fd_bpa < 0)
++		{
++			fprintf(stderr, "cannot access /dev/bpamem0! err = %d\n", fd_bpa);
++			return 1;
++		}
++	
++		bpa_data.bpa_part  = "LMI_VID";
++
++
++		pipe = fopen("/proc/bpa2","r");
++		if (pipe)
++		{
++			unsigned char found_part = 0;
++			while (fgets(buf,sizeof(buf),pipe))
++			{
++				if(found_part || strstr(buf, bpa_data.bpa_part) != NULL)
++				{
++					found_part = 1;
++					if (sscanf(buf, "- %lu B at %lx", &bpa_data.mem_size, &bpa_data.phys_addr) == 2)
++						break;;
++				}
++			}
++			fclose(pipe);
++		}
++
++		printf("Using bpa2 part %s - 0x%lx %lu\n", bpa_data.bpa_part, bpa_data.phys_addr, bpa_data.mem_size);
++
++		//bpa_data.phys_addr = 0x4a824000;
++		//bpa_data.mem_size = 28311552;
++	
++		ioctlres = ioctl(fd_bpa, BPAMEMIO_MAPMEM, &bpa_data); // request memory from bpamem
++		if(ioctlres)
++		{
++			fprintf(stderr, "cannot map required mem\n");
++			return 1;
++		}
++	
++		sprintf(bpa_mem_device, "/dev/bpamem%d", bpa_data.device_num);
++		close(fd_bpa);
++	
++		fd_bpa = open(bpa_mem_device, O_RDWR);
++	
++		// if somebody forgot to add all bpamem devs then this gets really bad here
++		if(fd_bpa < 0)
++		{
++			fprintf(stderr, "cannot access %s! err = %d\n", bpa_mem_device, fd_bpa);
++			return 1;
++		}
++	
++		decode_surface = (char *)mmap(0, bpa_data.mem_size, PROT_WRITE|PROT_READ, MAP_SHARED, fd_bpa, 0);
++	
++		if(decode_surface == MAP_FAILED) 
++		{
++			fprintf(stderr, "could not map bpa mem");
++			close(fd_bpa);
++			return 1;
++		}
++
++		//luma
++		offset = 0;
++		yblock = res/16;  //45
++		xblock = stride/16; //80
++		yblockoffset = stride*32; //0xA000
++		outiter = 0;
++		outoffset = 0;
++		outinc = 1;
++		out = luma;
++		
++		for (iyblock = 0; iyblock < yblock; iyblock++)
++		{
++			OUTL_16(((iyblock/2) * yblockoffset) + (iyblock%2?0x0100:0x0000) + offset, xblock);
++		}
++		
++		//chroma
++		offset = ((stride*res + yblockoffset/2 /*round up*/) / yblockoffset) * yblockoffset;
++		//cb
++		yblock = res/16; //45
++		xblock = (stride/2)/16; //40
++		yblockoffset = (stride/2)*8/*h in block*/*2/*y blocks*/*2/*cr cb*/; //16pixel per x block and 2 y blocks//0x5000
++		outiter = 0;
++		outinc = 2;
++		out = chroma;
++		
++		for (iyblock = 0; iyblock < yblock; iyblock++)
++		{
++			OUTL_16_C(((iyblock/2) * yblockoffset) + (iyblock%2?0x0100:0x0000) + offset, xblock, 1);
++		}
++
++		//cr
++		yblock = res/16; //45
++		xblock = (stride/2)/16; //40
++		yblockoffset = (stride/2)*8/*h in block*/*2/*y blocks*/*2/*cr cb*/; //16pixel per x block and 2 y blocks//0x5000
++		outiter = 1;
++		outinc = 2;
++		out = chroma;
++		
++		for (iyblock = 0; iyblock < yblock; iyblock++)
++		{
++			OUTL_16_C(((iyblock/2) * yblockoffset) + (iyblock%2?0x0100:0x0000) + offset, xblock, 0);
++		}
++		
++		ioctlres = ioctl(fd_bpa, BPAMEMIO_UNMAPMEM); // request memory from bpamem
++		if(ioctlres)
++		{
++			fprintf(stderr, "cannot unmap required mem\n");
++			close(fd_bpa);
++			return 1;
++		}
++
++		close(fd_bpa);
++	}
++	else if (stb_type == BRCM7401 || stb_type == BRCM7400 || stb_type == BRCM7405 || stb_type == BRCM7335 || stb_type == BRCM7358)
+ 	{
+ 		// grab brcm7401 pic from decoder memory
+ 		const unsigned char* data = (unsigned char*)mmap(0, 100, PROT_READ, MAP_SHARED, mem_fd, (stb_type == BRCM7358) ? 0x10600000 : 0x10100000);
+@@ -1059,12 +1293,14 @@
+ 			// now we do 4 pixels on each iteration this is more code but much faster
+ 			int Y=yuv2rgbtable_y[luma[pos]];
+ 
++			//p0:0
+ 			video[out1]=CLAMP((Y + RU)>>16);
+ 			video[out1+1]=CLAMP((Y - GV - GU)>>16);
+ 			video[out1+2]=CLAMP((Y + BV)>>16);
+ 
+ 			Y=yuv2rgbtable_y[luma[stride+pos]];
+ 
++			//p1:0
+ 			video[out1+rgbstride]=CLAMP((Y + RU)>>16);
+ 			video[out1+1+rgbstride]=CLAMP((Y - GV - GU)>>16);
+ 			video[out1+2+rgbstride]=CLAMP((Y + BV)>>16);
+@@ -1074,12 +1310,14 @@
+ 
+ 			Y=yuv2rgbtable_y[luma[pos]];
+ 
++			//p0:1
+ 			video[out1]=CLAMP((Y + RU)>>16);
+ 			video[out1+1]=CLAMP((Y - GV - GU)>>16);
+ 			video[out1+2]=CLAMP((Y + BV)>>16);
+ 
+ 			Y=yuv2rgbtable_y[luma[stride+pos]];
+ 
++			//p1:1
+ 			video[out1+rgbstride]=CLAMP((Y + RU)>>16);
+ 			video[out1+1+rgbstride]=CLAMP((Y - GV - GU)>>16);
+ 			video[out1+2+rgbstride]=CLAMP((Y + BV)>>16);
diff --git a/patches/aio-grab-47983a78821c0fdbef3aab36113d5c6fc34bb11b/series b/patches/aio-grab-47983a78821c0fdbef3aab36113d5c6fc34bb11b/series
new file mode 100644
index 0000000..69f2825
--- /dev/null
+++ b/patches/aio-grab-47983a78821c0fdbef3aab36113d5c6fc34bb11b/series
@@ -0,0 +1 @@
+aio-grab-47983a78821c0fdbef3aab36113d5c6fc34bb11b-ADD_ST_SUPPORT.patch
-- 
1.7.9.5

