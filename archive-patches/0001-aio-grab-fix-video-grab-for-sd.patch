From e303fa69ae35c61b606aaa79753a2385c499b225 Mon Sep 17 00:00:00 2001
From: Schischu <schischu@duckbox>
Date: Sun, 2 Jun 2013 12:32:15 +0200
Subject: [PATCH] [aio-grab] fix video grab for sd

---
 ...dbef3aab36113d5c6fc34bb11b-ADD_ST_SUPPORT.patch |  243 ++++++++------------
 1 file changed, 98 insertions(+), 145 deletions(-)

diff --git a/patches/aio-grab-47983a78821c0fdbef3aab36113d5c6fc34bb11b/aio-grab-47983a78821c0fdbef3aab36113d5c6fc34bb11b-ADD_ST_SUPPORT.patch b/patches/aio-grab-47983a78821c0fdbef3aab36113d5c6fc34bb11b/aio-grab-47983a78821c0fdbef3aab36113d5c6fc34bb11b-ADD_ST_SUPPORT.patch
index 5b03b49..7bce607 100644
--- a/patches/aio-grab-47983a78821c0fdbef3aab36113d5c6fc34bb11b/aio-grab-47983a78821c0fdbef3aab36113d5c6fc34bb11b-ADD_ST_SUPPORT.patch
+++ b/patches/aio-grab-47983a78821c0fdbef3aab36113d5c6fc34bb11b/aio-grab-47983a78821c0fdbef3aab36113d5c6fc34bb11b-ADD_ST_SUPPORT.patch
@@ -1,6 +1,6 @@
 --- aio-grab-47983a78821c0fdbef3aab36113d5c6fc34bb11b/main.c.org	2013-05-26 13:32:36.000000000 +0200
-+++ aio-grab-47983a78821c0fdbef3aab36113d5c6fc34bb11b/main.c	2013-05-31 15:48:54.781599528 +0200
-@@ -37,9 +37,139 @@
++++ aio-grab-47983a78821c0fdbef3aab36113d5c6fc34bb11b/main.c	2013-06-02 12:31:40.450417839 +0200
+@@ -37,9 +37,47 @@
  #include <sys/mman.h>
  #include <linux/types.h>
  #include <linux/fb.h>
@@ -9,8 +9,8 @@
  #include "jpeglib.h"
  
 +#define OUT(x) \
-+	out[outiter]=(unsigned char)*(decode_surface + x)&0xFF; \
-+	outiter+=outinc;
++	out[OUTITER]=(unsigned char)*(decode_surface + x)&0xFF; \
++	OUTITER+=OUTINC;
 +
 +#define OUT4(x) \
 +	OUT(x + 0x03); \
@@ -26,12 +26,6 @@
 +	OUT8(x); \
 +	OUT8(x + 0x40);
 +
-+#define OUT_CH_16A(x) \
-+	OUT4(x); \
-+	OUT4(x + 0x20); \
-+	OUT4(x + 0x80); \
-+	OUT4(x + 0xA0);
-+
 +#define OUT_CH_8A(x) \
 +	OUT4(x); \
 +	OUT4(x + 0x20);
@@ -42,13 +36,6 @@
 +#define OUT_LU_16(x,l) \
 +	OUT_LU_16A(x + (l/4) * 0x10 + (l%2) * 0x80 + ((l/2)%2?0x00:0x08));
 +
-+//pppppppppppppppp
-+//x: macroblock address
-+//l: line 0-7
-+//b: 0=cr 1=cb
-+#define OUT_CH_16(x,l,b) \
-+	OUT_CH_16A(x + (l/4) * 0x10 + (l%2) * 0x40 + ((l/2)%2?0x00:0x08) + (b?0x04:0x00));
-+
 +//pppppppp
 +//x: macroblock address
 +//l: line 0-7
@@ -58,89 +45,10 @@
 +
 +//----
 +
-+//pppppppppppppppp pppp...
-+//x: first macroblock address
-+//l: line 0-15 of macroblock line
-+//s: stride by factor 16, e.g. 1280=80
-+#define OUT_LU_16L(x,l,s) \
-+	{ \
-+		int iMacro; \
-+		for(iMacro = 0; iMacro < s; iMacro++) \
-+		{ \
-+			OUT_LU_16(x + iMacro*0x200, l); \
-+		} \
-+	}
-+
-+//pppppppppppppppp pppp...
-+//x: first macroblock address
-+//l: line 0-7
-+//s: stride by factor 16, e.g. 1280=80
-+//b: 0=cr 1=cb
-+#define OUT_CH_16L(x,l,s, b) \
-+	{ \
-+		int iMacro; \
-+		for(iMacro = 0; iMacro < s; iMacro++) \
-+		{ \
-+			OUT_CH_16(x + iMacro*0x200, l, b); \
-+		} \
-+	}
-+
-+//pppppppp pppp...
-+//x: first macroblock address
-+//l: line 0-7
-+//s: stride by factor 8, e.g. 360=45
-+//b: 0=cr 1=cb
-+#define OUT_CH_8L(x,l,s, b) \
-+	{ \
-+		int iMacro; \
-+		for(iMacro = 0; iMacro < s; iMacro++) \
-+		{ \
-+			OUT_CH_8(x + (iMacro/2)*0x200 + (iMacro%2?0x80:0x00), l, b); \
-+		} \
-+	}
-+
-+//----
-+
-+//x: first macroblock address
-+//s: stride by factor 16, e.g. 1280=80
-+#define OUT_LU_16L_16(x,s) \
-+	{ \
-+		int l; \
-+		for(l = 0; l < 16; l++) \
-+		{ \
-+			OUT_LU_16L(x, l, s); \
-+		} \
-+	}
-+
-+//x: first macroblock address
-+//s: stride by factor 16, e.g. 1280=80
-+//b: 0=cr 1=cb
-+#define OUT_CH_16L_8(x,s,b) \
-+	{ \
-+		int l; \
-+		for(l = 0; l < 8; l++) \
-+		{ \
-+			OUT_CH_16L(x, l, s, b); \
-+		} \
-+	}
-+
-+//x: first macroblock address
-+//s: stride by factor 8, e.g. 360=45
-+//b: 0=cr 1=cb
-+#define OUT_CH_8L_8(x,s,b) \
-+	{ \
-+		int l; \
-+		fprintf(stderr, "MB: 0x%08x\n", x); \
-+		for(l = 0; l < 8; l++) \
-+		{ \
-+			OUT_CH_8L(x, l, s, b); \
-+		} \
-+	}
-+
  #define CLAMP(x)    ((x < 0) ? 0 : ((x > 255) ? 255 : x))
  #define SWAP(x,y)	{ x ^= y; y ^= x; x ^= y; }
  
-@@ -82,8 +212,8 @@
+@@ -82,8 +120,8 @@
  void (*resize)(const unsigned char *source, unsigned char *dest, int xsource, int ysource, int xdest, int ydest, int colors);
  void combine(unsigned char *output, const unsigned char *video, const unsigned char *osd, int vleft, int vtop, int vwidth, int vheight, int xres, int yres);
  
@@ -151,7 +59,7 @@
  int stb_type=UNKNOWN;
  
  // main program
-@@ -124,6 +254,7 @@
+@@ -124,6 +162,7 @@
  		if (strcasestr(buf,"PALLAS")) stb_type=PALLAS;
  		if (strcasestr(buf,"XILLEON")) stb_type=XILLEON;
  		if (strcasestr(buf,"BCM7401") || strcasestr(buf,"BCMFB")) stb_type=BRCM7401;
@@ -159,15 +67,17 @@
  	}
  	pclose(pipe);
  
-@@ -645,7 +776,176 @@
+@@ -645,7 +684,221 @@
  	char buf[256];
  	FILE *pipe;
  
 -	if (stb_type == BRCM7401 || stb_type == BRCM7400 || stb_type == BRCM7405 || stb_type == BRCM7335 || stb_type == BRCM7358)
 +	if (stb_type == ST)
 +	{
-+		int yblock, xblock, iyblock, yblockoffset, offset, outiter, outoffset, outinc;
++		int yblock, xblock, iyblock, ixblock, yblockoffset, offset, layer_offset, OUTITER, OUTINC, OUTITERoffset;
++		int stride_half;
 +		unsigned char *out;
++		unsigned char even, cr;
 +		int fd_bpa;
 +		int ioctlres;
 +		BPAMemMapMemData bpa_data;
@@ -197,6 +107,8 @@
 +		if(stride == 0) stride = 720;
 +		if(res == 0) res = 576;
 +
++		stride_half = stride / 2;
++
 +		luma   = (unsigned char *)malloc(stride * res);
 +		chroma = (unsigned char *)malloc(stride * res / 2);
 +
@@ -207,7 +119,7 @@
 +		if(fd_bpa < 0)
 +		{
 +			fprintf(stderr, "cannot access /dev/bpamem0! err = %d\n", fd_bpa);
-+			return 1;
++			return;
 +		}
 +	
 +		bpa_data.bpa_part  = "LMI_VID";
@@ -247,7 +159,7 @@
 +		if(ioctlres)
 +		{
 +			fprintf(stderr, "cannot map required mem\n");
-+			return 1;
++			return;
 +		}
 +	
 +		sprintf(bpa_mem_device, "/dev/bpamem%d", bpa_data.device_num);
@@ -259,7 +171,7 @@
 +		if(fd_bpa < 0)
 +		{
 +			fprintf(stderr, "cannot access %s! err = %d\n", bpa_mem_device, fd_bpa);
-+			return 1;
++			return;
 +		}
 +	
 +		decode_surface = (char *)mmap(0, bpa_data.mem_size, PROT_WRITE|PROT_READ, MAP_SHARED, fd_bpa, 0);
@@ -268,67 +180,108 @@
 +		{
 +			fprintf(stderr, "could not map bpa mem");
 +			close(fd_bpa);
-+			return 1;
++			return;
 +		}
 +
 +		//luma
-+		offset = 0;
++		layer_offset = 0;
++		
++		//we do not have to round that every luma res will be a multiple of 16
 +		yblock = res/16; //45
 +		xblock = stride/16; //80
-+		printf("yblock: %u xblock:%u\n", yblock, xblock);
-+		yblockoffset = stride*32; //0xA000
-+		outiter = 0;
-+		outoffset = 0;
-+		outinc = 1;
-+		out = luma;
 +		
-+		for (iyblock = 0; iyblock < yblock; iyblock++)
++		//thereby yblockoffset does also not to be rounded up
++		yblockoffset = xblock * 256/*16x16px*/ * 2/*2 block rows*/; //0xA000 for 1280
++		
++		printf("yblock: %u xblock:%u yblockoffset:0x%x\n", yblock, xblock, yblockoffset);
++		
++		OUTITER       = 0;
++		OUTITERoffset = 0;
++		OUTINC        = 1; /*no spaces between pixel*/
++		out           = luma;
++		
++		for(even = 0; even < 2; even++)
 +		{
-+			OUT_LU_16L_16(((iyblock/2) * yblockoffset) + (iyblock%2?0x0100:0x0000) + offset, xblock);
++			offset        = layer_offset + even * 0x100;
++			OUTITERoffset = even * xblock * 256/*16x16px*/;
++			
++			for (iyblock = even; iyblock < yblock; iyblock+=2)
++			{
++				for (ixblock = 0; ixblock < xblock; ixblock++)
++				{
++					int line; 
++					
++					OUTITER = OUTITERoffset;
++					for (line = 0; line < 16; line++)
++					{
++						OUT_LU_16(offset, line);
++						OUTITER += (stride - 16 /*we have already incremented by 16*/);
++					}
++					
++					//0x00, 0x200, ...
++					offset += 0x200;
++					OUTITERoffset += 16;
++				}
++				OUTITERoffset += stride * 31;
++			}
 +		}
-+		printf("Itr: %lu\n", outiter);
 +		
 +		//chroma
-+		offset = ((stride*res + yblockoffset/2 /*round up*/) / yblockoffset) * yblockoffset;
-+#if 1
++		layer_offset = ((stride*res + yblockoffset/2 /*round up*/) / yblockoffset) * yblockoffset;
++
 +		//cb
++		//we do not have to round that every chroma y res will be a multiple of 16 
++		//and every chroma x res /2 will be a multiple of 8
 +		yblock = res/16; //45
-+		xblock = (stride/2)/8; //40
-+		printf("yblock: %u xblock:%u\n", yblock, xblock);
-+		yblockoffset = (stride/2)*8/*h in block*/*2/*y blocks*/*2/*cr cb*/; //16pixel per x block and 2 y blocks//0x5000
-+		outiter = 0;
-+		outinc = 2;
-+		out = chroma;
++		xblock = (stride_half)/8; //no roundin
 +		
-+		for (iyblock = 0; iyblock < yblock; iyblock++)
-+		{
-+			OUT_CH_8L_8(((iyblock/2) * yblockoffset) + (iyblock%2?0x0100:0x0000 /*0-1:0, 2-3:1*/) + offset, xblock, 1);
-+		}
-+		printf("Itr: %lu\n", outiter);
-+#endif
-+#if 1
-+		//cr
-+		yblock = res/16; //45
-+		xblock = (stride/2)/8; //40
-+		printf("yblock: %u xblock:%u\n", yblock, xblock);
-+		yblockoffset = (stride/2)*8/*h in block*/*2/*y blocks*/*2/*cr cb*/; //16pixel per x block and 2 y blocks//0x5000
-+		printf("total: %lu (0x%lx)\n", yblock * yblockoffset / 2, yblockoffset);
-+		outiter = 1;
-+		outinc = 2;
-+		out = chroma;
++		//if xblock is not even than we will have to move to the next even value an 
++		yblockoffset = (((xblock + 1) / 2) * 2) * 64/*8x8px*/ * 2/*2 block rows*/ * 2/*cr cb*/; 
++		
++		printf("yblock: %u xblock:%u yblockoffset:0x%x\n", yblock, xblock, yblockoffset);
 +		
-+		for (iyblock = 0; iyblock < yblock; iyblock++)
++		OUTITER       = 0;
++		OUTITERoffset = 0;
++		OUTINC        = 2;
++		out           = chroma;
++		
++		for(cr = 0; cr < 2; cr++)
 +		{
-+			OUT_CH_8L_8(((iyblock/2) * yblockoffset) + (iyblock%2?0x0100:0x0000) + offset, xblock, 0);
++			for(even = 0; even < 2; even++)
++			{
++				offset        = layer_offset + even * 0x100;
++				OUTITERoffset = even * xblock * 128/*8x8px * 2*/ + cr;
++			
++				for (iyblock = even; iyblock < yblock; iyblock+=2)
++				{
++					for (ixblock = 0; ixblock < xblock; ixblock++)
++					{
++						int line; 
++						OUTITER = OUTITERoffset;
++						
++						for (line = 0; line < 8; line++)
++						{
++							OUT_CH_8(offset, line, !cr);
++							OUTITER += (stride - 16 /*we have already incremented by OUTINC*8=16*/);
++						}
++					
++						//0x00 0x80 0x200 0x280, ...
++						offset += (offset%0x100?0x180/*80->200*/:0x80/*0->80*/);
++						OUTITERoffset += 16/*OUTINC*8=16*/;
++					}
++					OUTITERoffset += stride * 15;
++				}
++			}
 +		}
-+		printf("Itr: %lu\n", outiter);
-+#endif
++
++		munmap(decode_surface, bpa_data.mem_size);
++
 +		ioctlres = ioctl(fd_bpa, BPAMEMIO_UNMAPMEM); // request memory from bpamem
 +		if(ioctlres)
 +		{
 +			fprintf(stderr, "cannot unmap required mem\n");
 +			close(fd_bpa);
-+			return 1;
++			return;
 +		}
 +
 +		close(fd_bpa);
@@ -337,7 +290,7 @@
  	{
  		// grab brcm7401 pic from decoder memory
  		const unsigned char* data = (unsigned char*)mmap(0, 100, PROT_READ, MAP_SHARED, mem_fd, (stb_type == BRCM7358) ? 0x10600000 : 0x10100000);
-@@ -1059,12 +1359,14 @@
+@@ -1059,12 +1312,14 @@
  			// now we do 4 pixels on each iteration this is more code but much faster
  			int Y=yuv2rgbtable_y[luma[pos]];
  
@@ -352,7 +305,7 @@
  			video[out1+rgbstride]=CLAMP((Y + RU)>>16);
  			video[out1+1+rgbstride]=CLAMP((Y - GV - GU)>>16);
  			video[out1+2+rgbstride]=CLAMP((Y + BV)>>16);
-@@ -1074,12 +1376,14 @@
+@@ -1074,12 +1329,14 @@
  
  			Y=yuv2rgbtable_y[luma[pos]];
  
-- 
1.7.9.5

