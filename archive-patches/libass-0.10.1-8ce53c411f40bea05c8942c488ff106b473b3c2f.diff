diff --new-file -ur libass-0.10.1/libass/ass_bitmap.c libass/libass/ass_bitmap.c
--- libass-0.10.1/libass/ass_bitmap.c	2011-10-03 00:41:26.000000000 +0200
+++ libass/libass/ass_bitmap.c	2013-07-28 10:54:13.024050429 +0200
@@ -456,7 +456,7 @@
                        FT_Library ftlib, FT_Outline *outline, FT_Outline *border,
                        Bitmap **bm_g, Bitmap **bm_o, Bitmap **bm_s,
                        int be, double blur_radius, FT_Vector shadow_offset,
-                       int border_style)
+                       int border_style, int border_visible)
 {
     blur_radius *= 2;
     int bbord = be > 0 ? sqrt(2 * be) : 0;
@@ -485,7 +485,7 @@
     while (be--) {
         if (*bm_o)
             be_blur(*bm_o);
-        else
+        if (!*bm_o || border_style == 3)
             be_blur(*bm_g);
     }
 
@@ -493,7 +493,7 @@
     if (blur_radius > 0.0) {
         if (*bm_o)
             resize_tmp(priv_blur, (*bm_o)->w, (*bm_o)->h);
-        else
+        if (!*bm_o || border_style == 3)
             resize_tmp(priv_blur, (*bm_g)->w, (*bm_g)->h);
         generate_tables(priv_blur, blur_radius);
         if (*bm_o)
@@ -501,7 +501,7 @@
                            (*bm_o)->w, (*bm_o)->h, (*bm_o)->stride,
                            (int *) priv_blur->gt2, priv_blur->g_r,
                            priv_blur->g_w);
-        else
+        if (!*bm_o || border_style == 3)
             ass_gauss_blur((*bm_g)->buffer, priv_blur->tmp,
                            (*bm_g)->w, (*bm_g)->h, (*bm_g)->stride,
                            (int *) priv_blur->gt2, priv_blur->g_r,
@@ -512,8 +512,11 @@
     if (*bm_o && border_style != 3) {
         *bm_s = copy_bitmap(*bm_o);
         fix_outline(*bm_g, *bm_o);
-    } else if (*bm_o) {
+    } else if (*bm_o && border_visible) {
         *bm_s = copy_bitmap(*bm_o);
+    } else if (*bm_o) {
+        *bm_s = *bm_o;
+        *bm_o = 0;
     } else
         *bm_s = copy_bitmap(*bm_g);
 
diff --new-file -ur libass-0.10.1/libass/ass_bitmap.h libass/libass/ass_bitmap.h
--- libass-0.10.1/libass/ass_bitmap.h	2011-10-03 00:41:26.000000000 +0200
+++ libass/libass/ass_bitmap.h	2013-07-28 10:54:13.024050429 +0200
@@ -46,12 +46,13 @@
  * \param bm_o out: pointer to the bitmap of outline (border) glyph is returned here
  * \param bm_g out: pointer to the bitmap of glyph shadow is returned here
  * \param be 1 = produces blurred bitmaps, 0 = normal bitmaps
+ * \param border_visible whether border is visible if border_style is 3
  */
 int outline_to_bitmap3(ASS_Library *library, ASS_SynthPriv *priv_blur,
                        FT_Library ftlib, FT_Outline *outline, FT_Outline *border,
                        Bitmap **bm_g, Bitmap **bm_o, Bitmap **bm_s,
                        int be, double blur_radius, FT_Vector shadow_offset,
-                       int border_style);
+                       int border_style, int border_visible);
 
 void ass_free_bitmap(Bitmap *bm);
 
diff --new-file -ur libass-0.10.1/libass/ass.c libass/libass/ass.c
--- libass-0.10.1/libass/ass.c	2012-03-11 05:55:40.000000000 +0100
+++ libass/libass/ass.c	2013-07-28 10:54:13.024050429 +0200
@@ -240,6 +240,13 @@
 		target->name = strdup(token); \
 		ass_msg(track->library, MSGL_DBG2, "%s = %s", #name, token);
 
+#define STARREDSTRVAL(name) \
+    } else if (strcasecmp(tname, #name) == 0) { \
+        if (target->name != NULL) free(target->name); \
+        while (*token == '*') ++token; \
+        target->name = strdup(token); \
+        ass_msg(track->library, MSGL_DBG2, "%s = %s", #name, token);
+
 #define COLORVAL(name) \
 	} else if (strcasecmp(tname, #name) == 0) { \
 		target->name = string2color(track->library, token); \
@@ -387,6 +394,8 @@
             track->ScaledBorderAndShadow = parse_bool(token);
         else if (!strcasecmp(*fs, "Kerning"))
             track->Kerning = parse_bool(token);
+        else if (!strcasecmp(*fs, "YCbCr Matrix"))
+            track->YCbCrMatrix = parse_ycbcr_matrix(token);
 
         dt = strrchr(*fs, '.');
         if (dt) {
@@ -424,6 +433,7 @@
                     FPVAL(ScaleY)
                     FPVAL(Outline)
                     FPVAL(Shadow)
+                    FPVAL(Blur)
                 }
             }
         }
@@ -495,10 +505,9 @@
         NEXT(p, token);
 
         if (0) {                // cool ;)
-            STRVAL(Name)
-            if ((strcmp(target->Name, "Default") == 0)
-                || (strcmp(target->Name, "*Default") == 0))
-            track->default_style = sid;
+            STARREDSTRVAL(Name)
+            if (strcmp(target->Name, "Default") == 0)
+                track->default_style = sid;
             STRVAL(FontName)
             COLORVAL(PrimaryColour)
             COLORVAL(SecondaryColour)
@@ -514,7 +523,7 @@
             INTVAL(Underline)
             INTVAL(StrikeOut)
             FPVAL(Spacing)
-            INTVAL(Angle)
+            FPVAL(Angle)
             INTVAL(BorderStyle)
             INTVAL(Alignment)
             if (track->track_type == TRACK_TYPE_ASS)
@@ -573,6 +582,8 @@
         track->ScaledBorderAndShadow = parse_bool(str + 22);
     } else if (!strncmp(str, "Kerning:", 8)) {
         track->Kerning = parse_bool(str + 8);
+    } else if (!strncmp(str, "YCbCr Matrix:", 13)) {
+        track->YCbCrMatrix = parse_ycbcr_matrix(str + 13);
     } else if (!strncmp(str, "Language:", 9)) {
         char *p = str + 9;
         while (*p && isspace(*p)) p++;
@@ -587,10 +598,10 @@
 {
     track->parser_priv->state = PST_EVENTS;
     if (track->track_type == TRACK_TYPE_SSA)
-        track->event_format = strdup("Format: Marked, Start, End, Style, "
+        track->event_format = strdup("Marked, Start, End, Style, "
             "Name, MarginL, MarginR, MarginV, Effect, Text");
     else
-        track->event_format = strdup("Format: Layer, Start, End, Style, "
+        track->event_format = strdup("Layer, Start, End, Style, "
             "Actor, MarginL, MarginR, MarginV, Effect, Text");
     ass_msg(track->library, MSGL_V,
             "No event format found, using fallback");
@@ -988,7 +999,9 @@
                     oleft += size;
                 } else {
                     ass_msg(library, MSGL_WARN, "Error recoding file");
-                    return NULL;
+                    free(outbuf);
+                    outbuf = NULL;
+                    goto out;
                 }
             } else if (clear)
                 break;
@@ -996,6 +1009,7 @@
         outbuf[osize - oleft - 1] = 0;
     }
 
+out:
     if (icdsc != (iconv_t) (-1)) {
         (void) iconv_close(icdsc);
         icdsc = (iconv_t) (-1);
@@ -1103,7 +1117,7 @@
                            size_t bufsize, char *codepage)
 {
     ASS_Track *track;
-    int need_free = 0;
+    int copied = 0;
 
     if (!buf)
         return 0;
@@ -1114,12 +1128,19 @@
         if (!buf)
             return 0;
         else
-            need_free = 1;
+            copied = 1;
     }
 #endif
+    if (!copied) {
+        char *newbuf = malloc(bufsize + 1);
+        if (!newbuf)
+            return 0;
+        memcpy(newbuf, buf, bufsize);
+        newbuf[bufsize] = '\0';
+        buf = newbuf;
+    }
     track = parse_memory(library, buf);
-    if (need_free)
-        free(buf);
+    free(buf);
     if (!track)
         return 0;
 
diff --new-file -ur libass-0.10.1/libass/ass_font.c libass/libass/ass_font.c
--- libass-0.10.1/libass/ass_font.c	2012-10-15 01:49:56.000000000 +0200
+++ libass/libass/ass_font.c	2013-07-28 10:54:13.024050429 +0200
@@ -223,7 +223,8 @@
     // The idea was borrowed from asa (http://asa.diac24.net)
     if (hori && os2) {
         int hori_height = hori->Ascender - hori->Descender;
-        int os2_height = os2->usWinAscent + os2->usWinDescent;
+        /* sometimes used for signed values despite unsigned in spec */
+        int os2_height = (short)os2->usWinAscent + (short)os2->usWinDescent;
         if (hori_height && os2_height)
             mscale = (double) hori_height / os2_height;
     }
@@ -266,8 +267,8 @@
         if (FT_Get_Char_Index(face, ch)) {
             int y_scale = face->size->metrics.y_scale;
             if (os2) {
-                *asc = FT_MulFix(os2->usWinAscent, y_scale);
-                *desc = FT_MulFix(os2->usWinDescent, y_scale);
+                *asc = FT_MulFix((short)os2->usWinAscent, y_scale);
+                *desc = FT_MulFix((short)os2->usWinDescent, y_scale);
             } else {
                 *asc = FT_MulFix(face->ascender, y_scale);
                 *desc = FT_MulFix(-face->descender, y_scale);
@@ -711,12 +712,12 @@
             /* "inside" contour but we can't find anything it could be
              * inside of - assume the font is buggy and it should be
              * an "outside" contour, and reverse it */
-            for (j = 0; j < (end + 1 - start) / 2; j++) {
-                FT_Vector temp = outline->points[start + j];
-                char temp2 = outline->tags[start + j];
-                outline->points[start + j] = outline->points[end - j];
+            for (j = 0; j < (end - start) / 2; j++) {
+                FT_Vector temp = outline->points[start + 1 + j];
+                char temp2 = outline->tags[start + 1 + j];
+                outline->points[start + 1 + j] = outline->points[end - j];
                 outline->points[end - j] = temp;
-                outline->tags[start + j] = outline->tags[end - j];
+                outline->tags[start + 1 + j] = outline->tags[end - j];
                 outline->tags[end - j] = temp2;
             }
             dir ^= 1;
diff --new-file -ur libass-0.10.1/libass/ass_fontconfig.c libass/libass/ass_fontconfig.c
--- libass-0.10.1/libass/ass_fontconfig.c	2012-03-11 05:14:03.000000000 +0100
+++ libass/libass/ass_fontconfig.c	2013-07-28 10:54:13.024050429 +0200
@@ -179,6 +179,14 @@
     rc = FcConfigSubstitute(priv->config, pat, FcMatchPattern);
     if (!rc)
         goto error;
+    /* Fontconfig defaults include a language setting, which it sets based on
+     * some environment variables or defaults to "en". Unset this as we don't
+     * know the real language, and because some some attached fonts lack
+     * non-ascii characters included in fontconfig's list of characters
+     * required for English support and therefore don't match the lang=en
+     * criterion.
+     */
+    FcPatternDel(pat, "lang");
 
     fsorted = FcFontSort(priv->config, pat, FcTrue, NULL, &result);
     ffullname = match_fullname(library, priv, family, bold, italic);
@@ -249,11 +257,18 @@
 
     if (!treat_family_as_pattern &&
         !(r_family && strcasecmp((const char *) r_family, family) == 0) &&
-        !(r_fullname && strcasecmp((const char *) r_fullname, family) == 0))
-        ass_msg(library, MSGL_WARN,
-               "fontconfig: Selected font is not the requested one: "
-               "'%s' != '%s'",
-               (const char *) (r_fullname ? r_fullname : r_family), family);
+        !(r_fullname && strcasecmp((const char *) r_fullname, family) == 0)) {
+        char *fallback = (char *) (r_fullname ? r_fullname : r_family);
+        if (code) {
+            ass_msg(library, MSGL_WARN,
+                    "fontconfig: cannot find glyph U+%04X in font '%s', falling back to '%s'",
+                    (unsigned int)code, family, fallback);
+        } else {
+            ass_msg(library, MSGL_WARN,
+                    "fontconfig: cannot find font '%s', falling back to '%s'",
+                    family, fallback);
+        }
+    }
 
     result = FcPatternGetString(rpat, FC_STYLE, 0, &r_style);
     if (result != FcResultMatch)
diff --new-file -ur libass-0.10.1/libass/ass.h libass/libass/ass.h
--- libass-0.10.1/libass/ass.h	2012-10-01 15:37:24.000000000 +0200
+++ libass/libass/ass.h	2013-07-28 10:54:13.024050429 +0200
@@ -23,7 +23,7 @@
 #include <stdarg.h>
 #include "ass_types.h"
 
-#define LIBASS_VERSION 0x01010000
+#define LIBASS_VERSION 0x01020000
 
 /*
  * A linked list of images produced by an ass renderer.
@@ -44,6 +44,13 @@
     int dst_x, dst_y;           // Bitmap placement inside the video frame
 
     struct ass_image *next;   // Next image, or NULL
+
+    enum {
+        IMAGE_TYPE_CHARACTER,
+        IMAGE_TYPE_OUTLINE,
+        IMAGE_TYPE_SHADOW
+    } type;
+
 } ASS_Image;
 
 /*
@@ -153,6 +160,12 @@
 
 /**
  * \brief Set the frame size in pixels, including margins.
+ * The renderer will never return images that are outside of the frame area.
+ * The value set with this function can influence the pixel aspect ratio used
+ * for rendering. If the frame size doesn't equal to the video size, you may
+ * have to use ass_set_pixel_aspect().
+ * @see ass_set_pixel_aspect()
+ * @see ass_set_margins()
  * \param priv renderer handle
  * \param w width
  * \param h height
@@ -160,6 +173,19 @@
 void ass_set_frame_size(ASS_Renderer *priv, int w, int h);
 
 /**
+ * \brief Set the source image size in pixels.
+ * This is used to calculate the source aspect ratio and the blur scale.
+ * The source image size can be reset to default by setting w and h to 0.
+ * The value set with this function can influence the pixel aspect ratio used
+ * for rendering.
+ * @see ass_set_pixel_aspect()
+ * \param priv renderer handle
+ * \param w width
+ * \param h height
+ */
+void ass_set_storage_size(ASS_Renderer *priv, int w, int h);
+
+/**
  * \brief Set shaping level. This is merely a hint, the renderer will use
  * whatever is available if the request cannot be fulfilled.
  * \param level shaping level
@@ -168,7 +194,26 @@
 
 /**
  * \brief Set frame margins.  These values may be negative if pan-and-scan
- * is used.
+ * is used. The margins are in pixels. Each value specifies the distance from
+ * the video rectangle to the renderer frame. If a given margin value is
+ * positive, there will be free space between renderer frame and video area.
+ * If a given margin value is negative, the frame is inside the video, i.e.
+ * the video has been cropped.
+ *
+ * The renderer will try to keep subtitles inside the frame area. If possible,
+ * text is layout so that it is inside the cropped area. Subtitle events
+ * that can't be moved are cropped against the frame area.
+ *
+ * ass_set_use_margins() can be used to allow libass to render subtitles into
+ * the empty areas if margins are positive, i.e. the video area is smaller than
+ * the frame. (Traditionally, this has been used to show subtitles in
+ * the bottom "black bar" between video bottom screen border when playing 16:9
+ * video on a 4:3 screen.)
+ *
+ * When using this function, it is recommended to calculate and set your own
+ * aspect ratio with ass_set_pixel_aspect(), as the defaults won't make any
+ * sense.
+ * @see ass_set_pixel_aspect()
  * \param priv renderer handle
  * \param t top margin
  * \param b bottom margin
@@ -185,7 +230,29 @@
 void ass_set_use_margins(ASS_Renderer *priv, int use);
 
 /**
+ * \brief Set pixel aspect ratio correction.
+ * This is the ratio of pixel width to pixel height.
+ *
+ * Generally, this is (s_w / s_h) / (d_w / d_h), where s_w and s_h is the
+ * video storage size, and d_w and d_h is the video display size. (Display
+ * and storage size can be different for anamorphic video, such as DVDs.)
+ *
+ * If the pixel aspect ratio is 0, or if the aspect ratio has never been set
+ * by calling this function, libass will calculate a default pixel aspect ratio
+ * out of values set with ass_set_frame_size() and ass_set_storage_size(). Note
+ * that this is useful only if the frame size corresponds to the video display
+ * size. Keep in mind that the margins set with ass_set_margins() are ignored
+ * for aspect ratio calculations as well.
+ * If the storage size has not been set, a pixel aspect ratio of 1 is assumed.
+ * \param priv renderer handle
+ * \param par pixel aspect ratio (1.0 means square pixels, 0 means default)
+ */
+void ass_set_pixel_aspect(ASS_Renderer *priv, double par);
+
+/**
  * \brief Set aspect ratio parameters.
+ * This calls ass_set_pixel_aspect(priv, dar / sar).
+ * @deprecated New code should use ass_set_pixel_aspect().
  * \param priv renderer handle
  * \param dar display aspect ratio (DAR), prescaled for output PAR
  * \param sar storage aspect ratio (SAR)
diff --new-file -ur libass-0.10.1/libass/ass_parse.c libass/libass/ass_parse.c
--- libass-0.10.1/libass/ass_parse.c	2012-10-01 15:34:21.000000000 +0200
+++ libass/libass/ass_parse.c	2013-07-28 10:54:13.024050429 +0200
@@ -241,7 +241,7 @@
     drawing->scale = scale;
     drawing->scale_x = render_priv->font_scale_x * render_priv->font_scale;
     drawing->scale_y = render_priv->font_scale;
-    while (*p != ')' && *p != '}' && p != 0)
+    while (*p != ')' && *p != '}' && *p != 0)
         ass_drawing_add_char(drawing, *p++);
     skipopt(')');
 
@@ -311,7 +311,7 @@
         int x0, y0, x1, y1;
         int res = 1;
         char *start = p;
-        skipopt('(');
+        skip('(');
         res &= mystrtoi(&p, &x0);
         skipopt(',');
         res &= mystrtoi(&p, &y0);
@@ -418,6 +418,7 @@
         mystrtod(&p, &x2);
         skip(',');
         mystrtod(&p, &y2);
+        t1 = t2 = 0;
         if (*p == ',') {
             skip(',');
             mystrtoll(&p, &t1);
@@ -427,13 +428,20 @@
                    "movement6: (%f, %f) -> (%f, %f), (%" PRId64 " .. %"
                    PRId64 ")\n", x1, y1, x2, y2, (int64_t) t1,
                    (int64_t) t2);
-        } else {
+            // VSFilter
+            if (t1 > t2) {
+                double tmp = t2;
+                t2 = t1;
+                t1 = tmp;
+            }
+        }
+        if (t1 <= 0 && t2 <= 0) {
             t1 = 0;
             t2 = render_priv->state.event->Duration;
             ass_msg(render_priv->library, MSGL_DBG2,
                    "movement: (%f, %f) -> (%f, %f)", x1, y1, x2, y2);
         }
-        skip(')');
+        skipopt(')');
         delta_t = t2 - t1;
         t = render_priv->time - render_priv->state.event->Start;
         if (t < t1)
@@ -542,7 +550,7 @@
         mystrtod(&p, &v1);
         skip(',');
         mystrtod(&p, &v2);
-        skip(')');
+        skipopt(')');
         ass_msg(render_priv->library, MSGL_DBG2, "pos(%f, %f)", v1, v2);
         if (render_priv->state.evt_type == EVENT_POSITIONED) {
             ass_msg(render_priv->library, MSGL_V, "Subtitle has a new \\pos "
@@ -586,7 +594,7 @@
             skip(',');
             mystrtoll(&p, &t4);
         }
-        skip(')');
+        skipopt(')');
         if ((render_priv->state.parsed_tags & PARSED_FADE) == 0) {
             render_priv->state.fade =
                 interpolate_alpha(render_priv->time -
@@ -600,7 +608,7 @@
         mystrtoi(&p, &v1);
         skip(',');
         mystrtoi(&p, &v2);
-        skip(')');
+        skipopt(')');
         ass_msg(render_priv->library, MSGL_DBG2, "org(%d, %d)", v1, v2);
         if (!render_priv->state.have_origin) {
             render_priv->state.org_x = v1;
@@ -617,9 +625,8 @@
         double k;
         skip('(');
         for (cnt = 0; cnt < 3; ++cnt) {
-            if (*p == '\\')
+            if (!mystrtod(&p, &v[cnt]))
                 break;
-            mystrtod(&p, &v[cnt]);
             skip(',');
         }
         if (cnt == 3) {
@@ -654,15 +661,15 @@
             assert(delta_t != 0.);
             k = pow(((double) (t - t1)) / delta_t, v3);
         }
-        while (*p == '\\')
+        while (*p != ')' && *p != '}' && *p != '\0')
             p = parse_tag(render_priv, p, k);   // maybe k*pwr ? no, specs forbid nested \t's
         skip_to(')');           // in case there is some unknown tag or a comment
-        skip(')');
+        skipopt(')');
     } else if (mystrcmp(&p, "clip")) {
         char *start = p;
         int x0, y0, x1, y1;
         int res = 1;
-        skipopt('(');
+        skip('(');
         res &= mystrtoi(&p, &x0);
         skipopt(',');
         res &= mystrtoi(&p, &y0);
@@ -749,7 +756,7 @@
             strncpy(style, start, p - start);
             style[p - start] = '\0';
             reset_render_context(render_priv,
-                    render_priv->track->styles + lookup_style(render_priv->track, style));
+                    lookup_style_strict(render_priv->track, style));
             free(style);
         } else
             reset_render_context(render_priv, NULL);
diff --new-file -ur libass-0.10.1/libass/ass_render_api.c libass/libass/ass_render_api.c
--- libass-0.10.1/libass/ass_render_api.c	2012-10-01 15:35:27.000000000 +0200
+++ libass/libass/ass_render_api.c	2013-07-28 10:54:13.028050405 +0200
@@ -43,6 +43,13 @@
     priv->orig_height_nocrop =
         settings->frame_height - FFMAX(settings->top_margin, 0) -
         FFMAX(settings->bottom_margin, 0);
+    if (settings->storage_height) {
+        priv->storage_width = settings->storage_width;
+        priv->storage_height = settings->storage_height;
+    } else {
+        priv->storage_width = priv->orig_width;
+        priv->storage_height = priv->orig_height;
+    }
 }
 
 void ass_set_frame_size(ASS_Renderer *priv, int w, int h)
@@ -50,10 +57,16 @@
     if (priv->settings.frame_width != w || priv->settings.frame_height != h) {
         priv->settings.frame_width = w;
         priv->settings.frame_height = h;
-        if (priv->settings.aspect == 0.) {
-            priv->settings.aspect = ((double) w) / h;
-            priv->settings.storage_aspect = ((double) w) / h;
-        }
+        ass_reconfigure(priv);
+    }
+}
+
+void ass_set_storage_size(ASS_Renderer *priv, int w, int h)
+{
+    if (priv->settings.storage_width != w ||
+        priv->settings.storage_height != h) {
+        priv->settings.storage_width = w;
+        priv->settings.storage_height = h;
         ass_reconfigure(priv);
     }
 }
@@ -88,9 +101,13 @@
 
 void ass_set_aspect_ratio(ASS_Renderer *priv, double dar, double sar)
 {
-    if (priv->settings.aspect != dar || priv->settings.storage_aspect != sar) {
-        priv->settings.aspect = dar;
-        priv->settings.storage_aspect = sar;
+    ass_set_pixel_aspect(priv, dar / sar);
+}
+
+void ass_set_pixel_aspect(ASS_Renderer *priv, double par)
+{
+    if (priv->settings.par != par) {
+        priv->settings.par = par;
         ass_reconfigure(priv);
     }
 }
diff --new-file -ur libass-0.10.1/libass/ass_render.c libass/libass/ass_render.c
--- libass-0.10.1/libass/ass_render.c	2012-10-15 22:38:59.000000000 +0200
+++ libass/libass/ass_render.c	2013-07-28 10:54:13.028050405 +0200
@@ -240,7 +240,7 @@
 static ASS_Image **render_glyph_i(ASS_Renderer *render_priv,
                                   Bitmap *bm, int dst_x, int dst_y,
                                   uint32_t color, uint32_t color2, int brk,
-                                  ASS_Image **tail)
+                                  ASS_Image **tail, unsigned int type)
 {
     int i, j, x0, y0, x1, y1, cx0, cy0, cx1, cy1, sx, sy, zx, zy;
     Rect r[4];
@@ -308,6 +308,7 @@
                 lbrk - r[j].x0, r[j].y1 - r[j].y0,
                 bm->stride, dst_x + r[j].x0, dst_y + r[j].y0, color);
             if (!img) break;
+            img->type = type;
             *tail = img;
             tail = &img->next;
         }
@@ -317,6 +318,7 @@
                 r[j].x1 - lbrk, r[j].y1 - r[j].y0,
                 bm->stride, dst_x + lbrk, dst_y + r[j].y0, color2);
             if (!img) break;
+            img->type = type;
             *tail = img;
             tail = &img->next;
         }
@@ -339,12 +341,12 @@
  */
 static ASS_Image **
 render_glyph(ASS_Renderer *render_priv, Bitmap *bm, int dst_x, int dst_y,
-             uint32_t color, uint32_t color2, int brk, ASS_Image **tail)
+             uint32_t color, uint32_t color2, int brk, ASS_Image **tail, unsigned int type)
 {
     // Inverse clipping in use?
     if (render_priv->state.clip_mode)
         return render_glyph_i(render_priv, bm, dst_x, dst_y, color, color2,
-                              brk, tail);
+                              brk, tail, type);
 
     // brk is relative to dst_x
     // color = color left of brk
@@ -399,6 +401,7 @@
                              brk - b_x0, b_y1 - b_y0, bm->stride,
                              dst_x + b_x0, dst_y + b_y0, color);
         if (!img) return tail;
+        img->type = type;
         *tail = img;
         tail = &img->next;
     }
@@ -409,6 +412,7 @@
                              b_x1 - brk, b_y1 - b_y0, bm->stride,
                              dst_x + brk, dst_y + b_y0, color2);
         if (!img) return tail;
+        img->type = type;
         *tail = img;
         tail = &img->next;
     }
@@ -546,7 +550,6 @@
     ASS_Drawing *drawing = render_priv->state.clip_drawing;
     BitmapHashKey key;
     BitmapHashValue *val;
-    int error;
 
     if (!drawing)
         return;
@@ -586,10 +589,6 @@
 
         clip_bm = outline_to_bitmap(render_priv->library,
                 render_priv->ftlibrary, outline, 0);
-        if (clip_bm == NULL) {
-            ass_msg(render_priv->library, MSGL_WARN,
-                "Clip vector rasterization failed: %d. Skipping.", error);
-        }
 
         // Add to cache
         memset(&v, 0, sizeof(v));
@@ -721,7 +720,7 @@
             here_tail = tail;
             tail =
                 render_glyph(render_priv, bm, pen_x, pen_y, info->c[3], 0,
-                        1000000, tail);
+                        1000000, tail, IMAGE_TYPE_SHADOW);
 
             if (last_tail && tail != here_tail && ((info->c[3] & 0xff) > 0))
                 render_overlap(render_priv, last_tail, here_tail);
@@ -755,7 +754,7 @@
                 here_tail = tail;
                 tail =
                     render_glyph(render_priv, bm, pen_x, pen_y, info->c[2],
-                            0, 1000000, tail);
+                            0, 1000000, tail, IMAGE_TYPE_OUTLINE);
                 if (last_tail && tail != here_tail && ((info->c[2] & 0xff) > 0))
                     render_overlap(render_priv, last_tail, here_tail);
 
@@ -786,19 +785,19 @@
                 if (info->effect_timing > (info->bbox.xMax >> 6))
                     tail =
                         render_glyph(render_priv, bm, pen_x, pen_y,
-                                info->c[0], 0, 1000000, tail);
+                                info->c[0], 0, 1000000, tail, IMAGE_TYPE_CHARACTER);
                 else
                     tail =
                         render_glyph(render_priv, bm, pen_x, pen_y,
-                                info->c[1], 0, 1000000, tail);
+                                info->c[1], 0, 1000000, tail, IMAGE_TYPE_CHARACTER);
             } else if (info->effect_type == EF_KARAOKE_KF) {
                 tail =
                     render_glyph(render_priv, bm, pen_x, pen_y, info->c[0],
-                            info->c[1], info->effect_timing, tail);
+                            info->c[1], info->effect_timing, tail, IMAGE_TYPE_CHARACTER);
             } else
                 tail =
                     render_glyph(render_priv, bm, pen_x, pen_y, info->c[0],
-                            0, 1000000, tail);
+                            0, 1000000, tail, IMAGE_TYPE_CHARACTER);
             info = info->next;
         }
     }
@@ -869,7 +868,7 @@
     render_priv->state.scale_y = style->ScaleY;
     render_priv->state.hspacing = style->Spacing;
     render_priv->state.be = 0;
-    render_priv->state.blur = 0.0;
+    render_priv->state.blur = style->Blur;
     render_priv->state.shadow_x = style->Shadow;
     render_priv->state.shadow_y = style->Shadow;
     render_priv->state.frx = render_priv->state.fry = 0.;
@@ -930,13 +929,14 @@
  * Replace the outline of a glyph by a contour which makes up a simple
  * opaque rectangle.
  */
-static void draw_opaque_box(ASS_Renderer *render_priv, int asc, int desc,
-                            FT_Outline *ol, FT_Vector advance, int sx, int sy)
+static void draw_opaque_box(ASS_Renderer *render_priv, GlyphInfo *info,
+                            int asc, int desc, FT_Outline *ol,
+                            FT_Vector advance, int sx, int sy)
 {
     int i;
     int adv = advance.x;
-    double scale_y = render_priv->state.scale_y;
-    double scale_x = render_priv->state.scale_x;
+    double scale_y = info->scale_y;
+    double scale_x = info->scale_x;
 
     // to avoid gaps
     sx = FFMAX(64, sx);
@@ -944,8 +944,7 @@
 
     // Emulate the WTFish behavior of VSFilter, i.e. double-scale
     // the sizes of the opaque box.
-    adv += double_to_d6(render_priv->state.hspacing * render_priv->font_scale
-                        * scale_x);
+    adv += double_to_d6(info->hspacing * render_priv->font_scale * scale_x);
     adv *= scale_x;
     sx *= scale_x;
     sy *= scale_y;
@@ -1130,8 +1129,7 @@
 
         FT_Outline_Get_CBox(v.outline, &v.bbox_scaled);
 
-        if (info->border_style == 3 &&
-                (info->border_x > 0 || info->border_y > 0)) {
+        if (info->border_style == 3) {
             FT_Vector advance;
 
             v.border = calloc(1, sizeof(FT_Outline));
@@ -1141,7 +1139,7 @@
             else
                 advance = info->advance;
 
-            draw_opaque_box(priv, v.asc, v.desc, v.border, advance,
+            draw_opaque_box(priv, info, v.asc, v.desc, v.border, advance,
                     double_to_d6(info->border_x * priv->border_scale),
                     double_to_d6(info->border_y * priv->border_scale));
 
@@ -1314,9 +1312,10 @@
                 outline, border,
                 &hash_val.bm, &hash_val.bm_o,
                 &hash_val.bm_s, info->be,
-                info->blur * render_priv->border_scale,
+                info->blur * render_priv->blur_scale,
                 key->shadow_offset,
-                info->border_style);
+                info->border_style,
+                info->border_x || info->border_y);
         if (error)
             info->symbol = 0;
 
@@ -1684,8 +1683,6 @@
                  EventImages *event_images)
 {
     char *p;
-    FT_UInt previous;
-    FT_UInt num_glyphs;
     FT_Vector pen;
     unsigned code;
     DBBox bbox;
@@ -1712,7 +1709,6 @@
 
     drawing = render_priv->state.drawing;
     text_info->length = 0;
-    num_glyphs = 0;
     p = event->Text;
 
     int in_tag = 0;
@@ -1875,7 +1871,6 @@
     }
 
     // Preliminary layout (for line wrapping)
-    previous = 0;
     pen.x = 0;
     pen.y = 0;
     for (i = 0; i < text_info->length; i++) {
@@ -1897,7 +1892,6 @@
         info = glyphs + i;
         pen.x += info->cluster_advance.x;
         pen.y += info->cluster_advance.y;
-        previous = info->symbol;
     }
 
 
@@ -2229,9 +2223,6 @@
         && !render_priv->settings.frame_height)
         return 1;               // library not initialized
 
-    if (render_priv->library != track->library)
-        return 1;
-
     if (!render_priv->fontconfig_priv)
         return 1;
 
@@ -2247,21 +2238,39 @@
 
     render_priv->font_scale = settings_priv->font_size_coeff *
         render_priv->orig_height / render_priv->track->PlayResY;
+    if (render_priv->storage_height)
+        render_priv->blur_scale = ((double) render_priv->orig_height) /
+            render_priv->storage_height;
+    else
+        render_priv->blur_scale = 1.;
     if (render_priv->track->ScaledBorderAndShadow)
         render_priv->border_scale =
             ((double) render_priv->orig_height) /
             render_priv->track->PlayResY;
     else
-        render_priv->border_scale = 1.;
+        render_priv->border_scale = render_priv->blur_scale;
+    if (!settings_priv->storage_height)
+        render_priv->blur_scale = render_priv->border_scale;
+    render_priv->border_scale *= settings_priv->font_size_coeff;
 
     ass_shaper_set_kerning(render_priv->shaper, track->Kerning);
-    if (track->Language)
-        ass_shaper_set_language(render_priv->shaper, track->Language);
+    ass_shaper_set_language(render_priv->shaper, track->Language);
     ass_shaper_set_level(render_priv->shaper, render_priv->settings.shaper);
 
     // PAR correction
-    render_priv->font_scale_x = render_priv->settings.aspect /
-                                render_priv->settings.storage_aspect;
+    double par = render_priv->settings.par;
+    if (par == 0.) {
+        if (settings_priv->frame_width && settings_priv->frame_height &&
+            settings_priv->storage_width && settings_priv->storage_height) {
+            double dar = ((double) settings_priv->frame_width) /
+                         settings_priv->frame_height;
+            double sar = ((double) settings_priv->storage_width) /
+                         settings_priv->storage_height;
+            par = sar / dar;
+        } else
+            par = 1.0;
+    }
+    render_priv->font_scale_x = par;
 
     render_priv->prev_images_root = render_priv->images_root;
     render_priv->images_root = 0;
diff --new-file -ur libass-0.10.1/libass/ass_render.h libass/libass/ass_render.h
--- libass-0.10.1/libass/ass_render.h	2012-10-01 15:41:33.000000000 +0200
+++ libass/libass/ass_render.h	2013-07-28 10:54:13.028050405 +0200
@@ -26,6 +26,9 @@
 #include FT_STROKER_H
 #include FT_GLYPH_H
 #include FT_SYNTHESIS_H
+#ifdef CONFIG_HARFBUZZ
+#include "hb.h"
+#endif
 
 // XXX: fix the inclusion mess so we can avoid doing this here
 typedef struct ass_shaper ASS_Shaper;
@@ -65,6 +68,8 @@
 typedef struct {
     int frame_width;
     int frame_height;
+    int storage_width;          // width of the source image
+    int storage_height;         // height of the source image
     double font_size_coeff;     // font size multiplier
     double line_spacing;        // additional line spacing (in frame pixels)
     double line_position;       // vertical position for subtitles, 0-100 (0 = no change)
@@ -74,8 +79,7 @@
     int right_margin;
     int use_margins;            // 0 - place all subtitles inside original frame
     // 1 - use margins for placing toptitles and subtitles
-    double aspect;              // frame aspect ratio, d_width / d_height.
-    double storage_aspect;      // pixel ratio of the source image
+    double par;                 // user defined pixel aspect ratio (0 = unset)
     ASS_Hinting hinting;
     ASS_ShapingLevel shaper;
 
@@ -107,6 +111,11 @@
     ASS_Font *font;
     int face_index;
     int glyph_index;
+#ifdef CONFIG_HARFBUZZ
+    hb_script_t script;
+#else
+    int script;
+#endif
     double font_size;
     ASS_Drawing *drawing;
     FT_Outline *outline;
@@ -264,11 +273,14 @@
     int orig_width;             // frame width ( = screen width - margins )
     int orig_height_nocrop;     // frame height ( = screen height - margins + cropheight)
     int orig_width_nocrop;      // frame width ( = screen width - margins + cropwidth)
+    int storage_height;         // video height before any rescaling
+    int storage_width;          // video width before any rescaling
     ASS_Track *track;
     long long time;             // frame's timestamp, ms
     double font_scale;
     double font_scale_x;        // x scale applied to all glyphs to preserve text aspect ratio
     double border_scale;
+    double blur_scale;
 
     RenderContext state;
     TextInfo text_info;
diff --new-file -ur libass-0.10.1/libass/ass_shaper.c libass/libass/ass_shaper.c
--- libass-0.10.1/libass/ass_shaper.c	2012-10-15 22:53:31.000000000 +0200
+++ libass/libass/ass_shaper.c	2013-07-28 10:54:13.028050405 +0200
@@ -203,6 +203,12 @@
             return NULL;
 
         memcpy(&new_val.metrics, &face->glyph->metrics, sizeof(FT_Glyph_Metrics));
+
+        // if @font rendering is enabled and the glyph should be rotated,
+        // make cached_h_advance pick up the right advance later
+        if (metrics->vertical && glyph >= VERTICAL_LOWER_BOUND)
+            new_val.metrics.horiAdvance = new_val.metrics.vertAdvance;
+
         val = ass_cache_put(metrics->metrics_cache, &metrics->hash_key, &new_val);
     }
 
@@ -234,9 +240,6 @@
     if (!metrics)
         return 0;
 
-    if (metrics_priv->vertical && glyph > VERTICAL_LOWER_BOUND)
-        return metrics->metrics.vertAdvance;
-
     return metrics->metrics.horiAdvance;
 }
 
@@ -409,6 +412,107 @@
 }
 
 /**
+ * \brief Map script to default language.
+ *
+ * This maps a script to a language, if a script has a representative
+ * language it is typically used with. Otherwise, the invalid language
+ * is returned.
+ *
+ * The mapping is similar to Pango's pango-language.c.
+ *
+ * \param script script tag
+ * \return language tag
+ */
+static hb_language_t script_to_language(hb_script_t script)
+{
+    switch (script) {
+        // Unicode 1.1
+        case HB_SCRIPT_ARABIC: return hb_language_from_string("ar", -1); break;
+        case HB_SCRIPT_ARMENIAN: return hb_language_from_string("hy", -1); break;
+        case HB_SCRIPT_BENGALI: return hb_language_from_string("bn", -1); break;
+        case HB_SCRIPT_CANADIAN_ABORIGINAL: return hb_language_from_string("iu", -1); break;
+        case HB_SCRIPT_CHEROKEE: return hb_language_from_string("chr", -1); break;
+        case HB_SCRIPT_COPTIC: return hb_language_from_string("cop", -1); break;
+        case HB_SCRIPT_CYRILLIC: return hb_language_from_string("ru", -1); break;
+        case HB_SCRIPT_DEVANAGARI: return hb_language_from_string("hi", -1); break;
+        case HB_SCRIPT_GEORGIAN: return hb_language_from_string("ka", -1); break;
+        case HB_SCRIPT_GREEK: return hb_language_from_string("el", -1); break;
+        case HB_SCRIPT_GUJARATI: return hb_language_from_string("gu", -1); break;
+        case HB_SCRIPT_GURMUKHI: return hb_language_from_string("pa", -1); break;
+        case HB_SCRIPT_HANGUL: return hb_language_from_string("ko", -1); break;
+        case HB_SCRIPT_HEBREW: return hb_language_from_string("he", -1); break;
+        case HB_SCRIPT_HIRAGANA: return hb_language_from_string("ja", -1); break;
+        case HB_SCRIPT_KANNADA: return hb_language_from_string("kn", -1); break;
+        case HB_SCRIPT_KATAKANA: return hb_language_from_string("ja", -1); break;
+        case HB_SCRIPT_LAO: return hb_language_from_string("lo", -1); break;
+        case HB_SCRIPT_LATIN: return hb_language_from_string("en", -1); break;
+        case HB_SCRIPT_MALAYALAM: return hb_language_from_string("ml", -1); break;
+        case HB_SCRIPT_MONGOLIAN: return hb_language_from_string("mn", -1); break;
+        case HB_SCRIPT_ORIYA: return hb_language_from_string("or", -1); break;
+        case HB_SCRIPT_SYRIAC: return hb_language_from_string("syr", -1); break;
+        case HB_SCRIPT_TAMIL: return hb_language_from_string("ta", -1); break;
+        case HB_SCRIPT_TELUGU: return hb_language_from_string("te", -1); break;
+        case HB_SCRIPT_THAI: return hb_language_from_string("th", -1); break;
+
+        // Unicode 2.0
+        case HB_SCRIPT_TIBETAN: return hb_language_from_string("bo", -1); break;
+
+        // Unicode 3.0
+        case HB_SCRIPT_ETHIOPIC: return hb_language_from_string("am", -1); break;
+        case HB_SCRIPT_KHMER: return hb_language_from_string("km", -1); break;
+        case HB_SCRIPT_MYANMAR: return hb_language_from_string("my", -1); break;
+        case HB_SCRIPT_SINHALA: return hb_language_from_string("si", -1); break;
+        case HB_SCRIPT_THAANA: return hb_language_from_string("dv", -1); break;
+
+        // Unicode 3.2
+        case HB_SCRIPT_BUHID: return hb_language_from_string("bku", -1); break;
+        case HB_SCRIPT_HANUNOO: return hb_language_from_string("hnn", -1); break;
+        case HB_SCRIPT_TAGALOG: return hb_language_from_string("tl", -1); break;
+        case HB_SCRIPT_TAGBANWA: return hb_language_from_string("tbw", -1); break;
+
+        // Unicode 4.0
+        case HB_SCRIPT_UGARITIC: return hb_language_from_string("uga", -1); break;
+
+        // Unicode 4.1
+        case HB_SCRIPT_BUGINESE: return hb_language_from_string("bug", -1); break;
+        case HB_SCRIPT_OLD_PERSIAN: return hb_language_from_string("peo", -1); break;
+        case HB_SCRIPT_SYLOTI_NAGRI: return hb_language_from_string("syl", -1); break;
+
+        // Unicode 5.0
+        case HB_SCRIPT_NKO: return hb_language_from_string("nko", -1); break;
+
+        // no representative language exists
+        default: return HB_LANGUAGE_INVALID; break;
+    }
+}
+
+/**
+ * \brief Determine language to be used for shaping a run.
+ *
+ * \param shaper shaper instance
+ * \param script script tag associated with run
+ * \return language tag
+ */
+static hb_language_t
+hb_shaper_get_run_language(ASS_Shaper *shaper, hb_script_t script)
+{
+    hb_language_t lang;
+
+    // override set, use it
+    if (shaper->language != HB_LANGUAGE_INVALID)
+        return shaper->language;
+
+    // get default language for given script
+    lang = script_to_language(script);
+
+    // no dice, use system default
+    if (lang == HB_LANGUAGE_INVALID)
+        lang = hb_language_get_default();
+
+    return lang;
+}
+
+/**
  * \brief Shape event text with HarfBuzz. Full OpenType shaping.
  * \param glyphs glyph clusters
  * \param len number of clusters
@@ -430,6 +534,7 @@
         int k = i;
         int level = glyphs[i].shape_run_id;
         int direction = shaper->emblevels[k] % 2;
+        hb_script_t script = glyphs[i].script;
         while (i < (len - 1) && level == glyphs[i+1].shape_run_id)
             i++;
         runs[run].offset = k;
@@ -440,7 +545,9 @@
         hb_buffer_pre_allocate(runs[run].buf, i - k + 1);
         hb_buffer_set_direction(runs[run].buf, direction ? HB_DIRECTION_RTL :
                 HB_DIRECTION_LTR);
-        hb_buffer_set_language(runs[run].buf, shaper->language);
+        hb_buffer_set_language(runs[run].buf,
+                hb_shaper_get_run_language(shaper, script));
+        hb_buffer_set_script(runs[run].buf, script);
         hb_buffer_add_utf32(runs[run].buf, shaper->event_text + k, i - k + 1,
                 0, i - k + 1);
         hb_shape(runs[run].font, runs[run].buf, shaper->features,
@@ -493,6 +600,56 @@
     }
 
 }
+
+/**
+ * \brief Determine script property of all characters. Characters of script
+ * common and inherited get their script from their context.
+ *
+ */
+void ass_shaper_determine_script(ASS_Shaper *shaper, GlyphInfo *glyphs,
+                                  size_t len)
+{
+    int i;
+    int backwards_scan = 0;
+    hb_unicode_funcs_t *ufuncs = hb_unicode_funcs_get_default();
+    hb_script_t last_script = HB_SCRIPT_UNKNOWN;
+
+    // determine script (forward scan)
+    for (i = 0; i < len; i++) {
+        GlyphInfo *info = glyphs + i;
+        info->script = hb_unicode_script(ufuncs, info->symbol);
+
+        // common/inherit codepoints inherit script from context
+        if (info->script == HB_SCRIPT_COMMON ||
+                info->script == HB_SCRIPT_INHERITED) {
+            // unknown is not a valid context
+            if (last_script != HB_SCRIPT_UNKNOWN)
+                info->script = last_script;
+            else
+                // do a backwards scan to check if next codepoint
+                // contains a valid script for context
+                backwards_scan = 1;
+        } else {
+            last_script = info->script;
+        }
+    }
+
+    // determine script (backwards scan, if needed)
+    last_script = HB_SCRIPT_UNKNOWN;
+    for (i = len - 1; i >= 0 && backwards_scan; i--) {
+        GlyphInfo *info = glyphs + i;
+
+        // common/inherit codepoints inherit script from context
+        if (info->script == HB_SCRIPT_COMMON ||
+                info->script == HB_SCRIPT_INHERITED) {
+            // unknown script is not a valid context
+            if (last_script != HB_SCRIPT_UNKNOWN)
+                info->script = last_script;
+        } else {
+            last_script = info->script;
+        }
+    }
+}
 #endif
 
 /**
@@ -543,6 +700,11 @@
     int i;
     int shape_run = 0;
 
+#ifdef CONFIG_HARFBUZZ
+    ass_shaper_determine_script(shaper, glyphs, len);
+#endif
+
+    // find appropriate fonts for the shape runs
     for (i = 0; i < len; i++) {
         GlyphInfo *last = glyphs + i - 1;
         GlyphInfo *info = glyphs + i;
@@ -555,11 +717,11 @@
         // shape runs share the same font face and size
         if (i > 0 && (last->font != info->font ||
                     last->font_size != info->font_size ||
-                    last->face_index != info->face_index))
+                    last->face_index != info->face_index ||
+                    last->script != info->script))
             shape_run++;
         info->shape_run_id = shape_run;
     }
-
 }
 
 /**
@@ -579,7 +741,14 @@
 void ass_shaper_set_language(ASS_Shaper *shaper, const char *code)
 {
 #ifdef CONFIG_HARFBUZZ
-    shaper->language = hb_language_from_string(code, -1);
+    hb_language_t lang;
+
+    if (code)
+        lang = hb_language_from_string(code, -1);
+    else
+        lang = HB_LANGUAGE_INVALID;
+
+    shaper->language = lang;
 #endif
 }
 
@@ -715,10 +884,9 @@
     // Create reorder map line-by-line
     for (i = 0; i < text_info->n_lines; i++) {
         LineInfo *line = text_info->lines + i;
-        int level;
         FriBidiParType dir = FRIBIDI_PAR_ON;
 
-        level = fribidi_reorder_line(0,
+        fribidi_reorder_line(0,
                 shaper->ctypes + line->offset, line->len, 0, dir,
                 shaper->emblevels + line->offset, NULL,
                 shaper->cmap + line->offset);
diff --new-file -ur libass-0.10.1/libass/ass_types.h libass/libass/ass_types.h
--- libass-0.10.1/libass/ass_types.h	2012-03-11 05:14:03.000000000 +0100
+++ libass/libass/ass_types.h	2013-07-28 10:54:13.028050405 +0200
@@ -50,7 +50,7 @@
     double ScaleX;
     double ScaleY;
     double Spacing;
-    int Angle;
+    double Angle;
     int BorderStyle;
     double Outline;
     double Shadow;
@@ -60,6 +60,7 @@
     int MarginV;
     int Encoding;
     int treat_fontname_as_pattern;
+    double Blur;
 } ASS_Style;
 
 /*
@@ -113,6 +114,19 @@
     int ScaledBorderAndShadow;
     int Kerning;
     char *Language;
+    enum {
+        YCBCR_DEFAULT = 0,  // TV.601 on YCbCr video, None on RGB video
+        YCBCR_UNKNOWN,
+        YCBCR_NONE,         // untouched RGB values
+        YCBCR_BT601_TV,
+        YCBCR_BT601_PC,
+        YCBCR_BT709_TV,
+        YCBCR_BT709_PC,
+        YCBCR_SMPTE240M_TV,
+        YCBCR_SMPTE240M_PC,
+        YCBCR_FCC_TV,
+        YCBCR_FCC_PC
+    } YCbCrMatrix;
 
     int default_style;      // index of default style
     char *name;             // file name in case of external subs, 0 for streams
diff --new-file -ur libass-0.10.1/libass/ass_utils.c libass/libass/ass_utils.c
--- libass-0.10.1/libass/ass_utils.c	2012-03-11 05:55:16.000000000 +0100
+++ libass/libass/ass_utils.c	2013-07-28 10:54:13.028050405 +0200
@@ -122,6 +122,46 @@
     return 0;
 }
 
+int parse_ycbcr_matrix(char *str)
+{
+    while (*str == ' ' || *str == '\t')
+        str++;
+    if (*str == '\0')
+        return YCBCR_DEFAULT;
+
+    char *end = str + strlen(str);
+    while (end[-1] == ' ' || end[-1] == '\t')
+        end--;
+
+    // Trim a local copy of the input that we know is safe to
+    // modify. The buffer is larger than any valid string + NUL,
+    // so we can simply chop off the rest of the input.
+    char buffer[16];
+    size_t n = FFMIN(end - str, sizeof buffer - 1);
+    strncpy(buffer, str, n);
+    buffer[n] = '\0';
+
+    if (!strcasecmp(buffer, "none"))
+        return YCBCR_NONE;
+    if (!strcasecmp(buffer, "tv.601"))
+        return YCBCR_BT601_TV;
+    if (!strcasecmp(buffer, "pc.601"))
+        return YCBCR_BT601_PC;
+    if (!strcasecmp(buffer, "tv.709"))
+        return YCBCR_BT709_TV;
+    if (!strcasecmp(buffer, "pc.709"))
+        return YCBCR_BT709_PC;
+    if (!strcasecmp(buffer, "tv.240m"))
+        return YCBCR_SMPTE240M_TV;
+    if (!strcasecmp(buffer, "pc.240m"))
+        return YCBCR_SMPTE240M_PC;
+    if (!strcasecmp(buffer, "tv.fcc"))
+        return YCBCR_FCC_TV;
+    if (!strcasecmp(buffer, "pc.fcc"))
+        return YCBCR_FCC_PC;
+    return YCBCR_UNKNOWN;
+}
+
 void ass_msg(ASS_Library *priv, int lvl, char *fmt, ...)
 {
     va_list va;
@@ -165,14 +205,20 @@
  * \param track track
  * \param name style name
  * \return index in track->styles
- * Returnes 0 if no styles found => expects at least 1 style.
- * Parsing code always adds "Default" style in the end.
+ * Returns 0 if no styles found => expects at least 1 style.
+ * Parsing code always adds "Default" style in the beginning.
  */
 int lookup_style(ASS_Track *track, char *name)
 {
     int i;
-    if (*name == '*')
-        ++name;                 // FIXME: what does '*' really mean ?
+    // '*' seem to mean literally nothing;
+    // VSFilter removes them as soon as it can
+    while (*name == '*')
+        ++name;
+    // VSFilter then normalizes the case of "Default"
+    // (only in contexts where this function is called)
+    if (strcasecmp(name, "Default") == 0)
+        name = "Default";
     for (i = track->n_styles - 1; i >= 0; --i) {
         if (strcmp(track->styles[i].Name, name) == 0)
             return i;
@@ -181,7 +227,27 @@
     ass_msg(track->library, MSGL_WARN,
             "[%p]: Warning: no style named '%s' found, using '%s'",
             track, name, track->styles[i].Name);
-    return i;                   // use the first style
+    return i;
+}
+
+/**
+ * \brief find style by name as in \r
+ * \param track track
+ * \param name style name
+ * \return style in track->styles
+ * Returns NULL if no style has the given name.
+ */
+ASS_Style *lookup_style_strict(ASS_Track *track, char *name)
+{
+    int i;
+    for (i = track->n_styles - 1; i >= 0; --i) {
+        if (strcmp(track->styles[i].Name, name) == 0)
+            return track->styles + i;
+    }
+    ass_msg(track->library, MSGL_WARN,
+            "[%p]: Warning: no style named '%s' found",
+            track, name);
+    return NULL;
 }
 
 #ifdef CONFIG_ENCA
diff --new-file -ur libass-0.10.1/libass/ass_utils.h libass/libass/ass_utils.h
--- libass-0.10.1/libass/ass_utils.h	2012-03-11 05:55:35.000000000 +0100
+++ libass/libass/ass_utils.h	2013-07-28 10:54:13.028050405 +0200
@@ -49,9 +49,11 @@
 int mystrtod(char **p, double *res);
 int strtocolor(ASS_Library *library, char **q, uint32_t *res, int hex);
 char parse_bool(char *str);
+int parse_ycbcr_matrix(char *str);
 unsigned ass_utf8_get_char(char **str);
 void ass_msg(ASS_Library *priv, int lvl, char *fmt, ...);
 int lookup_style(ASS_Track *track, char *name);
+ASS_Style *lookup_style_strict(ASS_Track *track, char *name);
 #ifdef CONFIG_ENCA
 void *ass_guess_buffer_cp(ASS_Library *library, unsigned char *buffer,
                           int buflen, char *preferred_language,
diff --new-file -ur libass-0.10.1/libass/libass.sym libass/libass/libass.sym
--- libass-0.10.1/libass/libass.sym	2012-10-01 15:35:27.000000000 +0200
+++ libass/libass/libass.sym	2013-07-28 10:54:13.028050405 +0200
@@ -6,6 +6,7 @@
 ass_renderer_init
 ass_renderer_done
 ass_set_frame_size
+ass_set_storage_size
 ass_set_margins
 ass_set_use_margins
 ass_set_aspect_ratio
@@ -36,3 +37,4 @@
 ass_flush_events
 ass_set_shaper
 ass_set_line_position
+ass_set_pixel_aspect
diff --new-file -ur libass-0.10.1/libass/Makefile.am libass/libass/Makefile.am
--- libass-0.10.1/libass/Makefile.am	2012-10-15 16:45:23.000000000 +0200
+++ libass/libass/Makefile.am	2013-07-28 10:54:13.020050453 +0200
@@ -12,7 +12,7 @@
                     ass_drawing.h ass_cache_template.h ass_render.h \
                     ass_parse.c ass_parse.h ass_render_api.c ass_shaper.c \
                     ass_shaper.h ass_strtod.c
-libass_la_LDFLAGS = -version-info $(LIBASS_LT_CURRENT):$(LIBASS_LT_REVISION):$(LIBASS_LT_AGE)
+libass_la_LDFLAGS = -no-undefined -version-info $(LIBASS_LT_CURRENT):$(LIBASS_LT_REVISION):$(LIBASS_LT_AGE)
 libass_la_LDFLAGS += -export-symbols $(srcdir)/libass.sym
 
 assheadersdir = $(includedir)/ass
