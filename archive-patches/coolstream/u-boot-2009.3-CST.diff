commit 1792f8bca0e50dcd64ad38b30bd57bf975775676
Author: Stefan Seyfried <seife@tuxbox-git.slipkontur.de>
Date:   Thu Feb 10 14:44:02 2011 +0100

    import of u-boot-2009.03-CST as of svn rev 1145

diff --git a/Makefile b/Makefile
index 61bae6d..21bd00a 100644
--- a/Makefile
+++ b/Makefile
@@ -150,9 +150,15 @@ else
 ifeq ($(ARCH),ppc)
 CROSS_COMPILE = ppc_8xx-
 endif
+
 ifeq ($(ARCH),arm)
+ifeq ($(BOARD),coolstream_hdx)
+CROSS_COMPILE = arm-cx2450x-linux-gnueabi-
+else
 CROSS_COMPILE = arm-linux-
 endif
+endif
+
 ifeq ($(ARCH),i386)
 CROSS_COMPILE = i386-linux-
 endif
@@ -3052,6 +3058,9 @@ qong_config		: unconfig
 #########################################################################
 ## ARM1176 Systems
 #########################################################################
+coolstream_hdx_config :	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm1176 coolstream_hdx NULL nevis
+
 smdk6400_noUSB_config	\
 smdk6400_config	:	unconfig
 	@mkdir -p $(obj)include $(obj)board/samsung/smdk6400
diff --git a/README_COOLSTREAM b/README_COOLSTREAM
new file mode 100644
index 0000000..e554396
--- /dev/null
+++ b/README_COOLSTREAM
@@ -0,0 +1,32 @@
+This is the coolstream branch of u-boot. It contains all parts to build
+a working bootlaoder. This branch does not contain all the configurations
+for other boards and enviroments.
+
+
+A T T E N T I O N:
+==================
+
+Coolstream Intl. Ltd. will not be responsible for broken Set-Top-Boxes
+caused by your own work. If will not be able to restore your box into
+operational mode if something fail while replacing the bootloader. If
+your box is dead you have to give it to your dealer for repair, which
+will cause service fees, so be carefull! Your work is on your own risk!
+
+
+Notes about to build u-boot for Coolstream HDx Set-Top-Boxes:
+-------------------------------------------------------------
+
+- Make sure you have the ccross compiler installed properly on your system
+
+- Configure the build process for HDx boards by calling:
+
+  make coolstream_hdx_config
+
+- Build u-boot by calling:
+
+  make
+
+  The resulting executable binary will be u-boot.bin. The build process
+  also creates the mkimage tool in the tools directory, which is necessary
+  to convert Linux kernel binaries into u-boot compatible binaries.
+
diff --git a/board/coolstream_hdx/Makefile b/board/coolstream_hdx/Makefile
new file mode 100644
index 0000000..d631675
--- /dev/null
+++ b/board/coolstream_hdx/Makefile
@@ -0,0 +1,53 @@
+#
+# (C) Copyright 2000-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	:= coolstream_hdx.o interrupt.o flash.o gpio.o display.o network.o splash.o
+SOBJS	:= lowlevel_init.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+#make sure lowlevel is seen first ;)
+
+$(LIB):	$(obj).depend  $(SOBJS) $(OBJS)
+	$(AR) $(ARFLAGS) $@ $(SOBJS) $(OBJS) 
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/coolstream_hdx/config.mk b/board/coolstream_hdx/config.mk
new file mode 100644
index 0000000..6b7550d
--- /dev/null
+++ b/board/coolstream_hdx/config.mk
@@ -0,0 +1,6 @@
+#
+# (C) Copyright 2008
+# Coolstream International Limited
+#
+
+TEXT_BASE = 0x07F80000
diff --git a/board/coolstream_hdx/coolstream_hdx.c b/board/coolstream_hdx/coolstream_hdx.c
new file mode 100644
index 0000000..d58ee17
--- /dev/null
+++ b/board/coolstream_hdx/coolstream_hdx.c
@@ -0,0 +1,375 @@
+/*
+ * (C) Copyright 2008
+ * Coolstream International Limited
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <common.h>
+#include <asm/arch/nevis.h>
+#include <asm/arch/sys_proto.h>
+//#include <usb.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+
+#define DISPLAY_WIDTH			720
+#define DISPLAY_HEIGHT			576
+
+extern void arm926_spin_begin(void);
+extern void arm926_spin_end(void);
+
+#if (CONFIG_ARM9_SETUP_LEGACY_MODE == 1)
+#define ARM9_VECTOR_OFFSET		CONFIG_ARM9_OFFSET_LEGACY
+#define ARM9_SHARED_CODE_START		(CONFIG_ARM9_SHARED_CODE_OFFSET_LEGACY + CONFIG_ARM9_RESET_ADDR)
+#define ARM9_SHARED_RAM_START		(CONFIG_ARM9_SHARED_RAM_OFFSET_LEGACY + CONFIG_ARM9_RESET_ADDR)
+#else
+#define ARM9_VECTOR_OFFSET		CONFIG_ARM9_OFFSET
+#define ARM9_SHARED_CODE_START		(CONFIG_ARM9_SHARED_CODE_OFFSET + CONFIG_ARM9_RESET_ADDR)
+#define ARM9_SHARED_RAM_START		(CONFIG_ARM9_SHARED_RAM_OFFSET + CONFIG_ARM9_RESET_ADDR)
+#endif
+
+extern flash_info_t flash_info[];       /* info for FLASH chips */
+
+static void pwm_init(void)
+{
+	volatile u32 *CNTLO	= (volatile u32 *)0xE0480004;
+	volatile u32 *PLSEO	= (volatile u32 *)0xE0480008;
+
+	*CNTLO	= 0x05;
+	*PLSEO	= (0x265 << 16) | (0x265 << 0);
+}
+
+static void led_init(void)
+{
+	display_led_control(VFD_LED_1_ON);
+	display_led_control(VFD_LED_2_ON);
+}
+
+#ifdef CONFIG_LOAD_INITIAL_DECARM_CODE
+static void arm9_init(void)
+{
+    const volatile u32 *reset_code = (volatile u32 *) arm926_spin_begin;
+    volatile u32 *decarm_addr      = (volatile u32 *) RST_DECARM_CTL_REG;
+    volatile u32 *reset_addr       = (volatile u32 *) CONFIG_ARM9_RESET_ADDR;
+    volatile u32 *shr_code         = (volatile u32 *) ARM9_SHARED_CODE_START;
+    volatile u32 *shr_ram          = (volatile u32 *) ARM9_SHARED_RAM_START;
+    volatile u32 *ver_indicator    = (volatile u32 *) (CONFIG_ARM9_SHARED_CODE_OFFSET_LEGACY + CONFIG_ARM9_RESET_ADDR);
+    volatile u32 *dest;
+
+
+    dest = reset_addr;
+    while(reset_code < (volatile u32 *)arm926_spin_end) {
+        *dest++ = *reset_code++;
+    }
+
+    while(dest < (volatile u32 *) (CONFIG_ARM9_RESET_ADDR + ARM9_VECTOR_OFFSET)) {
+        *dest++ = 0x00000000;
+    }
+
+    *ver_indicator = 0xEEEEEEEE;
+    *shr_code     = 0x00000000;
+    *shr_ram      = 0x00000000;
+    *decarm_addr |= 1;  /* Remap to 0x10000 */
+    *decarm_addr &= ~2; /* Release reset    */
+}
+#endif
+
+
+/*******************************************************************************/
+/* do early hardware initializations                                           */
+
+int board_init(void)
+{
+    gd->bd->bi_arch_number = 0x04C8;	 /* Linux board ID -> Conexant Nevis */
+
+    /* define where the boot parameters are placed for the kernel.
+     * From <kernel>/Documentation/arm/Booting:
+     *
+     *	The tagged list must be placed in a region of memory where neither
+     *	the kernel decompressor nor initrd 'bootp' program will overwrite
+     *	it.  The recommended placement is in the first 16KiB of RAM.
+     *
+     *	For Conexant kernel we want it at physical address 0x17000000 (before kernel 
+     * 	entry point address at 1 megabyte boundary.
+     */
+
+    /* coolstream kernel */
+    gd->bd->bi_boot_params = 0x00000100;
+
+    /* Initialize the Interrupt Controller for board specific usage */
+    board_init_itc();
+
+    return 0;
+}
+
+/*******************************************************************************/
+/* miscellaneous platform dependent initialisations before devices_init(),     */
+/* but after the enviroment is available.                                      */
+
+int misc_init_p(void)
+{
+    /* Init our small VFD for which we do not need the framebuffer stuff. */
+    board_display_init();
+    display_set_text(NULL);
+
+    /* some misc GPIO's to setup */
+    board_gpio_drive(165, PIO_LOW);	/* SCART Pin 8 power on */
+    board_gpio_drive(176, PIO_LOW);	/* SCART Pin 8 = 12V */
+    board_gpio_drive(179, PIO_LOW);	/* SCART A/V out on */
+    board_gpio_drive(190, PIO_LOW);	/* SCART Fastblank on (enable RGB) */
+
+    /* low-level network config (PHY setup, Interrupt setup, ...) */
+    board_eth_init();
+
+    /* Set the FAN to on! */
+    board_gpio_drive(187, PIO_HIGH);
+
+    pwm_init();
+
+#ifdef CONFIG_LOAD_INITIAL_DECARM_CODE
+    arm9_init();
+#endif
+
+    led_init();
+
+    return 0;
+}
+
+
+
+/*******************************************************************************/
+/* set u-boot's idea of SDRAM size                                             */
+
+int dram_init(void)
+{
+    /* In low level init we stored the size of the installed RAM
+       into untouched RAM. Now copy that content into gd->bi */
+    volatile u32 *size1 = (volatile u32*) SCRATCH_2_REG;
+    volatile u32 *size2 = (volatile u32*) SCRATCH_3_REG;
+
+    gd->bd->bi_dram[0].start = 0;
+    gd->bd->bi_dram[0].size = *size1;
+
+    gd->bd->bi_dram[1].start = 0x10000000;
+    gd->bd->bi_dram[1].size = *size2;
+
+    return (0);
+}
+
+/*******************************************************************************/
+
+#ifdef CONFIG_SERIAL_TAG
+void get_board_serial(struct tag_serialnr *serialnr)
+{
+	serialnr->high = (flash_info[0].serial[0] << 24) | (flash_info[0].serial[1] << 16) | (flash_info[0].serial[2] << 8) | flash_info[0].serial[3];
+	serialnr->low  = (flash_info[0].serial[5] << 16) | (flash_info[0].serial[6] << 8) | flash_info[0].serial[7];
+}
+#endif
+
+#ifdef CONFIG_REVISION_TAG
+u32 get_board_rev(void)
+{
+	return flash_info[0].serial[4];
+}
+#endif
+
+#ifdef CONFIG_DISPLAY_CPUINFO
+int print_cpuinfo(void)
+{
+    volatile u32 *reg;
+    volatile u32 *idven = (volatile u32*) SCRATCH_4_REG;
+    volatile u32 *chrev = (volatile u32*) SCRATCH_5_REG;
+    volatile u32 *fuses = (volatile u32*) 0xE0440148;
+    volatile u32 *hwopt = (volatile u32*) 0xE044014C;
+    u32 CIV = *idven;
+    u16 ChipID, ChipVendor;
+    u8  Version;
+    u32 HaveChip = 0;
+    char  Rstr[10];
+    char *ukn   = "unknown";
+    char *Vstr  = ukn;
+    char *IDstr = ukn;
+    u32 pre, pos, cnt2;
+    u64 i, f, fin, fp;
+    u64 out;
+    u32 outx, outr;
+#ifdef CPU_CFG_DEBUG
+    volatile u32 *ccfg0 = (volatile u32*) 0xE0440100;
+    u32 ChipConfig;
+    u8 AddressBits;
+#endif
+
+    memset(Rstr, 0, 10);
+    strcpy(Rstr, ukn);
+
+    ChipVendor =  CIV & 0xFFFF;
+    ChipID     = (CIV >> 16) & 0xFFFF;
+    Version    =  *chrev & 0xFF;
+
+    if (ChipVendor == 0x14F1)
+    {
+	Vstr = "Conexant";
+	if (ChipID == 0x2427)
+	{
+	    IDstr = "CX2427x (Pecos)";
+	    HaveChip = 1;
+	    if (Version == 0x10)
+	    {
+		/* Nevis Rev. B0 comes up as Pecos Rev. B0, but has an unused fuse but set */
+		if (*fuses & 0x01000000)
+		{
+		    IDstr = "CX2450x (Nevis)";
+		    ChipID = 0x2450;
+		    *idven = 0x245014F1;
+		}
+	    }
+	}
+	else if (ChipID == 0x2450)
+	{
+	    IDstr = "CX2450x (Nevis)";
+	    HaveChip = 1;
+	    /* Rev C0 is coming up with wrong ID */
+	    if (Version == 0x10)
+	    {
+		Version = 0x20;
+		*chrev  = 0x20;
+	    }
+	}
+	else if (ChipID == 0x4170)
+	{
+	    IDstr = "Pecos or Nevis";
+	    HaveChip = 1;
+	}
+
+	if (HaveChip)
+	{
+	    /* Decode the chip revision */
+	    u8 major = (Version >> 4) & 0x0F;
+	    u8 minor =  Version       & 0x0F;
+	    Rstr[0] = major + 0x41;
+	    Rstr[1] = minor + 0x30;
+	    Rstr[2] = 0x00;
+	}
+    }
+    else
+	Vstr = ukn;
+
+    printf("\xBA Chipset information                                                          \xBA\n");
+    printf("\xBA Vendor: %-10sType: %-17sRevision: %-9sFuses: %.8X  \xBA\n", Vstr, IDstr, Rstr, *fuses);
+    printf("\xBA Option: %.8X  max. clock: %.3d MHz    Core voltage: %-22s\xBA\n", *hwopt, 
+	    ((Version >> 4) == 2) ? (((*hwopt) & 0x800000) ? 450 : 550) : 600,
+	    ((*hwopt) & 0x400000) ? "low" : "high");
+    printf("\xCC\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD"
+    	   "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD"
+	   "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD"
+	   "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xB9\n");
+
+    /* additionally read out the PLL's and display their clock frequency */
+    u32 cnt, val;
+    char *pllname[9] = {"MPG0", "MPG1", "HD  ", "AUD ", "PLL0", "PLL1", "PLL2", "FENRUS", "unknown"};
+    u32   pllfreq[8] = {0, 0, 0, 0, 0, 0, 0, 0};
+    u32   cpumap[16] = {0, 1, 2, 3, 4, 4, 5, 6, 7, 8, 8, 8, 8, 8, 8, 8};
+
+    printf("\xBA Clock information                                                            \xBA\n");
+    printf("\xBA ");
+
+    for (cnt = 0; cnt < 7; cnt++)	/* there are 7 (6) verve PLLs for our interrest (MPG1 is not avail in Nevis) */
+    {
+
+	reg = (volatile u32*)(0xE0440000 + (cnt * 8));
+	val = *reg;
+	i   = (val >> 25) & 0x3F;	/* Integer part      bit 30:25 */
+	f   =  val        & 0x01FFFFFF;	/* Fractional part   bit 24:00 */
+
+	reg = (volatile u32*)(0xE0440000 + (cnt * 8) + 4);
+	val = *reg;
+	pre = (val >> 16) & 0x0F;	/* Pre divider       bit 19:16 */
+	pos = (val >> 20) & 0x0F;	/* Post divider      bit 23:20 (not functional for Nevis Revision A to C) */
+
+	if (pre > 0)
+	{
+	    fin = 60000000 / pre;		/* PLL input frequency = 60 MHz xtal frequency / pre divider */
+	    fp  = (i << 32) + ((f << 32) / 0x02000000);
+	    out = ((fin * fp) >> 32);
+	}
+	else
+	    out = 0;
+
+	/* round down to kHz */
+	outx = (u32) out;	/* there is no code for u64 div, so cast here. It's save, believe me */
+	for (cnt2 = 0; cnt2 < 3; cnt2++)
+	{
+	    outr = outx / 10;
+	    if ((outx % 10) > 4)
+		outr++;
+	    outx /= 10;
+	}
+
+	pllfreq[cnt] = outr;
+
+	printf("%s: %3d.%.3d MHz  ", pllname[cnt], outr / 1000, outr % 1000);
+	if (cnt == 3)
+	    printf(" \xBA\n\xBA ");
+    }
+    printf("                    \xBA\n");
+
+    reg   = (volatile u32*)(0xE0440054);
+    val   = *reg;
+    outr  = pllfreq[cpumap[(val >> 24) & 0x0F]];
+    outr /= ((val >> 16) & 0xFF);		/* apply the CPU clock post divider */
+
+    printf("\xBA CPU : %3d.%.3d MHz from %-54s\xBA\n", outr / 1000, outr % 1000, pllname[cpumap[(val >> 24) & 0x0F]]);
+
+    printf("\xCC\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD"
+    	   "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD"
+	   "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD"
+	   "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xB9\n");
+
+#ifdef CPU_CFG_DEBUG
+    printf("\xBA CPU configuration information                                                \xBA\n");
+
+    ChipConfig  = *ccfg0;
+    AddressBits = (ChipConfig >> 11) & 7;
+    char *addrbits[6] = {"21 bits", "22 bits", "23 bits", "24 bits", "25 bits", "26 bits"};
+
+    printf("\xBA CFG0 : %.8X                                                              \xBA\n", ChipConfig);
+    printf("\xBA Flash addressing :  %.8X (%-10s)    Reset time: %.3dms               \xBA\n", AddressBits,
+            (AddressBits > 5) ? "invalid" : addrbits[AddressBits],
+            (ChipConfig & 1) ? 1 : 200);
+
+    printf("\xCC\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD"
+    	   "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD"
+	   "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD"
+	   "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xB9\n");
+#endif
+
+    return (0);
+}
+#endif
+
+u32 board_get_width(void)
+{
+	return DISPLAY_WIDTH;
+}
+
+u32 board_get_height(void)
+{
+	return DISPLAY_HEIGHT;
+}
+
diff --git a/board/coolstream_hdx/display.c b/board/coolstream_hdx/display.c
new file mode 100644
index 0000000..b958f1f
--- /dev/null
+++ b/board/coolstream_hdx/display.c
@@ -0,0 +1,618 @@
+/*
+ * (C) Copyright 2008
+ * Coolstream Internation Limited
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <version.h>
+#include <asm/arch/nevis.h>
+#include <asm/arch/fp_uart.h>
+#include <asm/arch/sys_proto.h>
+
+//DECLARE_GLOBAL_DATA_PTR;
+
+/* driver for an Samsun HCR-13SS22 serial VFD-display connected via an
+   Coolstream VFD-Controller.
+   We do not use the VFD-stuff provided by u-boot, because this VFD has only
+   12 digits with free programmable 5x7 matrix and some fixed display elements.
+   So it makes no sense to map it into a framebuffer. */
+
+#ifdef HAVE_COOLSTREAM_VFD_CONTROLLER
+
+#ifndef DISPLAY_PIO_CLOCK
+#error DISPLAY_PIO_CLOCK not defined
+#endif
+
+#ifndef DISPLAY_PIO_DATA
+#error DISPLAY_PIO_DATA not defined
+#endif
+
+#ifndef DISPLAY_PIO_RESET
+#error DISPLAY_PIO_STROBE not defined
+#endif
+
+#ifndef DISPLAY_PIO_STATUS
+#error DISPLAY_PIO_BLANK not defined
+#endif
+
+/*******************************************************************************/
+
+#define STX			0x02
+#define ETX			0x03
+#define ACK			0x06
+#define BEL			0x07
+#define NAK			0x15
+
+#define VFDCTRL_CMD_WRITE_CHAR	0x00	/* wirte the ASCCI charater to the given segment address (len = 1) */
+#define VFDCTRL_CMD_WRITE_RAW	0x10	/* write pixel data to the given segment address (len = 5) */
+#define VFDCTRL_CMD_CLEAR	0x20	/* clear the entire display (len = 0) */
+#define VFDCTRL_CMD_SET_BRIGHT	0x30	/* set the displays brightness (len = 0, address field = brightness 0 to 15) */
+#define VFDCTRL_CMD_SET_ICON    0x40
+#define VFDCTRL_CMD_CLR_ICON    0x50
+#define VFDCTRL_CMD_SET_PIO     0x60
+#define VFDCTRL_CMD_CLR_PIO     0x70
+#define VFDCTRL_CMD_VERSION	0xF0	/* let the controller print it's own version onto the display */
+#define VFDCTRL_CMD_WRITE_STR	0xF1	/* let the controller print a simple text */
+#define VFDCTRL_CMD_LED_CTRL	0xF2	/* let the controller set a led */
+
+#define VFD_DEFAULT_BAUDRATE   115200
+
+
+typedef enum
+{
+    VFD_ICON_BAR8       = 0x00000004,
+    VFD_ICON_BAR7       = 0x00000008,
+    VFD_ICON_BAR6       = 0x00000010,
+    VFD_ICON_BAR5       = 0x00000020,
+    VFD_ICON_BAR4       = 0x00000040,
+    VFD_ICON_BAR3       = 0x00000080,
+    VFD_ICON_BAR2       = 0x00000100,
+    VFD_ICON_BAR1       = 0x00000200,
+    VFD_ICON_FRAME      = 0x00000400,
+    VFD_ICON_HDD        = 0x00000800,
+    VFD_ICON_MUTE       = 0x00001000,
+    VFD_ICON_DOLBY      = 0x00002000,
+    VFD_ICON_POWER      = 0x00004000,
+    VFD_ICON_TIMESHIFT  = 0x00008000,
+    VFD_ICON_SIGNAL     = 0x00010000,
+    VFD_ICON_TV         = 0x00020000,
+    VFD_ICON_RADIO      = 0x00040000,
+    VFD_ICON_HD         = 0x01000001,
+    VFD_ICON_1080P      = 0x02000001,
+    VFD_ICON_1080I      = 0x03000001,
+    VFD_ICON_720P       = 0x04000001,
+    VFD_ICON_480P       = 0x05000001,
+    VFD_ICON_480I       = 0x06000001,
+    VFD_ICON_USB        = 0x07000001,
+    VFD_ICON_MP3        = 0x08000001,
+    VFD_ICON_PLAY       = 0x09000001,
+    VFD_ICON_COL1       = 0x09000002,
+    VFD_ICON_PAUSE      = 0x0A000001,
+    VFD_ICON_CAM1       = 0x0B000001,
+    VFD_ICON_COL2       = 0x0B000002,
+    VFD_ICON_CAM2       = 0x0C000001
+} vfd_icon;
+
+#if 0
+typedef enum {
+	VFD_LED_1_ON		= 0x81,
+	VFD_LED_2_ON		= 0x82,
+	VFD_LED_3_ON		= 0x83,
+	VFD_LED_1_OFF		= 0x01,
+	VFD_LED_2_OFF		= 0x02,
+	VFD_LED_3_OFF		= 0x03,
+} vfd_led_ctrl_t;
+#endif
+static u32 have_controller;
+static vfd_icon last_val = 0xFF;
+
+typedef struct {
+	int  (*init           )(void);
+	int  (*detect         )(void);
+	int  (*led_control    )(vfd_led_ctrl_t ctrl);
+	void (*tx             )(u8 cmd, u8 addr, u8 len, char *data);
+	void (*set_text       )(char *text, int len);
+} vfd_ops;
+
+static const vfd_ops *ops;
+
+/*******************************************************************************/
+
+static int fp_uart_rx(u8 *data, int len)
+{
+	int i = 0, j = len;
+	int timeout = 8000; /* 800 ms */
+
+	while (j--) {
+		while ((fp_uart_get_rx_count() == 0) && timeout) {
+			if ((fp_uart_get_status() & 1) && !fp_uart_get_rx_count())
+				fp_uart_get_rx();
+			udelay(100);
+			timeout--;
+		}
+		if (!timeout) {
+			printf("*** Warning: RX timed-out\n");
+			break;
+		}
+
+		data[i++] = fp_uart_get_rx();
+	}
+
+	return len - j;
+}
+
+/*******************************************************************************/
+
+static int fp_uart_tx(u8 *data, int len)
+{
+	int i = 0, j = len;
+	int timeout = 8000; /* 800 ms */
+
+	while (j--) {
+		while ((fp_uart_get_tx_count() != 0) && timeout) {
+			udelay(100);
+			timeout--;
+		}
+		if(!timeout) {
+			printf("*** Warning: TX timed-out\n");
+			break;
+		}
+
+		fp_uart_set_tx(data[i]);
+	}
+
+	return len - j;
+}
+
+/*******************************************************************************/
+
+static int _old_vfd_init(void)
+{
+	board_gpio_drive( 69, PIO_OFF);	/* hack */
+	board_gpio_drive(188, PIO_OFF);	/* hack */
+
+	board_gpio_drive(DISPLAY_PIO_RESET, PIO_HIGH);	/* assert reset signal */
+	board_gpio_drive(DISPLAY_PIO_STATUS, PIO_OFF);	/* configure as input */
+	board_gpio_drive(DISPLAY_PIO_CLOCK, PIO_HIGH);	/* set clock to high level for proper initial value */
+	udelay(2000);					/* wait a little bit */
+	board_gpio_drive(DISPLAY_PIO_RESET, PIO_LOW);	/* release reset signal */
+
+	return 0;
+}
+
+/*******************************************************************************/
+
+static int _old_vfd_detect(void)
+{
+	u32 have_ctrl = 0;
+	int cnt = 0;
+
+	for (cnt = 0; cnt < 16; cnt++) {
+		udelay(100);
+		/* read the status line, it goes low, if the controller is ready */
+		if (board_gpio_read(DISPLAY_PIO_STATUS) == 0) {
+			/* with a 18.432 MHz Xtal this takes around 5 loops */
+			cnt = 16;
+			have_ctrl = 1;
+		}
+	}
+
+	return have_ctrl == 1;
+}
+
+/*******************************************************************************/
+
+static void _old_vfd_set_text(char *text, int len)
+{
+	int cnt;
+
+	if (!ops)
+		return;
+
+	for (cnt = 0; cnt < 12; cnt++) {
+		if (cnt < len)
+			ops->tx(VFDCTRL_CMD_WRITE_CHAR, cnt + 1, 1, text + cnt);
+		else
+			ops->tx(VFDCTRL_CMD_WRITE_CHAR, cnt + 1, 1, " ");
+	}
+}
+
+/*******************************************************************************/
+
+static void _old_vfd_tx(u8 cmd, u8 addr, u8 len, char *data)
+{
+	char outbuffer[6];
+	u8 cnt = 0;
+	u8 err = 1;
+	s8 byte, bit;
+
+	if (((len > 0) & (!data)) || (!have_controller))
+		return;
+
+	board_gpio_drive(DISPLAY_PIO_CLOCK, PIO_LOW);	/* set clock to low level to indicate that we want xfer new data */
+
+	outbuffer[0] = cmd | addr;
+	if (len > 5)
+		len = 5;
+
+	for (byte = 0; byte < len; byte++)
+		outbuffer[byte + 1] = data[byte];
+
+	while (cnt < 16) {
+		cnt++;
+		udelay(1);
+		if (board_gpio_read(DISPLAY_PIO_STATUS) == 1) {
+			/* OK, the controller is ready to receive data */
+			err = 0;
+			cnt = 16;
+		}
+	}
+
+	if (err) {
+		printf("*** Warning: VFD-Controller did not respond.\n");
+		return;
+	}
+
+	/* send the data byte by byte, MSB first */
+	for (byte = 0; byte < 6; byte++) {
+		for (bit = 7; bit >= 0; bit--) {
+			board_gpio_drive(DISPLAY_PIO_CLOCK, PIO_LOW);
+			udelay(2);
+			board_gpio_drive(DISPLAY_PIO_DATA, (outbuffer[byte] & (1 << bit)) ? PIO_HIGH : PIO_LOW);
+			udelay(2);
+			board_gpio_drive(DISPLAY_PIO_CLOCK, PIO_HIGH);
+			udelay(10);	/* min. 9 clock cycles (0.5 us per clock cycle at 12 MHz) */
+		}
+	}
+	/* wait, until the controller set it's status line back to low level */
+	cnt = 0;
+	err = 1;
+	while (cnt < 255) {
+		cnt++;
+		udelay(10);
+		if (board_gpio_read(DISPLAY_PIO_STATUS) == 0) {
+			/* OK, the controller has finished receiving our data */
+			cnt = 255;
+			err = 0;
+		}
+	}
+
+	if (err)
+		printf("*** Warning: VFD-Controller did not accepted our data.\n");
+
+}
+
+/*******************************************************************************/
+
+static const vfd_ops old_vfd_ops = {
+	.init		= _old_vfd_init,
+	.detect		= _old_vfd_detect,
+	.tx		= _old_vfd_tx,
+	.set_text	= _old_vfd_set_text,
+};
+
+/*******************************************************************************/
+
+static int _new_vfd_init(void)
+{
+	volatile u8 *brdl = (volatile u8 *) UART_FIFO_BRDL_REG(FP_DEFAULT_UART);
+	volatile u8 *brdu = (volatile u8 *) UART_IRQE_BRDU_REG(FP_DEFAULT_UART);
+	volatile u8 *exp = (volatile u8 *) UART_EXP_REG(FP_DEFAULT_UART);
+	volatile u8 *frmc = (volatile u8 *) UART_FRMC_REG(FP_DEFAULT_UART);
+	volatile u8 *fifc = (volatile u8 *) UART_FIFC_REG(FP_DEFAULT_UART);
+	u32 baudrate;
+
+	baudrate	 = (54000000 / (16 * VFD_DEFAULT_BAUDRATE)) - 1;
+	*brdu		 = 0x00;		/* TIDE, TSRE, RSRE */
+	*frmc		|= 0x81;		/* BDS = 1 *//* 25000bps, 8, N, 1 */
+	*brdl		 =  baudrate       & 0xFF;
+	*brdu		 = (baudrate >> 8) & 0xFF;
+	*exp		 = 0x00;
+	*frmc		&= ~0x80;		/* BDS = 0 */
+	*fifc		 = 0x07 | (3 << 4);	/* FIFO:128b, TXINT: empty */
+	*brdu		 = 0x00;		/* TIDE, TSRE, RSRE */
+
+	board_gpio_drive(DISPLAY_PIO_RESET, PIO_HIGH);	/* assert reset signal */
+	udelay(2000);		/* wait a little bit */
+	board_gpio_drive(DISPLAY_PIO_RESET, PIO_LOW);	/* release reset signal */
+
+	return 0;
+}
+
+/*******************************************************************************/
+
+static int _new_vfd_detect(void)
+{
+	u8 data;
+
+	fp_uart_rx(&data, 1);
+	if (data != BEL)
+		return 0;
+
+	/* Enable button irq here! */
+	fp_uart_start_rx();
+
+	return 1;
+}
+
+/*******************************************************************************/
+
+static void _new_vfd_tx(u8 cmd, u8 addr, u8 len, char *data)
+{
+	unsigned char cmd_buf[256 + 4];
+	u8 cnt = 0, i;
+
+	if (((len > 0) && (!data)))
+		return;
+
+	cmd_buf[cnt++] = STX;
+	switch (cmd) {
+	case VFDCTRL_CMD_WRITE_STR:
+		cmd_buf[cnt++] = 'A';
+		memcpy(cmd_buf + cnt, data, len);
+		cnt += len;
+		break;
+	case VFDCTRL_CMD_SET_BRIGHT:
+		cmd_buf[cnt++] = 'B';
+		cmd_buf[cnt++] = addr;
+		break;
+	case VFDCTRL_CMD_CLEAR:
+		cmd_buf[cnt++] = 'A';
+		break;
+	case VFDCTRL_CMD_WRITE_RAW:
+		cmd_buf[cnt++] = 'P';
+		cmd_buf[cnt++] = addr;			/* Segment */
+		memcpy(cmd_buf + cnt, data, len);	/* Pixel data */
+		cnt += len;
+		break;
+	case VFDCTRL_CMD_LED_CTRL:
+		cmd_buf[cnt++] = 'L';
+		cmd_buf[cnt++] = addr;			/* LED */
+		break;
+	case VFDCTRL_CMD_SET_ICON:
+	case VFDCTRL_CMD_CLR_ICON:
+	{
+		cmd_buf[cnt++] = 'P';
+		cmd_buf[cnt++]  = addr | 0x80 | ((cmd == VFDCTRL_CMD_CLR_ICON) ? 0x40 : 0x00);
+		memset(&cmd_buf[cnt], 0, 2);
+		cnt += 2;
+		memcpy(&cmd_buf[cnt], data, 3);	/* Pixel data (max 3 bytes) */
+		cnt += 3;
+		break;
+	}
+	case VFDCTRL_CMD_SET_PIO:
+	case VFDCTRL_CMD_CLR_PIO:
+	case VFDCTRL_CMD_VERSION:
+	case VFDCTRL_CMD_WRITE_CHAR:
+	default:
+		printf("*** Warning: FrontPanel: unknown command\n");
+		return;
+	}
+
+	cmd_buf[cnt++] = ETX;
+
+	fp_uart_stop_rx();
+
+	for (i = 0; i < cnt; i++) {
+		u8 d;
+		fp_uart_tx(&cmd_buf[i], 1);
+		fp_uart_rx(&d, 1);
+		if (d != ACK) {
+			printf("*** Warning: FrontPanel: no ACK\n");
+			//break;
+		}
+	}
+
+	fp_uart_start_rx();
+}
+
+/*******************************************************************************/
+
+static int _new_vfd_led_control(vfd_led_ctrl_t ctrl)
+{
+	if (!ops || !ops->tx)
+		return 0;
+
+	ops->tx(VFDCTRL_CMD_LED_CTRL, ctrl, 0, NULL);
+
+	return 0;
+}
+
+/*******************************************************************************/
+
+static void _new_vfd_set_text(char *text, int len)
+{
+	if(!ops || !ops->tx)
+		return;
+
+	ops->tx(VFDCTRL_CMD_WRITE_STR, 0, len, text);
+}
+
+/*******************************************************************************/
+
+static const vfd_ops new_vfd_ops = {
+	.init		= _new_vfd_init,
+	.detect		= _new_vfd_detect,
+	.tx		= _new_vfd_tx,
+	.led_control	= _new_vfd_led_control,
+	.set_text	= _new_vfd_set_text,
+};
+
+/*******************************************************************************/
+
+void board_display_init(void)
+{
+	u32 system_rev;
+	extern u32 get_board_rev(void);
+
+	system_rev = get_board_rev();
+
+	//system_rev = 8;// HACK
+	if (system_rev >= 8)
+		ops = &new_vfd_ops;
+	else
+		ops = &old_vfd_ops;
+
+	if(ops->init)
+		ops->init();
+
+	if (ops->detect) {
+		if (!(have_controller = ops->detect()))
+			printf("*** Warning: no VFD-Controller present\n");
+	}
+}
+
+/*******************************************************************************/
+
+void board_display_clear(void)
+{
+	if (!have_controller)
+		return;
+
+	if (!ops || ops->tx)
+		return;
+
+	ops->tx(VFDCTRL_CMD_CLEAR, 0, 0, NULL);
+}
+
+/*******************************************************************************/
+
+void display_set_text(char *text)
+{
+	u32 tlen;
+
+	if (!have_controller)
+		return;
+
+	if (!ops || !ops->set_text)
+		return;
+
+	if (!text)
+		text = "U-Boot";
+
+	tlen = strlen(text);
+	ops->set_text(text, tlen);
+}
+
+/*******************************************************************************/
+
+static const vfd_icon ict[9] = {0, VFD_ICON_BAR1, VFD_ICON_BAR2, VFD_ICON_BAR3, VFD_ICON_BAR4, VFD_ICON_BAR5, VFD_ICON_BAR6, VFD_ICON_BAR7, VFD_ICON_BAR8};
+
+/*******************************************************************************/
+
+void display_show_progress(u32 first, u32 last, u32 current)
+{
+	char ic_data[3];
+	u32 tmp, val = 0;
+	vfd_icon vin = 0;
+
+	if (!have_controller)
+		return;
+
+	if(!ops || !ops->tx)
+		return;
+
+	if ((first == 0) && (last == 0) && (current == 0)) {
+		/* switch off */
+		vin |= VFD_ICON_BAR8 | VFD_ICON_BAR7 | VFD_ICON_BAR6 | VFD_ICON_BAR5 | VFD_ICON_BAR4 | VFD_ICON_BAR3 | VFD_ICON_BAR2 | VFD_ICON_BAR1 | VFD_ICON_FRAME;
+		ic_data[0] = (vin >> 16) & 0xFF;
+		ic_data[1] = (vin >>  8) & 0xFF;
+		ic_data[2] =  vin	 & 0xFF;
+		ops->tx(VFDCTRL_CMD_CLR_ICON, 0, sizeof(ic_data), ic_data);
+	} else {
+		if (first > last) {
+			/* revert */
+			tmp = first;
+			first = last;
+			last = tmp;
+		}
+
+		if (current > last)
+			current = last;
+
+		/* adjust range so that it start at 0 */
+		last -= first;
+		current -= first;
+
+		/* break down the values to get a range of 0 to 8 */
+		if (last == 0)
+			val = 8;
+		else {
+			val = (current * 8) / last;
+			if (((current * 8) % last) > (last / 2))	/* round up */
+				val++;
+
+			if (val > 8)	/* should never happen */
+				val = 8;
+		}
+
+		if (val != last_val) {
+			for (tmp = val + 1; tmp < 9; tmp++)
+				vin |= ict[tmp];
+
+			ic_data[0] = (vin >> 16) & 0xFF;
+			ic_data[1] = (vin >>  8) & 0xFF;
+			ic_data[2] =  vin	 & 0xFF;
+			ops->tx(VFDCTRL_CMD_CLR_ICON, 0, sizeof(ic_data), ic_data);
+
+			vin = VFD_ICON_FRAME;
+			for (tmp = 0; tmp <= val; tmp++)
+				vin |= ict[tmp];
+
+			ic_data[0] = (vin >> 16) & 0xFF;
+			ic_data[1] = (vin >>  8) & 0xFF;
+			ic_data[2] =  vin	 & 0xFF;
+			ops->tx(VFDCTRL_CMD_SET_ICON, 0, sizeof(ic_data), ic_data);
+			last_val = val;
+		}
+	}
+}
+
+/*******************************************************************************/
+
+void display_show_icon(u32 icon, u32 clear)
+{
+	char ic_data[3];
+	//u8 cmd;
+
+	if (!have_controller)
+		return;
+
+	if(!ops || !ops->tx)
+		return;
+
+	ic_data[0] = (icon >> 16) & 0xFF;
+	ic_data[1] = (icon >>  8) & 0xFF;
+	ic_data[2] =  icon	  & 0xFF;
+	//cmd	   = clear ? VFDCTRL_CMD_CLR_ICON : VFDCTRL_CMD_SET_ICON;
+
+	ops->tx(clear ? VFDCTRL_CMD_CLR_ICON : VFDCTRL_CMD_SET_ICON, (icon >> 24) & 0xFF, sizeof(ic_data), ic_data);
+}
+
+void display_led_control(vfd_led_ctrl_t ctrl)
+{
+	if (!have_controller)
+		return;
+
+	if(!ops || !ops->led_control)
+		return;
+
+	ops->led_control(ctrl);
+}
+
+#endif /* HAVE_COOLSTREAM_VFD_CONTROLLER */
diff --git a/board/coolstream_hdx/flash.c b/board/coolstream_hdx/flash.c
new file mode 100644
index 0000000..3bf2d7d
--- /dev/null
+++ b/board/coolstream_hdx/flash.c
@@ -0,0 +1,865 @@
+/*
+ * (C) Copyright 2008
+ * Coolstream International Limited
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/arch/nevis.h>
+#include <asm/arch/sys_proto.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+flash_info_t flash_info[CONFIG_SYS_MAX_FLASH_BANKS];
+
+static u32 flash_flags = 0;
+
+#ifndef CFG_EXT_LEGACY_FLASH
+#error CFG_EXT_LEGACY_FLASH must be set to use this flash driver
+#endif
+
+/* AMD/Spansion commands */
+#define CMD_UNLOCK1		0x00AA
+#define CMD_UNLOCK2		0x0055
+#define CMD_WRITE_BUFF_SETUP	0x0025
+#define CMD_WRITE_BUFF_CONFIRM	0x0029
+#define CMD_ERASE_CONFIRM	0x0030
+#define CMD_ERASE_SETUP		0x0080
+#define CMD_SSP_ENTER		0x0088	/* enter secured silicon sector entry access */
+#define CMD_AUTOSELECT		0x0090	/* enter auto selection command mode */
+#define CMD_WRITE_WORD_SETUP	0x00A0
+#define	CMD_PPB_ENTER		0x00C0	/* enter persistent protection bit programming mode */
+#define CMD_READ_ARRAY		0x00F0	/* also know as reset */
+
+/* flags */
+#define FLASH_ERASE_ALL		0x0001
+
+/*******************************************************************************/
+
+static void exec_flash_cmd(ushort bank, ulong base_addr, ulong sect_addr, ushort cmd)
+{
+    volatile u32 *romdesc = (volatile u32*)(ROM_DESC0_REG + (bank * 4));
+    *romdesc |= 0x00800000;	/* bit 23: enable write access (16 bit translation) */
+
+    *((volatile ushort*)(base_addr + (0x0555 << 1))) = CMD_UNLOCK1;
+    *((volatile ushort*)(base_addr + (0x02AA << 1))) = CMD_UNLOCK2;
+
+    if ((cmd == CMD_ERASE_CONFIRM) || (cmd == CMD_WRITE_BUFF_SETUP))
+	*((volatile ushort*) sect_addr) = cmd;
+    else
+	*((volatile ushort*)(base_addr + (0x0555 << 1))) = cmd;
+
+    *romdesc &= 0xFF7FFFFF;	/* bit 23: disable write access */
+}
+
+/*******************************************************************************/
+
+static void leave_flash_pgm(ushort bank, ulong addr, int leave_ssse)
+{
+    volatile u32 *romdesc = (volatile u32*)(ROM_DESC0_REG + (bank * 4));
+    *romdesc |= 0x00800000;	/* bit 23: enable write access (16 bit translation) */
+    if (leave_ssse)
+    {
+	*((volatile ushort*)(addr + (0x0555 << 1))) = CMD_UNLOCK1;
+        *((volatile ushort*)(addr + (0x02AA << 1))) = CMD_UNLOCK2;
+	*((volatile ushort*)(addr + (0x0555 << 1))) = 0x090;
+    }
+    else
+	*((volatile ushort*) addr) = 0x0090;
+    *((volatile ushort*) addr) = 0x0000;
+    *romdesc &= 0xFF7FFFFF;	/* bit 23: disable write access */
+}
+
+/*******************************************************************************/
+
+static int wait_for_write_exec_done(ulong sect_addr)
+{
+    /* not as shown in the datasheet, because we can not read back data while 
+       in program mode */
+    u16 d1, d2;
+
+    while (1)
+    {
+        /* read status byte twice */
+        d1 = *((volatile ushort*)(sect_addr));
+	d2 = *((volatile ushort*)(sect_addr));
+
+	if ((d1 & 0x40) == (d2 & 0x40))
+	{
+	    /* no more toggle, so the flash is ready */
+	    return ERR_OK;
+	}
+    }
+}
+
+/*******************************************************************************/
+
+static int wait_for_erase_exec_done(ulong sect_addr)
+{
+    /* as shown in datasheet page 32, Figure 7.4 */
+    u16 d1, d2, d3;
+
+    while (1)
+    {
+	/* read 1, check DQ7 */
+	d1 = *((volatile ushort*)(sect_addr));
+
+	if (d1 & 0x80)
+	{
+	    /* data is valid, read status twice */
+	    d2 = *((volatile ushort*)(sect_addr));
+	    d3 = *((volatile ushort*)(sect_addr));
+
+	    if ((d2 & 0x40) == (d3 & 0x40))
+	    {
+		/* no mor toggling, check DQ2 */
+		if ((d2 & 0x04) == (d3 & 0x04))
+		    return ERR_OK;
+		else
+		    return ERR_NOT_ERASED;	/* device in Erase/Suspend Mode */
+	    }
+	    else
+		return ERR_NOT_ERASED;	/* device error */
+	}
+	else
+	{
+	    /* data not (yet) valid, check DQ5 */
+	    if (d1 & 0x20)
+	    {
+		d2 = *((volatile ushort*)(sect_addr));
+		d3 = *((volatile ushort*)(sect_addr));
+
+		/* check DQ6 */
+		if ((d2 & 0x40) != (d3 & 0x40))
+		    return ERR_TIMOUT;		/* operation timed out */
+		/* else device busy, repoll */
+	    }
+	    /* else device busy, repoll */
+	}
+    }
+}
+
+/*******************************************************************************/
+
+static int wait_for_ppb_exec_done(ulong sa0, ulong sa, ushort erase)
+{
+    /* as shown in datasheet page 39, Figure 8.2 */
+
+    u16 d1, d2;
+
+    while (1)
+    {
+	/* read status byte twice */
+        d1 = *((volatile ushort*)(sa0));
+        d2 = *((volatile ushort*)(sa0));
+
+	if ((d1 & 0x40) == (d2 & 0x40))
+	{
+	    /* no more toggle of DQ6, so the flash is ready */
+	    udelay(500);			/* wait 500 us */
+	    d1 = *((volatile ushort*)(sa + 4));
+	    if ((d1 & 1) == (erase & 1))	/* DQ0 equals the erase/program state ? */
+		return ERR_OK;
+	    else
+	    {
+		printf("%s(0x%.8lX, 0x%.8lX, %d); DQ0 verify failed\n", __FUNCTION__, sa0, sa, erase);
+		return ERR_TIMOUT;
+	    }
+	}
+	else
+	{
+	    /* check DQ5 */
+	    if (d1 & 0x20) 
+	    {
+		/* check for togglind DQ6 once more */
+    		d1 = *((volatile ushort*)(sa0));
+    		d2 = *((volatile ushort*)(sa0));
+
+		if ((d1 & 0x40) == (d2 & 0x40))
+		{
+		    udelay(500);			/* wait 500 us */
+		    d1 = *((volatile ushort*)(sa + 4));
+		    if ((d1 & 1) == (erase & 1))	/* DQ0 equals the erase/program state ? */
+			return ERR_OK;
+		    else
+		    {
+			printf("%s(0x%.8lX, 0x%.8lX, %d); DQ0 verify failed (repeat)\n", __FUNCTION__, sa0, sa, erase);
+			return ERR_TIMOUT;
+		    }
+		}
+	    }
+	}
+    }
+
+    /* send a reset command - normally, but leave_flash_pgm() must be called, which includes an device reset */
+    
+}
+
+/*******************************************************************************/
+/* Detect the installed flash chips and initalize the controller in that way
+   that we have an continous address range starting at 0xF0000000. This
+   routine requires, that u-boot was relocated into RAM.                       */
+
+ulong flash_init(void)
+{
+    ulong  full_size = 0;
+    ushort bank;
+    ulong  curr_addr = 0xF0000000;
+    ulong  data;
+
+    flash_flags = 0;
+
+    for (bank = 0; bank < CONFIG_SYS_MAX_FLASH_BANKS; bank++)
+    {
+	/* setup the ROM descriptor and enable write access */
+	volatile u32 *romdesc = (volatile u32*)(ROM_DESC0_REG + (bank * 4));
+	*romdesc &= 0x7FFFF000;	/* bit 31: ROM descritptor, bit 10 ... 8: clear CS, bit 4: 16 bit ROM */
+	*romdesc |= 0x00000020;	/* bit 5: 16 bit ROM */
+	*romdesc |= bank << 8;	/* bit 10 ... 8: set CS */
+
+	/* enable ROM_MAP_REG to have access to the next possible available chip */
+	volatile u32 *rommap = (volatile u32*)(ROM_MAP_REG + (bank * 4));
+	*rommap = (curr_addr & 0x0FFF0000) | 0x00000FFF;
+
+	/* disable XOE for this CS */
+	volatile u32 *romxoe = (volatile u32*) ROM_XOE_MASK_REG;
+	*romxoe |= (1 << bank);
+
+	/* timing stuff this CS */
+	volatile u32 *romext = (volatile u32*)(0xE0010080 + (bank * 4));
+	*romext = 0x00020021;
+
+	/* enter auto select command state */
+	exec_flash_cmd(bank, curr_addr, curr_addr, CMD_AUTOSELECT);
+
+	/* read the manufacture ID / basic product ID */
+	volatile u32 *read_addr = (volatile u32*) curr_addr;
+	data = *read_addr;
+
+	if (data != 0x227E0001)		/* Spansion S29GLxxxP (Mirrorbit TM) series */
+	{
+	    exec_flash_cmd(bank, curr_addr, curr_addr, CMD_READ_ARRAY);
+	    *romdesc |= 0x80000000;	/* bit 31: ROM descritptor - no supported ROM present */
+	    continue;
+	}
+
+	flash_info[bank].flash_id        = (data << 16) | (data >> 16);
+	flash_info[bank].manufacturer_id = data & 0xFFFF;
+	flash_info[bank].device_id       = data >> 16;
+
+	/* read extended chip IDs*/
+	read_addr = (volatile u32*)(curr_addr + 0x1C);
+	data = *read_addr;
+
+	flash_info[bank].device_id2 = data & 0xFFFF;
+	flash_info[bank].device_id3 = data >> 16;
+
+	flash_info[bank].bank_number = bank;
+
+	/* fill in the rest of flash_info */
+	switch (flash_info[bank].flash_id)
+	{
+	    case 0x0001227E:
+	    {
+		flash_info[bank].sector_size = SZ_128K;
+		switch (flash_info[bank].device_id2)
+		{
+		    case 0x2228:	/* 128 MB */
+		        flash_info[bank].size         = 0x08000000;
+		        flash_info[bank].sector_count = 1024;
+		        flash_info[bank].name         = "Spansion S29GL01GP (1024 Mbit / 64M x 16)";
+		        break;
+		    case 0x2223:	/* 64 MB */
+		        flash_info[bank].size         = 0x04000000;
+		        flash_info[bank].sector_count = 512;
+		        flash_info[bank].name         = "Spansion S29GL512P (512 Mbit / 32M x 16)";
+		        break;
+		    case 0x2222:	/* 32 MB */
+		        flash_info[bank].size         = 0x02000000;
+		        flash_info[bank].sector_count = 256;
+		        flash_info[bank].name         = "Spansion S29GL256P (256 Mbit / 16M x 16)";
+		        break;
+		    case 0x2221:	/* 16 MB */
+		        flash_info[bank].size         = 0x01000000;
+		        flash_info[bank].sector_count = 128;
+		        flash_info[bank].name         = "Spansion S29GL128P (128 Mbit / 8M x 16)";
+		        break;
+		    default:
+		        flash_info[bank].size         = 0x00000000;
+		        flash_info[bank].sector_count = 0;
+		        flash_info[bank].name         = "Unknown Spansion S29GLxxxP";
+		        break;
+		}
+		break;
+	    }
+	    default:
+		flash_info[bank].size         = 0x00000000;
+		flash_info[bank].sector_count = 0;
+		flash_info[bank].name         = "Unknown device";
+		break;
+	}
+
+	if (flash_info[bank].size > 0)
+	{
+	    /* setup the size in the SoC, to have proper address translation */
+	    rommap = (volatile u32*)(ROM_MAP_REG + (bank * 4));
+	    u32 size_mask = 0;
+
+	    if (flash_info[bank].size == SZ_64K)
+		size_mask = 0x0FFF;
+	    else if (flash_info[bank].size == SZ_128K)
+		size_mask = 0x0FFE;
+	    else if (flash_info[bank].size == SZ_256K)
+		size_mask = 0x0FFC;
+	    else if (flash_info[bank].size == SZ_512K)
+		size_mask = 0x0FF8;
+	    else if (flash_info[bank].size == SZ_1M)
+		size_mask = 0x0FF0;
+	    else if (flash_info[bank].size == SZ_2M)
+		size_mask = 0x0FE0;
+	    else if (flash_info[bank].size == SZ_4M)
+		size_mask = 0x0FC0;
+	    else if (flash_info[bank].size == SZ_8M)
+		size_mask = 0x0F80;
+	    else if (flash_info[bank].size == SZ_16M)
+		size_mask = 0x0F00;
+	    else if (flash_info[bank].size == SZ_32M)
+		size_mask = 0x0E00;
+	    else if (flash_info[bank].size == SZ_64M)
+		size_mask = 0x0C00;
+	    else if (flash_info[bank].size == SZ_128M)
+		size_mask = 0x0800;
+	    else if (flash_info[bank].size == SZ_256M)
+		size_mask = 0x0000;
+
+	    *rommap = ((curr_addr & 0x0FFF0000) | size_mask);	/* offset from 0xF0000000 to the start address of the flash */
+
+	    ulong sect;
+	    for (sect = 0; sect < flash_info[bank].sector_count; sect++)
+	    {
+		flash_info[bank].start[sect] = curr_addr + (sect * flash_info[bank].sector_size);
+		/* we are still in auto select command mode, so read the protection status of each sector */
+		read_addr = (volatile u32*)(flash_info[bank].start[sect] + 4);
+		data = *read_addr;
+		flash_info[bank].protect[sect] = data & 0xFFFF;
+	    }
+	    /* leave auto select command state */
+	    exec_flash_cmd(bank, curr_addr, curr_addr, CMD_READ_ARRAY);
+
+	    /* read ESN - this is special for our Flash usage */
+	    exec_flash_cmd(bank, curr_addr, curr_addr, CMD_SSP_ENTER);
+	    read_addr = (volatile u32*) (curr_addr + 0x30);
+	    data = *read_addr;
+	    flash_info[bank].serial[7] = (data >> 24) & 0xFF;
+	    flash_info[bank].serial[6] = (data >> 16) & 0xFF;
+	    flash_info[bank].serial[5] = (data >>  8) & 0xFF;
+	    flash_info[bank].serial[4] =  data        & 0xFF;
+
+	    read_addr = (volatile u32*) (curr_addr + 0x34);
+	    data = *read_addr;
+	    flash_info[bank].serial[3] = (data >> 24) & 0xFF;
+	    flash_info[bank].serial[2] = (data >> 16) & 0xFF;
+	    flash_info[bank].serial[1] = (data >>  8) & 0xFF;
+	    flash_info[bank].serial[0] =  data        & 0xFF;
+	    leave_flash_pgm(bank, curr_addr, 1);
+
+	    /* increase address and size */
+	    curr_addr +=  flash_info[bank].size;
+	    full_size +=  flash_info[bank].size;
+
+	    #if defined (BEAUTIFY_CONSOLE) && (CFG_EXT_LEGACY_FLASH)
+	    /* because the flash_info is not exported, this output is done here */
+	    printf("\xBA %.8lX \xB3 %.8lX \xB3 FLASH \xB3 %-46s \xBA\n", flash_info[bank].start[0], flash_info[bank].start[0] + flash_info[bank].size - 1, flash_info[bank].name);
+	    #endif
+	}
+	else
+	    bank = CONFIG_SYS_MAX_FLASH_BANKS;	/* cancel auto detect */
+
+    }
+
+    /* protect our self */
+    flash_protect(FLAG_PROTECT_SET, CONFIG_SYS_FLASH_BASE, CONFIG_SYS_FLASH_BASE + monitor_flash_len - 1, &flash_info[0]);
+    #ifdef CONFIG_ENV_IS_IN_FLASH
+    flash_protect(FLAG_PROTECT_SET, CONFIG_ENV_ADDR,       CONFIG_ENV_ADDR     + CONFIG_ENV_SIZE     - 1, &flash_info[0]);
+    #endif
+
+    /* print out the serial info */
+    #if defined (BEAUTIFY_CONSOLE) && (CFG_EXT_LEGACY_FLASH)
+    printf("\xCC\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD" \
+	   "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xB9\n");
+    printf("\xBA Serial number: %.3d-%.8d (%.2X-%.2X%.2X%.2X)                                      \xBA\n", 
+	    flash_info[0].serial[4], (flash_info[0].serial[5] << 16) | (flash_info[0].serial[6] << 8) | flash_info[0].serial[7], 
+	    flash_info[0].serial[4], flash_info[0].serial[5], flash_info[0].serial[6], flash_info[0].serial[7]);
+    #endif
+	
+    return full_size;
+}
+
+/*******************************************************************************/
+/* print out some informations about the installed Flash(es) (cmd "flinfo")    */
+
+void flash_print_info(flash_info_t *info)
+{
+    u32 sect;
+
+    if (info->size > 0)
+    {
+        /* the bank has an flash chip installed */
+        printf("    %s\n              %ld MB in %d uniform sectors\n", info->name, info->size >> 20, info->sector_count);
+
+	printf("              \xDA\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xBF\n");
+	printf("              \xB3 %-59s \xB3\n", "Sector status");
+	printf("              \xC3\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC2\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xB4\n");
+	for (sect = 0; sect < info->sector_count; sect++)
+	{
+	    if ((sect % 48) == 0)
+	    {
+		if (sect > 0)
+		    printf(" \xB3\n");
+		printf("              \xB3 %.8lX \xB3 ", info->start[sect]);
+	    }
+	    /* check, if the sector is empty */
+	    ulong not_empty = 0;
+	    ulong addr_count = 0;
+	    volatile u32 *read_addr = (volatile u32*)info->start[sect];
+
+	    while (addr_count < info->sector_size)
+	    {
+		if (*read_addr != 0xFFFFFFFF)
+		{
+		    not_empty = 1;
+		    addr_count = info->sector_size;
+		}
+		read_addr++;	/* 32-bit pointer, so it incrememts by 32 bit! */
+		addr_count += 4;
+	    }
+	    if (not_empty)
+	        printf("%c", info->protect[sect] ? '#' : '*');
+	    else
+		printf("%c", info->protect[sect] ? '_' : '.');
+	}
+	if (sect % 48)
+	{
+    	    while (sect % 48)
+	    {
+		printf(" ");
+		sect++;
+	    }
+	    printf(" ");
+	}
+	printf("\xB3\n");
+	printf("              \xC3\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC1\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xB4\n");
+	printf("              \xB3 . empty, _ empty & protected, * used, # used & protected    \xB3\n");
+	printf("              \xC0\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xD9\n");
+    }
+    else
+	printf("NO FLASH INSTALLED\n");
+}
+
+/*******************************************************************************/
+/* erase flash sectors 							       */
+
+int flash_erase(flash_info_t *info, int s_first, int s_last)
+{
+    int ret = ERR_OK;
+    u32 sect;
+
+    /* reject all types of flashes which we do not know to work with this routines */
+    if (info->flash_id != 0x0001227E)
+	return ERR_UNKNOWN_FLASH_TYPE;
+
+    if ((s_first < 0) || (s_first > s_last))
+	return ERR_INVAL;
+
+    for (sect = s_first; sect <= s_last; sect++)
+    {
+	if (info->protect[sect])
+	    return ERR_PROTECTED;
+    }
+
+    display_set_text("Erase Flash");
+
+    #ifdef CONFIG_USE_IRQ
+    int irq_status = disable_interrupts();
+    #endif
+
+    /* Start erase on unprotected sectors */
+    for (sect = s_first; sect <= s_last && !ctrlc(); sect++)
+    {
+	if ((info->start[sect] >= CONFIG_SYS_MONITOR_BASE) && (info->start[sect] < CONFIG_SYS_MONITOR_BASE + monitor_flash_len))
+	{
+	    /* the user try to erase ourself. So ech, if he has enabled the hidden stuff. */
+	    if ((flash_flags & FLASH_ERASE_ALL) == 0)
+	    {
+		printf("Sector at 0x%.8lX not erased. You are not allowed to erase the bootloader!\n", info->start[sect]);
+		continue;
+	    }
+	    else
+		printf("Warning, you erased the bootloader. Your box will be dead, after the next reboot\nif no new bootloader is written. !\n");
+	}
+
+	display_show_progress(s_first, s_last, sect);
+	/* for speed up, first test, if the requested sector is empty or not */
+	u32 not_empty = 0;
+	u32 addr_count = 0;
+	volatile u32 *read_addr = (volatile u32*)(info->start[sect] + addr_count);
+
+	while(addr_count < info->sector_size)
+	{
+	    if (*read_addr != 0xFFFFFFFF)
+	    {
+	        not_empty = 1;
+	        addr_count = info->sector_size;
+	    }
+	    read_addr++;
+	    addr_count += 4;
+	}
+
+	if (not_empty)
+	{
+    	    exec_flash_cmd(info->bank_number, info->start[0], info->start[0], CMD_ERASE_SETUP);
+    	    exec_flash_cmd(info->bank_number, info->start[0], info->start[sect], CMD_ERASE_CONFIRM);
+
+	    /* datasheet page 26, figure 7.3 - poll DQ3 until it becomes 1 */
+	    volatile u16 *stat_addr = (volatile u16 *)(info->start[sect]);
+	    while ((*stat_addr & 0x08) == 0x08)
+	    {
+		;
+	    }
+
+	    /* execute data polling algo */
+	    ret = wait_for_erase_exec_done(info->start[sect]);
+
+    	    exec_flash_cmd(info->bank_number, info->start[0], info->start[0], CMD_READ_ARRAY);
+	}
+	putc('.');
+    }
+
+    #ifdef CONFIG_USE_IRQ
+    if (irq_status)
+	enable_interrupts();
+    #endif
+
+    printf("\n");
+    display_show_progress(0, 0, 0);
+    display_set_text(NULL);
+
+    return ret;
+}
+
+/*******************************************************************************/
+/* write a block of data from given src and with given length into flash.
+   The Spansion Chips support page write, so we can accellerate the flash 
+   programming process by writing the data in pages of 32 words (64 byte).     */
+
+int write_buff(flash_info_t *info, uchar *src, ulong addr, ulong cnt)
+{
+    int ret = ERR_OK;
+
+    /* reject all types of flashes which we do not know to work with this routines */
+    if (info->flash_id != 0x0001227E)
+	return ERR_UNKNOWN_FLASH_TYPE;
+
+    #ifdef CONFIG_USE_IRQ
+    int irq_status = disable_interrupts();
+    #endif
+
+    u32 pages  = cnt / 64;
+    u32 rbytes = cnt % 64;
+    u32 current_page;
+    u16 *sdata = (u16*) src;
+    u16 vdata;
+    volatile u16 *dstaddr = (volatile u16*) addr;
+    u32 sector = (addr - info->start[0]) / info->sector_size;
+    volatile u32 *romdesc = (volatile u32*)(ROM_DESC0_REG + (info->bank_number * 4));
+
+    display_set_text("Write Flash");
+
+    /* first write the pages */
+    for (current_page = 0; current_page < pages; current_page++)
+    {
+	display_show_progress(0, pages - 1, current_page);
+
+	exec_flash_cmd(info->bank_number, info->start[0], info->start[sector], CMD_WRITE_BUFF_SETUP);
+
+        /* enter uncashed 16-bit mode */
+        *romdesc |= 0x00800000;
+
+	u16 wordcount = 0;
+	*((volatile ushort*)(info->start[sector])) = 31;	/* words minus one */
+
+	while (wordcount < 32)
+	{
+	    /* write a page of 32 words (64 bytes) into the flash's volatile buffer */
+	    *dstaddr = *sdata;
+	    dstaddr++;
+	    vdata = *sdata;
+	    sdata++;
+	    wordcount++;
+	}
+	
+	*((volatile ushort*)(info->start[sector])) = CMD_WRITE_BUFF_CONFIRM;
+
+	ret = wait_for_write_exec_done(info->start[sector]);
+
+	if (ret != ERR_OK)
+	    printf("error while flash write (%d)\n", ret);
+
+	u32 old_sector = sector;
+	sector = ((u32)dstaddr - info->start[0]) / info->sector_size;
+	if (sector != old_sector)
+	    putc('.');
+
+	*romdesc &= 0xFF7FFFFF;	/* bit 23: disable write access */
+    }
+
+    /* write the outstanding bytes */
+    if (rbytes % 2)	/* round up, if odd byte count */
+	rbytes++;
+    u32 rwords = rbytes >> 1;	/* divide by two to have word count */
+
+    if (rwords)
+    {
+	u16 wordcount = 0;
+	while (wordcount < rwords)
+	{
+	    exec_flash_cmd(info->bank_number, info->start[0], info->start[sector], CMD_WRITE_WORD_SETUP);
+    	    *romdesc |= 0x00800000;
+	    *dstaddr = *sdata;
+	    vdata = *sdata;
+	    dstaddr++;
+	    sdata++;
+	    wordcount++;
+	    ret = wait_for_write_exec_done(info->start[sector]);
+
+	    *romdesc &= 0xFF7FFFFF;
+	}
+    }
+
+    if (ret != ERR_OK)
+	exec_flash_cmd(info->bank_number, info->start[0], info->start[0], CMD_READ_ARRAY);
+
+    #ifdef CONFIG_USE_IRQ
+    if (irq_status)
+	enable_interrupts();
+    #endif
+
+    putc('\n');
+    display_show_progress(0, 0, 0);
+    display_set_text(NULL);
+
+    return ret;
+}
+
+/*******************************************************************************/
+/* set the protection bit for the given sector				       */
+
+int flash_real_protect(flash_info_t *info, long sector, int prot)
+{
+    int ret = ERR_OK;
+
+    /* reject all types of flashes which we do not know to work with this routines */
+    if (info->flash_id != 0x0001227E)
+	return ERR_UNKNOWN_FLASH_TYPE;
+
+    #ifdef CONFIG_USE_IRQ
+    int irq_status = disable_interrupts();
+    #endif
+
+    if (info->protect[sector] != prot)
+    {
+	/* only do anything, if it's necessary */
+	if (prot)
+	{
+	    /* protecting is easy */
+	    /* enter auto select command state */
+	    exec_flash_cmd(info->bank_number, info->start[0], info->start[0], CMD_PPB_ENTER);
+
+	    /* enter uncashed 16-bit mode */
+    	    volatile u32 *romdesc = (volatile u32*)(ROM_DESC0_REG + (info->bank_number * 4));
+	    *romdesc |= 0x00800000;
+
+	    /* protect by clearing the bit */
+	    *((volatile ushort*)(info->start[0]))      = 0x00A0;
+	    *((volatile ushort*)(info->start[sector])) = 0x0000;
+
+	    ret = wait_for_ppb_exec_done(info->start[0], info->start[sector], 0);
+
+	    if (ret == ERR_OK)
+		info->protect[sector] = 1;
+
+	    leave_flash_pgm(info->bank_number, info->start[sector], 0);
+	}
+	else
+	{
+	    /* this is a little bit more work, because protection can only be disabled globally */
+	    exec_flash_cmd(info->bank_number, info->start[0], info->start[0], CMD_PPB_ENTER);
+
+	    /* enter uncashed 16-bit mode */
+    	    volatile u32 *romdesc = (volatile u32*)(ROM_DESC0_REG + (info->bank_number * 4));
+	    *romdesc |= 0x00800000;
+
+	    /* unprotect all */
+	    *((volatile ushort*)(info->start[0])) = 0x0080;
+	    *((volatile ushort*)(info->start[0])) = 0x0030;
+
+	    ret = wait_for_ppb_exec_done(info->start[0], info->start[sector], 1);
+
+	    leave_flash_pgm(info->bank_number, info->start[0], 0);
+
+	    /* unset protection status for this sector */
+	    if (ret == ERR_OK)
+		info->protect[sector] = 0;
+
+	    /* loop through all sectors and reprotect if necessary */
+	    u32 sect;
+	    for (sect = 0; sect < info->sector_count; sect++)
+	    {
+		if (info->protect[sect])
+		{
+		    info->protect[sect] = 0;		/* indicate, this sector is not protected */
+		    flash_real_protect(info, sect, 1);	/* call ourself to reprotect */
+		}
+	    }
+	}
+    }
+
+    #ifdef CONFIG_USE_IRQ
+    if (irq_status)
+	enable_interrupts();
+    #endif
+
+    return ret;
+}
+
+/*******************************************************************************/
+
+void flash_set_flag(void)
+{
+    flash_flags |= FLASH_ERASE_ALL;
+}
+
+/*******************************************************************************/
+
+#ifdef CONFIG_SYS_FLASH_OTP
+
+int flash_dump_otp(flash_info_t *info)
+{
+    #ifdef CONFIG_USE_IRQ
+    int irq_status = disable_interrupts();
+    #endif
+
+    volatile u32 *read_addr;
+    u32 data;
+    unsigned int ofs;
+
+    /* enter SSP mode */
+    exec_flash_cmd(0, info->start[0], info->start[0], CMD_SSP_ENTER);
+
+    /* flash's SSP size is 128 word (256 byte) */
+    printf("otpdata: ");
+    for (ofs = 0; ofs < 256; ofs += 4)
+    {
+	read_addr = (volatile u32*) (info->start[0] + ofs);
+	data = *read_addr;
+	printf("%.2X%.2X%.2X%.2X", data & 0xFF, (data >> 8) & 0xFF, (data >> 16) & 0xFF, (data >> 24) & 0xFF);
+    }
+    printf("\n\n");
+
+    /* leave SSP mode */
+    leave_flash_pgm(0, info->start[0], 1);
+
+    #ifdef CONFIG_USE_IRQ
+    if (irq_status)
+	enable_interrupts();
+    #endif
+
+    return ERR_OK;
+}
+
+/*******************************************************************************/
+
+int flash_write_otp(flash_info_t *info, uchar *data, ulong cnt)
+{
+    #ifdef CONFIG_USE_IRQ
+    int irq_status = disable_interrupts();
+    #endif
+
+    int ret = ERR_OK;
+    int ofs;
+    int rbytes = cnt;
+    u16 *wdata = (u16*) data;
+    volatile u16 *dstaddr = (volatile u16*) info->start[0];
+    volatile u32 *romdesc = (volatile u32*)(ROM_DESC0_REG + (info->bank_number * 4));
+
+    u8 *sdata = (u8*) data;
+    printf("writing the following %ld byte of data into flash:\n", cnt);
+    for (ofs = 0; ofs < 256; ofs += 4)
+    {
+	if ((ofs % 16) == 0)
+	    printf("\n0x%.4X: ", ofs);
+
+	printf("%.2X %.2X %.2X %.2X ", sdata[ofs], sdata[ofs + 1], sdata[ofs + 2], sdata[ofs + 3]);
+    }
+    printf("\n");
+
+
+    exec_flash_cmd(0, info->start[0], info->start[0], CMD_SSP_ENTER);
+
+
+    display_set_text("Write OTP");
+
+    /* write the outstanding bytes */
+    if (rbytes % 2)	/* round up, if odd byte count */
+	rbytes++;
+    u32 rwords = rbytes >> 1;	/* divide by two to have word count */
+
+    if (rwords)
+    {
+	u16 wordcount = 0;
+	while (wordcount < rwords)
+	{
+	    exec_flash_cmd(info->bank_number, info->start[0], info->start[0], CMD_WRITE_WORD_SETUP);
+    	    *romdesc |= 0x00800000;
+	    *dstaddr = *wdata;
+	    dstaddr++;
+	    wdata++;
+	    wordcount++;
+	    ret = wait_for_write_exec_done(info->start[0]);
+
+	    *romdesc &= 0xFF7FFFFF;
+	}
+    }
+
+    /* leave SSP mode */
+    leave_flash_pgm(0, info->start[0], 1);
+
+    #ifdef CONFIG_USE_IRQ
+    if (irq_status)
+	enable_interrupts();
+    #endif
+
+    putc('\n');
+    display_set_text(NULL);
+
+    return ret;
+}
+
+#endif /* CONFIG_SYS_FLASH_OTP */
diff --git a/board/coolstream_hdx/gpio.c b/board/coolstream_hdx/gpio.c
new file mode 100644
index 0000000..ddf4693
--- /dev/null
+++ b/board/coolstream_hdx/gpio.c
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2008
+ * Coolstream Internation Limited
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/arch/nevis.h>
+#include <asm/arch/sys_proto.h>
+
+/* some helpers for the GPIO controller */
+
+/*******************************************************************************/
+/* switch the pio number to the given state (PIO_HIGH, PIO_LOW, PIO_OFF)       */
+
+void board_gpio_drive(u32 pio, u32 state)
+{
+    /* decode the requested PIO to the assigned bank/bit */
+
+    volatile u32 *reg;
+    u32 bank = pio / 32;
+    u32 bit  = pio % 32;
+
+    if (bank < 7)
+    {
+	reg = (volatile u32*)(state + (bank * 0x40));
+	*reg = (1 << bit);
+    }
+}
+
+/*******************************************************************************/
+/* read the state of one GPIO pin (if configured as input before)              */
+
+u32 board_gpio_read(u32 pio)
+{
+    volatile u32 *reg;
+    u32 bank = pio / 32;
+    u32 bit  = pio % 32;
+    u32 ret  = 0;
+
+    if (bank < 7)
+    {
+	reg = (volatile u32*)(PIO_READ_REG + (bank * 0x40));
+	if ((*reg) & (1 << bit))
+	    ret = 1;
+    }
+
+    return ret;
+}
diff --git a/board/coolstream_hdx/interrupt.c b/board/coolstream_hdx/interrupt.c
new file mode 100644
index 0000000..394d855
--- /dev/null
+++ b/board/coolstream_hdx/interrupt.c
@@ -0,0 +1,261 @@
+/*
+ * (C) Copyright 2008
+ * Coolstream Internation Limited
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/arch/nevis.h>
+#include <asm/arch/fp_uart.h>
+#include <asm/arch/sys_proto.h>
+
+#ifdef CONFIG_USE_IRQ
+
+static u32 last_btn = 0;
+static u32 last_pos = 0;
+static u32 found_ent= 0;
+
+static u8 uart_rx_pos;
+static u8 uart_rx_data[256];
+
+/* HD1: Menu - OK - CH+ - OK - VOL- - OK - Stanby - Standby */
+static const u32 btn_seq[8] = { 0x0C, 0x04, 0x06, 0x04, 0x03, 0x04, 0x08, 0x08 };
+
+/*******************************************************************************/
+/* basic initialization of the ITC                                             */
+int cs_fp_key = 0;
+
+void board_init_itc(void)
+{
+    u32 bank;
+
+    /* set defaults */
+    last_btn = 0;
+    last_pos = 0;
+
+    /* reset all pending interrupts on the GPIO-lines */
+    for (bank = 0; bank < 7; bank++)
+    {
+	volatile u32 *pio_reg = (volatile u32*)(PIO_IRQSTAT_REG + (bank * 0x40));
+        *pio_reg = 0xFFFFFFFF;
+    }
+
+    /* setup the Interrupt controller here */
+    volatile u32 *G1 = (volatile u32*) 0xE0450000;	/* INTDEST1_REG */
+    *G1 = 0xFFFFFFFF;   /* sources generates IRQ and no FIQ */
+
+    G1 = (volatile u32*) 0xE0450004;			/* ITC_ENABLE1_REG */
+    *G1 = 0x01126202;   /* 0000 0001 0001 0010 0110 0010 0000 0010 */ /* 23apr2010 enable UART2 IRQ */
+
+    G1 = (volatile u32*) 0xE0450020;			/* INTDEST2_REG */
+    *G1 = 0xFFFFFFFF;   /* sources generates IRQ and no FIQ */
+
+    G1 = (volatile u32*) 0xE0450024;			/* ITC_ENABLE2_REG */
+    *G1 = 0x00000080;   /* 0000 0000 0000 0000 0000 0000 1000 0000 */
+
+    G1 = (volatile u32*) 0xE0450040;			/* INTDEST3_REG */
+    *G1 = 0xFFFFFFFF;   /* sources generates IRQ and no FIQ */
+
+    G1 = (volatile u32*) 0xE0450044;			/* ITC_ENABLE3_REG */
+    *G1 = 0x00000000;   /* 0000 0001 0000 0000 0000 0000 0000 0000 */
+
+    /* enable PIO 048, 049 (CI-slots) */
+    G1 = (volatile u32*) 0xE0470054;			/* IRQ_ENABLE0_2_REG */
+    *G1 = 0x00030000;   /* 0000 0000 0000 0011 0000 0000 0000 0000 PIO 032 */
+
+    G1 = (volatile u32*) 0xE0470058;    		/* POS_EDGE_2_REG */
+    *G1 = 0x00030000;   /* 0000 0000 0000 0011 0000 0000 0000 0000 PIO 032 */
+
+    G1 = (volatile u32*) 0xE047005C;    		/* NEG_EDGE_2_REG */
+    *G1 = 0x00030000;   /* 0000 0000 0000 0011 0000 0000 0000 0000 PIO 032 */
+
+
+    /* enable interrupts for PIO 182, 183, 185, 186 (front panel button matrix) */
+    G1 = (volatile u32*) 0xE0470154;			/* IRQ_ENABLE0_6_REG */
+    *G1 = 0x06C00000;   /* 0000 0110 1100 0000 0000 0000 0000 0000 PIO 160 */
+
+    G1 = (volatile u32*) 0xE0470158;    		/* POS_EDGE_6_REG */
+    *G1 = 0x06C00000;   /* 0000 0110 1100 0000 0000 0000 0000 0000 PIO 160 */
+
+    G1 = (volatile u32*) 0xE047015C;    		/* NEG_EDGE_6_REG */
+    *G1 = 0x06C00000;   /* 0000 0110 1100 0000 0000 0000 0000 0000 PIO 160 */
+}
+
+/*******************************************************************************/
+/* handle the received interrupts (read and reset the bits set in the ITC)     */
+int board_do_interrupt(struct pt_regs *pt_regs)
+{
+    int ret = 0;
+    u32 data, group, num;
+    u32 reset_irq = 1;
+    volatile u32 *itc_reg;
+
+    for (group = 0; group < 3; group++)
+    {
+	itc_reg  = (volatile u32*)(ITC_INTRIRQ1_REG + (group * 0x20));
+	data = *itc_reg;
+
+	if (data)
+	{
+	    for (num = 0; num < 32; num++)
+	    {
+		if (data & (1 << num))
+		{
+		    s32 bank;
+		    u32 irq = num + (group * 32);
+		    switch (irq)
+		    {
+			case 1:				/* UART 2 */
+			{
+				u8 d;
+
+				if (fp_uart_get_rx_count() == 0) { /* No data to read, just a timeout */
+					d = fp_uart_get_rx();
+				} else if (fp_uart_get_rx_count() > 0) {
+					u32 btn_val;
+
+					while(fp_uart_get_rx_count()) {
+						d = fp_uart_get_rx();
+						if (d == 0x02) { // STX
+							uart_rx_pos = 0;
+						} else if ((d == 0x03) && (uart_rx_data[1] == 'B')) { //ETX
+							if (uart_rx_data[2] == 0x30) /* Button release */
+								break;
+							btn_val = uart_rx_data[2] & 0x0F;
+							/* printf("Received button code: %02x\n", btn_val); */
+							if (btn_val == 0x8)
+								cs_fp_key = 1;
+							uart_rx_data[1] = 0; /* Clear 'B' */
+							/* check, if the user tries to enter the hidden stuff */
+							if (btn_val == btn_seq[last_pos]) {
+								last_pos++;
+								if (last_pos == 8) {
+									/* Tilt - the user found the hidden entrace */
+									found_ent	= 1;
+									last_pos	= 0;
+//									
+								}
+							} else
+								last_pos = 0;
+						}
+						uart_rx_data[uart_rx_pos++ & 255] = d;
+					}
+				}
+				reset_irq = 1;
+				break;
+			}
+			case 13:			/* USB 0 */
+			case 17:			/* USB 1 */
+			case 20:			/* USB 2 */
+			    printf("Interrupt from USB (IRQ-num = %d)\n", irq);
+			    break;
+			case 14:			/* IRQ 14 = GPIO0 controller */
+//			    printf("IRQ %.2d: GPIO0 ", irq);
+			    for (bank = 6; bank >= 0; bank--)
+			    {
+				volatile u32 *pio_reg = (volatile u32*)(PIO_IRQSTAT_REG + (bank * 0x40));
+				u32 pio_data = *pio_reg;
+
+				if (bank == 5)	/* handle our front panel buttons */
+				{
+				    u32 btn_irq = ((pio_data >> 22) & 0x03) | ((pio_data >> 23) & 0x0C);
+				    if (btn_irq)	/* one of the front buttons are pressed */
+				    {
+					u32 btn_val = (board_gpio_read(182) << 3) | 
+						      (board_gpio_read(186) << 2) |
+						      (board_gpio_read(185) << 1) |
+						      (board_gpio_read(183) << 0);
+					btn_val ^= 0x0F;
+					/* printf("Received button code: %02x\n", btn_val); */
+
+					if(btn_val == 0x8)
+						cs_fp_key = 1;
+					if (btn_val != last_btn)	/* debounce */
+					{
+					    last_btn = btn_val;
+					    if (btn_val > 0)
+					    {
+						udelay(25000);		/* necessary here for debounce, belive me */
+						/* check, if the user tries to enter the hidden stuff */
+						if (btn_val == btn_seq[last_pos])
+						{
+						    last_pos++;
+						    if (last_pos == 8)
+						    {
+							/* Tilt - the user found the hidden entrace */
+							last_pos	= 0;
+							found_ent	= 1;
+						    }
+						}
+						else
+						    last_pos = 0;
+					    }
+					}
+				    }
+				}
+
+				/* reset */
+				if (pio_data)
+				    *pio_reg = pio_data;
+			    }
+			    break;
+			case 24:			/* IRQ 24 = EMAC0 Ethernet controller */
+			    reset_irq = eth_handle_interrupt();
+			    break;
+			default:
+			    printf("IRQ %.2d: unknown source\n", irq);
+			    break;
+		    }
+		}
+	    }
+	}
+	/* reset */
+	if (reset_irq)
+	{
+	    itc_reg = (volatile u32*)(ITC_INTRCLR1_REG + (group * 0x20));
+	    *itc_reg = data;
+	}
+
+	if (found_ent)
+	{
+		printf("\nCongrats, you found the hidden entrace ;-)\n");
+		flash_set_flag();
+		display_show_icon(0x0B000001, 0);
+		found_ent = 0;
+	}
+    }
+
+    return ret;
+}
+
+/*******************************************************************************/
+
+void board_disable_all_interrupts(void)
+{
+	volatile u32 *ie;
+
+        /* Disable all Interrupts */
+	ie = (volatile u32*)ITC_INTENABLE1_REG;
+	*ie = (u32) 0;
+
+	ie = (volatile u32*)ITC_INTENABLE2_REG;
+	*ie =(u32) 0;
+}
+
+
+
+#endif
diff --git a/board/coolstream_hdx/lowlevel_init.S b/board/coolstream_hdx/lowlevel_init.S
new file mode 100644
index 0000000..6ad5a2a
--- /dev/null
+++ b/board/coolstream_hdx/lowlevel_init.S
@@ -0,0 +1,912 @@
+/*
+ * Board specific very low level init
+ *
+ * (C) Copyright 2008
+ * Coolstream International Limited
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+#include <asm/arch/nevis.h>
+
+#define PIN_CONFIG0_REG_DEFAULT		0xBFFFEFFE	/* 1111 1111 1111 1111 1110 1111 1111 1110			*/ /* 23apr2010 SMC1 on */
+#define PIN_ALT_FUNC_REG_DEFAULT	0x00000010	/* 0000 0000 0000 0000 0000 0000 0001 0000			*/ /* 23apr2010 UART1 on */
+
+#define GPIO_PIN_MUX0_REG_DEFAULT	0x0100D000	/* 0000 0001 0000 0000 1101 0000 0000 0000	PIO 031 ... 000 */ /* 22jun2009: PIO24 to PWM */
+#define GPIO_PIN_MUX1_REG_DEFAULT	0x00000080	/* 0000 0000 0000 0000 0000 0000 1000 0000	PIO 063 ... 032 */
+#define GPIO_PIN_MUX2_REG_DEFAULT	0x000021C0	/* 0000 0000 0000 0000 0010 0001 1100 0000	PIO 095 ... 064 */
+#define GPIO_PIN_MUX3_REG_DEFAULT	0xFFBFC380	/* 1111 1111 1011 1111 1100 0011 1000 0000	PIO 127 ... 096 */
+#define GPIO_PIN_MUX4_REG_DEFAULT	0xFFFC0006	/* 1111 1111 1111 1100 0000 0000 0000 0110	PIO 159 ... 128 */
+#define GPIO_PIN_MUX5_REG_DEFAULT	0x0006F209	/* 0000 0000 0000 0110 1111 0010 0000 1001	PIO 191 ... 160 */
+#define GPIO_PIN_MUX6_REG_DEFAULT	0x00000002	/* 0000 0000 0000 0000 0000 0000 0000 0010	PIO 223 ... 192 */
+
+#define GPIO_PIN_SMUX0_REG_DEFAULT	0x00000000	/* 0000 0000 0000 0000 0000 0000 0000 0000	PIO 031 ... 000 */
+#define GPIO_PIN_SMUX1_REG_DEFAULT	0x00003000	/* 0000 0000 0000 0000 0011 0000 0000 0000	PIO 063 ... 032 */
+#define GPIO_PIN_SMUX2_REG_DEFAULT	0x3F7C0000	/* 0011 1111 0111 1100 0000 0000 0000 0000	PIO 095 ... 064 */
+#define GPIO_PIN_SMUX3_REG_DEFAULT	0x20000000	/* 0010 0000 0000 0000 0000 0000 0000 0000	PIO 127 ... 096 */
+#define GPIO_PIN_SMUX4_REG_DEFAULT	0x00000000	/* 0000 0000 0000 0000 0000 0000 0000 0000	PIO 159 ... 128 */
+#define GPIO_PIN_SMUX5_REG_DEFAULT	0x00000000	/* 0000 0000 0000 0000 0000 0000 0000 0000	PIO 191 ... 160 */
+#define GPIO_PIN_SMUX6_REG_DEFAULT	0x00000000	/* 0000 0000 0000 0000 0000 0000 0000 0000	PIO 223 ... 192 */
+
+#define ITC_INTENABLE1_REG_DEFAULT	0x00000000
+#define ITC_INTENABLE2_REG_DEFAULT	0x00000000
+
+#if (CONFIG_ARM9_SETUP_LEGACY_MODE == 1)
+#define ARM9_VECTOR_OFFSET		CONFIG_ARM9_OFFSET_LEGACY
+#else
+#define ARM9_VECTOR_OFFSET		CONFIG_ARM9_OFFSET
+#endif
+
+_TEXT_BASE:
+	.word	TEXT_BASE	/* sdram load addr from config.mk */
+
+PLL_NEVIS:
+	.word 0xE0440050			, 0x00120508 /* DIV_MUX_CTRL0 */ /* ASX -> PLL0(432MHZ) / 8 == 54Mhz */
+	.word 0xE0440054			, 0x06010002 /* DIV_MUX_CTRL1 */
+	.word 0xE0440058			, 0x07020003 /* DIV_MUX_CTRL2 */
+	.word 0xE044005C			, 0x000B000B /* DIV_MUX_CTRL3 */
+	.word 0xE0440060			, 0x07020004 /* DIV_MUX_CTRL4 */
+	.word 0xE0440064			, 0x00000702 /* DIV_MUX_CTRL5 */
+	.word 0xE0440068			, 0x00630058 /* DIV_MUX_CTRL6 */
+	.word 0xE044006C			, 0x00030003 /* DIV_MUX_CTRL7 */
+	.word 0xE0440070			, 0x00000803 /* DIV_MUX_CTRL8 */
+	.word 0xE0440074			, 0x00000002 /* DIV_MUX_CTRL9 */
+	.word 0xE0440078			, 0x00000003 /* DIV_MUX_CTRL10 */
+	.word 0xE044007C			, 0x05080506 /* DIV_MUX_CTRL11 */
+	.word 0xE0440080			, 0x00080512 /* DIV_MUX_CTRL12 */
+	.word 0xE0440084			, 0x08030003 /* DIV_MUX_CTRL13 */
+	.word 0xE0440088			, 0x08120812 /* DIV_MUX_CTRL14 */
+	.word 0xE044008C			, 0x00030003 /* DIV_MUX_CTRL15 */
+
+	.word 0xE0440000			, 0x13CCCCCD /* MPG0_INTFRAC	*/
+	.word 0xE0440010			, 0x13C7BC7C /* HD_INTFRAC	*/
+	.word 0xE0440018			, 0x10624DD3 /* AUD_INTFRAC	*/
+	.word 0xE0440020			, 0x0E666666 /* PLL0_INTFRAC	*/
+	/* 0x13CCCCCD = 594 Mhz, 0x0F000000 = 450 Mhz */
+	.word 0xE0440028			, 0x0F000000 /* PLL1_INTFRAC	*/
+	.word 0xE0440030			, 0x11C71C70 /* PLL2_INTFRAC	*/
+	.word 0xE0440004			, 0x02214242 /* MPG0_CTRL	*/
+	.word 0xE0440014			, 0x02214242 /* HD_CTRL		*/
+	.word 0xE044001C			, 0x02514242 /* AUD_CTRL	*/
+	.word 0xE0440024			, 0x02117242 /* PLL0_CTRL	*/
+	.word 0xE044002C			, 0x02117242 /* PLL1_CTRL	*/
+	.word 0xE0440034			, 0x02117242 /* PLL2_CTRL	*/
+	.word 0xE0440048			, 0xCF0004A3 /* FENRUS_PLL_CTRL */
+	.word 0xE0440070			, 0x00001803 /* DIV_MUX_CTRL8	*/
+
+	.word 0xE04400AC			, 0x249F0064 /* SMART0_PLL_CTRL */
+	.word 0xE04400B0			, 0x249F0064 /* SMART1_PLL_CTRL */
+
+	.word 0xE04400E4			, 0x00000064 /* PIO_CLK_DIV0 */
+	.word 0xE04400E8			, 0x00000064 /* PIO_CLK_DIV1 */
+	.word 0xE04400EC			, 0x00000064 /* PIO_CLK_DIV2 */
+	.word 0xE04400E0			, 0x00000888 /* PIO_CLK_MUX */
+
+	.word 0xE0440228			, 0x07777770 /* HS_CLK_MUX_CTRL0 */
+	.word 0xE044022C			, 0x00005500 /* HS_CLK_MUX_CTRL1 */
+	.word 0xE0440204			, 0x03E8000A /* HS1_CLK_DIV_CTRL */
+	.word 0xE0440208			, 0x03E8000A /* HS2_CLK_DIV_CTRL */
+	.word 0xE044020C			, 0x03E8000A /* HS3_CLK_DIV_CTRL */
+	.word 0xE0440210			, 0x03E8000A /* HS4_CLK_DIV_CTRL */
+	.word 0xE0440214			, 0x03E8000A /* HS5_CLK_DIV_CTRL */
+	.word 0xE0440218			, 0x03E8000A /* HS6_CLK_DIV_CTRL */
+	.word 0xDEADBEEF			, 0xDEADBEEF
+
+MC_COMMON:
+	.word MC_CTL_REG			, 0x00000000
+	.word MC_PRIORITY_PCI_REG		, 0x02010002
+	.word MC_PRIORITY_SATA1_REG		, 0x03010006
+	.word MC_PRIORITY_DMA0_REG		, 0x02010004
+	.word MC_PRIORITY_CRYPT_REG		, 0x03010002
+	.word MC_PRIORITY_JTAG_REG		, 0x00010002
+	.word MC_PRIORITY_JPEG_REG		, 0x05010001
+	.word MC_PRIORITY_SBM_REG		, 0x02010004
+	.word MC_PRIORITY_SSP_REG		, 0x03010000
+	.word MC_PRIORITY_SATA0_REG		, 0x03010006
+	.word MC_PRIORITY_TSP0_REG		, 0x02010007
+	.word MC_PRIORITY_TSP1_REG		, 0x02010007
+	.word MC_PRIORITY_TSR0_REG		, 0x02010007
+	.word MC_PRIORITY_TSR1_REG		, 0x02010007
+	.word MC_PRIORITY_BSP0_REG		, 0x02010004
+	.word MC_PRIORITY_BSP1_REG		, 0x02010004
+	.word MC_PRIORITY_AMP_REG		, 0x00010005
+	.word MC_PRIORITY_APP_REG		, 0x01010007
+	.word MC_PRIORITY_IMP0_REG		, 0x02010005
+	.word MC_PRIORITY_IMP1_REG		, 0x02010005
+	.word MC_PRIORITY_DPROC_INST_REG	, 0x02010007
+	.word MC_PRIORITY_DPROC_DATA_REG	, 0x02010007
+	.word MC_PRIORITY_CPM_REG		, 0x01010007
+	.word MC_PRIORITY_DMA1_REG		, 0x02010004
+	.word MC_PRIORITY_DNT_REG		, 0x00020006
+	.word MC_PRIORITY_DRM00_REG		, 0x03040006
+	.word MC_PRIORITY_DRM01_REG		, 0x03040006
+	.word MC_PRIORITY_DRM02_REG		, 0x03060007
+	.word MC_PRIORITY_DRM03_REG		, 0x03000006
+	.word MC_PRIORITY_DRM10_REG		, 0x03040006
+	.word MC_PRIORITY_DRM11_REG		, 0x03040006
+	.word MC_PRIORITY_DRM12_REG		, 0x03060007
+	.word MC_PRIORITY_DRM13_REG		, 0x03000006
+	.word MC_PRIORITY_POSTP0_REG		, 0x01020004
+	.word MC_PRIORITY_POSTP1_REG		, 0x00020004
+	.word MC_PRIORITY_GXA_REG		, 0x09030000
+	.word MC_PRIORITY_NU12_REG		, 0x00010000
+	.word MC_PRIORITY_MSDF0_REG		, 0x04030005
+	.word MC_PRIORITY_MSDP0_REG		, 0x04030005
+	.word MC_PRIORITY_MSDF1_REG		, 0x04070005
+	.word MC_PRIORITY_MSDP1_REG		, 0x04070005
+	.word MC_PRIORITY_MBF0_REG		, 0x00010000
+	.word MC_PRIORITY_MBP0_REG		, 0x00010000
+	.word MC_PRIORITY_MBF1_REG		, 0x00010000
+	.word MC_PRIORITY_MBP1_REG		, 0x00010000
+	.word MC_PRIORITY_ARM_INST		, 0x00000007
+	.word MC_PRIORITY_ARM_DATA		, 0x00000007
+	.word MC_PRIORITY_USB0			, 0x00000004
+	.word MC_PRIORITY_USB1			, 0x00000004
+	.word MC_PRIORITY_USB2			, 0x00000004
+	.word MC_PRIORITY_EMAC0			, 0x00000007
+	.word MC_PRIORITY_EMAC1			, 0x00000007
+	.word MC_PRIORITY_MCARD0		, 0x00000007
+	.word MC_PRIORITY_BUS4_WR_REG		, 0x00000007
+	.word MC_ATTR0_START_REG		, 0x00000000
+	.word MC_ATTR1_START_REG		, 0x00000000
+	.word MC_ATTR2_START_REG		, 0x00000000
+	.word MC_ATTR3_START_REG		, 0x00000000
+	.word MC_ATTR4_START_REG		, 0x00000000
+	.word MC_ATTR5_START_REG		, 0x00000000
+	.word MC_ATTR6_START_REG		, 0x00000000
+	.word MC_ATTR7_START_REG		, 0x00000000
+	.word MC_ATTR8_START_REG		, 0x00000000
+	.word MC_ATTR9_START_REG		, 0x00000000
+	.word MC_ATTR10_START_REG		, 0x00000000
+	.word MC_ATTR11_START_REG		, 0x00000000
+	.word MC_ATTR12_START_REG		, 0x00000000
+	.word MC_ATTR13_START_REG		, 0x00000000
+	.word MC_ATTR14_START_REG		, 0x00000000
+	.word MC_ATTR15_START_REG		, 0x00000000
+	.word MC_ATTR0_END_REG			, 0x00000000
+	.word MC_ATTR1_END_REG			, 0x00000000
+	.word MC_ATTR2_END_REG			, 0x00000000
+	.word MC_ATTR3_END_REG			, 0x00000000
+	.word MC_ATTR4_END_REG			, 0x00000000
+	.word MC_ATTR5_END_REG			, 0x00000000
+	.word MC_ATTR6_END_REG			, 0x00000000
+	.word MC_ATTR7_END_REG			, 0x00000000
+	.word MC_ATTR8_END_REG			, 0x00000000
+	.word MC_ATTR9_END_REG			, 0x00000000
+	.word MC_ATTR10_END_REG			, 0x00000000
+	.word MC_ATTR11_END_REG			, 0x00000000
+	.word MC_ATTR12_END_REG			, 0x00000000
+	.word MC_ATTR13_END_REG			, 0x00000000
+	.word MC_ATTR14_END_REG			, 0x00000000
+	.word MC_ATTR15_END_REG			, 0x00000000
+	.word MC_ATTR_WP_CTL_REG		, 0x00000000
+	.word MC_ATTR_INTR_EN_REG		, 0x00000000
+	.word MC_ATTR_WP_LOG0_REG		, 0x00000000
+	.word MC_ATTR_WP_LOG1_REG		, 0x00000000
+	.word MC_ATTR_CONTENT_RD_LOG0_REG	, 0x00000000
+	.word MC_ATTR_CONTENT_RD_LOG1_REG	, 0x00000000
+	.word MC_TILE0_START_REG		, 0x00000000
+	.word MC_TILE1_START_REG		, 0x00000000
+	.word MC_TILE2_START_REG		, 0x00000000
+	.word MC_TILE3_START_REG		, 0x00000000
+	.word MC_TILE4_START_REG		, 0x00000000
+	.word MC_TILE5_START_REG		, 0x00000000
+	.word MC_TILE6_START_REG		, 0x00000000
+	.word MC_TILE7_START_REG		, 0x00000000
+	.word MC_TILE0_END_REG			, 0x00000000
+	.word MC_TILE1_END_REG			, 0x00000000
+	.word MC_TILE2_END_REG			, 0x00000000
+	.word MC_TILE3_END_REG			, 0x00000000
+	.word MC_TILE4_END_REG			, 0x00000000
+	.word MC_TILE5_END_REG			, 0x00000000
+	.word MC_TILE6_END_REG			, 0x00000000
+	.word MC_TILE7_END_REG			, 0x00000000
+	.word MC_TILE0_CTL_REG			, 0x00000000
+	.word MC_TILE1_CTL_REG			, 0x00000000
+	.word MC_TILE2_CTL_REG			, 0x00000000
+	.word MC_TILE3_CTL_REG			, 0x00000000
+	.word MC_TILE4_CTL_REG			, 0x00000000
+	.word MC_TILE5_CTL_REG			, 0x00000000
+	.word MC_TILE6_CTL_REG			, 0x00000000
+	.word MC_TILE7_CTL_REG			, 0x00000000
+	.word MC_RING_CTL_REG			, 0x00000000
+	.word MC_RING_FREQUENCY_REG		, 0x00000000
+	.word MC_EVENT_SEL0_REG			, 0x00000000
+	.word MC_EVENT_SEL1_REG			, 0x00000000
+	.word MC_EVENT_CTL_REG			, 0x00000000
+	.word MC_EVENT_TIM_REG			, 0x00000000
+	.word MC_DBG_CTL_REG			, 0x00000000
+	.word 0xDEADBEEF			, 0xDEADBEEF
+
+MC_NEVIS_C:
+	/* Memory controller #0 settings */
+	.word MC_CFG0_REG			, 0x1AF40111
+	.word MC_CFG1_REG			, 0x01010308
+	.word MC_CFG2_REG			, 0x0A070807
+	.word MC_PARAM0_REG			, 0x120D0404
+	.word MC_PARAM1_REG			, 0x030D0704
+	.word MC_PARAM2_REG			, 0x062704B9
+	.word MC_PARAM3_REG			, 0x05020101
+	.word MC_PARAM4_REG			, 0x057C00C7
+	.word MC_MRS_REG			, 0x00000853
+	.word MC_EMRS1_REG			, 0x00000006
+	.word MC_EMRS2_REG			, 0x00000000
+	.word MC_EMRS3_REG			, 0x00000000
+	.word MC_DLL_CTL_CLOCK_REG		, 0x15151515
+	.word MC_DLL_CTL_SKEW_REG		, 0x99999999
+	.word MC_DLL_CTL_OVERRIDE0_REG		, 0x00000000
+	.word MC_DLL_CTL_OVERRIDE1_REG		, 0x00000000
+	.word MC_INTR_EN_REG			, 0x00000000
+	.word MC_INTR_STAT_REG			, 0xFFFFFFFF
+	.word MC_THRESH0_REG			, 0x18203040
+	.word MC_THRESH1_REG			, 0x00040810
+	.word MC_CFG3_REG			, 0x00F00704
+	.word MC_PARAM5_REG			, 0x0B00F231
+	.word MC_PARAM6_REG			, 0x00506210
+	.word MC_DRIVE0_REG			, 0x00000006
+	.word MC_DRIVE1_REG			, 0x00000000
+	.word MC_DRIVE2_REG			, 0x00000006
+	.word MC_DRIVE3_REG			, 0x00000000
+	.word MC_DRIVE4_REG			, 0x00000000
+	.word MC_O_DELAY_REG			, 0x003FFFFF
+	.word MC_RING_CTL_REG			, 0x00000000
+	.word MC_RING_FREQUENCY_REG		, 0x00000000
+
+	/* Memory controller #1 settings */
+	.word MC_CFG0_M1_REG			, 0x1AF40111
+	.word MC_CFG1_M1_REG			, 0x01010308
+	.word MC_PARAM0_M1_REG			, 0x120D0404
+	.word MC_PARAM1_M1_REG			, 0x030D0704
+	.word MC_PARAM2_M1_REG			, 0x062704B9
+	.word MC_PARAM3_M1_REG			, 0x05020101
+	.word MC_PARAM4_M1_REG			, 0x057C00C7
+	.word MC_MRS_M1_REG			, 0x00000853
+	.word MC_EMRS1_M1_REG			, 0x00000006
+	.word MC_EMRS2_M1_REG			, 0x00000000
+	.word MC_EMRS3_M1_REG			, 0x00000000
+	.word MC_PARAM5_M1_REG			, 0x0B00F231
+	.word MC_PARAM6_M1_REG			, 0x00506210
+	.word MC_O_DELAY_M1_REG			, 0x003FFFFF
+	/* Memory PLL settings (310MHz) */
+	.word MEM_PLL_CTRL0_REG			, 0x00414032
+	.word MEM_PLL_CTRL1_REG			, 0x0000943A	/* .word 0xE0500804, 0x0000143A */
+	.word MEM_PLL_CTRL2_REG			, 0x0000003E	/* .word 0xE0500808, 0x86120043 */
+	.word MEM_PLL_CTRL3_REG			, 0x00000000
+	.word MEM_PLL_CTRL1_REG			, (0x0000943A & 0xFFFD) /* Reset Memory controller */
+	.word MEM_PLL_CTRL1_REG			, 0x0000943A	/* Release again */
+	.word 0xDEADBEEF			, 0xDEADBEEF
+
+MC_NEVIS_D:
+	/* Memory controller #0 settings */
+	.word MC_CFG0_REG			, 0x1AF40111
+	.word MC_CFG1_REG			, 0x21010308
+	.word MC_CFG2_REG			, 0x0A070807
+	.word MC_PARAM0_REG			, 0x120D0404
+	.word MC_PARAM1_REG			, 0x030D0704
+	.word MC_PARAM2_REG			, 0x062704B9
+	.word MC_PARAM3_REG			, 0x05020101
+	.word MC_PARAM4_REG			, 0x057C00C7
+	.word MC_MRS_REG			, 0x00000853
+	.word MC_EMRS1_REG			, 0x00000006
+	.word MC_EMRS2_REG			, 0x00000000
+	.word MC_EMRS3_REG			, 0x00000000
+	.word MC_DLL_CTL_CLOCK_REG		, 0x16151515
+	.word MC_DLL_CTL_SKEW_REG		, 0x99999999
+	.word MC_DLL_CTL_OVERRIDE0_REG		, 0x00000000
+	.word MC_DLL_CTL_OVERRIDE1_REG		, 0x00000000
+	.word MC_INTR_EN_REG			, 0x00000000
+	.word MC_INTR_STAT_REG			, 0xFFFFFFFF
+	.word MC_THRESH0_REG			, 0x18203040
+	.word MC_THRESH1_REG			, 0x00040810
+	.word MC_CFG3_REG			, 0x00F00704
+	.word MC_PARAM5_REG			, 0x0B00F231
+	.word MC_PARAM6_REG			, 0x00606210
+	.word MC_DRIVE0_REG			, 0x00000006
+	.word MC_DRIVE1_REG			, 0x00000000
+	.word MC_DRIVE2_REG			, 0x00000006
+	.word MC_DRIVE3_REG			, 0x00000000
+	.word MC_DRIVE4_REG			, 0x00000000
+	.word MC_O_DELAY_REG			, 0x0016FFFF
+	.word MC_RING_CTL_REG			, 0x00000000
+	.word MC_RING_FREQUENCY_REG		, 0x00000000
+
+	/* Memory controller #1 settings */
+	.word MC_CFG0_M1_REG			, 0x1AF40111
+	.word MC_CFG1_M1_REG			, 0x21010308
+	.word MC_PARAM0_M1_REG			, 0x120D0404
+	.word MC_PARAM1_M1_REG			, 0x030D0704
+	.word MC_PARAM2_M1_REG			, 0x062704B9
+	.word MC_PARAM3_M1_REG			, 0x05020101
+	.word MC_PARAM4_M1_REG			, 0x057C00C7
+	.word MC_MRS_M1_REG			, 0x00000853
+	.word MC_EMRS1_M1_REG			, 0x00000006
+	.word MC_EMRS2_M1_REG			, 0x00000000
+	.word MC_EMRS3_M1_REG			, 0x00000000
+	.word MC_PARAM5_M1_REG			, 0x0B00F231
+	.word MC_PARAM6_M1_REG			, 0x00606210
+	.word MC_O_DELAY_M1_REG			, 0x0016FFFF
+	/* Memory PLL settings (310MHz) */
+	.word MEM_PLL_CTRL0_REG			, 0x00414032
+	.word MEM_PLL_CTRL1_REG			, 0x0000943A
+	.word MEM_PLL_CTRL2_REG			, 0x0000003E
+	.word MEM_PLL_CTRL3_REG			, 0x00000000
+	.word MEM_PLL_CTRL1_REG			, (0x0000943A & 0xFFFD) /* Reset Memory controller */
+	.word MEM_PLL_CTRL1_REG			, 0x0000943A	/* Release again */
+	.word 0xDEADBEEF			, 0xDEADBEEF
+
+/*******************************************************************************/
+/* small helper to unlock the locked special function registers */
+UnlockRegs:
+	mov	r10, lr	/* save callers address */
+
+	ldr	r2, =LOCKCMD_REG
+	mov	r3, #0x00
+	str	r3, [r2]
+	mov	r3, #0xF8
+	str	r3, [r2]
+	mov	r3, #0x2B
+	str	r3, [r2]
+	ldr	r2, =LOCKSTAT_REG
+	ldr	r3, [r2]
+	bic	r3, r3,r0
+	str	r3, [r2]
+
+	ldr	r2, =LOCKCMD_REG
+	mov	r3, #0x00
+	str	r3, [r2]
+
+	mov pc, r10	/* return to caller */
+	.ltorg
+
+/*******************************************************************************/
+LockRegs:
+	mov r10, lr	/* save callers address */
+
+	ldr	r2, =LOCKCMD_REG
+	mov	r3, #0x00
+	str	r3, [r2]
+	mov	r3, #0xF8
+	str	r3, [r2]
+	mov	r3, #0x2B
+	str	r3, [r2]
+	ldr	r2, =LOCKSTAT_REG 
+	ldr	r3, [r2]
+	orr	r3, r3, r0
+	str	r3, [r2]
+
+	ldr	r2, =LOCKCMD_REG
+	mov	r3, #0x00
+	str	r3, [r2]
+
+	mov	pc, r10	/* return to caller */
+	.ltorg
+
+/*******************************************************************************/
+
+.globl ReadChipIDs
+ReadChipIDs:
+	mov r10, lr	/* save callers address */
+
+	ldr	r1, =PCI_CFG_ADDR_REG
+	ldr	r2, =PCI_CFG_DATA_REG
+	ldr	r3, =SCRATCH_4_REG
+	ldr	r4, =SCRATCH_5_REG
+	mov	r0, #0x00		@ PCI-Config register 0x00 contains the chip ID (bit 31...16) and the chip vendor (bit 15...0)
+	str	r0, [r1]
+	ldr	r0, [r2]
+	str	r0, [r3]
+	ldr	r0, =0x08		@ PCI-Config register 0x08 contains the major (bit 7..4) and minor (bit 3...0) chip revision
+	str	r0, [r1]
+	ldr	r0, [r2]
+	ldr	r1, =0x000000FF		@ remove upper 24 bit (contains the PCI class code)
+	and	r0, r0, r1
+	str	r0, [r4]
+
+	mov pc, r10	/* return to caller */
+	.ltorg
+
+/*******************************************************************************/
+/* helper function to load a bunch of registers */
+
+.globl LoadRegArray
+LoadRegArray:
+	mov	r10, lr	/* save callers address */
+
+LoadRegArrayLoop:
+	ldr	r1, [r0]
+	add	r0, r0, #4
+	ldr	r2, [r0]
+	add	r0, r0, #4
+	cmp	r1, r2
+	strne	r2, [r1]
+	bne	LoadRegArrayLoop
+
+	mov pc, r10	/* return to caller */
+
+InitClockSpeed:
+	mov	r10, lr	/* save callers address */
+
+	/*
+	 * CPU clock setting.
+	 *
+	 * Check which revision we have and update the CPU-clock to the max 
+	 * supported value (Rev. A/B/C -> 450/550 MHz, Rev. D -> 594 MHz).
+	 * Notes:	SCRATCH_4_REG contains the vendor ID and 
+	 *		SCRATCH_5_REG contains the chip revision code.
+	 */
+
+	ldr	r0, =SCRATCH_5_REG	/* r0 = register address */
+	ldr	r1, [r0]		/* r1 = register value */
+	and	r1, #0xFF
+	cmp	r1, #0x2F		/* Rev. A = 0x0x, B = 0x1x, C = 0x2x */
+	ble	CPU_REV_ABC
+	ldr	r1, =0x13CCCCCD		/* PL1_INTFRAC = 594 */
+	b	CPU_CLK_SET
+CPU_REV_ABC:
+	ldr	r0, =0xE044014C		/* undocumented hardware erata register */
+	ldr	r1, [r0]
+	ands	r1, #0x00800000		/* mask bit 23 */
+	bne	CPU_CLOCK_DONE
+	ldr	r1, =0x12555555		/* PL1_INTFRAC = 550 */
+CPU_CLK_SET:
+	ldr	r0, =0xE0440028		/* PL1_INTFRAC_REG */
+	str	r1, [r0]
+CPU_CLOCK_DONE:
+	mov	pc, r10 /* return to caller */
+	.ltorg
+
+/*******************************************************************************/
+/* main function for really low level init (before any C enviroment) called
+   from cpu/<CPU>/Start.S							   */
+
+.globl lowlevel_init
+lowlevel_init:
+	mov	r13, lr
+
+	ldr	r0, =HSX_ASX_BRIDGE_CTRL_REG
+	ldr	r1, [r0]
+	orr	r1,r1, #0x00000001
+	str	r1, [r0]
+
+	/* Setup the primary GPIO MUX configuration */
+	ldr	r0, =PIN_CONFIG0_REG
+	ldr	r1, =PIN_CONFIG0_REG_DEFAULT
+	str	r1, [r0]
+
+	ldr	r0, =PIN_ALT_FUNC_REG
+	ldr	r1, =PIN_ALT_FUNC_REG_DEFAULT
+	str	r1, [r0]
+
+	ldr	r0, =GPIO_PIN_MUX0_REG
+	ldr	r1, =GPIO_PIN_MUX0_REG_DEFAULT
+	str	r1, [r0]
+
+	ldr	r0, =GPIO_PIN_MUX1_REG
+	ldr	r1, =GPIO_PIN_MUX1_REG_DEFAULT
+	str	r1, [r0]
+
+	ldr	r0, =GPIO_PIN_MUX2_REG
+	ldr	r1, =GPIO_PIN_MUX2_REG_DEFAULT
+	str	r1, [r0]
+
+	ldr	r0, =GPIO_PIN_MUX3_REG
+	ldr	r1, =GPIO_PIN_MUX3_REG_DEFAULT
+	str	r1, [r0]
+
+	ldr	r0, =GPIO_PIN_MUX4_REG
+	ldr	r1, =GPIO_PIN_MUX4_REG_DEFAULT
+	str	r1, [r0]
+
+	ldr	r0, =GPIO_PIN_MUX5_REG
+	ldr	r1, =GPIO_PIN_MUX5_REG_DEFAULT
+	str	r1, [r0]
+
+	ldr	r0, =GPIO_PIN_MUX6_REG
+	ldr	r1, =GPIO_PIN_MUX6_REG_DEFAULT
+	str	r1, [r0]
+
+	/* Setup the secondary MUX registers */
+	ldr	r0, =GPIO_PIN_SMUX0_REG
+	ldr	r1, =GPIO_PIN_SMUX0_REG_DEFAULT
+	str	r1, [r0]
+
+	ldr	r0, =GPIO_PIN_SMUX1_REG
+	ldr	r1, =GPIO_PIN_SMUX1_REG_DEFAULT
+	str	r1, [r0]
+
+	ldr	r0, =GPIO_PIN_SMUX2_REG
+	ldr	r1, =GPIO_PIN_SMUX2_REG_DEFAULT
+	str	r1, [r0]
+
+	ldr	r0, =GPIO_PIN_SMUX3_REG
+	ldr	r1, =GPIO_PIN_SMUX3_REG_DEFAULT
+	str	r1, [r0]
+
+	ldr	r0, =GPIO_PIN_SMUX4_REG
+	ldr	r1, =GPIO_PIN_SMUX4_REG_DEFAULT
+	str	r1, [r0]
+
+	ldr	r0, =GPIO_PIN_SMUX5_REG
+	ldr	r1, =GPIO_PIN_SMUX5_REG_DEFAULT
+	str	r1, [r0]
+
+	ldr	r0, =GPIO_PIN_SMUX6_REG
+	ldr	r1, =GPIO_PIN_SMUX6_REG_DEFAULT
+	str	r1, [r0]
+
+	/* Remove FLASH shadow */
+	ldr	r0, =REMAP_REG
+	ldr	r1, =0x00000000
+	str	r1, [r0]
+
+	/* read the chip vendor, ID,revision */
+	bl	ReadChipIDs
+
+	/* Setup PLLs */
+	mov	r0, #0x300
+	bl	UnlockRegs
+
+	adrl	r0, PLL_NEVIS
+	bl	LoadRegArray
+
+	bl	InitClockSpeed
+
+	ldr	r0, =SREG_PLL_BYPASS_REG
+	ldr	r1, =0x000005FF
+	str	r1, [r0]
+
+	/* MPG0 */
+	ldr	r0, =AUDIO_CLK_SEL_REG
+	ldr	r1, [r0]
+	ldr	r2, =0x00FFFFFF 
+	bic	r1, r1, r2
+	str	r1, [r0]
+
+	ldr	r0, =AUDIO_DIVIDE0_REG
+	ldr	r1, [r0]
+	ldr	r2, =0xFFFF0000
+	bic	r1, r1, r2
+	ldr	r2, =0x30570000
+	orr	r1, r1, r2
+	str	r1, [r0]
+	ldr	r2, =0x0000FFFF
+	bic	r1, r1, r2
+	mov	r2, #0x00000200
+	orr	r1, r1, r2
+	str	r1, [r0]
+
+	ldr	r0, =AUDIO_DIVIDE1_REG
+	ldr	r1, [r0]
+	ldr	r2, =0xFFFF0000
+	bic	r1, r1, r2
+	ldr	r2, =0x30570000
+	orr	r1, r1, r2
+	str	r1, [r0]
+	ldr	r2, =0x0000FFFF
+	bic	r1, r1, r2
+	mov	r2, #0x00000200
+	orr	r1, r1, r2
+	str	r1, [r0]
+
+	ldr	r0, =AUDIO_DIVIDE2_REG
+	ldr	r1, [r0]
+	ldr	r2, =0xFFFF0000
+	bic	r1, r1, r2
+	ldr	r2, =0x30570000
+	orr	r1, r1, r2
+	str	r1, [r0]
+	ldr	r2, =0x0000FFFF
+	bic	r1, r1, r2
+	mov	r2, #0x00000200
+	orr	r1, r1, r2
+	str	r1, [r0]
+
+	ldr	r0, =AUDIO_DIVIDE3_REG
+	ldr	r1, [r0]
+	ldr	r2, =0xFFFF0000
+	bic	r1, r1, r2
+	ldr	r2, =0x30570000
+	orr	r1, r1, r2
+	str	r1, [r0]
+	ldr	r2, =0x0000FFFF
+	bic	r1, r1, r2
+	mov	r2, #0x00000200
+	orr	r1, r1, r2
+	str	r1, [r0]
+
+	ldr	r0, =AUDIO_DIVIDE4_REG
+	ldr	r1, [r0]
+	ldr	r2, =0xFFFF0000
+	bic	r1, r1, r2
+	ldr	r2, =0x30570000
+	orr	r1, r1, r2
+	str	r1, [r0]
+	ldr	r2, =0x0000FFFF
+	bic	r1, r1, r2
+	mov	r2, #0x00000200
+	orr	r1, r1, r2
+	str	r1, [r0]
+
+	ldr	r0, =AUDIO_DIVIDE5_REG
+	ldr	r1, [r0]
+	ldr	r2, =0xFFFF0000
+	bic	r1, r1, r2
+	ldr	r2, =0x30570000
+	orr	r1, r1, r2
+	str	r1, [r0]
+	ldr	r2, =0x0000FFFF
+	bic	r1, r1, r2
+	mov	r2, #0x00000200
+	orr	r1, r1, r2
+	str	r1, [r0]
+
+	ldr	r0, =MPG2_DIVIDE_REG
+	ldr	r1, [r0]
+	ldr	r2, =0xFFFF0000
+	bic	r1, r1, r2
+	ldr	r2, =0x2B030000
+	orr	r1, r1, r2
+	str	r1, [r0]
+	ldr	r2, =0x0000FFFF
+	bic	r1, r1, r2
+	mov	r2, #0x000003E8
+	orr	r1, r1, r2
+	str	r1, [r0]
+
+	ldr	r0, =MPG3_DIVIDE_REG
+	ldr	r1, [r0]
+	ldr	r2, =0xFFFF0000
+	bic	r1, r1, r2
+	mov	r2, #0x08000000
+	orr	r1, r1, r2
+	str	r1, [r0]
+	ldr	r2, =0x0000FFFF
+	bic	r1, r1, r2
+	mov	r2, #0x000000E1
+	orr	r1, r1, r2
+	str	r1, [r0]
+
+	/* wait for PLLs to lock */
+	mov	r1, #0x000000FF
+WFL:
+	ldr	r0, =0xE0400018
+	ldr	r0, [r0]
+	and	r0, r0, r1
+	cmp	r0, r1
+	bne	WFL
+
+	mov	r0, #0x300
+	bl	LockRegs
+
+	/* Exception vector table at 0x00000000 */
+	mrc	p15, 0, r0, c1, c0
+	and	r0, r0, #0xFFFFDFFF
+	mcr	p15, 0, r0, c1, c0
+
+	ldr	r2, =MC_CTL_REG /* Set the "START" bit to 0 to stop the memory controller */
+	mov	r3, #0
+	str	r3, [r2]
+
+WaitForMCStop:
+	ldr	r1, [r2]
+	and	r1, r1, #0x000F0000
+	cmp	r1, #0x000A0000
+	bne	WaitForMCStop
+
+	/* Setup DDR-Controller */
+	adrl	r0, MC_COMMON
+	bl	LoadRegArray
+
+	ldr	r0, =SCRATCH_5_REG	/* r0 = register address */
+	ldr	r1, [r0]		/* r1 = register value */
+	and	r1, #0xF0
+	cmp	r1, #0x20		/* Rev. A = 0x0x, B = 0x1x, C = 0x2x */
+	beq	MEM_REVC
+	cmp	r1, #0x30
+	beq	MEM_REVD
+	b	MEM_REVC
+MEM_REVC:
+	adrl	r0, MC_NEVIS_C
+	bl	LoadRegArray
+	b	PLL_LOCK
+MEM_REVD:
+	adrl	r0, MC_NEVIS_D
+	bl	LoadRegArray
+PLL_LOCK:
+	/* wait for MC PLLs to lock */
+	ldr	r2, =0x000001FF
+WFMCL:
+	ldr	r0, =0xE0400018
+	ldr	r1, [r0]
+	cmp	r1, r2
+	bne	WFMCL
+
+	ldr	r0, =HSX_0_ARBMODE_REG
+	ldr	r1, =0x00000000
+	str	r1, [R0]
+
+	ldr	r0, =HSX_0_ARBMODE1_REG
+	ldr	r1, =0x00000000
+	str	r1, [r0]
+
+	ldr	r0, =HSX_1_ARBMODE_REG
+	ldr	r1, =0x00000000
+	str	r1, [r0]
+
+	ldr	r0, =HSX_1_ARBMODE1_REG
+	ldr	r1, =0x00000000
+	str	r1, [r0]
+
+	ldr	r0, =HSX_2_ARBMODE_REG
+	ldr	r1, =0x00000000
+	str	r1, [r0]
+
+	ldr	r0, =HSX_2_ARBMODE1_REG
+	ldr	r1, =0x00000000
+	str	r1, [r0]
+
+	ldr	r0, =MEMORY_TIMER_REG
+	ldr	r1, =0x0000000
+	str	r1, [r0]
+
+	ldr	r0, =MC_TILE_CFG_REG
+	ldr	r1, =0x00001038 /* 0x00001036 0x00001038 */
+	str	r1, [r0]
+
+	ldr	r2, =MC_CTL_REG /* Set the "START" bit to 1 to load and use configured values */
+	mov	r3, #0
+	str	r3, [r2]
+	mov	r3, #1
+	str	r3, [r2]
+
+	ldr	r2, =MC_CTL_REG /* we see PDN_STATE0 and PDN_STATE1 fields go to zero when MC is up */
+WaitForMC:
+	ldr	R1, [r2]
+	ands	r3, R1, #0x000F0000
+	bne	WaitForMC
+	/* Debug settings */
+	ldr	r1, =HSX_PIT_GENERAL_REG
+	ldr	r0, =0x00000001
+	str	r0, [r1]
+	ldr	r1, =HSX_PIT_DATA_REG
+	ldr	r0, =0x00000000
+	str	r0, [r1]
+	ldr	r1, =HSX_PIT_INSTR_REG
+	ldr	r0, =0x00800000
+	str	r0, [r1]
+
+	/* RAM check */
+	/* first clear addresses which we will check */
+	ldr	r0, =0x00400000		@ first address to test for bank 0
+	ldr	r1, =0x00000000
+	ldr	r4, =0x20000000		@ limit the clear range to 512 MB 
+
+	/* write zeros at all addresses which we will test */
+init_loop:
+	str	r1, [r0]
+	add	r0, r0, #0x00400000
+	cmp	r0, r4
+	bne	init_loop
+
+	ldr	r0, =0x00400000		@ first address to test
+	ldr	r4, =0x10000000		@ limit the test to 256 MB 
+	ldr	r5, =0x00000000
+
+	/* hardware bank #0 */
+test_loop_b0:
+	ldr	r1, =0x55AA55AA;	@ test pattern
+	str	r1, [r0]		@ write test pattern
+	ldr	r2, [r0]		@ read back
+	cmp	r1, r2			@ compare written and read value
+	bne	not_pass_b0
+
+	ldr	r1, =0xAA55AAB0;	@ test pattern
+	str	r1, [r0]		@ write test pattern
+	ldr	r2, [r0]		@ read back
+	cmp	r1, r2			@ compare written and read value
+	bne	not_pass_b0
+
+	mov	r5, r0			@ copy current address to r5
+ntest_loop_b0:
+	add	r5, r5, #0x00400000
+	ldr	r2, [r5]
+	cmp	r1, r2
+	beq	not_pass_b0
+	cmp	r5, r4
+	bne	ntest_loop_b0
+
+	add	r0, r0, #0x00400000	@ increment the address to test by 4 MB
+	cmp	r0, r4			@ compare current address with max address
+	blt	test_loop_b0
+not_pass_b0:
+	ldr	r0, =SCRATCH_2_REG	@ save the size of bank 0
+	str	r5, [r0]
+
+	/* hardware bank #1 */
+	ldr	r0, =0x10000000		@ first address to test for bank 1
+	ldr	r4, =0x20000000		@ limit the test to 512 MB
+	ldr	r5, =0x10000000
+
+test_loop_b1:
+	ldr	r1, =0xAA55AA55		@ test pattern
+	str	r1, [r0]		@ write test pattern
+	ldr	r2, [r0]		@ read back
+	cmp	r1, r2			@ compare written and read value
+	bne	not_pass_b1
+
+	ldr	r1, =0x55AA55B1		@ test pattern
+	str	r1, [r0]		@ write test pattern
+	ldr	r2, [r0]		@ read back
+	cmp	r1, r2			@ compare written and read value
+	bne	not_pass_b1
+
+	mov	r5, r0			@ copy current address to r5
+ntest_loop_b1:
+	add	r5, r5, #0x00400000
+	ldr	r2, [r5]
+	cmp	r1, r2
+	beq	not_pass_b1
+	cmp	r5, r4
+	bne	ntest_loop_b1
+
+	add	r0, r0, #0x00400000	@ increment the address to test by 4 MB
+	cmp	r0, r4			@ compare current address with max address
+	blt	test_loop_b1
+not_pass_b1:
+	sub	r5, r5, #0x10000000
+	ldr	r0, =SCRATCH_3_REG	@ save the size of bank 1
+	str	r5, [r0]
+
+	/* Disable all Interrupts */
+	ldr	r1, =ITC_INTENABLE1_REG_DEFAULT
+	ldr	r0, =ITC_INTENABLE1_REG
+	str	r1, [r0]
+
+	ldr	r1, =ITC_INTENABLE2_REG_DEFAULT
+	ldr	r0, =ITC_INTENABLE2_REG
+	str	r1, [r0]
+
+	/* enable the peripherial port */
+	ldr	r0, =0xE8000009
+	mcr	p15, 0, r0, c15, c2, 4
+
+	/* back to arch calling code */
+	mov	pc, r13
+	/* the literal pools origin */
+	.ltorg
+
+/*
+ * Some code for ARM 926. We assemble it here so we can use it in our
+ * C code later.. ;)
+ */
+.globl arm926_spin_begin
+arm926_spin_begin:
+	ldr	r0, [pc, #(ARM9_VECTOR_OFFSET - 0x08)] /* consider the prefetch! */
+	ldr	r1, [pc, #(ARM9_VECTOR_OFFSET - 0x08)] /* consider the prefetch! */
+	cmp	r0, #0
+	subeq	pc, pc, #0x14
+	cmp	r1, #0
+	subeq	pc, pc, #0x1C
+	bx	r0
+.globl arm926_spin_end
+arm926_spin_end:
+	/* the literal pools origin */
+	.ltorg
diff --git a/board/coolstream_hdx/network.c b/board/coolstream_hdx/network.c
new file mode 100644
index 0000000..dbe9f3f
--- /dev/null
+++ b/board/coolstream_hdx/network.c
@@ -0,0 +1,526 @@
+/*
+ * Low level driver to access the network via the embedded VMAC 
+ * controller and an attached Realtek RTL8201 PHY.
+ *
+ * (C) Copyright 2008
+ * Coolstream Internation Limited
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/arch/nevis.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <net.h>
+
+#define NUM_RX_BDT	32
+#define NUM_TX_BDT	1
+
+
+/* TX Control Information Written By the EMAC Bit Masks */
+#define ENET_CTL_INFO_TX_LEN		0x000007FF	/* Tx Length in this buffer to be Xmitted */
+#define ENET_CTL_INFO_FIRST		0x00010000	/* First TX buffer in the packet */
+#define ENET_CTL_INFO_LAST		0x00020000	/* Last TX buffer in the packet */
+#define ENET_CTL_INFO_ADDCRC		0x00040000	/* Add the CRC to the pkt that is transmitted */
+#define ENET_CTL_INFO_CARR_LOSS		0x00200000	/* Carrier Lost during xmission */
+#define ENET_CTL_INFO_DEFER		0x00400000	/* xmission deferred due to traffic */
+#define ENET_CTL_INFO_DROPPED		0x00800000	/* pkt dropped after 16 retries */
+#define ENET_CTL_INFO_RETRY		0x0F000000	/* Retry count for TX */
+#define ENET_CTL_INFO_RETRY_SHIFT	24  
+#define ENET_CTL_INFO_LATE_COLL		0x10000000	/* Late Collision */
+#define ENET_CTL_INFO_UFLO		0x20000000	/* Data not available on time */
+#define ENET_CTL_INFO_BUFF		0x40000000	/* Buffer error - bad FIRST and LAST */
+#define ENET_CTL_INFO_OWN		0x80000000	/* CPU/EMAC Ownership of buffer */
+
+#define MDIO_WRITE		0x50020000	/* 0101 xxxx xxxx xx10 xxxx xxxx xxxx xxxx */
+#define MDIO_READ		0x60020000	/* 0110 xxxx xxxx xx10 xxxx xxxx xxxx xxxx */
+
+#define RTL8201_BMC_REG		0x00000000	/* Basic Mode Control Register   */
+#define RTL8201_BMS_REG		0x00040000	/* Basic Mode Status Register    */
+#define RTL8201_PHYID1_REG	0x00080000	/* PHY Identification Register 1 */
+#define RTL8201_PHYID2_REG	0x000C0000	/* PHY Identification Register 2 */
+
+
+typedef struct _xbdt
+{
+    volatile u32	 info;
+    volatile u8		*data;
+} __attribute__((packed)) xbdt;
+
+typedef struct _rbdt
+{
+    xbdt bdt[NUM_RX_BDT];
+} __attribute__((packed)) rbdt;
+
+typedef struct _tbdt
+{
+    xbdt bdt[NUM_TX_BDT];
+} __attribute__((packed)) tbdt;
+
+static int have_vmac = 0;
+static int phy_addr  = 0x20;
+static volatile rbdt *dma_rx_buf = NULL;
+static volatile tbdt *dma_tx_buf = NULL;
+static volatile u8 *tx_buf[NUM_TX_BDT];
+static volatile u8 *rx_buf[NUM_RX_BDT];
+static u32 current_tx_packet;
+static u32 current_rx_packet;
+static u8 *rx_chain;
+static u32 rx_chain_pos;
+
+extern flash_info_t flash_info[];       /* info for FLASH chips */
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static u16 _mdio_xfer(u32 dir, u32 addr, u32 reg, u16 data);
+void debug_dump_hex (unsigned int len, unsigned char *data);
+
+/*******************************************************************************/
+/* Initialize the NIC - low-level part, only executed once                     */
+
+void board_eth_init(void)
+{
+    char *nhwf = "*** Warning - no supported hardware found ***";
+    volatile u32 *reg;
+    volatile u32 *idreg   = (volatile u32*) EMAC_ID_REG;
+    u32 id = *idreg;
+    u8 ID  = id & 0xFF;
+    u8 nID = (id >> 8) & 0xFF;
+    u32 phy_cnt;
+
+    have_vmac = 0;
+
+    #ifdef BEAUTIFY_CONSOLE
+    printf("\xBA %-76s \xBA\n", "Network configuration");
+    #endif
+
+    /* ID integrity check, ID-Register bit 15...8 are the complements to bit 7...0 */
+    if ((ID ^ nID) != 0xFF)
+    {
+	#ifdef BEAUTIFY_CONSOLE
+	printf("\xBA MAC: %-64s (%.2X/%.2X) \xBA\n", nhwf, ID, nID);
+	#else
+	printf("NET: Error device ID mismatch (%.2X/%.2X)\n", ID, nID);
+	#endif
+	return /*have_vmac*/;
+    }
+
+    /* check configured MAC-address and set default, if not configured */
+    if (memcmp(gd->bd->bi_enetaddr, "\0\0\0\0\0\0", 6) == 0)
+    {
+        gd->bd->bi_enetaddr[0] = flash_info[0].serial[1];
+        gd->bd->bi_enetaddr[1] = flash_info[0].serial[2];
+        gd->bd->bi_enetaddr[2] = flash_info[0].serial[3];
+        gd->bd->bi_enetaddr[3] = flash_info[0].serial[5];
+        gd->bd->bi_enetaddr[4] = flash_info[0].serial[6];
+        gd->bd->bi_enetaddr[5] = flash_info[0].serial[7];
+    }
+
+    #ifdef BEAUTIFY_CONSOLE
+    printf("\xBA MAC: Conexant VMAC rev. %.2X       address: %.2X-%.2X-%.2X-%.2X-%.2X-%.2X%-18s\xBA\n", 
+	    (id >> 16) & 0xFF, 
+	    gd->bd->bi_enetaddr[0], gd->bd->bi_enetaddr[1], gd->bd->bi_enetaddr[2], 
+	    gd->bd->bi_enetaddr[3], gd->bd->bi_enetaddr[4], gd->bd->bi_enetaddr[5],
+	    " ");
+    #else
+    printf("NET: Conexant VMAC rev. 0x%.2X detected\n", (id >> 16) & 0xFF);
+    #endif
+
+    reg   = (volatile u32*) EMAC_CTRL_REG;
+    *reg &= 0xFFFFFFE6;		/* clear bit 0 to stop all network traffic */
+
+    /* load the MAC-address into the device */
+    reg  = (volatile u32*) EMAC_ADDRL_REG;
+    *reg = (gd->bd->bi_enetaddr[3] << 24) | (gd->bd->bi_enetaddr[2] << 16) | (gd->bd->bi_enetaddr[1] << 8) | gd->bd->bi_enetaddr[0];
+
+    reg  = (volatile u32*) EMAC_ADDRH_REG;
+    *reg = (gd->bd->bi_enetaddr[5] << 8) | gd->bd->bi_enetaddr[4];
+
+    /* clear filter */
+    reg  = (volatile u32*) EMAC_LAFL_REG;
+    *reg = 0;
+    reg  = (volatile u32*) EMAC_LAFH_REG;
+    *reg = 0;
+
+    /* check the PHY - reset is not required here */
+    for (phy_cnt = 0; phy_cnt < 32; phy_cnt++)
+    {
+	/* try to read ID2-register from every possible address */
+	u16 data = _mdio_xfer(MDIO_READ, phy_cnt, RTL8201_PHYID2_REG, 0);
+
+	switch(data) {
+	    case 0x8201: // Realtek 8201CL
+	        /* ok, seems to be a RTL8201CL, but for security, also check ID1 register */
+	        data = _mdio_xfer(MDIO_READ, phy_cnt, RTL8201_PHYID1_REG, 0);
+	        if (data == 0)
+	        {
+    		    /* tilt! This is a RTL8201CL, so store the address and skip the loop */
+		    phy_addr = phy_cnt;
+                    #ifdef BEAUTIFY_CONSOLE
+                    printf("\xBA PHY: Realtek RTL8201CL           address: %.2X %32s\xBA\n", phy_addr, " ");
+		    #else
+		    printf("NET: Realtek RTL8201CL PHY at address 0x%.2X detected\n", phy_addr);
+		    #endif
+		    phy_cnt = 32;
+	        }
+		break;
+	    case 0x0C54:
+	        /* ok, seems to be a RTL8201CL, but for security, also check ID1 register */
+	        data = _mdio_xfer(MDIO_READ, phy_cnt, RTL8201_PHYID1_REG, 0);
+	        if (data == 0x0243)
+	        {
+    		    /* tilt! This is a IC Plus IP0101 so store the address and skip the loop */
+		    phy_addr = phy_cnt;
+                    #ifdef BEAUTIFY_CONSOLE
+                    printf("\xBA PHY: IC Plus IP101               address: %.2X %32s\xBA\n", phy_addr, " ");
+		    #else
+		    printf("NET: IC Plus IP101 PHY at address 0x%.2X detected\n", phy_addr);
+		    #endif
+		    phy_cnt = 32;
+	        }
+		break;
+	}
+    }
+
+    if (phy_addr < 0x20)
+    {
+	/* only continue, if we have an PHY */
+
+	/* setup VMAC's DMA controller (alloc RAM for the BDT's and map to the DMA controller) */
+	dma_tx_buf = malloc(NUM_TX_BDT * sizeof(tbdt));
+	dma_rx_buf = malloc(NUM_RX_BDT * sizeof(rbdt));
+
+	if (dma_tx_buf && dma_rx_buf)
+	{
+	    reg   = (volatile u32*) EMAC_CTRL_REG;
+	    *reg  = (NUM_RX_BDT << 24) | (NUM_TX_BDT << 16);	/* delete all bits and set the TX and RX ringbuffer to only handle 1 BDT */
+
+	    reg  = (volatile u32*) EMAC_TXRINGPTR_REG;
+	    *reg = (u32) dma_tx_buf;
+	    reg  = (volatile u32*) EMAC_RXRINGPTR_REG;
+	    *reg = (u32) dma_rx_buf;
+
+	    reg  = (volatile u32*) EMAC_XCTRL_REG;
+	    *reg = 0x004F0040;
+
+	    reg  = (volatile u32*) EMAC_POLLR_REG;
+	    *reg = 1;
+
+	    /* reset all interrupt status bits */
+	    reg  = (volatile u32*) EMAC_STAT_REG;
+	    *reg = 0x0000171F;
+
+	    reg   = (volatile u32*) EMAC_ENABLE_REG;
+	    *reg = 0x0000171F;	/* 1000 0000 0000 0000 0001 0111 0001 1111 */
+
+	    u32 cnt;
+
+	    for (cnt = 0; cnt < NUM_TX_BDT; cnt++)
+	    {
+		tx_buf[cnt] = malloc(0x0800);
+		dma_tx_buf->bdt[cnt].data = tx_buf[cnt];
+		dma_tx_buf->bdt[cnt].info = ENET_CTL_INFO_FIRST | ENET_CTL_INFO_LAST | ENET_CTL_INFO_ADDCRC;
+	    }
+
+	    for (cnt = 0; cnt < NUM_RX_BDT; cnt++)
+	    {
+		rx_buf[cnt] = malloc(0x0800);
+		dma_rx_buf->bdt[cnt].data = rx_buf[cnt];
+		dma_rx_buf->bdt[cnt].info = 0x07FF | ENET_CTL_INFO_OWN;
+	    }
+
+	    current_tx_packet = 0;
+	    current_rx_packet = 0;
+	    rx_chain = malloc(NUM_RX_BDT * 0x0800);
+	    rx_chain_pos = 0;
+
+	    have_vmac = 1;
+	}
+	else
+	    #ifdef BEAUTIFY_CONSOLE
+	    printf("\xBA *** Error - no memory for DMA available %-36s \xBA\n", "***");
+	    #else
+	    printf("NET: Error no memory for DMA available!\n");
+	    #endif
+    }
+    else
+    {
+	#ifdef BEAUTIFY_CONSOLE
+	printf("\xBA PHY: %-72s\xBA\n", nhwf);
+	#else
+	printf("NET: Error no PHY found\n");
+	#endif
+
+    }
+}
+
+/*******************************************************************************/
+/* Initialize the NIC - u-boot call it every time before a network operation   */
+
+int eth_init(bd_t *bis)
+{
+    u16 data;
+    volatile u32 *reg;
+    int ret = -1;	/* error condition */
+
+    if (have_vmac)
+    {
+	/* read the link status from the PHY and update the link status in the MAC */
+        data = _mdio_xfer(MDIO_READ, phy_addr, RTL8201_BMS_REG, 0);
+	if ((data & 0x0024) == 0x0024)
+	{
+	    u16 duplex;
+	    /* physical link established. Now read the spead and duplex mode */
+	    data   = _mdio_xfer(MDIO_READ, phy_addr, RTL8201_BMC_REG, 0);
+	    duplex = (data >>  8) & 1;	/* 0: half duplex, 1: full duplex */
+
+	    /* write duplex mode into VMAC's cotrol register */
+	    reg = (volatile u32*) EMAC_CTRL_REG;
+	    if (duplex)		/* set bit 10 depending on the duplex mode read from the PHY */
+		*reg |= 0x00000400;
+	    else
+		*reg &= 0xFFFFFBFF;
+
+	    /* enable traffic */
+	    reg   = (volatile u32*) EMAC_CTRL_REG;
+	    *reg |= 0x00000019;	/* set bit 0, bit 3 (TX run), bit 4 (RX run) */
+
+	    ret = 0;
+	}
+	else
+	    printf("VMAC: network connection not established. Please check cable!\n");
+    }
+
+    return ret;
+}
+
+/*******************************************************************************/
+
+#define INT_STATUS_TX	0x00000001	/* TX data send successfully */
+#define INT_STATUS_RX	0x00000002	/* RX data available */
+#define INT_STATUS_ERR	0x00000004	/* ERROR (one or more of the others set) */
+#define INT_STATUS_TXCH	0x00000008	/* TX Chaining error (bad combination FIRST vs. LAST) */
+#define INT_STATUS_MSER	0x00000010	/* Missed packed counter rooled over */
+#define INT_STATUS_RXCR	0x00000100	/* RX CRC error counter rolled over */
+#define INT_STATUS_RXFR	0x00000200	/* RX frame error counter rolled over */
+#define INT_STATUS_RXFL	0x00000400	/* RX overflow counter rolled over */
+#define INT_STATUS_MDIO	0x00001000	/* MDIO xfer to/from PHY complete */
+
+int eth_handle_interrupt(void)
+{
+    volatile u32 *statusreg = (volatile u32*) EMAC_STAT_REG;
+    u32 status = *statusreg;
+    u32 cnt, do_rx = 0;
+
+    if (status & INT_STATUS_ERR)
+    {
+	u32 ack = INT_STATUS_ERR;
+
+	if (status & INT_STATUS_TXCH)
+	    ack |= INT_STATUS_TXCH;
+
+	if (status & INT_STATUS_MSER)
+	    ack |= INT_STATUS_MSER;
+
+	if (status & INT_STATUS_RXCR)
+	    ack |= INT_STATUS_RXCR;
+
+	if (status & INT_STATUS_RXFR)
+	    ack |= INT_STATUS_RXFR;
+
+	if (status & INT_STATUS_RXFL)
+	    ack |= INT_STATUS_RXFL;
+
+	*statusreg |= ack;
+	status = *statusreg;
+    }
+
+    if (status & INT_STATUS_TX)	/* TX Interrupt */
+    {
+	for (cnt = 0; cnt < NUM_TX_BDT; cnt++)
+	{
+	    if ((dma_tx_buf->bdt[current_tx_packet].info & ENET_CTL_INFO_OWN) == 0)
+	    {
+//		printf("TX info: %.8X\n", dma_tx_buf->bdt[cnt].info);
+//		debug_dump_hex(dma_tx_buf->bdt[cnt].info & 0x07FF, (u8*) dma_tx_buf->bdt[cnt].data);
+	    }
+	}
+
+	*statusreg |= INT_STATUS_TX;
+	status = *statusreg;
+	do_rx = 1;
+    }
+
+    if ((status & INT_STATUS_RX) || (do_rx))	/* RX Interrupt */
+    {
+	while ((dma_rx_buf->bdt[current_rx_packet].info & ENET_CTL_INFO_OWN) == 0)
+	{
+//	    printf("RX info: %.8X\n", dma_rx_buf->bdt[current_rx_packet].info);
+
+	    if (dma_rx_buf->bdt[current_rx_packet].info & ENET_CTL_INFO_FIRST)
+		rx_chain_pos = 0;
+
+	    u32 len = dma_rx_buf->bdt[current_rx_packet].info & 0x07FF;
+	    if (len)
+	    {
+		memcpy(rx_chain + rx_chain_pos, (u8*) dma_rx_buf->bdt[current_rx_packet].data, len);
+		rx_chain_pos += len;
+	    }
+	    if (dma_rx_buf->bdt[current_rx_packet].info & ENET_CTL_INFO_LAST)
+	    {
+//		debug_dump_hex(rx_chain_pos, rx_chain);
+		NetReceive(rx_chain, rx_chain_pos);
+	    }
+
+	    dma_rx_buf->bdt[current_rx_packet].info = ENET_CTL_INFO_OWN | 0x07FF;
+	    current_rx_packet++;
+	    if (current_rx_packet == NUM_RX_BDT)
+		current_rx_packet = 0;
+	}
+
+	if (status & INT_STATUS_RX)
+	{
+	    *statusreg |= INT_STATUS_RX;
+	    status = *statusreg;
+	}
+    }
+
+    if (status & INT_STATUS_MDIO)	/* MIDO xfer ready - can happen even if it's handled in _mdio_xfer() */
+    {
+	*statusreg |= INT_STATUS_MDIO;
+	status = *statusreg;
+    }
+
+    return 1;
+}
+
+/*******************************************************************************/
+
+int eth_send(volatile void *ptr, int len)
+{
+    volatile u32 *reg = (volatile u32*) EMAC_STAT_REG;
+
+    memcpy((u8*) tx_buf[current_tx_packet], (u8*) ptr, len & 0x07FF);
+    dma_tx_buf->bdt[current_tx_packet].info = (len & ENET_CTL_INFO_TX_LEN) | 
+					       ENET_CTL_INFO_FIRST  | ENET_CTL_INFO_LAST | 
+					       ENET_CTL_INFO_ADDCRC | ENET_CTL_INFO_OWN;
+
+    *reg |= 0x80000000;	/* force poll */
+    return 1;
+}
+
+/*******************************************************************************/
+
+int eth_rx(void)
+{
+    /* we run in interrupt mode, so just return to the poller after some delay */
+    udelay(250000);
+    return 1;
+}
+
+/*******************************************************************************/
+
+void eth_halt(void)
+{
+    /* stop all pending network traffic */
+//    volatile u32 *reg = (volatile u32*) EMAC_CTRL_REG;
+//    *reg &= 0xFFFFFFE6;		/* clear bit 0 */
+}
+
+/*******************************************************************************/
+
+static u16 _mdio_xfer(u32 dir, u32 addr, u32 reg, u16 data)
+{
+    volatile u32 *mdioreg = (volatile u32*) EMAC_MDIO_DATA_REG;
+    volatile u32 *statreg = (volatile u32*) EMAC_STAT_REG;
+    u32 x = 0;
+    u16 ret = 0xFFFF;
+
+    *mdioreg = dir | (addr << 23) | reg;
+
+    /* loop while the MDIO xfer ready bit is set. */
+    while (((*statreg) & 0x00001000) == 0)
+    {
+	udelay(100);
+	x++;
+	if (x > 20)		/* xfer timed out */
+	    return ret;
+    }
+
+    ret = *mdioreg & 0xFFFF;
+    *statreg |= 0x00001000;	/* ACK the status bit */
+
+    return ret;
+}
+
+
+void debug_dump_hex (unsigned int len, unsigned char *data)
+{
+    unsigned short y = 0;
+    unsigned int   x = 0;
+    int z;
+
+    if ((!data) || (!len))
+	return;
+
+    printf("    ");
+
+    for (x = 0; x < len; x++)
+    {
+        printf ("%.2X ", data[x]);
+        y++;
+        if (y == 16)
+        {
+            printf ("  ");
+            for (z = 0; z < 16; z++)
+            {
+                if ((data[((x/16) * 16) + z] > 0x1F) &&
+                    (data[((x/16) * 16) + z] < 0x7F))
+                {
+                    printf ("%c", data[((x/16) * 16) + z]);
+                }
+                else
+                {
+                    printf (".");
+                }
+            }
+            y = 0;
+            if (x < (len - 1))
+            printf ("\n    ");
+        }
+    }
+    if (y > 0)
+    {
+        for (z = y; z < 16; z++)
+            printf ("   ");
+        printf ("  ");
+        for (z = 0; z < y; z++)
+        {
+            if ((data[(len - (len % 16)) + z] > 0x1F) &&
+                (data[(len - (len % 16)) + z] < 0x7F))
+            {
+                printf ("%c", data[(len - (len % 16)) + z]);
+            }
+            else
+            {
+                printf (".");
+            }
+        }
+    }
+    printf ("\n");
+}
+
diff --git a/board/coolstream_hdx/splash.c b/board/coolstream_hdx/splash.c
new file mode 100644
index 0000000..67e3644
--- /dev/null
+++ b/board/coolstream_hdx/splash.c
@@ -0,0 +1,724 @@
+/*
+ * (C) Copyright 2010
+ * Coolstream Internation Limited
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <version.h>
+#include <asm/arch/nevis.h>
+#include <asm/arch/sys_proto.h>
+#include <video_fb.h>
+
+#define VIDEO_CLK_REG			(0xE0400000 + 0x40000 + 0xA8)
+#define DRM_UNIT_OFFSET			(0x10000)
+#define DRM_UNIT(unit)			(0xe0560000 + ((unit) * DRM_UNIT_OFFSET))
+#define AFE_BASE			(0xE0540000 + 0x1000)
+#define PHYSICAL_ADDRESS(a)		(a)
+#define ALIGN_16(a) 			((unsigned long)((((unsigned long)(a)) + 15) & ~(16-1)))
+
+extern u32 get_board_rev(void);
+
+typedef struct {
+	volatile u32 *reg;
+	u32 val;
+} reg_pair_t;
+
+static const u32 cx2450x_osd_coeff[] = {
+	0x00033215, 0x00022050, 0x00033214, 0x00023050,
+	0x00033204, 0x00023060, 0x00033204, 0x00023060,
+	0x000331f4, 0x00024060, 0x000331f3, 0x00024070,
+	0x000331e3, 0x00025070, 0x000331e3, 0x00025070,
+	0x000331d2, 0x00026080, 0x000331d2, 0x00026080,
+	0x000331c2, 0x00026090, 0x000321c2, 0x00027090,
+	0x000321b2, 0x00028090, 0x000321b1, 0x000280a0,
+	0x000321a2, 0x000280a0, 0x00032191, 0x0002a0a0,
+	0x00032191, 0x000290b0, 0x00032191, 0x000290b0,
+	0x00031181, 0x0002a0c0, 0x00031181, 0x0002a0c0,
+	0x00031170, 0x0002b0d0, 0x00031170, 0x0002b0d0,
+	0x00031160, 0x0002b0e0, 0x00030160, 0x0002c0e0,
+	0x00030150, 0x0002c0f0, 0x00030150, 0x0002c0f0,
+	0x00030140, 0x0002d0f0, 0x0002f140, 0x0002d100,
+	0x0002f130, 0x0002e100, 0x0002f120, 0x0002e110,
+	0x0002f120, 0x0002e110, 0x0002e120, 0x0002e120,
+	0x0002e110, 0x0002f120, 0x0002e110, 0x0002f120,
+	0x0002e100, 0x0002f130, 0x0002d100, 0x0002f140,
+	0x0002d0f0, 0x00030140, 0x0002c0f0, 0x00030150,
+	0x0002c0f0, 0x00030150, 0x0002c0e0, 0x00030160,
+	0x0002b0e0, 0x00031160, 0x0002b0d0, 0x00031170,
+	0x0002b0d0, 0x00031170, 0x0002a0c0, 0x00031181,
+	0x0002a0c0, 0x00031181, 0x000290b0, 0x00032191,
+	0x000290b0, 0x00032191, 0x000290a0, 0x00033191,
+	0x000280a0, 0x000321a2, 0x000280a0, 0x000321b1,
+	0x00028090, 0x000321b2, 0x00027090, 0x000321c2,
+	0x00026090, 0x000331c2, 0x00026080, 0x000331d2,
+	0x00026080, 0x000331d2, 0x00025070, 0x000331e3,
+	0x00025070, 0x000331e3, 0x00024070, 0x000331f3,
+	0x00024060, 0x000331f4, 0x00023060, 0x00033204,
+	0x00023060, 0x00033204, 0x00022050, 0x00034214,
+	0x00022050, 0x00033215, 0x00022050, 0x00032225,
+
+	0x000401f0, 0x00021000, 0x000401e0, 0x00022000,
+	0x000401e0, 0x00022000, 0x000401d0, 0x00023000,
+	0x000401c0, 0x00024000, 0x000401b0, 0x00025000,
+	0x000401b0, 0x00025000, 0x0003f1a0, 0x00026010,
+	0x0003f190, 0x00027010, 0x0003f180, 0x00028010,
+	0x0003f170, 0x00029010, 0x0003f170, 0x00029010,
+	0x0003e160, 0x0002a020, 0x0003e150, 0x0002b020,
+	0x0003e140, 0x0002c020, 0x0003e140, 0x0002c020,
+	0x0003d130, 0x0002d030, 0x0003d120, 0x0002e030,
+	0x0003d120, 0x0002e030, 0x0003c110, 0x0002f040,
+	0x0003c100, 0x00030040, 0x0003b100, 0x00030050,
+	0x0003b0f0, 0x00031050, 0x0003b0e0, 0x00032050,
+	0x0003a0e0, 0x00032060, 0x0003a0d0, 0x00033060,
+	0x000390c0, 0x00034070, 0x000390c0, 0x00034070,
+	0x000380b0, 0x00035080, 0x000380b0, 0x00035080,
+	0x000370a0, 0x00036090, 0x00037090, 0x00037090,
+	0x00036090, 0x000370a0, 0x00035080, 0x000380b0,
+	0x00035080, 0x000380b0, 0x00034070, 0x000390c0,
+	0x00034070, 0x000390c0, 0x00033060, 0x0003a0d0,
+	0x00032060, 0x0003a0e0, 0x00032050, 0x0003b0e0,
+	0x00031050, 0x0003b0f0, 0x00030050, 0x0003b100,
+	0x00030040, 0x0003c100, 0x0002f040, 0x0003c110,
+	0x0002e030, 0x0003d120, 0x0002e030, 0x0003d120,
+	0x0002d030, 0x0003d130, 0x0002c020, 0x0003e140,
+	0x0002c020, 0x0003e140, 0x0002b020, 0x0003e150,
+	0x0002a020, 0x0003e160, 0x00029010, 0x0003f170,
+	0x00029010, 0x0003f170, 0x00028010, 0x0003f180,
+	0x00027010, 0x0003f190, 0x00026010, 0x0003f1a0,
+	0x00025000, 0x000401b0, 0x00025000, 0x000401b0,
+	0x00024000, 0x000401c0, 0x00023000, 0x000401d0,
+	0x00022000, 0x000401e0, 0x00022000, 0x000401e0,
+	0x00021000, 0x000401f0, 0x00020000, 0x00040200,
+
+	0x0004c190, 0x0001b000, 0x0004c180, 0x0001c000,
+	0x0004c170, 0x0001d000, 0x0004b160, 0x0001f000,
+	0x0004b150, 0x00020000, 0x0004b140, 0x00021000,
+	0x0004b130, 0x00022000, 0x0004b120, 0x00023000,
+	0x0004b110, 0x00024000, 0x0004b100, 0x00025000,
+	0x0004a0f0, 0x00027000, 0x0004a0e0, 0x00028000,
+	0x000490e0, 0x00029000, 0x000490d0, 0x0002a000,
+	0x000490c0, 0x0002b000, 0x000490b0, 0x0002c000,
+	0x000480a0, 0x0002e000, 0x000470a0, 0x0002f000,
+	0x00047090, 0x00030000, 0x00047080, 0x00031000,
+	0x00046080, 0x00032000, 0x00046070, 0x00033000,
+	0x00045060, 0x00035000, 0x00044060, 0x00036000,
+	0x00044050, 0x00037000, 0x00043050, 0x00038000,
+	0x00042040, 0x00039010, 0x00041040, 0x0003a010,
+	0x00041030, 0x0003b010, 0x00040030, 0x0003c010,
+	0x0003f020, 0x0003d020, 0x0003e020, 0x0003e020,
+	0x0003d020, 0x0003f020, 0x0003c010, 0x00040030,
+	0x0003b010, 0x00041030, 0x0003a010, 0x00041040,
+	0x00039010, 0x00042040, 0x00038000, 0x00043050,
+	0x00037000, 0x00044050, 0x00036000, 0x00044060,
+	0x00035000, 0x00045060, 0x00033000, 0x00046070,
+	0x00032000, 0x00046080, 0x00031000, 0x00047080,
+	0x00030000, 0x00047090, 0x0002f000, 0x000470a0,
+	0x0002d000, 0x000490a0, 0x0002c000, 0x000490b0,
+	0x0002b000, 0x000490c0, 0x0002a000, 0x000490d0,
+	0x00029000, 0x000490e0, 0x00028000, 0x0004a0e0,
+	0x00027000, 0x0004a0f0, 0x00025000, 0x0004b100,
+	0x00024000, 0x0004b110, 0x00023000, 0x0004b120,
+	0x00022000, 0x0004b130, 0x00021000, 0x0004b140,
+	0x00020000, 0x0004b150, 0x0001e000, 0x0004c160,
+	0x0001d000, 0x0004c170, 0x0001c000, 0x0004c180,
+	0x0001b000, 0x0004c190, 0x0001a000, 0x0004c1a0,
+
+	0x0005b110, 0x00014000, 0x0005b100, 0x00015000,
+	0x0005a0f0, 0x00017000, 0x0005a0e0, 0x00018000,
+	0x0005a0d0, 0x00019000, 0x000590c0, 0x0001b000,
+	0x000590b0, 0x0001c000, 0x000590a0, 0x0001d000,
+	0x00058090, 0x0001f000, 0x00058080, 0x00020000,
+	0x00057070, 0x00022000, 0x00056060, 0x00024000,
+	0x00056050, 0x00025000, 0x00055050, 0x00026000,
+	0x00054040, 0x00028000, 0x00053040, 0x00029000,
+	0x00052030, 0x0002b000, 0x00051020, 0x0002d000,
+	0x00050020, 0x0002e000, 0x0004f020, 0x0002f000,
+	0x0004e010, 0x00031000, 0x0004d010, 0x00032000,
+	0x0004c000, 0x00034000, 0x0004b000, 0x00035000,
+	0x00049000, 0x00037000, 0x00048000, 0x00038000,
+	0x00047000, 0x00039000, 0x00045000, 0x0003b000,
+	0x00044000, 0x0003c000, 0x00043000, 0x0003d000,
+	0x00041000, 0x0003f000, 0x00040000, 0x00040000,
+	0x0003f000, 0x00041000, 0x0003d000, 0x00043000,
+	0x0003c000, 0x00044000, 0x0003b000, 0x00045000,
+	0x00039000, 0x00047000, 0x00038000, 0x00048000,
+	0x00037000, 0x00049000, 0x00035000, 0x0004b000,
+	0x00034000, 0x0004c000, 0x00032000, 0x0004d010,
+	0x00031000, 0x0004e010, 0x0002f000, 0x0004f020,
+	0x0002e000, 0x00050020, 0x0002d000, 0x00051020,
+	0x0002b000, 0x00052030, 0x00029000, 0x00053040,
+	0x00028000, 0x00054040, 0x00026000, 0x00055050,
+	0x00025000, 0x00056050, 0x00024000, 0x00056060,
+	0x00022000, 0x00057070, 0x00020000, 0x00058080,
+	0x0001f000, 0x00058090, 0x0001d000, 0x000590a0,
+	0x0001c000, 0x000590b0, 0x0001b000, 0x000590c0,
+	0x00019000, 0x0005a0d0, 0x00018000, 0x0005a0e0,
+	0x00017000, 0x0005a0f0, 0x00015000, 0x0005b100,
+	0x00014000, 0x0005b110, 0x00013000, 0x0005a130,
+
+	0x0006b090, 0x0000c000, 0x0006b080, 0x0000d000,
+	0x0006b070, 0x0000e000, 0x0006a060, 0x00010000,
+	0x0006a050, 0x00011000, 0x00069040, 0x00013000,
+	0x00069030, 0x00014000, 0x00067030, 0x00016000,
+	0x00067020, 0x00017000, 0x00065020, 0x00019000,
+	0x00064010, 0x0001b000, 0x00063010, 0x0001c000,
+	0x00062000, 0x0001e000, 0x00060000, 0x00020000,
+	0x0005e000, 0x00022000, 0x0005d000, 0x00023000,
+	0x0005b000, 0x00025000, 0x00059000, 0x00027000,
+	0x00057000, 0x00029000, 0x00056000, 0x0002a000,
+	0x00054000, 0x0002c000, 0x00052000, 0x0002e000,
+	0x00050000, 0x00030000, 0x0004f000, 0x00031000,
+	0x0004d000, 0x00033000, 0x0004b000, 0x00035000,
+	0x00049000, 0x00037000, 0x00047000, 0x00039000,
+	0x00045000, 0x0003b000, 0x00044000, 0x0003c000,
+	0x00042000, 0x0003e000, 0x00040000, 0x00040000,
+	0x0003e000, 0x00042000, 0x0003c000, 0x00044000,
+	0x0003b000, 0x00045000, 0x00039000, 0x00047000,
+	0x00037000, 0x00049000, 0x00035000, 0x0004b000,
+	0x00033000, 0x0004d000, 0x00031000, 0x0004f000,
+	0x00030000, 0x00050000, 0x0002e000, 0x00052000,
+	0x0002c000, 0x00054000, 0x0002a000, 0x00056000,
+	0x00029000, 0x00057000, 0x00027000, 0x00059000,
+	0x00025000, 0x0005b000, 0x00023000, 0x0005d000,
+	0x00022000, 0x0005e000, 0x00020000, 0x00060000,
+	0x0001e000, 0x00062000, 0x0001c000, 0x00063010,
+	0x0001b000, 0x00064010, 0x00019000, 0x00065020,
+	0x00018000, 0x00066020, 0x00016000, 0x00067030,
+	0x00014000, 0x00069030, 0x00013000, 0x00069040,
+	0x00011000, 0x0006a050, 0x00010000, 0x0006a060,
+	0x0000e000, 0x0006b070, 0x0000d000, 0x0006b080,
+	0x0000c000, 0x0006b090, 0x0000a000, 0x0006c0a0,
+
+	0x0007a020, 0x00004000, 0x0007a010, 0x00005000,
+	0x00079010, 0x00006000, 0x00078010, 0x00007000,
+	0x00077000, 0x00009000, 0x00076000, 0x0000a000,
+	0x00075000, 0x0000b000, 0x00073000, 0x0000d000,
+	0x00072000, 0x0000e000, 0x00070000, 0x00010000,
+	0x0006e000, 0x00012000, 0x0006c000, 0x00014000,
+	0x0006b000, 0x00015000, 0x00069000, 0x00017000,
+	0x00067000, 0x00019000, 0x00065000, 0x0001b000,
+	0x00063000, 0x0001d000, 0x00061000, 0x0001f000,
+	0x0005e000, 0x00022000, 0x0005c000, 0x00024000,
+	0x0005a000, 0x00026000, 0x00058000, 0x00028000,
+	0x00055000, 0x0002b000, 0x00053000, 0x0002d000,
+	0x00051000, 0x0002f000, 0x0004e000, 0x00032000,
+	0x0004c000, 0x00034000, 0x0004a000, 0x00036000,
+	0x00047000, 0x00039000, 0x00045000, 0x0003b000,
+	0x00042000, 0x0003e000, 0x00040000, 0x00040000,
+	0x0003e000, 0x00042000, 0x0003b000, 0x00045000,
+	0x00039000, 0x00047000, 0x00036000, 0x0004a000,
+	0x00034000, 0x0004c000, 0x00032000, 0x0004e000,
+	0x0002f000, 0x00051000, 0x0002d000, 0x00053000,
+	0x0002b000, 0x00055000, 0x00028000, 0x00058000,
+	0x00026000, 0x0005a000, 0x00024000, 0x0005c000,
+	0x00022000, 0x0005e000, 0x0001f000, 0x00061000,
+	0x0001d000, 0x00063000, 0x0001b000, 0x00065000,
+	0x00019000, 0x00067000, 0x00017000, 0x00069000,
+	0x00015000, 0x0006b000, 0x00014000, 0x0006c000,
+	0x00012000, 0x0006e000, 0x00010000, 0x00070000,
+	0x0000e000, 0x00072000, 0x0000d000, 0x00073000,
+	0x0000b000, 0x00075000, 0x0000a000, 0x00076000,
+	0x00009000, 0x00077000, 0x00007000, 0x00078010,
+	0x00006000, 0x00079010, 0x00005000, 0x0007a010,
+	0x00004000, 0x0007a020, 0x00003000, 0x0007a030,
+};
+
+static const reg_pair_t video_clock_pal[] = {
+	{ (volatile u32 *)VIDEO_CLK_REG, 0x00000001 }, /* SD Interlaced(27MHz), Chan0, Chan1: MPG0 PLL */ 
+	{ (volatile u32 *)0xffffffff   , 0xffffffff },
+};
+
+static const reg_pair_t denc_pal_settings[] = {
+	/* PAL settings */
+	{ (volatile u32 *)0xe05d0114, 0x00001108 },
+	{ (volatile u32 *)0xe05d0118, 0x007f9551 },
+	{ (volatile u32 *)0xe05d011c, 0x00808080 },
+	{ (volatile u32 *)0xe05d0120, 0x00906680 },
+	{ (volatile u32 *)0xe05d0124, 0x0085f056 },
+	{ (volatile u32 *)0xe05d0128, 0x00a48ec8 },
+	{ (volatile u32 *)0xe05d012c, 0x00a4f000 },
+	{ (volatile u32 *)0xe05d0130, 0x2a098acb },
+	{ (volatile u32 *)0xe05d0134, 0x00000000 },
+	{ (volatile u32 *)0xe05d0138, 0x05a3049f },
+	{ (volatile u32 *)0xe05d013c, 0x05a3049f },
+	{ (volatile u32 *)0xe05d0140, 0x00000000 },
+	{ (volatile u32 *)0xe05d0144, 0x7f00007f },
+	{ (volatile u32 *)0xffffffff, 0xffffffff },
+};
+
+static const reg_pair_t denc_regs[] = {
+	{ (volatile u32 *)0xe05d0000, 0x00000001 },
+	{ (volatile u32 *)0xe05d0004, 0x00100000 },
+	{ (volatile u32 *)0xe05d0008, 0x00000100 }, // DRM0-> SD Enc
+	{ (volatile u32 *)0xe05d000c, 0x0000027f },
+	{ (volatile u32 *)0xe05d001c, 0x00000003 },
+
+	/* MAIN Raster registers */
+	{ (volatile u32 *)0xe05d0100, 0x00000001 },
+	{ (volatile u32 *)0xe05d0104, 0x80000161 | (0 << 9) },
+	{ (volatile u32 *)0xe05d0108, 0x000006c0 },
+	{ (volatile u32 *)0xe05d010c, 0x05a00116 },
+	{ (volatile u32 *)0xe05d0110, 0x01200016 },
+
+	/* AUX Raster registers */
+	{ (volatile u32 *)0xe05d0504, 0x80000161 | (0 << 9) },
+	{ (volatile u32 *)0xe05d0508, 0x000006c0 },
+	{ (volatile u32 *)0xe05d050c, 0x05a00116 },
+	{ (volatile u32 *)0xe05d0510, 0x01200016 },
+
+//	{ (volatile u32 *)0xe05d0100, 0x00000001 },
+	{ (volatile u32 *)0xe05d0200, 0x00000000 },
+#if 0
+	{ (volatile u32 *)0xe05d0148, 0x098c014a },
+	{ (volatile u32 *)0xe05d014c, 0x00008080 },
+	{ (volatile u32 *)0xe05d0150, 0x00008080 },
+	{ (volatile u32 *)0xe05d0154, 0x00440000 },
+	{ (volatile u32 *)0xe05d0158, 0x00000000 },
+	{ (volatile u32 *)0xe05d015c, 0x00070139 },
+	{ (volatile u32 *)0xe05d0160, 0x00000000 },
+	{ (volatile u32 *)0xe05d0164, 0x00000000 },
+	{ (volatile u32 *)0xe05d0168, 0x80000000 },
+	{ (volatile u32 *)0xe05d016c, 0x00000110 },
+	{ (volatile u32 *)0xe05d0170, 0x0000011e },
+#endif
+#if 0
+	{ (volatile u32 *)0xe05d0174, 0x00000000 },
+	{ (volatile u32 *)0xe05d0178, 0x00000000 },
+	{ (volatile u32 *)0xe05d017c, 0x00000000 },
+	{ (volatile u32 *)0xe05d0180, 0x029d3001 },
+	{ (volatile u32 *)0xe05d0184, 0x0000020d },
+#endif
+	{ (volatile u32 *)0xffffffff, 0xffffffff },
+};
+
+static const reg_pair_t drm0_regs[] = {
+	{ (volatile u32 *)0xe0560000, 0x00100000 },
+	{ (volatile u32 *)0xe056000c, 0x00808000 },
+
+	{ (volatile u32 *)0xe056002c, 0x00000000 },
+	{ (volatile u32 *)0xe0560030, 0x00000000 },
+	{ (volatile u32 *)0xe0560034, 0x00000000 },
+	{ (volatile u32 *)0xe0560038, 0x03030000 },
+	{ (volatile u32 *)0xe056003c, 0x00000000 },
+	{ (volatile u32 *)0xe0560040, 0x00000000 },
+	{ (volatile u32 *)0xe0560044, 0x00000000 },
+	{ (volatile u32 *)0xe0560048, 0x00000000 },
+	{ (volatile u32 *)0xe056004c, 0x00000000 },
+	{ (volatile u32 *)0xe0560050, 0x0000ffff },
+	{ (volatile u32 *)0xe0560054, 0x07203010 }, //0x07203010 
+	{ (volatile u32 *)0xe0560058, 0x00000000 },
+	{ (volatile u32 *)0xe056005c, 0x00000000 },
+	{ (volatile u32 *)0xe0560060, 0x00000000 },
+	{ (volatile u32 *)0xe0560064, 0x00000000 },
+	{ (volatile u32 *)0xe0560068, 0x23000000 },
+	{ (volatile u32 *)0xe056006c, 0x00000000 },
+	{ (volatile u32 *)0xe0560070, 0x00000000 },
+	{ (volatile u32 *)0xe0560074, 0x00000000 },
+	{ (volatile u32 *)0xe0560078, 0x00000000 },
+	{ (volatile u32 *)0xe056007c, 0x00000000 },
+	{ (volatile u32 *)0xe0560084, 0x43430000 },
+	{ (volatile u32 *)0xe05600a0, 0x00000000 },
+	{ (volatile u32 *)0xe05600a4, 0x00000000 },
+	{ (volatile u32 *)0xe05600a8, 0x83410000 },
+	{ (volatile u32 *)0xe05600ac, 0x00000000 },
+	{ (volatile u32 *)0xe05600b0, 0x00000000 },
+	{ (volatile u32 *)0xe05600f0, 0x00000000 },
+	{ (volatile u32 *)0xe05600f4, 0x007f01bd },
+	{ (volatile u32 *)0xe05600f8, 0x00000000 },
+	{ (volatile u32 *)0xffffffff, 0xffffffff },
+};
+
+
+static const reg_pair_t hdmi_regs[] = {
+	{ (volatile u32 *)0xe0541018, 0x00000055 },
+	{ (volatile u32 *)0xe0541040, 0x000001bf },
+	{ (volatile u32 *)0xe0541044, 0x0000001f },
+	{ (volatile u32 *)0xe0541048, 0x0000001f },
+	{ (volatile u32 *)0xe054104c, 0x0000001f },
+	{ (volatile u32 *)0xe0541050, 0x0000001f },
+	{ (volatile u32 *)0xe0541054, 0x00000000 },
+	{ (volatile u32 *)0xe0541058, 0x00000000 },
+	{ (volatile u32 *)0xe054105c, 0x57000004 },
+	{ (volatile u32 *)0xe0541060, 0x00000003 },
+	{ (volatile u32 *)0xe0541064, 0x00000000 },
+	{ (volatile u32 *)0xffffffff, 0xffffffff },
+};
+
+struct cx2450x_fb_osd_header {
+	unsigned int next_osd_ptr;
+	unsigned int x_display_start_width;
+	unsigned int image_height_width;
+	unsigned int display_data_addr;
+	unsigned int line_stride_bits;
+	unsigned int y_pos_rgn_alpha;
+	unsigned int scale_factors;
+	unsigned int palette_addr;
+	unsigned int chroma_min_val;
+	unsigned int chroma_max_val;
+};
+
+struct cx2450x_fb_color_system_descr {
+	const char *name;
+	int resX, resY;
+	unsigned short startX, startY, activeX;
+	unsigned short offsetX, offsetY;
+	int interlaced;
+	int nr_drm;
+
+	const reg_pair_t *video_clock;
+	const reg_pair_t *denc_system;
+	const reg_pair_t *denc;
+	const reg_pair_t *drm0;
+	const reg_pair_t *drm1;
+	const reg_pair_t *hdmi;
+};
+
+static struct cx2450x_fb_data {
+	volatile struct cx2450x_fb_osd_header *osd_header;
+	volatile unsigned int *palette;
+	volatile unsigned int *fb;
+	int system_idx;
+} fb_data;
+
+static const struct cx2450x_fb_color_system_descr cx2450x_output_system_descr[] = {
+	{
+		.name		= "PAL-BG 576i@50Hz",
+		.resX		= 720,
+		.resY		= 576,
+		.startX		= 0x116, /* startX * (1/54000000) */
+		.startY		= 0x2b,
+		.activeX	= 703,
+		.offsetX	= 40,
+		.offsetY	= 20,
+		.video_clock	= video_clock_pal,
+		.denc_system	= denc_pal_settings,
+		.denc		= denc_regs,
+		.drm0		= drm0_regs,
+		.hdmi		= hdmi_regs,
+
+		.nr_drm		= 1,
+		.interlaced	= 1,
+	},
+};
+
+#define CX2450X_VIDEO_PAL_INDEX		0
+
+static GraphicDevice cx2450x_fb;
+
+static void cx2450x_fb_set_register(volatile u32 *reg, u32 mask, u32 val)
+{
+	*reg = (*reg & ~mask) | (val & mask);
+}
+
+#if 0
+static u32 cx2450x_fb_get_register(volatile u32 *reg, u32 mask)
+{
+	return *reg & ~mask;
+}
+
+static void cx2450x_fb_set_registers(const reg_set_t *regs, int size)
+{
+	int i;
+
+	for (i = 0; i < size; i++)
+		cx2450x_fb_set_register(regs[i].reg, regs[i].mask, regs[i].val);
+}
+#endif
+
+static void cx2450x_fb_set_register_pair(const reg_pair_t *regs)
+{
+	int i = 0;
+
+	while((regs[i].reg != (volatile u32 *)0xFFFFFFFF) && (regs[i].val != 0xFFFFFFFF)) {
+		cx2450x_fb_set_register(regs[i].reg, 0xFFFFFFFF, regs[i].val);
+		i++;
+	}
+}
+
+void draw_rect_32 (u32 *fb, u32 line_length, int x1, int y1, int x2, int y2, u32 pixel)
+{
+	int count;
+
+	while( y1 < y2) {
+		for(count = x1 ; count < x2 ; count++ ) {
+			*((u32 *) fb + line_length/4 * y1 + count ) = (u_int32_t)pixel;
+		}
+		y1++;
+	}
+}
+
+static inline unsigned short cx2450x_fb_get_scale_x(unsigned short srcX, unsigned short dstX)
+{
+	int scale_x = -1;
+
+	if (srcX <= (dstX << 1))
+		scale_x = ((srcX - 1) << 14) / (dstX - 1); /* Axis starts at 0 */
+
+	return scale_x;
+}
+
+static inline unsigned short cx2450x_fb_get_scale_y(unsigned short srcY, unsigned short dstY)
+{
+	int scale_y = -1;
+
+	if (dstY >= srcY)
+		scale_y = ((srcY - 1) << 14) / (dstY - 1); /* Axis starts at 0 */
+
+	return scale_y;
+}
+
+static inline int cx2450x_fb_get_scale_index_coeff(unsigned short scale_x)
+{
+	int index;
+
+	index = (((90 * 0x4000) / scale_x) - 35) / 10; /* 0x4000 == 2^14 */
+
+	if(index < 0)
+		index = 0;
+	if(index > 5)
+		index = 5;
+
+	return index;
+}
+
+static void cx2450x_fb_setup_osd_coeff(int unit, int index)
+{
+	volatile u32 *reg_base = (volatile u32 *)(DRM_UNIT(unit) + 0x1000);
+	int i, j, k;
+
+	if(unit > 1)
+		return;
+	if((index < 0) || (index > 5))
+		return;
+
+	j = (index * 128);
+	k = 0;
+
+	/* Setup 64 phases */
+	for (i = 0; i < 64; i++) {
+		cx2450x_fb_set_register(reg_base + k++, 0xFFFFFFFF, cx2450x_osd_coeff[j++]);
+		cx2450x_fb_set_register(reg_base + k++, 0xFFFFFFFF, cx2450x_osd_coeff[j++]);
+	}
+	cx2450x_fb_set_register((volatile u32 *)(DRM_UNIT(unit) + 0x88), 0x0000007F, 0x30);
+}
+
+static void cx2450x_fb_setup_active_screen(int unit, const struct cx2450x_fb_color_system_descr *sys_descr)
+{
+	volatile u32 *act_scr_x = (volatile u32 *)(DRM_UNIT(unit) + 0x4);
+	volatile u32 *act_scr_y = (volatile u32 *)(DRM_UNIT(unit) + 0x8);
+	int x_active_start, x_active_end;
+	int y_active_start, y_active_end;
+
+	/* Pixel CLK Start / End */
+	x_active_start	= sys_descr->startX;
+	x_active_end	= x_active_start + ((sys_descr->activeX << 1) - 1);
+
+	/* Line Start / End */
+	y_active_start	= sys_descr->startY;
+	y_active_end	= y_active_start + (sys_descr->resY - 1);
+
+	/* Update the settings */
+	*act_scr_x	= (x_active_end << 16) | x_active_start;
+	*act_scr_y	= (y_active_end << 16) | y_active_start;
+}
+
+static void cx2450x_fb_setup_encoder(const struct cx2450x_fb_color_system_descr *sys_descr)
+{
+	volatile u32 *dac0 = (volatile u32 *)0xe05d0010;
+	volatile u32 *dac1 = (volatile u32 *)0xe05d0014;
+	volatile u32 *dac2 = (volatile u32 *)0xe05d0018;
+	u32 rev = get_board_rev();
+
+	if (rev >= 7) {
+		volatile u32 *bypass = (volatile u32 *)(AFE_BASE + 0x04);
+
+		/* Disable RFmod mode */
+		*bypass = (*bypass & ~0x300000) | 0x100000;
+		*dac0	= 0x090708; /* Ypr, Y, Ypb */
+		*dac1	= 0x0C0B0A; /* R, G, B */
+		*dac2	= 0x1f1f0D;
+	} else {
+		*dac0	= 0x080907;
+		*dac1	= 0x1f1f0D;
+	}
+
+	/* Initialize all needed registers */
+	cx2450x_fb_set_register_pair(sys_descr->video_clock);
+	cx2450x_fb_set_register_pair(sys_descr->denc_system);
+	cx2450x_fb_set_register_pair(sys_descr->denc);
+	cx2450x_fb_set_register_pair(sys_descr->hdmi);
+
+	/* Disable MV! */
+	cx2450x_fb_set_register((volatile u32 *)0xE05D0194, 0xFF000000, 0);
+	cx2450x_fb_set_register((volatile u32 *)0xE05D0294, 0xFF000000, 0);
+}
+
+static int cx2450x_fb_setup_osd(int unit, const struct cx2450x_fb_color_system_descr *sys_descr, int bpp, int srcW, int srcH)
+{
+	volatile u32 *osd_hdr = (volatile u32 *)(DRM_UNIT(unit) + 0x80);
+	volatile struct cx2450x_fb_osd_header *header = fb_data.osd_header;
+	int scaleX, scaleY;
+	int coeff_index;
+	int dstW, dstH;
+	int startX, startY;
+	int offsetX, offsetY;
+	int endX, endY;
+	int stride = 4;
+	u8 pixmode;
+
+	if (!fb_data.osd_header)
+		return -1;
+	if (!fb_data.palette)
+		return -1;
+	if (!fb_data.fb)
+		return -1;
+	if (unit > 1)
+		return -1;
+
+	switch(bpp) {
+	case GDF_32BIT_X888RGB:
+		pixmode	= 0x13;
+		stride	= 4;
+		break;
+		/* TODO: add more pixel modes? */
+	default:
+		printf("Invalid pixel mode\n");
+		return -1;
+	}
+
+	offsetX = (sys_descr->offsetX + 7) & ~7; /* align it to dword boundary */
+	if (offsetX < 0)
+		offsetX = 0;
+
+	offsetY = sys_descr->offsetY;
+	if (offsetY < 0)
+		offsetY = 0;
+
+	dstW	= sys_descr->resX - offsetX;
+	dstH	= sys_descr->resY - offsetY;
+
+	if ((scaleX = cx2450x_fb_get_scale_x(srcW, dstW)) < 0)
+		return -1;
+	if ((scaleY = cx2450x_fb_get_scale_y(srcH, dstH)) < 0)
+		return -1;
+	/*
+	 * Calculate the coordinates for Line and pixel counter
+	 * Note: we assume we always draw at offset 0, horizontally
+	 *	 and vertically
+	 */
+
+	startX	= sys_descr->startX + (offsetX << 1);
+	endX	= dstW; /* just the display width in pixels */
+	startY	= sys_descr->startY + offsetY;
+	endY	= startY + (dstH - 1);
+
+	/* Clear the osd header. this should disable the plane */
+	cx2450x_fb_set_register(osd_hdr, 0xFFFFFFFF, (u32) 0);
+	/* Setup the active screen in DRM */
+	cx2450x_fb_setup_active_screen(unit, sys_descr);
+	/* Init the DRM module */
+	cx2450x_fb_set_register_pair(unit == 0 ? sys_descr->drm0 : sys_descr->drm1);
+	/* Calculate the scaling coefficient index for Horizontal scaling */
+	coeff_index = cx2450x_fb_get_scale_index_coeff(scaleX);
+	/* Set the coefficients */
+	cx2450x_fb_setup_osd_coeff(unit, coeff_index);
+
+
+	header->next_osd_ptr		= 0; /* NO next OSD window */
+	header->x_display_start_width	= (2 << 30) | (endX << 16) | (2 << 14) | (startX << 0); /* Alpha blender1 input plane 0 = OSD, Alpha blender1 input plane 1 = OSD, 720 width, start 0 */
+	header->image_height_width	= (2 << 29) | (1 << 28) | (srcH << 16) | (1 << 15) | (0 << 14) | (0 << 13) | (0 << 11) | (srcW << 0);
+	header->display_data_addr	= (u32)PHYSICAL_ADDRESS((void *)fb_data.fb);
+	header->line_stride_bits	= (1 << 29) | (2 << 25) | (1 << 23) | (pixmode << 16) | ((srcW * stride) << 0); /* Use region alpha to support 32 bit pixels without alpha value */
+	header->y_pos_rgn_alpha		= (0xFF << 24) | (endY << 12) | (startY << 0);
+	header->scale_factors		= (scaleY << 16) | scaleX; /* YScale, XScale*/
+	header->palette_addr		= (u32)PHYSICAL_ADDRESS((void *)fb_data.palette);
+	header->chroma_min_val		= 0;
+	header->chroma_max_val		= 0;
+
+	/* set the osd header pointer */
+	cx2450x_fb_set_register(osd_hdr, 0xFFFFFFFF, (u32) PHYSICAL_ADDRESS((void *)header));
+
+	return 0;
+}
+
+void *video_hw_init(void)
+{
+	GraphicDevice *pGd = &cx2450x_fb;
+	int i;
+	unsigned int *osd_palette, *image;
+	volatile struct cx2450x_fb_osd_header *osd_header;
+	int image_size;
+	int system_idx;
+
+	pGd->winSizeX	= board_get_width();
+	pGd->winSizeY	= board_get_height();
+	pGd->gdfIndex	= GDF_32BIT_X888RGB;
+	pGd->gdfBytesPP = 4;
+
+	image_size = 	pGd->winSizeX *
+			pGd->winSizeY *
+			pGd->gdfBytesPP;
+
+	/*
+	 * Start allocating framebuffer, osd header and palette,
+	 * We do this at 1MB offset from PHYS_RAM_START. We dont use
+	 * the MMU so we're dealing with physical memory addresses.
+	 * If we want this picture to remain during linux kernel boot, we
+	 * need to reserve this area as 'bootmem'.
+	 */
+	osd_header	= (volatile struct cx2450x_fb_osd_header *)0x100000; /* 1MB */
+	image		= (unsigned int *) ALIGN_16(0x100000 + sizeof(struct cx2450x_fb_osd_header));
+	osd_palette	= (unsigned int *) ALIGN_16(0x100000 + sizeof(struct cx2450x_fb_osd_header) + image_size);
+	pGd->frameAdrs	= (unsigned long) image;
+
+	/* Generate LUT */
+	for (i = 0; i < 256; i++)
+		osd_palette[i] = (i << 24) | (i << 16) | (i << 8) | i;
+
+	/* Clear the image */
+	memset(image, 0, image_size);
+
+	system_idx		= CX2450X_VIDEO_PAL_INDEX;
+	fb_data.osd_header	= osd_header;
+	fb_data.palette		= osd_palette;
+	fb_data.fb		= image;
+	fb_data.system_idx	= system_idx;
+
+	/* Setup the video encoder */
+	cx2450x_fb_setup_encoder(&cx2450x_output_system_descr[system_idx]);
+	/* TVEnc is setup to use DRM0 for SD and HD */
+	if (cx2450x_fb_setup_osd(0, &cx2450x_output_system_descr[system_idx],
+				pGd->gdfIndex,
+				pGd->winSizeX,
+				pGd->winSizeY) < 0)
+		goto error;
+
+	return pGd;
+error:
+	return NULL;
+}
+
+void video_set_lut (
+	unsigned int index,           /* color number */
+	unsigned char r,              /* red */
+	unsigned char g,              /* green */
+	unsigned char b               /* blue */
+	)
+{
+	/* nothing in here */
+}
diff --git a/board/coolstream_hdx/u-boot.lds b/board/coolstream_hdx/u-boot.lds
new file mode 100644
index 0000000..1ec08ad
--- /dev/null
+++ b/board/coolstream_hdx/u-boot.lds
@@ -0,0 +1,59 @@
+/*
+ * January 2004 - Changed to support H4 device
+ * Copyright (c) 2004 Texas Instruments
+ *
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text	   :
+	{
+	  cpu/arm1176/start.o	(.text)
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = .;
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss (NOLOAD) : { *(.bss) }
+	_end = .;
+}
diff --git a/common/cmd_bootm.c b/common/cmd_bootm.c
index 6fdeef4..1f86b7f 100644
--- a/common/cmd_bootm.c
+++ b/common/cmd_bootm.c
@@ -58,6 +58,10 @@
 #include <lzma/LzmaTools.h>
 #endif /* CONFIG_LZMA */
 
+#ifdef HAVE_COOLSTREAM_VFD_CONTROLLER
+#include <asm/arch/sys_proto.h>
+#endif
+
 DECLARE_GLOBAL_DATA_PTR;
 
 extern int gunzip (void *dst, int dstlen, unsigned char *src, unsigned long *lenp);
@@ -802,6 +806,9 @@ static void *boot_get_kernel (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]
 	*os_data = *os_len = 0;
 	switch (genimg_get_format ((void *)img_addr)) {
 	case IMAGE_FORMAT_LEGACY:
+                #ifdef HAVE_COOLSTREAM_VFD_CONTROLLER
+                display_set_text("BOOT KERNEL ");
+                #endif
 		printf ("## Booting kernel from Legacy Image at %08lx ...\n",
 				img_addr);
 		hdr = image_get_kernel (img_addr, images->verify);
@@ -838,6 +845,9 @@ static void *boot_get_kernel (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]
 		break;
 #if defined(CONFIG_FIT)
 	case IMAGE_FORMAT_FIT:
+                #ifdef HAVE_COOLSTREAM_VFD_CONTROLLER
+                display_set_text("BOOT KERNEL ");
+                #endif
 		fit_hdr = (void *)img_addr;
 		printf ("## Booting kernel from FIT Image at %08lx ...\n",
 				img_addr);
diff --git a/common/cmd_flash.c b/common/cmd_flash.c
index 510654e..cbf380f 100644
--- a/common/cmd_flash.c
+++ b/common/cmd_flash.c
@@ -696,6 +696,75 @@ int flash_sect_protect (int p, ulong addr_first, ulong addr_last)
 }
 #endif /* CONFIG_SYS_NO_FLASH */
 
+#ifdef CONFIG_SYS_FLASH_OTP
+#include <asm/arch/sys_proto.h>
+
+int do_otpdump(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+    return flash_dump_otp(&flash_info[0]);
+}
+
+int do_otpwrite(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+    uchar buffer[256];
+    ulong inpos = 0;
+    ulong outpos = 0;
+    ulong len = strlen(argv[1]);
+
+    if ((len < 2) || (len % 2))
+    {
+	printf("\nError: Invalid OTP data\n\n");
+	return 1;
+    }
+    if (len > 512)
+	len = 512;
+
+    memset(buffer, 0, 256);
+
+    while (inpos < len)
+    {
+	switch (argv[1][inpos])
+	{
+	    case 0x30 ... 0x39:	/* digit 0 ... 9 */
+		buffer[outpos] = (argv[1][inpos] - 0x30) << 4;
+		break;
+	    case 0x41 ... 0x46:	/* digit A ... F */
+		buffer[outpos] = (argv[1][inpos] - 0x37) << 4;
+		break;
+	    case 0x61 ... 0x66:	/* digit a ... f */
+		buffer[outpos] = (argv[1][inpos] - 0x57) << 4;
+		break;
+	    default:
+		puts("\nError: Invalid OTP data\n\n");
+		return 1;
+	}
+
+	inpos++;
+
+	switch (argv[1][inpos])
+	{
+	    case 0x30 ... 0x39:	/* digit 0 ... 9 */
+		buffer[outpos] |= (argv[1][inpos] - 0x30);
+		break;
+	    case 0x41 ... 0x46:	/* digit A ... F */
+		buffer[outpos] |= (argv[1][inpos] - 0x37);
+		break;
+	    case 0x61 ... 0x66:	/* digit a ... f */
+		buffer[outpos] |= (argv[1][inpos] - 0x57);
+		break;
+	    default:
+		puts("\nError: Invalid OTP data\n\n");
+		return 1;
+	}
+
+	inpos++;
+	outpos++;
+    }
+
+    return flash_write_otp(&flash_info[0], buffer, len / 2);
+}
+
+#endif /* CONFIG_SYS_FLASH_OTP */
 
 /**************************************************/
 #if defined(CONFIG_CMD_JFFS2) && defined(CONFIG_JFFS2_CMDLINE)
@@ -754,6 +823,22 @@ U_BOOT_CMD(
 	"protect off all\n    - make all FLASH banks writable\n"
 );
 
+#ifdef CONFIG_SYS_FLASH_OTP
+
+U_BOOT_CMD(
+	otpdump, 1, 1, do_otpdump,
+	"dump the content of the flash's OTP-sector",
+	"\n    - dump the content of the flash's OTP-sector\n"
+);
+
+U_BOOT_CMD(
+	otpwrite, 2, 1, do_otpwrite,
+	"write data into the flash's OTP-sector (factory only).",
+	"\n    - write data into the flash's OTP-sector (factory only).\n"
+);
+
+#endif /* CONFIG_SYS_FLASH_OTP */
+
 #undef	TMP_ERASE
 #undef	TMP_PROT_ON
 #undef	TMP_PROT_OFF
diff --git a/common/cmd_usb.c b/common/cmd_usb.c
index a18e16e..597bbb3 100644
--- a/common/cmd_usb.c
+++ b/common/cmd_usb.c
@@ -674,6 +674,135 @@ int do_usb(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 }
 
 #ifdef CONFIG_USB_STORAGE
+extern int do_protect (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
+extern int do_flerase (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
+extern int do_fat_fsload (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
+extern int do_mem_cp (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
+extern int do_reset (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
+extern void display_set_text(char *text);
+#if 0
+		kernel 0xF0080000 - 0xF0480000 size 0x00400000
+			system 0xF0480000 - 0xF2000000 size 0x01B80000
+#endif
+//#define TEST_ONLY
+int do_usbup(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	int i, n = 0;
+	extern char usb_started;
+	long size;
+	char *s;
+	char *istr[] = { "coolstream/kernel.img", "coolstream/system.img" };
+	char *iaddr[] = { "0xF0080000", "0xF0480000" };
+	char *isize[] = { "+0x400000", "+0x01B80000" };
+	char *uargv[] = { "usbup", "usb", "00", "0x0E000000", 0};
+	char *pargv[] = { "protect", "off", 0, 0 };
+	char *eargv[] = { "erase", 0, 0 };
+	char *cargv[] = { "cp.b", "0x0E000000", 0, "0xFFFFFFFF" };
+
+	cmd_tbl_t *bcmd;
+
+	usb_stor_curr_dev = -1;
+
+	usb_stop();
+	printf("(Re)start USB...\n");
+
+	display_set_text("USB update");
+	i = usb_init();
+
+	if (i >= 0)
+		usb_stor_curr_dev = usb_stor_scan(1);
+
+	if(usb_stor_curr_dev < 0) {
+		printf("No usb-storage device found..\n");
+		display_set_text("No USB dev");
+		goto _return;
+	}
+	sprintf(uargv[1], "%d", usb_stor_curr_dev);
+
+	while(n < 2) {
+		uargv[4] = istr[n];
+
+		pargv[2] = iaddr[n];
+		pargv[3] = isize[n];
+
+		eargv[1] = iaddr[n];
+		eargv[2] = isize[n];
+
+		cargv[2] = iaddr[n];
+
+		bcmd = find_cmd("fatload");
+
+		if (!bcmd) {
+			printf("** 'fatload' command not present. **\n");
+			goto _return;
+		}
+		display_set_text(&istr[n][11]);
+		i = do_fat_fsload(bcmd, 0, 5, uargv);
+		if(i) {
+			printf("** Unable to read %s **\n", istr[n]);
+			/* goto _return;*/
+			n++;
+			continue;
+		}
+		s = getenv("filesize");
+		if(s == NULL) {
+			printf("** Unable to get file size **\n");
+			goto _return;
+		}
+		size = simple_strtoul(s, NULL, 16);
+		printf("%s size %x\n", istr[n], (int) size);
+
+		bcmd = find_cmd("protect");
+		if (!bcmd) {
+			printf("** 'protect' command not present. **\n");
+			goto _return;
+		}
+
+		printf("Unprotecting %s %s\n", pargv[2], pargv[3]);
+#ifndef TEST_ONLY
+		i = do_protect(bcmd, 0, 4, pargv);
+		if(i) {
+			printf("** 'protect' command failed **\n");
+			goto _return;
+		}
+#endif
+		bcmd = find_cmd("erase");
+		if (!bcmd) {
+			printf("** 'erase' command not present. **\n");
+			goto _return;
+		}
+		printf("Erasing %s %s\n", eargv[1], eargv[2]);
+#ifndef TEST_ONLY
+		i = do_flerase(bcmd, 0, 3, eargv);
+		if(i) {
+			printf("** 'erase' command failed **\n");
+			goto _return;
+		}
+#endif
+		bcmd = find_cmd("cp");
+		if (!bcmd) {
+			printf("** 'cp' command not present. **\n");
+			goto _return;
+		}
+		sprintf(cargv[3], "0x%x", (int) size);
+		printf("Coping to %s size %s\n", cargv[2], cargv[3]);
+#ifndef TEST_ONLY
+		i = do_mem_cp(bcmd, 0, 4, cargv);
+		if(i) {
+			printf("** 'cp' command failed **\n");
+			goto _return;
+		}
+#endif
+		n++;
+	}
+	display_set_text("Reboot");
+	udelay(2000000);
+	do_reset (NULL, 0, 0, NULL);
+_return:
+	usb_stop();
+	return 0;
+}
+
 U_BOOT_CMD(
 	usb,	5,	1,	do_usb,
 	"USB sub-system",
@@ -696,6 +825,11 @@ U_BOOT_CMD(
 	"loadAddr dev:part\n"
 );
 
+U_BOOT_CMD(
+	usbup,	3,	1,	do_usbup,
+	"upgrade from USB device",
+	"usb upgrade - flash kernel/system from usb stick\n"
+);
 #else
 U_BOOT_CMD(
 	usb,	5,	1,	do_usb,
diff --git a/common/env_common.c b/common/env_common.c
index 6be3bb0..6ba0312 100644
--- a/common/env_common.c
+++ b/common/env_common.c
@@ -255,7 +255,11 @@ void env_relocate (void)
 #if defined(CONFIG_GTH)	|| defined(CONFIG_ENV_IS_NOWHERE)	/* Environment not changable */
 		puts ("Using default environment\n\n");
 #else
-		puts ("*** Warning - bad CRC, using default environment\n\n");
+#ifdef BEAUTIFY_CONSOLE
+                printf("\xBA *** Warning - bad CRC, using default environment %-27s \xBA\n", "***");
+#else
+                puts ("*** Warning - bad CRC, using default environment\n\n");
+#endif
 		show_boot_progress (-60);
 #endif
 		set_default_env();
diff --git a/common/main.c b/common/main.c
index 905d40f..fcdd828 100644
--- a/common/main.c
+++ b/common/main.c
@@ -48,7 +48,7 @@ DECLARE_GLOBAL_DATA_PTR;
  * Board-specific Platform code can reimplement show_boot_progress () if needed
  */
 void inline __show_boot_progress (int val) {}
-void inline show_boot_progress (int val) __attribute__((weak, alias("__show_boot_progress")));
+void show_boot_progress (int val) __attribute__((weak, alias("__show_boot_progress")));
 
 #if defined(CONFIG_BOOT_RETRY_TIME) && defined(CONFIG_RESET_TO_RETRY)
 extern int do_reset (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);		/* for do_reset() prototype */
@@ -210,7 +210,7 @@ static __inline__ int abortboot(int bootdelay)
 #ifdef CONFIG_MENUKEY
 static int menukey = 0;
 #endif
-
+extern int cs_fp_key;
 static __inline__ int abortboot(int bootdelay)
 {
 	int abort = 0;
@@ -227,6 +227,8 @@ static __inline__ int abortboot(int bootdelay)
 	 * Don't check if bootdelay < 0
 	 */
 	if (bootdelay >= 0) {
+		if(cs_fp_key)
+			return 1;
 		if (tstc()) {	/* we got a key press	*/
 			(void) getc();  /* consume input	*/
 			puts ("\b\b\b 0");
@@ -241,6 +243,9 @@ static __inline__ int abortboot(int bootdelay)
 		--bootdelay;
 		/* delay 100 * 10ms */
 		for (i=0; !abort && i<100; ++i) {
+			if(cs_fp_key)
+				return 1;
+
 			if (tstc()) {	/* we got a key press	*/
 				abort  = 1;	/* don't auto boot	*/
 				bootdelay = 0;	/* no more delay	*/
@@ -270,7 +275,7 @@ static __inline__ int abortboot(int bootdelay)
 #endif	/* CONFIG_BOOTDELAY >= 0  */
 
 /****************************************************************************/
-
+extern void display_set_text(char *text);
 void main_loop (void)
 {
 #ifndef CONFIG_SYS_HUSH_PARSER
@@ -397,6 +402,7 @@ void main_loop (void)
 
 	debug ("### main_loop: bootcmd=\"%s\"\n", s ? s : "<UNDEFINED>");
 
+	display_set_text("Coolstream");
 	if (bootdelay >= 0 && s && !abortboot (bootdelay)) {
 # ifdef CONFIG_AUTOBOOT_KEYED
 		int prev = disable_ctrlc(1);	/* disable Control C checking */
@@ -413,6 +419,16 @@ void main_loop (void)
 		disable_ctrlc(prev);	/* restore Control C checking */
 # endif
 	}
+	if(cs_fp_key) {
+		cmd_tbl_t *cmdtp;
+		cmdtp = find_cmd("usbup");
+		if(cmdtp) {
+			printf("\nEmergency update from usb\n");
+			udelay (500000);
+			cmdtp->cmd(cmdtp, 0, 0, NULL);
+		}
+		display_set_text("Update fail");
+	}
 
 # ifdef CONFIG_MENUKEY
 	if (menukey == CONFIG_MENUKEY) {
diff --git a/cpu/arm1176/config.mk b/cpu/arm1176/config.mk
index 5083594..2a6d115 100644
--- a/cpu/arm1176/config.mk
+++ b/cpu/arm1176/config.mk
@@ -24,7 +24,7 @@ PLATFORM_RELFLAGS += -fno-strict-aliasing  -fno-common -ffixed-r8 \
 	-msoft-float
 
 # Make ARMv5 to allow more compilers to work, even though its v6.
-PLATFORM_CPPFLAGS += -march=armv5t
+PLATFORM_CPPFLAGS += -march=armv6
 # =========================================================================
 #
 # Supply options according to compiler version
diff --git a/cpu/arm1176/cpu.c b/cpu/arm1176/cpu.c
index 1e94f7d..b9ea7d9 100644
--- a/cpu/arm1176/cpu.c
+++ b/cpu/arm1176/cpu.c
@@ -33,9 +33,12 @@
 
 #include <common.h>
 #include <command.h>
-#include <s3c6400.h>
+#include <asm/arch/nevis.h>
+#include <asm/arch/sys_proto.h>
 
-static void cache_flush (void);
+#ifdef CONFIG_USE_IRQ
+DECLARE_GLOBAL_DATA_PTR;
+#endif
 
 /* read co-processor 15, register #1 (control register) */
 static unsigned long read_p15_c1 (void)
@@ -43,10 +46,10 @@ static unsigned long read_p15_c1 (void)
 	unsigned long value;
 
 	__asm__ __volatile__(
-		"mrc	p15, 0, %0, c1, c0, 0   @ read control reg\n"
-		: "=r" (value)
-		:
-		: "memory");
+						"mrc	p15, 0, %0, c1, c0, 0   @ read control reg\n"
+						: "=r" (value)
+						:
+						: "memory");
 	return value;
 }
 
@@ -54,12 +57,12 @@ static unsigned long read_p15_c1 (void)
 static void write_p15_c1 (unsigned long value)
 {
 	__asm__ __volatile__(
-		"mcr	p15, 0, %0, c1, c0, 0   @ write it back\n"
-		:
-		: "r" (value)
-		: "memory");
+						"mcr	p15, 0, %0, c1, c0, 0   @ write it back\n"
+						:
+						: "r" (value)
+						: "memory");
 
-	read_p15_c1();
+	read_p15_c1 ();
 }
 
 static void cp_delay (void)
@@ -67,24 +70,31 @@ static void cp_delay (void)
 	volatile int i;
 
 	/* Many OMAP regs need at least 2 nops  */
-	for (i = 0; i < 100; i++)
-		__asm__ __volatile__("nop\n");
+	for (i = 0; i < 100; i++);
 }
 
 /* See also ARM Ref. Man. */
-#define C1_MMU		(1 << 0)	/* mmu off/on */
-#define C1_ALIGN	(1 << 1)	/* alignment faults off/on */
-#define C1_DC		(1 << 2)	/* dcache off/on */
-#define C1_WB		(1 << 3)	/* merging write buffer on/off */
-#define C1_BIG_ENDIAN	(1 << 7)	/* big endian off/on */
-#define C1_SYS_PROT	(1 << 8)	/* system protection */
-#define C1_ROM_PROT	(1 << 9)	/* ROM protection */
-#define C1_IC		(1 << 12)	/* icache off/on */
-#define C1_HIGH_VECTORS	(1 << 13)	/* location of vectors: low/high */
+#define C1_MMU		(1<<0)		/* mmu off/on */
+#define C1_ALIGN	(1<<1)		/* alignment faults off/on */
+#define C1_DC		(1<<2)		/* dcache off/on */
+#define C1_WB		(1<<3)		/* merging write buffer on/off */
+#define C1_BIG_ENDIAN	(1<<7)	/* big endian off/on */
+#define C1_SYS_PROT	(1<<8)		/* system protection */
+#define C1_ROM_PROT	(1<<9)		/* ROM protection */
+#define C1_IC		(1<<12)		/* icache off/on */
+#define C1_HIGH_VECTORS	(1<<13)	/* location of vectors: low/high addresses */
 #define RESERVED_1	(0xf << 3)	/* must be 111b for R/W */
 
 int cpu_init (void)
 {
+	/*
+	 * setup up stacks if necessary
+	 */
+#ifdef CONFIG_USE_IRQ
+	IRQ_STACK_START = _armboot_start - CONFIG_SYS_MALLOC_LEN - CONFIG_SYS_GBL_DATA_SIZE - 4;
+	FIQ_STACK_START = IRQ_STACK_START - CONFIG_STACKSIZE_IRQ;
+#endif
+	 
 	return 0;
 }
 
@@ -96,31 +106,35 @@ int cleanup_before_linux (void)
 	 *
 	 * we turn off caches etc ...
 	 */
-
-	disable_interrupts ();
-
+	unsigned long i;
+
+	disable_interrupts();
+	
+#ifdef CONFIG_NEVIS
+	/* silly hack to make sure we boot all kernels */
+	CleanupBeforeLinux();
+#endif
+
+#ifdef CONFIG_LCD
+	{
+		extern void lcd_disable(void);
+		extern void lcd_panel_disable(void);
+
+		lcd_disable(); /* proper disable of lcd & panel */
+		lcd_panel_disable();
+	}
+#endif
 	/* turn off I/D-cache */
-	icache_disable();
-	dcache_disable();
-	cache_flush();
-
-	return 0;
-}
+	asm ("mrc p15, 0, %0, c1, c0, 0":"=r" (i));
+	i &= ~(C1_DC | C1_IC);
+	asm ("mcr p15, 0, %0, c1, c0, 0": :"r" (i));
 
+	/* flush I/D-cache */
+	i = 0;
+	asm ("mcr p15, 0, %0, c7, c7, 0": :"r" (i));  /* invalidate both caches and flush btb */
+	asm ("mcr p15, 0, %0, c7, c10, 4": :"r" (i)); /* mem barrier to sync things */
 
-/* * reset the cpu by setting up the watchdog timer and let him time out */
-void reset_cpu (ulong ignored)
-{
-	printf("reset... \n\n\n");
-	SW_RST_REG = 0x6400;
-	/* loop forever and wait for reset to happen */
-	while (1) {
-		if (serial_tstc()) {
-			serial_getc();
-			break;
-		}
-	}
-	/*NOTREACHED*/
+	return(0);
 }
 
 int do_reset (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
@@ -128,7 +142,7 @@ int do_reset (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 	disable_interrupts ();
 	reset_cpu (0);
 	/*NOTREACHED*/
-	return 0;
+	return(0);
 }
 
 void icache_enable (void)
@@ -151,38 +165,5 @@ void icache_disable (void)
 
 int icache_status (void)
 {
-	return (read_p15_c1 () & C1_IC) != 0;
-}
-
-/* It makes no sense to use the dcache if the MMU is not enabled */
-void dcache_enable (void)
-{
-	ulong reg;
-
-	reg = read_p15_c1 ();
-	cp_delay ();
-	write_p15_c1 (reg | C1_DC);
-}
-
-void dcache_disable (void)
-{
-	ulong reg;
-
-	reg = read_p15_c1 ();
-	cp_delay ();
-	write_p15_c1 (reg & ~C1_DC);
-}
-
-int dcache_status (void)
-{
-	return (read_p15_c1 () & C1_DC) != 0;
-}
-
-/* flush I/D-cache */
-static void cache_flush (void)
-{
-	/* invalidate both caches and flush btb */
-	asm ("mcr p15, 0, %0, c7, c7, 0": :"r" (0));
-	/* mem barrier to sync things */
-	asm ("mcr p15, 0, %0, c7, c10, 4": :"r" (0));
+	return(read_p15_c1 () & C1_IC) != 0;
 }
diff --git a/cpu/arm1176/nevis/Makefile b/cpu/arm1176/nevis/Makefile
new file mode 100644
index 0000000..4ff1797
--- /dev/null
+++ b/cpu/arm1176/nevis/Makefile
@@ -0,0 +1,45 @@
+#
+# (C) Copyright 2000-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(SOC).a
+
+COBJS	= interrupts.o serial.o misc.o
+
+SRCS	:= $(START:.o=.S) $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS) $(SOBJS))
+
+all:	$(obj).depend $(START) $(LIB)
+
+$(LIB):	$(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/cpu/arm1176/nevis/interrupts.c b/cpu/arm1176/nevis/interrupts.c
new file mode 100644
index 0000000..cbae9ed
--- /dev/null
+++ b/cpu/arm1176/nevis/interrupts.c
@@ -0,0 +1,236 @@
+/*
+ * ITC and timer routines for CX2450x/ARM11 SoC
+ *
+ * (C) Copyright 2008
+ * Coolstream International Limited
+ *
+ * Timer code derived from:
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ * Alex Zuepke <azu@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+#ifdef CONFIG_NEVIS
+
+#include <asm/arch/nevis.h>
+#include <asm/arch/sys_proto.h>
+
+/* the Nevis SoC has 16 General Purpose Timers */
+
+static const u32 timer_index = 0;
+
+/*******************************************************************************/
+
+/* some globals */
+int timer_load_val = 0;
+static ulong timestamp;
+static ulong lastinc;
+
+/*******************************************************************************/
+
+/* macro to read the 16 bit timer */
+static inline ulong READ_TIMER(void)
+{
+    volatile u32 *tvalue = (volatile u32*) (TIMER_BASE_REG + (timer_index << 4) + 0);
+    return (ulong) *tvalue;
+}
+
+/*******************************************************************************/
+
+int interrupt_init(void)
+{
+    u32 timer = timer_index << 4;
+
+    /* the registers to access the first of the 16 general purpose timers. */
+    volatile u32 *tvalue  = (volatile u32*) (TIMER_BASE_REG + timer + 0);
+    volatile u32 *tlimit  = (volatile u32*) (TIMER_BASE_REG + timer + 4);
+    volatile u32 *tmode   = (volatile u32*) (TIMER_BASE_REG + timer + 8);
+    volatile u32 *ttimeb  = (volatile u32*) (TIMER_BASE_REG + timer +12);
+    /* set the right lockbit according to the timer index */
+    u32 lock_mask = 1 << (timer_index + 16); 
+
+    /* step one: the system timer */
+
+    UnlockRegs(lock_mask);
+    /* setup the timer */
+    *tvalue = 0;                /* start value is 0 */
+    *tlimit = 0xFFFFFFFF;       /* the limit at which the timer rolls over to 0 */
+    *ttimeb = 54;               /* the input clock for the timer is hardwired to 54 MHz. So 54 clock periods equals 1us stepping */
+    *tmode  = 0x01;             /* set bit 0 to enable the timer */
+    LockRegs(lock_mask);
+
+    reset_timer_masked();
+
+    /* step two: the interrupt controller 
+       we do nothing here, because the only things to do with the ITC is to enabled
+       the interrupt source, which depends on the board */
+
+    return (0);
+}
+
+/*******************************************************************************/
+
+void reset_timer(void)
+{
+    reset_timer_masked();
+}
+
+/*******************************************************************************/
+
+void reset_timer_masked(void)
+{
+    lastinc = READ_TIMER();
+    timestamp = 0;
+}
+
+/*******************************************************************************/
+
+ulong get_timer(ulong base)
+{
+    return get_timer_masked() - base;
+}
+
+/*******************************************************************************/
+
+ulong get_timer_masked(void)
+{
+    u32 now = READ_TIMER();
+
+    if (now >= lastinc)                 /* normal mode (non roll) */
+        timestamp += (now - lastinc);   /* move stamp fordward with absoulte diff ticks */
+    else                                /* we have rollover of incrementer */
+        timestamp += (0xFFFFFFFF - lastinc) + now;
+        lastinc = now;
+    return timestamp;
+}
+
+/*******************************************************************************/
+
+void set_timer(ulong t)
+{
+    timestamp = t;
+}
+
+/*******************************************************************************/
+/* delay x useconds AND perserve advance timstamp value                        */
+
+void udelay(unsigned long usec)
+{
+    /* our timer runs at a resolution of 1 us, so we need no unsave calculations */
+    u32 now = READ_TIMER();                     /* the current timer value */
+    u32 end = (now + usec) & 0xFFFFFFFF;        /* the end value the timer must reach, including the timer rollover to 0 */
+
+    if (end > now)
+    {
+        /* normal case without rollover */
+        while (READ_TIMER() < end);
+    }
+    else
+    {
+        /* rollover case */
+        while (READ_TIMER() > end);
+        while (READ_TIMER() < end);
+    }
+}
+									    
+/*******************************************************************************/
+
+/* waits specified delay value and resets timestamp */
+
+void udelay_masked(unsigned long usec)
+{
+    ulong tmo;
+    ulong endtime;
+    signed long diff;
+
+    if (usec >= 1000)			/* if "big" number, spread normalization to seconds */
+    {
+        tmo  = usec / 1000;		/* start to normalize for usec to ticks per sec */
+        tmo *= CFG_HZ;			/* find number of "ticks" to wait to achieve target */
+        tmo /= 1000;			/* finish normalize. */
+    }
+    else                                /* else small number, don't kill it prior to HZ multiply */
+    {
+        tmo  = usec * CFG_HZ;
+        tmo /= (1000*1000);
+    }
+
+    endtime = get_timer_masked () + tmo;
+
+    do
+    {
+        ulong now = get_timer_masked ();
+        diff = endtime - now;
+    } while (diff >= 0);
+}
+													    
+/*******************************************************************************/
+/* This function is derived from PowerPC code (read timebase as long long).
+   On ARM it just returns the timer value.				       */
+
+unsigned long long get_ticks(void)
+{
+   return get_timer(0);
+}
+
+/*******************************************************************************/
+/* This function is derived from PowerPC code (timebase clock frequency).
+   On ARM it returns the number of timer ticks per second.		       */
+
+ulong get_tbclk(void)
+{
+    return 54000000;
+}
+
+/*******************************************************************************/
+/* reset the cpu by writing something into the reset register		       */
+
+void reset_cpu(ulong ignored)
+{
+    /* every write access - independend of the written value - 
+       will cause a hard reset */
+
+    volatile u32 *reg = (volatile u32*) SOFTRESET_REG;
+    *reg = 0x0000000;
+}
+
+/*******************************************************************************/
+/* handle incoming interrupts                                                  */
+
+void do_irq(struct pt_regs *pt_regs)
+{
+    /* call the boards interupt handler */
+
+    if (board_do_interrupt(pt_regs))
+    {
+	printf ("Warning, unhandled IRQ\n");
+	show_regs(pt_regs);
+    }
+}
+
+#endif /* CONFIG_NEVIS */
diff --git a/cpu/arm1176/nevis/misc.c b/cpu/arm1176/nevis/misc.c
new file mode 100644
index 0000000..546142d
--- /dev/null
+++ b/cpu/arm1176/nevis/misc.c
@@ -0,0 +1,93 @@
+/*
+ * misc. routines for CX2450x/ARM11 SoC
+ *
+ * (C) Copyright 2008
+ * Coolstream International Limited
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+#ifdef CONFIG_NEVIS
+#include <asm/arch/nevis.h>
+#include <asm/arch/sys_proto.h>
+
+/* helper routines to lock / unlock the protected registers */
+void LockRegs(u32 mask)
+{
+	/* access to the timer registers are globally locked */
+	volatile u32 *lcmdreg = (volatile u32*) LOCKCMD_REG;
+	volatile u32 *lstareg = (volatile u32*) LOCKSTAT_REG;
+
+	/* unlock sequence for access to the LOCKSTAT_REG */
+	*lcmdreg = 0x00;
+	*lcmdreg = 0xF8;
+	*lcmdreg = 0x2B;
+	/* re-set the lock bits */
+	*lstareg |= mask;
+	*lcmdreg = 0x00;
+}
+
+void UnlockRegs(u32 mask)
+{
+	/* access to the timer registers are globally locked */
+	volatile u32 *lcmdreg = (volatile u32*) LOCKCMD_REG;
+	volatile u32 *lstareg = (volatile u32*) LOCKSTAT_REG;
+
+	/* unlock sequence for access to the LOCKSTAT_REG */
+	*lcmdreg = 0x00;
+	*lcmdreg = 0xF8;
+	*lcmdreg = 0x2B;
+	/* clear the bits */
+	*lstareg &= ~mask;      /* disable one of bit 31 ... 16 to unlock timer register */
+	*lcmdreg = 0x00;
+}
+
+/* Conexant compiled kernel needs a few registers in the default
+ * state. Make sure they are.
+ */
+void CleanupBeforeLinux(void)
+{
+	u32 i;
+
+        /* unlock HACK for Conexant Linux Kernel */
+	UnlockRegs(0xFFFF0000);
+#if 1
+        /* reset the timers to default values, again conexant is BAD! This must 
+	   be done at the last point at all, because this also disables u-boots
+	   system timer */
+        for(i = 0; i < 16; i++) {
+                u32 timer_index = i << 4;
+                volatile u32 *tvalue  = (volatile u32*) (TIMER_BASE_REG + timer_index + 0);
+                volatile u32 *tlimit  = (volatile u32*) (TIMER_BASE_REG + timer_index + 4);
+                volatile u32 *tmode   = (volatile u32*) (TIMER_BASE_REG + timer_index + 8);
+                volatile u32 *ttimeb  = (volatile u32*) (TIMER_BASE_REG + timer_index +12);
+
+                /* setup the timer */
+                *tvalue = 0;
+                *tlimit = 0;
+                *ttimeb = 0;
+                *tmode  = 0;
+        }
+#endif
+
+}
+
+#endif
diff --git a/cpu/arm1176/nevis/serial.c b/cpu/arm1176/nevis/serial.c
new file mode 100644
index 0000000..abd890c
--- /dev/null
+++ b/cpu/arm1176/nevis/serial.c
@@ -0,0 +1,222 @@
+/*
+ * low level UART routines for CX2450x/ARM1176 SoC (Nevis)
+ *
+ * (c) 2008 Coolstream International Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <common.h>
+#include <asm/arch/nevis.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#ifdef CONFIG_NEVIS
+
+#ifdef CONFIG_SERIAL1
+#define UART_NR	0
+
+#elif defined(CONFIG_SERIAL2)
+#define UART_NR	1
+
+#elif defined(CONFIG_SERIAL3)
+#define UART_NR	2
+
+#elif defined(CONFIG_SERIAL4)
+#define UART_NR	3
+
+#else
+#error "Bad: you didn't configure serial ..."
+#endif
+
+/*******************************************************************************/
+
+/* register definitions. The UART works nearly similar to 15550 standard UART,
+   except all the Flow-Control stuff. */
+
+enum 
+{
+    UART_FIFO_BRDL	= 0x00,		/* u8 - FRMC:BDS = 0: Write: Top of TX-FIFO, Read: Bottom of RX-FIFO. */
+    UART_IRQE_BRDU	= 0x04,		/* u8 - FRMC:BDS = 0: Interrupt Enable Register. */
+    UART_FIFC		= 0x08,		/* u8 - FIFO Control Register */
+    UART_FRMC		= 0x0C,		/* u8 - Frame Control Register */
+    UART_STAT		= 0x14,		/* u8 - Status Register */
+    UART_IRVL		= 0x18,		/* u8 - Interrup Level Register */
+    UART_IRDC		= 0x20,		/* u8 - IrDA Control Register */
+    UART_TXSTA		= 0x28,		/* u8 - Transmit FIFO Status Register */
+    UART_RXSTA		= 0x2C,		/* u8 - Receive FIFO Status Register */
+    UART_EXP		= 0x30,		/* u8 - Expansion Register */
+    UART_MDMC		= 0x34		/* u8 - Modem Control Register */
+};
+
+/*******************************************************************************/
+
+/* Setup the baudrate */
+
+void serial_setbrg(void)
+{
+    volatile u8 *FIFO_BRDL = (volatile u8*)(UART_BASE_REG + UART_FIFO_BRDL + (UART_NR * 0x1000));
+    volatile u8 *IRQE_BRDU = (volatile u8*)(UART_BASE_REG + UART_IRQE_BRDU + (UART_NR * 0x1000));
+    volatile u8 *FRMC      = (volatile u8*)(UART_BASE_REG + UART_FRMC      + (UART_NR * 0x1000));
+    volatile u8 *EXP       = (volatile u8*)(UART_BASE_REG + UART_EXP       + (UART_NR * 0x1000));
+
+    u32 brdiv = (54000000 / (16 * gd->baudrate)) - 1;
+
+    *FRMC     |= 0x80;		/* set BDS to access the baudrate registers */
+    *FIFO_BRDL = brdiv & 0xFF;
+    *IRQE_BRDU = (brdiv >> 8) & 0xFF;
+
+    /* fractional part of brdiv - from the formula above, rounded to 0 (0x00), 1/4 (0x01), 1/2 (0x02) or 3/4 (0x03) */
+    switch (gd->baudrate)
+    {
+	case 9600:
+	case 57600:
+	    *EXP = 0x02;
+	    break;
+	case 19200:
+	case 38400:
+	    *EXP = 0x03;
+	    break;
+	case 115200:
+	    *EXP = 0x01;
+	    break;
+	default:
+	    *EXP = 0;
+    }
+
+    *FRMC     &= 0x7F;		/* unset BDS to have FIFO access */
+    *IRQE_BRDU = 0x00;		/* disable interrupts */
+}
+
+/*******************************************************************************/
+
+/* Initialise the serial port with the given baudrate. The settings
+ * are always 8 data bits, no parity, 1 stop bit, no start bits. */
+
+int serial_init(void)
+{
+    volatile u8 *FRMC = (volatile u8*)(UART_BASE_REG + UART_FRMC + (UART_NR * 0x1000));
+    volatile u8 *IRDC = (volatile u8*)(UART_BASE_REG + UART_IRDC + (UART_NR * 0x1000));
+    volatile u8 *FIFC = (volatile u8*)(UART_BASE_REG + UART_FIFC + (UART_NR * 0x1000));
+    volatile u8 *MDMC = (volatile u8*)(UART_BASE_REG + UART_MDMC + (UART_NR * 0x1000));
+
+    /* setup baudrate */
+    serial_setbrg();
+
+    *FRMC = 0x01;	/* default setup: 8 databits, 1 stop bit, no parity */ 
+    *IRDC = 0x00;	/* Disable IrDA */
+    *FIFC = 0x03;
+    *MDMC = 0x00;	/* set RTS and DTR */
+
+#ifdef BEAUTIFY_CONSOLE
+    /* some VTxxx control character to initalize the console */
+    const char *cls = {"\x1B[2h"	/* enable ANSI compatibility */
+		       "\x1B[61\x22p"	/* switch to VT100 mode - most PC-Terminal-Emulators do not know this command */
+		       "\x1B[m"		/* turn all attributes off */
+		       "\x1B[44m"
+		       "\x1B[37m"
+		       "\x1B[1m"
+		       "\x1B[2J"	/* erase entire screen */
+		       "\x1B[1;1H"	/* move cursor to upper left corner */
+		       "\x07"		/* BEL */
+		       "\x1B[(B"	/* US character set as G0 */
+		       "\x1B[)B"	/* US character set as G1 */
+		       "\x1B[?3l"	/* 80 column mode */
+		       "\x1B[?9h"};	/* 40 line mode */
+
+    const char *topline = {"\xC9\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD"
+			   "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD"
+			   "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD"
+			   "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD"
+			   "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD"
+			   "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD"
+			   "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD"
+			   "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xBB\n"};
+    printf("%s", cls);
+    printf("%s", topline);
+#endif /* BEAUTIFY_CONSOLE */
+
+    return (0);
+}
+
+/*******************************************************************************/
+
+/* Read a single byte from the serial port. Returns 1 on success, 0
+ * otherwise. When the function is succesfull, the character read is
+ * written into its argument c. */
+
+int serial_getc(void)
+{
+    s32 ret;
+    s32 error = 0;
+    volatile u8 *FIFO_BRDL = (volatile u8*)(UART_BASE_REG + UART_FIFO_BRDL + (UART_NR * 0x1000));
+    volatile u8 *STAT      = (volatile u8*)(UART_BASE_REG + UART_STAT      + (UART_NR * 0x1000));
+    volatile u8 *RXSTA     = (volatile u8*)(UART_BASE_REG + UART_RXSTA     + (UART_NR * 0x1000));
+
+    /* wait for character to arrive */
+    while (!(*RXSTA & 0x1F));
+
+    /* the datasheet request to read the Status register everytime before getting
+       the next char from the FIFO */
+    if ((*STAT & 0x1C))
+	error = 1;
+    
+    /* even if there was an data error, we have to read the FIFO */
+    ret = *FIFO_BRDL & 0xFF;
+
+    return (error != 0) ? 0x00 : ret;
+}
+
+/*******************************************************************************/
+
+/* Output a single byte to the serial port. */
+
+void serial_putc(const char c)
+{
+    volatile u8 *FIFO_BRDL = (volatile u8*)(UART_BASE_REG + UART_FIFO_BRDL + (UART_NR * 0x1000));
+    volatile u8 *TXSTA     = (volatile u8*)(UART_BASE_REG + UART_TXSTA     + (UART_NR * 0x1000));
+
+    /* wait for room in the tx FIFO */
+    while ((*TXSTA & 0x1F));
+
+    *FIFO_BRDL = c;
+
+    /* If \n, also do \r */
+    if (c == '\n')
+	serial_putc('\r');
+}
+
+/*******************************************************************************/
+
+/* Test whether a character is in the RX buffer */
+int serial_tstc(void)
+{
+    volatile u8 *RXSTA = (volatile u8*)(UART_BASE_REG + UART_RXSTA + (UART_NR * 0x1000));
+
+    return *RXSTA & 0x1F;
+}
+
+/*******************************************************************************/
+
+void serial_puts(const char *s)
+{
+    while (*s)
+    {
+	serial_putc (*s++);
+    }
+}
+
+#endif /* CONFIG_NEVIS */
diff --git a/cpu/arm1176/start.S b/cpu/arm1176/start.S
index cb891df..0122b0f 100644
--- a/cpu/arm1176/start.S
+++ b/cpu/arm1176/start.S
@@ -1,10 +1,18 @@
 /*
- *  armboot - Startup Code for S3C6400/ARM1176 CPU-core
+ *  armboot - Startup Code for CX2450x/ARM1176 CPU core
+ *  Copyright (c) 2008 Coolstream Intl. Ltd.
  *
- * Copyright (c) 2007	Samsung Electronics
+ *  derivend from:
  *
- * Copyright (C) 2008
- * Guennadi Liakhovetki, DENX Software Engineering, <lg@denx.de>
+ *  armboot - Startup Code for OMP2420/ARM1136 CPU-core
+ *
+ *  Copyright (c) 2004	Texas Instruments <r-woodruff2@ti.com>
+ *
+ *  Copyright (c) 2001	Marius Grger <mag@sysgo.de>
+ *  Copyright (c) 2002	Alex Zpke <azu@sysgo.de>
+ *  Copyright (c) 2002	Gary Jennejohn <gj@denx.de>
+ *  Copyright (c) 2003	Richard Woodruff <r-woodruff2@ti.com>
+ *  Copyright (c) 2003	Kshitij <kshitij@ti.com>
  *
  * See file CREDITS for list of people who contributed to this
  * project.
@@ -23,301 +31,211 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
  * MA 02111-1307 USA
- *
- * 2007-09-21 - Restructured codes by jsgood (jsgood.yang@samsung.com)
- * 2007-09-21 - Added MoviNAND and OneNAND boot codes by
- * jsgood (jsgood.yang@samsung.com)
- * Base codes by scsuh (sc.suh)
  */
 
 #include <config.h>
 #include <version.h>
-#ifdef CONFIG_ENABLE_MMU
-#include <asm/proc/domain.h>
-#endif
-#include <s3c6400.h>
 
-#if !defined(CONFIG_ENABLE_MMU) && !defined(CONFIG_SYS_PHY_UBOOT_BASE)
-#define CONFIG_SYS_PHY_UBOOT_BASE	CONFIG_SYS_UBOOT_BASE
-#endif
+#define SSP_ENABLED_MASK                 0x00000010
+#define SSP_PLL_SPEED_MASK               0x18000000
+#define SSP_PLL_SPEED_60MHZ              0x00000000
+#define SSP_PLL_NOT_BYPASS_MASK          0x00001000
 
-/*
- *************************************************************************
- *
- * Jump vector table as in table 3.1 in [1]
- *
- *************************************************************************
- */
+#define CACHE_CLOCK_MODE_MASK		0xc0000000
+#define CACHE_FASTBUS			0x40000000
+#define CACHE_ASYNC			0x80000000
+#define CACHE_PROT_ENABLE		0x00000001
+#define CACHE_DCACHE_ENABLE		0x00000004
+#define CACHE_ICACHE_ENABLE		0x00001000
 
 .globl _start
-_start: b	reset
-#ifndef CONFIG_NAND_SPL
-	ldr	pc, _undefined_instruction
-	ldr	pc, _software_interrupt
-	ldr	pc, _prefetch_abort
-	ldr	pc, _data_abort
-	ldr	pc, _not_used
-	ldr	pc, _irq
-	ldr	pc, _fiq
-
-_undefined_instruction:
-	.word undefined_instruction
-_software_interrupt:
-	.word software_interrupt
-_prefetch_abort:
-	.word prefetch_abort
-_data_abort:
-	.word data_abort
-_not_used:
-	.word not_used
-_irq:
-	.word irq
-_fiq:
-	.word fiq
-_pad:
-	.word 0x12345678 /* now 16*4=64 */
-#else
-	. = _start + 64
-#endif
-
+_start: 
+    b	reset
+    ldr	pc, _undefined_instruction
+    ldr	pc, _software_interrupt
+    ldr	pc, _prefetch_abort
+    ldr	pc, _data_abort
+    ldr	pc, _not_used
+    ldr	pc, _irq
+    ldr	pc, _fiq
+
+_undefined_instruction: .word undefined_instruction
+_software_interrupt:	.word software_interrupt
+_prefetch_abort:	.word prefetch_abort
+_data_abort:		.word data_abort
+_not_used:		.word not_used
+_irq:			.word irq
+_fiq:			.word fiq
+_pad:			.word 0x12345678 /* now 16*4=64 */
 .global _end_vect
 _end_vect:
-	.balignl 16,0xdeadbeef
-/*
- *************************************************************************
+
+    .balignl 16,0xdeadbeef
+
+/*************************************************************************
  *
  * Startup Code (reset vector)
  *
- * do important init only if we don't start from memory!
+ * do important init only if we don t start from memory!
  * setup Memory and board specific bits prior to relocation.
  * relocate armboot to ram
  * setup stack
  *
- *************************************************************************
- */
+ *************************************************************************/
 
 _TEXT_BASE:
-	.word	TEXT_BASE
-
-/*
- * Below variable is very important because we use MMU in U-Boot.
- * Without it, we cannot run code correctly before MMU is ON.
- * by scsuh.
- */
-_TEXT_PHY_BASE:
-	.word	CONFIG_SYS_PHY_UBOOT_BASE
+        .word	TEXT_BASE
 
 .globl _armboot_start
 _armboot_start:
-	.word _start
+        .word _start
 
-/*
- * These are defined in the board-specific linker script.
- */
+/* These are defined in the board-specific linker script.  */
 .globl _bss_start
 _bss_start:
-	.word __bss_start
+        .word __bss_start
 
 .globl _bss_end
 _bss_end:
-	.word _end
+        .word _end
+
+#ifdef CONFIG_USE_IRQ
+/* IRQ stack memory (calculated at run-time) */
+.globl IRQ_STACK_START
+IRQ_STACK_START:
+	.word	0x0badc0de
+
+/* IRQ stack memory (calculated at run-time) */
+.globl FIQ_STACK_START
+FIQ_STACK_START:
+        .word	0x0badc0de
+#endif
 
-/*
- * the actual reset code
- */
+/* the actual reset code */
 
 reset:
-	/*
-	 * set the cpu to SVC32 mode
-	 */
+#if defined (CONFIG_NEVIS)
+	/* The NEVIS SoC (and other SoC from Conexant) comes up with ROM 
+	   shadowing. The (Flash-) ROM is located fixed at address 0xF0000000, 
+	   but the reset vector for ARM of course is 0xFFFF0000. ROM-shadowing 
+	   maps all access to 0xFFFFxxxx to 0xF000xxxx.
+	   To continue initialization we have to manipulate the Prorgram
+	   Counter here first. */
+
+	ldr	r1, =0xF000FFFF
+	and	pc, pc, r1
+#endif
+
+	/* set the cpu to SVC32 mode */
 	mrs	r0, cpsr
-	bic	r0, r0, #0x3f
+	bic	r0, r0, #0x1f
 	orr	r0, r0, #0xd3
 	msr	cpsr, r0
 
-/*
- *************************************************************************
- *
- * CPU_init_critical registers
- *
- * setup important registers
- * setup memory timing
- *
- *************************************************************************
- */
-	/*
-	 * we do sys-critical inits only at reboot,
-	 * not when booting from ram!
-	 */
 cpu_init_crit:
-	/*
-	 * When booting from NAND - it has definitely been a reset, so, no need
-	 * to flush caches and disable the MMU
-	 */
-#ifndef CONFIG_NAND_SPL
-	/*
-	 * flush v4 I/D caches
-	 */
+	/* flush v4 I/D caches */
 	mov	r0, #0
-	mcr	p15, 0, r0, c7, c7, 0	/* flush v3/v4 cache */
-	mcr	p15, 0, r0, c8, c7, 0	/* flush v4 TLB */
+	mcr	p15, 0, r0, c7, c7, 0		/* flush v3/v4 cache */
+	mcr	p15, 0, r0, c8, c7, 0		/* flush v4 TLB */
+	nop
+	nop
 
 	/*
 	 * disable MMU stuff and caches
 	 */
 	mrc	p15, 0, r0, c1, c0, 0
-	bic	r0, r0, #0x00002300	@ clear bits 13, 9:8 (--V- --RS)
-	bic	r0, r0, #0x00000087	@ clear bits 7, 2:0 (B--- -CAM)
-	orr	r0, r0, #0x00000002	@ set bit 2 (A) Align
-	orr	r0, r0, #0x00001000	@ set bit 12 (I) I-Cache
-	/* Prepare to disable the MMU */
-	adr	r1, mmu_disable_phys
-	/* We presume we're within the first 1024 bytes */
-	and	r1, r1, #0x3fc
-	ldr	r2, _TEXT_PHY_BASE
-	ldr	r3, =0xfff00000
-	and	r2, r2, r3
-	orr	r2, r2, r1
-	b	mmu_disable
-
-	.align 5
-	/* Run in a single cache-line */
-mmu_disable:
+	bic	r0, r0, #0x00002300		@ clear bits 13, 9:8 (--V- --RS)
+	bic	r0, r0, #0x00000087		@ clear bits 7, 2:0  (B--- -CAM)
+	orr	r0, r0, #0x00000002		@ set bit 2 (A) Align
+	orr	r0, r0, #0x00001000		@ set bit 12 (I) I-Cache
 	mcr	p15, 0, r0, c1, c0, 0
+
 	nop
 	nop
-	mov	pc, r2
-#endif
 
-mmu_disable_phys:
-	/* Peri port setup */
-	ldr	r0, =0x70000000
-	orr	r0, r0, #0x13
-	mcr	p15,0,r0,c15,c2,4       @ 256M (0x70000000 - 0x7fffffff)
+        /* before relocating, we have to setup RAM timing because memory timing 
+	   is board-dependend, you will find a lowlevel_init.S in your board 
+	   directory. */
+#ifndef CONFIG_SKIP_LOWLEVEL_INIT
+	bl      lowlevel_init
+#endif
 
-	/*
-	 * Go setup Memory and board specific bits prior to relocation.
-	 */
-	bl	lowlevel_init		/* go setup pll,mux,memory */
-
-after_copy:
-#ifdef CONFIG_ENABLE_MMU
-enable_mmu:
-	/* enable domain access */
-	ldr	r5, =0x0000ffff
-	mcr	p15, 0, r5, c3, c0, 0	/* load domain access register */
-
-	/* Set the TTB register */
-	ldr	r0, _mmu_table_base
-	ldr	r1, =CONFIG_SYS_PHY_UBOOT_BASE
-	ldr	r2, =0xfff00000
-	bic	r0, r0, r2
-	orr	r1, r0, r1
-	mcr	p15, 0, r1, c2, c0, 0
-
-	/* Enable the MMU */
-	mrc	p15, 0, r0, c1, c0, 0
-	orr	r0, r0, #1		/* Set CR_M to enable MMU */
+#ifndef CONFIG_SKIP_RELOCATE_UBOOT
+relocate:					/* relocate U-Boot to RAM	    */
+	adr	r0, _start			/* r0 <- current position of code   */
+	ldr	r1, _TEXT_BASE			/* test if we run from flash or RAM */
+	cmp	r0, r1				/* don t reloc during debug	    */
+	beq	stack_setup
 
-	/* Prepare to enable the MMU */
-	adr	r1, skip_hw_init
-	and	r1, r1, #0x3fc
-	ldr	r2, _TEXT_BASE
-	ldr	r3, =0xfff00000
-	and	r2, r2, r3
-	orr	r2, r2, r1
-	b	mmu_enable
+	ldr	r2, _armboot_start
+	ldr	r3, _bss_start
+	sub	r2, r3, r2			/* r2 <- size of armboot	    */
+	add	r2, r0, r2			/* r2 <- source end address	    */
 
-	.align 5
-	/* Run in a single cache-line */
-mmu_enable:
+copy_loop:
+	ldmia	r0!, {r3-r10}			/* copy from source address [r0]    */
+	stmia	r1!, {r3-r10}			/* copy to   target address [r1]    */
+	cmp	r0, r2				/* until source end addreee [r2]    */
+	ble	copy_loop
+#endif	/* CONFIG_SKIP_RELOCATE_UBOOT */
 
-	mcr	p15, 0, r0, c1, c0, 0
-	nop
-	nop
-	mov	pc, r2
-#endif
-
-skip_hw_init:
 	/* Set up the stack						    */
 stack_setup:
-#ifdef CONFIG_MEMORY_UPPER_CODE
-	ldr	sp, =(CONFIG_SYS_UBOOT_BASE + CONFIG_SYS_UBOOT_SIZE - 0xc)
-#else
-	ldr	r0, _TEXT_BASE		/* upper 128 KiB: relocated uboot   */
-	sub	r0, r0, #CONFIG_SYS_MALLOC_LEN	/* malloc area                      */
-	sub	r0, r0, #CONFIG_SYS_GBL_DATA_SIZE /* bdinfo                        */
-	sub	sp, r0, #12		/* leave 3 words for abort-stack    */
-
+	ldr	r0, _TEXT_BASE			/* upper 128 KiB: relocated uboot   */
+	sub	r0, r0, #CONFIG_SYS_MALLOC_LEN		/* malloc area			    */
+	sub	r0, r0, #CONFIG_SYS_GBL_DATA_SIZE	/* bdinfo			    */
+#ifdef CONFIG_USE_IRQ
+	sub	r0, r0, #(CONFIG_STACKSIZE_IRQ + CONFIG_STACKSIZE_FIQ)
 #endif
+	sub	sp, r0, #12			/* leave 3 words for abort-stack    */
 
 clear_bss:
-	ldr	r0, _bss_start		/* find start of bss segment        */
-	ldr	r1, _bss_end		/* stop here                        */
-	mov 	r2, #0			/* clear                            */
+	ldr	r0, _bss_start			/* find start of bss segment	    */
+	ldr	r1, _bss_end			/* stop here			    */
+	mov	r2, #0x00000000			/* clear			    */
 
 clbss_l:
-	str	r2, [r0]		/* clear loop...                    */
+	str	r2, [r0]			/* clear loop...		    */
 	add	r0, r0, #4
 	cmp	r0, r1
-	ble	clbss_l
+	bne	clbss_l
+
+#ifdef CONFIG_USE_IRQ
+        /* Setup the exception vector table to be located at address 0x00000000 */
+	/* clear CP15 c1 bit 13 "normal exception vectors" (see. ARM document DDI 0333G) */
+        mrc     p15, 0, r0, c1, c0
+        and     r0, r0, #0xFFFFDFFF
+        mcr     p15, 0, r0, c1, c0
+
+	/* set exception vector base address */
+	ldr	r0, _TEXT_BASE
+	mcr	p15, 0, r0, c12, c0, 0
+#endif
 
-#ifndef CONFIG_NAND_SPL
 	ldr	pc, _start_armboot
 
-_start_armboot:
+_start_armboot: 
 	.word start_armboot
-#else
-	b	nand_boot
-/*	.word nand_boot*/
-#endif
-
-#ifdef CONFIG_ENABLE_MMU
-_mmu_table_base:
-	.word mmu_table
-#endif
 
-#ifndef CONFIG_NAND_SPL
-/*
- * we assume that cache operation is done before. (eg. cleanup_before_linux())
- * actually, we don't need to do anything about cache if not use d-cache in
- * U-Boot. So, in this function we clean only MMU. by scsuh
+/*************************************************************************
  *
- * void	theLastJump(void *kernel, int arch_num, uint boot_params);
- */
-#ifdef CONFIG_ENABLE_MMU
-	.globl theLastJump
-theLastJump:
-	mov	r9, r0
-	ldr	r3, =0xfff00000
-	ldr	r4, _TEXT_PHY_BASE
-	adr	r5, phy_last_jump
-	bic	r5, r5, r3
-	orr	r5, r5, r4
-	mov	pc, r5
-phy_last_jump:
-	/*
-	 * disable MMU stuff
-	 */
-	mrc	p15, 0, r0, c1, c0, 0
-	bic	r0, r0, #0x00002300	/* clear bits 13, 9:8 (--V- --RS) */
-	bic	r0, r0, #0x00000087	/* clear bits 7, 2:0 (B--- -CAM) */
-	orr	r0, r0, #0x00000002	/* set bit 2 (A) Align */
-	orr	r0, r0, #0x00001000	/* set bit 12 (I) I-Cache */
-	mcr	p15, 0, r0, c1, c0, 0
+ * CPU_init_critical registers
+ *
+ * setup important registers
+ * setup memory timing
+ *
+ *************************************************************************/
 
-	mcr	p15, 0, r0, c8, c7, 0	/* flush v4 TLB */
+#ifndef CONFIG_SKIP_LOWLEVEL_INIT
 
-	mov	r0, #0
-	mov	pc, r9
-#endif
-/*
- *************************************************************************
+
+#endif /* CONFIG_SKIP_LOWLEVEL_INIT */
+
+/*************************************************************************
  *
  * Interrupt handling
  *
- *************************************************************************
- */
+ *************************************************************************/
 @
 @ IRQ stack frame.
 @
@@ -348,83 +266,83 @@ phy_last_jump:
 
 /*
  * use bad_save_user_regs for abort/prefetch/undef/swi ...
+ * use irq_save_user_regs / irq_restore_user_regs for IRQ/FIQ handling
  */
 
 	.macro	bad_save_user_regs
-	/* carve out a frame on current user stack */
-	sub	sp, sp, #S_FRAME_SIZE
-	/* Save user registers (now in svc mode) r0-r12 */
-	stmia	sp, {r0 - r12}
+	sub	sp, sp, #S_FRAME_SIZE		@ carve out a frame on current user stack
+	stmia	sp, {r0 - r12}			@ Save user registers (now in svc mode) r0-r12
 
 	ldr	r2, _armboot_start
 	sub	r2, r2, #(CONFIG_SYS_MALLOC_LEN)
-	/* set base 2 words into abort stack */
-	sub	r2, r2, #(CONFIG_SYS_GBL_DATA_SIZE+8)
-	/* get values for "aborted" pc and cpsr (into parm regs) */
-	ldmia	r2, {r2 - r3}
-	/* grab pointer to old stack */
-	add	r0, sp, #S_FRAME_SIZE
+	sub	r2, r2, #(CONFIG_SYS_GBL_DATA_SIZE+8)	@ set base 2 words into abort stack
+	ldmia	r2, {r2 - r3}			@ get values for "aborted" pc and cpsr (into parm regs)
+	add	r0, sp, #S_FRAME_SIZE		@ grab pointer to old stack
 
 	add	r5, sp, #S_SP
 	mov	r1, lr
-	/* save sp_SVC, lr_SVC, pc, cpsr */
-	stmia	r5, {r0 - r3}
-	/* save current stack into r0 (param register) */
+	stmia	r5, {r0 - r3}			@ save sp_SVC, lr_SVC, pc, cpsr
+	mov	r0, sp				@ save current stack into r0 (param register)
+	.endm
+
+	.macro	irq_save_user_regs
+	sub	sp, sp, #S_FRAME_SIZE
+	stmia	sp, {r0 - r12}			@ Calling r0-r12
+	add	r8, sp, #S_PC			@ !!!! R8 NEEDS to be saved !!!! a reserved stack spot would be good.
+	stmdb	r8, {sp, lr}^			@ Calling SP, LR
+	str	lr, [r8, #0]			@ Save calling PC
+	mrs	r6, spsr
+	str	r6, [r8, #4]			@ Save CPSR
+	str	r0, [r8, #8]			@ Save OLD_R0
 	mov	r0, sp
 	.endm
 
+	.macro	irq_restore_user_regs
+	ldmia	sp, {r0 - lr}^			@ Calling r0 - lr
+	mov	r0, r0
+	ldr	lr, [sp, #S_PC]			@ Get PC
+	add	sp, sp, #S_FRAME_SIZE
+	subs	pc, lr, #4			@ return & move spsr_svc into cpsr
+	.endm
+
 	.macro get_bad_stack
-	/* setup our mode stack (enter in banked mode) */
-	ldr	r13, _armboot_start
-	/* move past malloc pool */
-	sub	r13, r13, #(CONFIG_SYS_MALLOC_LEN)
-	/* move to reserved a couple spots for abort stack */
-	sub	r13, r13, #(CONFIG_SYS_GBL_DATA_SIZE + 8)
-
-	/* save caller lr in position 0 of saved stack */
-	str	lr, [r13]
-	/* get the spsr */
-	mrs	lr, spsr
-	/* save spsr in position 1 of saved stack */
-	str	lr, [r13, #4]
-
-	/* prepare SVC-Mode */
-	mov	r13, #MODE_SVC
+	ldr	r13, _armboot_start		@ setup our mode stack (enter in banked mode)
+	sub	r13, r13, #(CONFIG_SYS_MALLOC_LEN)	@ move past malloc pool
+	sub	r13, r13, #(CONFIG_SYS_GBL_DATA_SIZE+8) @ move to reserved a couple spots for abort stack
+
+	str	lr, [r13]			@ save caller lr in position 0 of saved stack
+	mrs	lr, spsr			@ get the spsr
+	str	lr, [r13, #4]			@ save spsr in position 1 of saved stack
+
+	mov	r13, #MODE_SVC			@ prepare SVC-Mode
 	@ msr	spsr_c, r13
-	/* switch modes, make sure moves will execute */
-	msr	spsr, r13
-	/* capture return pc */
-	mov	lr, pc
-	/* jump to next instruction & switch modes. */
-	movs	pc, lr
+	msr	spsr, r13			@ switch modes, make sure moves will execute
+	mov	lr, pc				@ capture return pc
+	movs	pc, lr				@ jump to next instruction & switch modes.
 	.endm
 
 	.macro get_bad_stack_swi
-	/* space on current stack for scratch reg. */
-	sub	r13, r13, #4
-	/* save R0's value. */
-	str	r0, [r13]
-	/* get data regions start */
-	ldr	r0, _armboot_start
-	/* move past malloc pool */
-	sub	r0, r0, #(CONFIG_SYS_MALLOC_LEN)
-	/* move past gbl and a couple spots for abort stack */
-	sub	r0, r0, #(CONFIG_SYS_GBL_DATA_SIZE + 8)
-	/* save caller lr in position 0 of saved stack */
-	str	lr, [r0]
-	/* get the spsr */
-	mrs	r0, spsr
-	/* save spsr in position 1 of saved stack */
-	str	lr, [r0, #4]
-	/* restore r0 */
-	ldr	r0, [r13]
-	/* pop stack entry */
-	add	r13, r13, #4
+	sub	r13, r13, #4			@ space on current stack for scratch reg.
+	str	r0, [r13]			@ save R0 s value.
+	ldr	r0, _armboot_start		@ get data regions start
+	sub	r0, r0, #(CONFIG_SYS_MALLOC_LEN)	@ move past malloc pool
+	sub	r0, r0, #(CONFIG_SYS_GBL_DATA_SIZE+8)	@ move past gbl and a couple spots for abort stack
+	str	lr, [r0]			@ save caller lr in position 0 of saved stack
+	mrs	r0, spsr			@ get the spsr
+	str	lr, [r0, #4]			@ save spsr in position 1 of saved stack
+	ldr	r0, [r13]			@ restore r0
+	add	r13, r13, #4			@ pop stack entry
 	.endm
 
-/*
- * exception handlers
- */
+	.macro get_irq_stack			@ setup IRQ stack
+	ldr	sp, IRQ_STACK_START
+	.endm
+
+	.macro get_fiq_stack			@ setup FIQ stack
+	ldr	sp, FIQ_STACK_START
+	.endm
+
+/* exception handlers */
 	.align	5
 undefined_instruction:
 	get_bad_stack
@@ -455,6 +373,25 @@ not_used:
 	bad_save_user_regs
 	bl	do_not_used
 
+#ifdef CONFIG_USE_IRQ
+
+	.align	5
+irq:
+	get_irq_stack
+	irq_save_user_regs
+	bl	do_irq
+	irq_restore_user_regs
+
+	.align	5
+fiq:
+	get_fiq_stack
+	/* someone ought to write a more effiction fiq_save_user_regs */
+	irq_save_user_regs
+	bl	do_fiq
+	irq_restore_user_regs
+
+#else
+
 	.align	5
 irq:
 	get_bad_stack
@@ -466,4 +403,30 @@ fiq:
 	get_bad_stack
 	bad_save_user_regs
 	bl	do_fiq
-#endif /* CONFIG_NAND_SPL */
+
+#endif
+	.align 5
+.global arm1176_cache_flush
+arm1176_cache_flush:
+	mov     r0, #0
+	mrs     r1, cpsr
+	cpsid   ifa                 @ disable interrupts
+	mcr p15, 0, r0, c7, c5, 0   @ Invalidate entire Instruction Cache
+	mcr p15, 0, r0, c7, c5, 0   @ Invalidate entire Instruction Cache
+	mcr p15, 0, r0, c7, c5, 0   @ Invalidate entire Instruction Cache
+	mcr p15, 0, r0, c7, c5, 0   @ Invalidate entire Instruction Cache
+	msr     cpsr_cx, r1         @ reenable interrupts
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+
+@		mcr	p15, 0, r1, c7, c5, 0	@ invalidate I cache
+	mov	pc, lr			@ back to caller
diff --git a/drivers/usb/Makefile b/drivers/usb/Makefile
index b306a65..5950496 100644
--- a/drivers/usb/Makefile
+++ b/drivers/usb/Makefile
@@ -40,6 +40,7 @@ COBJS-$(CONFIG_USB_EHCI_IXP4XX) += usb_ehci_ixp.o
 COBJS-$(CONFIG_MUSB_HCD) += musb_hcd.o musb_core.o
 COBJS-$(CONFIG_USB_DAVINCI) += davinci_usb.o
 COBJS-$(CONFIG_USB_EHCI_VCT) += usb_ehci_vct.o
+COBJS-$(CONFIG_USB_EHCI_CX2450X) += usb_ehci_cx2450x.o
 
 # device
 ifdef CONFIG_USB_DEVICE
diff --git a/drivers/usb/usb_ehci_core.c b/drivers/usb/usb_ehci_core.c
index 4dbfb66..a6d3319 100644
--- a/drivers/usb/usb_ehci_core.c
+++ b/drivers/usb/usb_ehci_core.c
@@ -549,9 +549,13 @@ ehci_submit_root(struct usb_device *dev, unsigned long pipe, void *buffer,
 	      req->requesttype, req->requesttype,
 	      le16_to_cpu(req->value), le16_to_cpu(req->index));
 
-	typeReq = req->request << 8 | req->requesttype;
+	typeReq = (req->requesttype << 8) | req->request ;
 
-	switch (le16_to_cpu(typeReq)) {
+	debug("typereq=%u (%#x)\n", le16_to_cpu(typeReq), le16_to_cpu(typeReq));
+	debug("typereq=%u (%#x)\n", typeReq, typeReq);
+
+
+	switch (typeReq) {
 	case DeviceRequest | USB_REQ_GET_DESCRIPTOR:
 		switch (le16_to_cpu(req->value) >> 8) {
 		case USB_DT_DEVICE:
diff --git a/drivers/usb/usb_ehci_cx2450x.c b/drivers/usb/usb_ehci_cx2450x.c
new file mode 100644
index 0000000..d2398e0
--- /dev/null
+++ b/drivers/usb/usb_ehci_cx2450x.c
@@ -0,0 +1,70 @@
+/*
+ * (C) Copyright 2008, Coolstream International Limited
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <pci.h>
+#include <usb.h>
+#include <asm/arch/nevis.h>
+
+#include "usb_ehci.h"
+#include "usb_ehci_core.h"
+
+#define BASE_ADDR	0xE8000000
+
+#define USB_DEBUG 1
+
+/*******************************************************************************/
+
+int ehci_hcd_init(void)
+{
+    volatile u32 *usb_enable = (volatile u32*) SREG_USB_ENABLE_REG;
+
+    #ifdef USB_DEBUG
+    printf("%s();\n", __FUNCTION__);
+    #endif
+
+    *usb_enable |= 0x00000703;		/* bit 8-6: bus pwr polarity: 0 = active high, bit 5-3: fault polarity: 0 = active low, bit 1-0: power on/off: 0 = off, 1 = on */
+    udelay(250000);
+
+
+    /* setup controllers register addresses */
+    hccr = (struct ehci_hccr *)((uint32_t) (BASE_ADDR + 0x0100));
+    hcor = (struct ehci_hcor *)((uint32_t) hccr + HC_LENGTH(ehci_readl(&hccr->cr_capbase)));
+
+    printf("CX2450x init hccr %x and hcor %x hc_length %d\n",
+           (uint32_t)hccr, (uint32_t)hcor,
+           (uint32_t)HC_LENGTH(ehci_readl(&hccr->cr_capbase)));
+
+    return 0;
+}
+
+/*******************************************************************************/
+
+int ehci_hcd_stop(void)
+{
+    volatile u32 *usb_enable = (volatile u32*) SREG_USB_ENABLE_REG;
+
+    #ifdef USB_DEBUG
+    printf("%s();\n", __FUNCTION__);
+    #endif
+
+    *usb_enable &= ~3;
+
+    return 0;
+}
diff --git a/include/asm-arm/arch-nevis/fp_uart.h b/include/asm-arm/arch-nevis/fp_uart.h
new file mode 100644
index 0000000..22703fc
--- /dev/null
+++ b/include/asm-arm/arch-nevis/fp_uart.h
@@ -0,0 +1,81 @@
+#ifndef __FP_UART_H__
+#define __FP_UART_H__
+
+#define FP_DEFAULT_UART				(1)
+
+/* UART's 
+   (16550 compatible except: FIFOs allways on, no DMA mode select, 
+   no support for 5 and 6 bit data frames, no scratch register) */
+#define UART_FIFO_BRDL_REG(x)		(0xE0410000 + ((x) * 0x1000))	/* FIFO (BDS=0) or lower baud rate divisor (BDS=1) register (x = 0 ... 3) */
+#define UART_IRQE_BRDU_REG(x)		(0xE0410004 + ((x) * 0x1000))	/* Interrupt enable (BDS=0) or upper baud rate divisor (BDS=1) register (x = 0 ... 3) */
+#define UART_FIFC_REG(x)		(0xE0410008 + ((x) * 0x1000))	/* FIFO control register (x = 0 ... 3) */
+#define UART_FRMC_REG(x)		(0xE041000C + ((x) * 0x1000))	/* Frame control register (x = 0 ... 3) */
+#define UART_STAT_REG(x)		(0xE0410014 + ((x) * 0x1000))	/* Status register (x = 0 ... 3) */
+#define UART_IRLVL_REG(x)		(0xE0410018 + ((x) * 0x1000))	/* Interrupt level register (x = 0 ... 3) */
+#define UART_IRDC_REG(x)		(0xE0410020 + ((x) * 0x1000))	/* IrDA control register (x = 0 ... 3) */
+#define UART_TXSTA_REG(x)		(0xE0410028 + ((x) * 0x1000))	/* Transmit FIFO status register (x = 0 ... 3) */
+#define UART_RXSTA_REG(x)		(0xE041002C + ((x) * 0x1000))	/* Receive FIFO status register (x = 0 ... 3) */
+#define UART_EXP_REG(x)			(0xE0410030 + ((x) * 0x1000))	/* Expansion register (x = 0 ... 3) */
+
+static inline void fp_uart_start_tx(void)
+{
+	volatile u8 *irqe = (volatile u8 *) UART_IRQE_BRDU_REG(FP_DEFAULT_UART);
+	*irqe |= 0x40;		/* TID */
+}
+
+static inline void fp_uart_stop_tx(void)
+{
+	volatile u8 *irqe = (volatile u8 *) UART_IRQE_BRDU_REG(FP_DEFAULT_UART);
+	*irqe &= ~0x60;
+}
+
+static inline void fp_uart_start_rx(void)
+{
+	volatile u8 *irqe = (volatile u8 *) UART_IRQE_BRDU_REG(FP_DEFAULT_UART);
+	*irqe |= 0x01;		/* TID */
+}
+
+static inline void fp_uart_stop_rx(void)
+{
+	volatile u8 *irqe = (volatile u8 *) UART_IRQE_BRDU_REG(FP_DEFAULT_UART);
+	*irqe &= ~0x01;
+}
+
+static inline u8 fp_uart_get_status(void)
+{
+	volatile u8 *sta = (volatile u8 *) UART_STAT_REG(FP_DEFAULT_UART);
+	return *sta;
+}
+
+static inline u8 fp_uart_get_ie(void)
+{
+	volatile u8 *irqe = (volatile u8 *) UART_IRQE_BRDU_REG(FP_DEFAULT_UART);
+
+	return *irqe;
+}
+
+static inline u8 fp_uart_get_rx(void)
+{
+	volatile u8 *fifo = (volatile u8 *) UART_FIFO_BRDL_REG(FP_DEFAULT_UART);
+	return *fifo;
+}
+
+static inline void fp_uart_set_tx(u8 d)
+{
+	volatile u8 *fifo = (volatile u8 *) UART_FIFO_BRDL_REG(FP_DEFAULT_UART);
+	*fifo = d;
+}
+
+static inline u8 fp_uart_get_rx_count(void)
+{
+	volatile u8 *rxsta = (volatile u8 *) UART_RXSTA_REG(FP_DEFAULT_UART);
+	return *rxsta;
+}
+
+static inline u8 fp_uart_get_tx_count(void)
+{
+	volatile u8 *txsta = (volatile u8 *) UART_TXSTA_REG(FP_DEFAULT_UART);
+	return *txsta;
+}
+
+#endif /* __FP_UART_H__ */
diff --git a/include/asm-arm/arch-nevis/hardware.h b/include/asm-arm/arch-nevis/hardware.h
new file mode 100644
index 0000000..7e4fb91
--- /dev/null
+++ b/include/asm-arm/arch-nevis/hardware.h
@@ -0,0 +1,6 @@
+#ifndef __HARDWARE_H__
+#define __HARDWARE_H__
+
+/* empty */
+
+#endif /* __HARDWARE_H__ */
diff --git a/include/asm-arm/arch-nevis/nevis.h b/include/asm-arm/arch-nevis/nevis.h
new file mode 100644
index 0000000..9664816
--- /dev/null
+++ b/include/asm-arm/arch-nevis/nevis.h
@@ -0,0 +1,389 @@
+/*
+ * (C) Copyright 2008
+ * Coolstream International Limited
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __NEVIS_H__
+#define __NEVIS_H__
+
+#include <asm/arch/sizes.h>
+
+/* some important registers */
+#define HSX_0_ARBMODE_REG		0xE0000000
+#define HSX_0_ARBMODE1_REG		0xE0000004
+#define HSX_1_ARBMODE_REG		0xE0000010
+#define HSX_1_ARBMODE1_REG		0xE0000014
+#define HSX_2_ARBMODE_REG		0xE0000020
+#define HSX_2_ARBMODE1_REG		0xE0000024
+
+#define HSX_ASX_BRIDGE_CTRL_REG		0xE0000050
+
+#define HSX_PIT_GENERAL_REG		0xE0000100
+#define HSX_PIT_DATA_REG		0xE0000104
+#define HSX_PIT_INSTR_REG		0xE0000108
+
+#define ROM_DESC0_REG			0xE0010000	/* ROM descriptor */
+#define PCI_ROM_DESC0_REG		0xE0010000	/* ROM descriptor */
+#define ROM_MAP_REG			0xE0010020	/* ROM mapping register */
+#define ROM_XOE_MASK_REG		0xE0010034
+#define	PCI_CFG_ADDR_REG		0xE0010040
+#define PCI_CFG_DATA_REG		0xE0010044
+
+#define RESET_STATUS_REG		0xE0400000
+#define REMAP_REG			0xE0400014	/* ROM shadow enable / disable */
+#define PLL_STATUS_REG			0xE0400018
+#define SOFTRESET_REG			0xE040001C	/* writing anything to this reg causes a system reset */
+#define RST_DECARM_CTL_REG		0xE0400044	/* writing anything to this reg causes a system reset */
+#define SCRATCH_2_REG			0xE0400050	/* scratch, used to pass size of DDR-RAM bank #1 */
+#define SCRATCH_3_REG			0xE0400054	/* scratch, used to pass size of DDR-RAM bank #2 */
+#define SCRATCH_4_REG			0xE0400058	/* scratch, used to pass the chip vendor and ID */
+#define SCRATCH_5_REG			0xE040005C	/* scratch, used to pass the chip major and minor revision ID */
+
+#define UART_BASE_REG			0xE0410000	/* UART0. UART1 is at UART0 + 0x1000, UART2 at UART0 + 0x2000, UART3 at UART0 + 0x3000 */
+
+#define TIMER_BASE_REG			0xE0430000	/* 16 timers; 4 regs for each timer */
+#define TIMER_IRQ_REG			0xE0430100
+
+#define PLL_MPG0_INTFRAC_REG		0xE0440000
+#define PLL_MPG0_CTRL_REG		0xE0440004
+#define PLL_MPG1_INTFRAC_REG		0xE0440008
+#define PLL_MPG1_CTRL_REG		0xE044000C
+#define PLL_HD_INTFRAC_REG		0xE0440010
+#define PLL_HD_CTRL_REG			0xE0440014
+#define PLL_AUD_INTFRAC_REG		0xE0440018
+#define PLL_AUD_CTRL_REG		0xE044001C
+#define PLL_PLL0_INTFRAC_REG		0xE0440020
+#define PLL_PLL0_CTRL_REG		0xE0440024
+#define PLL_PLL1_INTFRAC_REG		0xE0440028
+#define PLL_PLL1_CTRL_REG		0xE044002C
+#define PLL_PLL2_INTFRAC_REG		0xE0440030
+#define PLL_PLL2_CTRL_REG		0xE0440034
+#define PLL_MEM_CTRL0_REG		0xE0440038
+#define PLL_MEM_CTRL1_REG		0xE044003C
+#define PLL_MEM_CTRL2_REG		0xE0440040
+#define PLL_MEM_CTRL3_REG		0xE0440044
+#define PLL_FENRUS_CTRL_REG		0xE0440048
+
+#define DIV_MUX_CTRL0_REG		0xE0440050
+#define DIV_MUX_CTRL1_REG		0xE0440054
+#define DIV_MUX_CTRL2_REG		0xE0440058
+#define DIV_MUX_CTRL3_REG		0xE044005C
+#define DIV_MUX_CTRL4_REG		0xE0440060
+#define DIV_MUX_CTRL5_REG		0xE0440064
+#define DIV_MUX_CTRL6_REG		0xE0440068
+#define DIV_MUX_CTRL7_REG		0xE044006C
+#define DIV_MUX_CTRL8_REG		0xE0440070
+#define DIV_MUX_CTRL9_REG		0xE0440074
+#define DIV_MUX_CTRL10_REG		0xE0440078
+#define DIV_MUX_CTRL11_REG		0xE044007C
+#define DIV_MUX_CTRL12_REG		0xE0440080
+#define DIV_MUX_CTRL13_REG		0xE0440084
+#define DIV_MUX_CTRL14_REG		0xE0440088
+#define DIV_MUX_CTRL15_REG		0xE044008C
+
+#define SMART0_PLL_CTRL_REG		0xE04400AC
+#define SMART1_PLL_CTRL_REG		0xE04400B0
+
+#define AUDIO_CLK_SEL_REG		0xE04400B8
+#define AUDIO_DIVIDE0_REG		0xE04400BC
+#define AUDIO_DIVIDE1_REG		0xE04400C0
+#define AUDIO_DIVIDE2_REG		0xE04400C4
+#define AUDIO_DIVIDE3_REG		0xE04400C8
+#define AUDIO_DIVIDE4_REG		0xE04400CC
+#define AUDIO_DIVIDE5_REG		0xE04400D0
+#define MPG2_DIVIDE_REG			0xE04400D4
+#define MPG3_DIVIDE_REG			0xE04400D8
+
+#define PIN_CONFIG0_REG			0xE0440100
+#define PIN_ALT_FUNC_REG		0xE0440110
+
+#define MEMORY_TIMER_REG		0xE0440140
+
+#define SREG_PLL_BYPASS_REG		0xE0440154
+
+#define GPIO_PIN_MUX0_REG		0xE0440180	/* PIO 031 ... 000 alternate function pin mux select */
+#define GPIO_PIN_MUX1_REG		0xE0440184	/* PIO 063 ... 032 alternate function pin mux select */
+#define GPIO_PIN_MUX2_REG		0xE0440188	/* PIO 095 ... 064 alternate function pin mux select */
+#define GPIO_PIN_MUX3_REG		0xE044018C	/* PIO 127 ... 096 alternate function pin mux select */
+#define GPIO_PIN_MUX4_REG		0xE0440190	/* PIO 159 ... 128 alternate function pin mux select */
+#define GPIO_PIN_MUX5_REG		0xE0440194	/* PIO 191 ... 160 alternate function pin mux select */
+#define GPIO_PIN_MUX6_REG		0xE0440198	/* PIO 223 ... 191 alternate function pin mux select */
+
+#define GPIO_PIN_SMUX0_REG		0xE04401C0	/* PIO 031 ... 000 secundary alternate function pin mux select */
+#define GPIO_PIN_SMUX1_REG		0xE04401C4	/* PIO 063 ... 032 secundary alternate function pin mux select */
+#define GPIO_PIN_SMUX2_REG		0xE04401C8	/* PIO 095 ... 064 secundary alternate function pin mux select */
+#define GPIO_PIN_SMUX3_REG		0xE04401CC	/* PIO 127 ... 096 secundary alternate function pin mux select */
+#define GPIO_PIN_SMUX4_REG		0xE04401D0	/* PIO 159 ... 128 secundary alternate function pin mux select */
+#define GPIO_PIN_SMUX5_REG		0xE04401D4	/* PIO 191 ... 160 secundary alternate function pin mux select */
+#define GPIO_PIN_SMUX6_REG		0xE04401D8	/* PIO 223 ... 191 secundary alternate function pin mux select */
+
+#define LOCKCMD_REG			0xE0440120	/* to unlock some specific registers */
+#define LOCKSTAT_REG			0xE0440124	/* to unlock some specific registers */
+
+#define SREG_USB_ENABLE_REG		0xE0440138
+
+#define SREG_HS_CLK_DIV_CTRL0		0xE0440200
+#define SREG_HS_CLK_DIV_CTRL1		0xE0440204
+#define SREG_HS_CLK_DIV_CTRL2		0xE0440208
+#define SREG_HS_CLK_DIV_CTRL3		0xE044020C
+#define SREG_HS_CLK_DIV_CTRL4		0xE0440210
+#define SREG_HS_CLK_DIV_CTRL5		0xE0440214
+#define SREG_HS_CLK_DIV_CTRL6		0xE0440218
+#define SREG_HS_CLK_DIV_CTRL7		0xE044021C
+#define SREG_HS_CLK_DIV_CTRL8		0xE0440220
+#define SREG_HS_CLK_DIV_CTRL9		0xE0440224
+#define SREG_HS_CLK_MUX_CTRL0_REG	0xE0440228
+#define SREG_HS_CLK_MUX_CTRL1_REG	0xE044022C
+
+#define ITC_INTENABLE1_REG		0xE0450004	/* Group 1 Interrupt Enable Register */
+#define ITC_INTRIRQ1_REG		0xE0450008
+#define ITC_INTRCLR1_REG		0xE0450010
+#define ITC_INTENABLE2_REG		0xE0450024	/* Group 2 Interrupt Enable Register */
+#define ITC_INTRIRQ2_REG		0xE0450028
+#define ITC_INTRCLR2_REG		0xE0450030
+#define ITC_INTRIRQ3_REG		0xE0450048
+#define ITC_INTRCLR3_REG		0xE0450050
+
+#define IR1_STAT_REG			0xE0460010
+#define IR1_FIFO_REG			0xE0460040
+
+#define PIO_READ_REG			0xE0470000
+#define PIO_DRIVE_HIGH_REG		0xE0470004
+#define PIO_DRIVE_LOW_REG		0xE0470008
+#define PIO_DRIVE_OFF_REG		0xE047000C
+#define PIO_IRQSTAT_REG			0xE0470010
+
+#define MC_PRIORITY_PCI_REG		0xE0500008
+#define MC_PRIORITY_SATA1_REG		0xE050000C
+#define MC_PRIORITY_DMA0_REG		0xE0500010
+#define MC_PRIORITY_CRYPT_REG		0xE0500014
+#define MC_PRIORITY_JTAG_REG		0xE0500018
+#define MC_PRIORITY_JPEG_REG		0xE050001C
+
+#define MC_PRIORITY_SBM_REG		0xE0500028
+#define MC_PRIORITY_SSP_REG		0xE050002C
+#define MC_PRIORITY_SATA0_REG		0xE0500030
+
+#define MC_PRIORITY_TSP0_REG		0xE0500044
+#define MC_PRIORITY_TSP1_REG		0xE0500048
+#define MC_PRIORITY_TSR0_REG		0xE050004C
+#define MC_PRIORITY_TSR1_REG		0xE0500050
+#define MC_PRIORITY_BSP0_REG		0xE0500054
+#define MC_PRIORITY_BSP1_REG		0xE0500058
+
+#define MC_PRIORITY_AMP_REG		0xE0500060
+#define MC_PRIORITY_APP_REG		0xE0500064
+#define MC_PRIORITY_IMP0_REG		0xE0500068
+#define MC_PRIORITY_IMP1_REG		0xE050006C
+#define MC_PRIORITY_DPROC_INST_REG	0xE0500070
+#define MC_PRIORITY_DPROC_DATA_REG	0xE0500074
+#define MC_PRIORITY_CPM_REG		0xE0500078
+#define MC_PRIORITY_DMA1_REG		0xE050007C
+#define MC_PRIORITY_DNT_REG		0xE0500080
+
+#define MC_PRIORITY_DRM00_REG		0xE0500090
+#define MC_PRIORITY_DRM01_REG		0xE0500094
+#define MC_PRIORITY_DRM02_REG		0xE0500098
+#define MC_PRIORITY_DRM03_REG		0xE050009C
+#define MC_PRIORITY_DRM10_REG		0xE05000A0
+#define MC_PRIORITY_DRM11_REG		0xE05000A4
+#define MC_PRIORITY_DRM12_REG		0xE05000A8
+#define MC_PRIORITY_DRM13_REG		0xE05000AC
+#define MC_PRIORITY_POSTP0_REG		0xE05000B0
+#define MC_PRIORITY_POSTP1_REG		0xE05000B4
+#define MC_PRIORITY_GXA_REG		0xE05000B8
+#define MC_PRIORITY_NU12_REG		0xE05000BC
+#define MC_PRIORITY_MSDF0_REG		0xE05000C0
+#define MC_PRIORITY_MSDP0_REG		0xE05000C4
+#define MC_PRIORITY_MSDF1_REG		0xE05000C8
+#define MC_PRIORITY_MSDP1_REG		0xE05000CC
+#define MC_PRIORITY_MBF0_REG 		0xE05000D0
+#define MC_PRIORITY_MBP0_REG 		0xE05000D4
+#define MC_PRIORITY_MBF1_REG 		0xE05000D8
+#define MC_PRIORITY_MBP1_REG 		0xE05000DC
+
+#define MC_ATTR0_START_REG		0xE0500100
+#define MC_ATTR0_END_REG		0xE0500104
+#define MC_ATTR1_START_REG		0xE0500108
+#define MC_ATTR1_END_REG		0xE050010C
+#define MC_ATTR2_START_REG		0xE0500110
+#define MC_ATTR2_END_REG		0xE0500114
+#define MC_ATTR3_START_REG		0xE0500118
+#define MC_ATTR3_END_REG		0xE050011C
+#define MC_ATTR4_START_REG		0xE0500120
+#define MC_ATTR4_END_REG		0xE0500124
+#define MC_ATTR5_START_REG		0xE0500128
+#define MC_ATTR5_END_REG		0xE050012C
+#define MC_ATTR6_START_REG		0xE0500130
+#define MC_ATTR6_END_REG		0xE0500134
+#define MC_ATTR7_START_REG		0xE0500138
+#define MC_ATTR7_END_REG		0xE050013C
+#define MC_ATTR8_START_REG		0xE0500140
+#define MC_ATTR8_END_REG		0xE0500144
+#define MC_ATTR9_START_REG		0xE0500148
+#define MC_ATTR9_END_REG		0xE050014C
+#define MC_ATTR10_START_REG		0xE0500150
+#define MC_ATTR10_END_REG		0xE0500154
+#define MC_ATTR11_START_REG		0xE0500158
+#define MC_ATTR11_END_REG		0xE050015C
+#define MC_ATTR12_START_REG		0xE0500160
+#define MC_ATTR12_END_REG		0xE0500164
+#define MC_ATTR13_START_REG		0xE0500168
+#define MC_ATTR13_END_REG		0xE050016C
+#define MC_ATTR14_START_REG		0xE0500170
+#define MC_ATTR14_END_REG		0xE0500174
+#define MC_ATTR15_START_REG		0xE0500178
+#define MC_ATTR15_END_REG		0xE050017C
+#define MC_ATTR_WP_CTL_REG		0xE0500180
+#define MC_ATTR_INTR_EN_REG		0xE0500184
+#define MC_ATTR_INTR_STAT_REG		0xE0500188
+#define MC_ATTR_WP_LOG0_REG		0xE050018C
+#define MC_ATTR_WP_LOG1_REG		0xE0500190
+#define MC_ATTR_CONTENT_RD_LOG0_REG	0xE0500194
+#define MC_ATTR_CONTENT_RD_LOG1_REG	0xE0500198
+#define MC_ATTR_CONTENT_WR_LOG0_REG	0xE050019C
+#define MC_ATTR_CONTENT_WR_LOG1_REG	0xE05001A0
+#define MC_ATTR_CONTENT_CTL_REG		0xE05001A4
+
+#define MC_TILE0_START_REG		0xE0500200
+#define MC_TILE0_END_REG		0xE0500204
+#define MC_TILE0_CTL_REG		0xE0500208
+#define MC_TILE1_START_REG		0xE050020C
+#define MC_TILE1_END_REG		0xE0500210
+#define MC_TILE1_CTL_REG		0xE0500214
+#define MC_TILE2_START_REG		0xE0500218
+#define MC_TILE2_END_REG		0xE050021C
+#define MC_TILE2_CTL_REG		0xE0500220
+#define MC_TILE3_START_REG		0xE0500224
+#define MC_TILE3_END_REG		0xE0500228
+#define MC_TILE3_CTL_REG		0xE050022C
+#define MC_TILE4_START_REG		0xE0500230
+#define MC_TILE4_END_REG		0xE0500234
+#define MC_TILE4_CTL_REG		0xE0500238
+#define MC_TILE5_START_REG		0xE050023C
+#define MC_TILE5_END_REG		0xE0500240
+#define MC_TILE5_CTL_REG		0xE0500244
+#define MC_TILE6_START_REG		0xE0500248
+#define MC_TILE6_END_REG		0xE050024C
+#define MC_TILE6_CTL_REG		0xE0500250
+#define MC_TILE7_START_REG		0xE0500254
+#define MC_TILE7_END_REG		0xE0500258
+#define MC_TILE7_CTL_REG		0xE050025C
+#define MC_TILE_CFG_REG			0xE0500260
+
+#define MC_CFG0_REG			0xE0500300
+#define MC_CFG1_REG			0xE0500304
+#define MC_CFG2_REG			0xE0500308
+#define MC_PARAM0_REG			0xE050030C
+#define MC_PARAM1_REG			0xE0500310
+#define MC_PARAM2_REG			0xE0500314
+#define MC_PARAM3_REG			0xE0500318
+#define MC_PARAM4_REG			0xE050031C
+
+#define MC_MRS_REG			0xE0500320
+#define MC_EMRS1_REG			0xE0500324
+#define MC_EMRS2_REG			0xE0500328
+#define MC_EMRS3_REG			0xE050032C
+#define MC_DLL_CTL_CLOCK_REG		0xE0500330
+#define MC_DLL_CTL_SKEW_REG		0xE0500334
+#define MC_DLL_CTL_OVERRIDE0_REG	0xE0500338
+#define MC_DLL_CTL_OVERRIDE1_REG	0xE050033C
+#define MC_INTR_EN_REG			0xE0500340
+#define MC_INTR_STAT_REG		0xE0500344
+#define MC_THRESH0_REG			0xE0500348
+#define MC_THRESH1_REG			0xE050034C
+#define MC_CFG3_REG			0xE0500350
+#define MC_PARAM5_REG			0xE0500354
+#define MC_PARAM6_REG			0xE0500358
+#define MC_DRIVE0_REG			0xE050035C
+#define MC_DRIVE1_REG			0xE0500360
+#define MC_DRIVE2_REG			0xE0500364
+#define MC_DRIVE3_REG			0xE0500368
+#define MC_DRIVE4_REG			0xE050036C
+#define MC_O_DELAY_REG			0xE0500370
+
+#define MEM_PLL_CTRL0_REG		0xE0500800
+#define MEM_PLL_CTRL1_REG		0xE0500804
+#define MEM_PLL_CTRL2_REG		0xE0500808
+#define MEM_PLL_CTRL3_REG		0xE050080C
+
+#define MC_CTL_REG		 	0xE0500380
+
+#define MC_RING_CTL_REG			0xE050039C
+#define MC_RING_FREQUENCY_REG		0xE05003A0
+
+#define MC_EVENT_SEL0_REG		0xE0500500
+#define MC_EVENT_SEL1_REG		0xE0500504
+#define MC_EVENT_CTL_REG		0xE0500508
+#define MC_EVENT_TIM_REG		0xE050050C
+#define MC_EVENT_CNT0_REG		0xE0500510
+#define MC_EVENT_CNT1_REG		0xE0500514
+#define MC_EVENT_CNT2_REG		0xE0500518
+#define MC_EVENT_CNT3_REG		0xE050051C
+#define MC_EVENT_CNT4_REG		0xE0500520
+#define MC_EVENT_CNT5_REG		0xE0500524
+
+#define MC_DBG_CTL_REG			0xE0500640
+
+#define MC_PRIORITY_ARM_INST		0xE0500700
+#define MC_PRIORITY_ARM_DATA		0xE0500704
+#define MC_PRIORITY_USB0		0xE0500720
+#define MC_PRIORITY_USB1		0xE0500724
+#define MC_PRIORITY_USB2		0xE0500728
+#define MC_PRIORITY_EMAC0		0xE050072C
+#define MC_PRIORITY_EMAC1		0xE0500730
+#define MC_PRIORITY_MCARD0		0xE0500734
+#define MC_PRIORITY_BUS4_WR_REG		0xE0500740
+
+#define MC_CFG0_M1_REG			0xE0500900
+#define MC_CFG1_M1_REG			0xE0500904
+#define MC_PARAM0_M1_REG		0xE050090C
+#define MC_PARAM1_M1_REG		0xE0500910
+#define MC_PARAM2_M1_REG		0xE0500914
+#define MC_PARAM3_M1_REG		0xE0500918
+#define MC_PARAM4_M1_REG		0xE050091C
+#define MC_MRS_M1_REG			0xE0500920
+#define MC_EMRS1_M1_REG			0xE0500924
+#define MC_EMRS2_M1_REG			0xE0500928
+#define MC_EMRS3_M1_REG			0xE050092C
+#define MC_PARAM5_M1_REG		0xE0500954
+#define MC_PARAM6_M1_REG		0xE0500958
+#define MC_O_DELAY_M1_REG		0xE0500970
+
+#define EMAC_ID_REG			0xE8003000
+#define EMAC_STAT_REG			0xE8003004
+#define EMAC_ENABLE_REG			0xE8003008
+#define EMAC_CTRL_REG			0xE800300C
+#define EMAC_POLLR_REG			0xE8003010
+
+#define EMAC_TXRINGPTR_REG		0xE800301C
+#define EMAC_RXRINGPTR_REG		0xE8003020
+#define EMAC_ADDRL_REG			0xE8003024
+#define EMAC_ADDRH_REG			0xE8003028
+#define EMAC_LAFL_REG			0xE800302C
+#define EMAC_LAFH_REG			0xE8003030
+#define EMAC_MDIO_DATA_REG		0xE8003034
+#define EMAC_RXRINGREAD_REG		0xE800303C
+
+#define EMAC_XCTRL_REG			0xE8003040
+#define EMAC_XSTAT_REG			0xE8003044
+
+#endif	/* __NEVIS_H__ */
diff --git a/include/asm-arm/arch-nevis/sizes.h b/include/asm-arm/arch-nevis/sizes.h
new file mode 100644
index 0000000..aaba18f
--- /dev/null
+++ b/include/asm-arm/arch-nevis/sizes.h
@@ -0,0 +1,49 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307	 USA
+ */
+/*  Size defintions
+ *  Copyright (C) ARM Limited 1998. All rights reserved.
+ */
+
+#ifndef __sizes_h
+#define __sizes_h			1
+
+/* handy sizes */
+#define SZ_1K				0x00000400
+#define SZ_4K				0x00001000
+#define SZ_8K				0x00002000
+#define SZ_16K				0x00004000
+#define SZ_32K				0x00008000
+#define SZ_64K				0x00010000
+#define SZ_128K				0x00020000
+#define SZ_256K				0x00040000
+#define SZ_512K				0x00080000
+
+#define SZ_1M				0x00100000
+#define SZ_2M				0x00200000
+#define SZ_4M				0x00400000
+#define SZ_8M				0x00800000
+#define SZ_16M				0x01000000
+#define SZ_31M				0x01F00000
+#define SZ_32M				0x02000000
+#define SZ_64M				0x04000000
+#define SZ_128M				0x08000000
+#define SZ_256M				0x10000000
+#define SZ_512M				0x20000000
+
+#define SZ_1G				0x40000000
+#define SZ_2G				0x80000000
+
+#endif	/* __sizes_h */
diff --git a/include/asm-arm/arch-nevis/sys_proto.h b/include/asm-arm/arch-nevis/sys_proto.h
new file mode 100644
index 0000000..ac679c3
--- /dev/null
+++ b/include/asm-arm/arch-nevis/sys_proto.h
@@ -0,0 +1,78 @@
+/*
+ * (C) Copyright 2008
+ * Coolstream International Limited
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR /PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+  */
+#ifndef _NEVIS_SYS_PROTO_H_
+#define _NEVIS_SYS_PROTO_H_
+
+#define PIO_HIGH	PIO_DRIVE_HIGH_REG	/* drive PIO HIGH */
+#define PIO_LOW		PIO_DRIVE_LOW_REG	/* drive PIO LOW */
+#define PIO_OFF		PIO_DRIVE_OFF_REG	/* switch PIO into input mode */
+
+#define	SYSFLAG_FULLERASE	0x80000000	/* enabled the flash routines to erase/write the boot sector itself */
+
+/* board/<board>/interrupt.c */
+#ifdef CONFIG_USE_IRQ
+void board_init_itc(void);
+int board_do_interrupt(struct pt_regs *pt_regs);
+void board_disable_all_interrupts(void);
+#endif
+
+/* board/<board>/gpio.c */
+void board_gpio_drive(u32 pio, u32 state);
+u32 board_gpio_read(u32 pio);
+
+/* board/<board>/network.c */
+void board_eth_init(void);		/* our low level init, only called once */
+int eth_init(bd_t * bis);		/* called from u-boot's network subsys multiple times */
+int eth_handle_interrupt(void);
+
+/* board/<board>/display.c */
+typedef enum {
+	VFD_LED_1_ON		= 0x81,
+	VFD_LED_2_ON		= 0x82,
+	VFD_LED_3_ON		= 0x83,
+	VFD_LED_1_OFF		= 0x01,
+	VFD_LED_2_OFF		= 0x02,
+	VFD_LED_3_OFF		= 0x03,
+} vfd_led_ctrl_t;
+
+void board_display_init(void);
+void display_set_text(char *text);
+void display_show_progress(u32 first, u32 last, u32 current);
+void board_display_clear(void);
+void display_show_icon(u32 icon, u32 clear);
+void display_led_control(vfd_led_ctrl_t ctrl);
+
+/* board/<board>/flash.c */
+void flash_set_flag(void);
+#ifdef CONFIG_SYS_FLASH_OTP
+int flash_dump_otp(flash_info_t *info);
+int flash_write_otp(flash_info_t *info, uchar *data, ulong cnt);
+#endif /* CONFIG_SYS_FLASH_OTP */
+
+/* board/<board>/splash.c */
+u32 board_get_width(void);
+u32 board_get_height(void);
+
+/* cpu/arm1176/nevis/misc.c */
+void LockRegs(u32 mask);
+void UnlockRegs(u32 mask);
+void CleanupBeforeLinux(void);
+
+#endif
diff --git a/include/asm-arm/setup.h b/include/asm-arm/setup.h
index 89df4dc..729660e 100644
--- a/include/asm-arm/setup.h
+++ b/include/asm-arm/setup.h
@@ -205,10 +205,17 @@ struct tag_memclk {
 	u32 fmemclk;
 };
 
+#define ATAG_MAC       0x5441000A
+
+struct tag_mac {
+        u8 mac_address[6];
+};
+
 struct tag {
 	struct tag_header hdr;
 	union {
 		struct tag_core		core;
+		struct tag_mac          mac;
 		struct tag_mem32	mem;
 		struct tag_videotext	videotext;
 		struct tag_ramdisk	ramdisk;
diff --git a/include/common.h b/include/common.h
index b75ea60..bbd630d 100644
--- a/include/common.h
+++ b/include/common.h
@@ -297,6 +297,10 @@ void	pciinfo	      (int, int);
 int	misc_init_f   (void);
 int	misc_init_r   (void);
 
+#ifdef CONFIG_MISC_INIT_P
+int     misc_init_p   (void);
+#endif
+
 /* common/exports.c */
 void	jumptable_init(void);
 
diff --git a/include/configs/coolstream_hdx.h b/include/configs/coolstream_hdx.h
new file mode 100644
index 0000000..49e9958
--- /dev/null
+++ b/include/configs/coolstream_hdx.h
@@ -0,0 +1,205 @@
+/*
+ * Configuration for the HD1 board (Satellite HDTV capable Set-Top-Box)
+ *
+ * (C) Copyright 2008
+ * Coolstream International Limited
+ *
+ * Configuration settings for Coolstream's HD1 STB board.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <asm/arch/nevis.h>				/* get chip and board defs */
+
+#define LITTLEENDIAN		1			/* we have an LE architecture */
+
+/* High Level Configuration Options */
+#define CONFIG_ARM1176		1			/* We have an ARM1176 CPU core */
+#define CONFIG_NEVIS		1			/* in an CX2450x (Nevis) SoC */
+
+#define PRODUCT_NAME		"Coolstream HDx"	/* up to 24 characters */
+#define VENDOR_VERSION		"0.9"			/* vendor specific version string, apended to u-boots version string */
+
+#define CONFIG_USE_IRQ                 			/* no support for IRQs at this time */
+#define CONFIG_MISC_INIT_P				/* we have some additional inits to do */
+
+#define CONFIG_CMDLINE_TAG		0		/* enable passing kernel commandline tags */
+#define CONFIG_SETUP_MEMORY_TAGS	1
+#define CONFIG_DECARM_TAG		1
+#define CONFIG_MAC_TAG			1
+#define CONFIG_SERIAL_TAG		1
+#define CONFIG_REVISION_TAG		1
+
+#define CONFIG_FIXED_MEM_START		0x00000000
+#define CONFIG_FIXED_MEM_SIZE		0x18000000
+
+#define CONFIG_ARM9_RESET_ADDR			0x10000
+#define CONFIG_ARM9_SETUP_LEGACY_MODE		0
+#define CONFIG_ARM9_OFFSET			0x1000
+#define CONFIG_ARM9_OFFSET_LEGACY		0x0040
+#define CONFIG_ARM9_SHARED_CODE_OFFSET		(CONFIG_ARM9_OFFSET + 0x0000)
+#define CONFIG_ARM9_SHARED_RAM_OFFSET		(CONFIG_ARM9_OFFSET + 0x0004)
+#define CONFIG_ARM9_SHARED_CODE_OFFSET_LEGACY	(CONFIG_ARM9_OFFSET_LEGACY + 0x0000)
+#define CONFIG_ARM9_SHARED_RAM_OFFSET_LEGACY	(CONFIG_ARM9_OFFSET_LEAGCY + 0x0004)
+#define CONFIG_LOAD_INITIAL_DECARM_CODE	1		/* the ARM9 co-processor must be initialized with default code */
+
+/* Size of malloc() pool */
+#define CONFIG_ENV_SIZE			SZ_128K		/* Total Size of Environment Sector */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + SZ_4M)
+#define CONFIG_SYS_GBL_DATA_SIZE	128		/* size in bytes reserved for initial data */
+
+/* Hardware drivers */
+
+/* serial VFD module */
+#define HAVE_COOLSTREAM_VFD_CONTROLLER	1
+
+#ifdef HAVE_COOLSTREAM_VFD_CONTROLLER
+#define DISPLAY_PIO_CLOCK		8		/* PIO for the clock */
+#define DISPLAY_PIO_RESET		9		/* PIO to reset the controller (1 = reset, 0 = normal operation) */
+#define DISPLAY_PIO_DATA		68		/* PIO for the serial data */
+#define DISPLAY_PIO_STATUS		189		/* PIO to read the status from the controller */
+#endif /* HAVE_COOLSTREAM_VFD_CONTROLLER */
+
+/* select serial console configuration */
+#define CONFIG_SERIAL3					/* we use the 3. serial port (UART) for console communication */
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_SYS_BAUDRATE_TABLE	{9600, 19200, 38400, 57600, 115200}
+#define CONFIG_SYS_CONSOLE_INFO_QUIET
+
+/* Command line commands configuration. */
+#define CONFIG_CMD_AUTOSCRIPT				/* Autoscript Support                                          	*/
+#define CONFIG_CMD_BDI					/* bdinfo                                                      	*/
+#define CONFIG_CMD_BOOTD				/* bootd                                                       	*/
+#define CONFIG_CMD_CONSOLE				/* coninfo                                                     	*/
+#define CONFIG_CMD_DIAG					/* Diagnostics                                                 	*/
+#define CONFIG_CMD_ENV					/* saveenv                                                     	*/
+#define CONFIG_CMD_FLASH				/* flinfo, erase, protect                                      	*/
+#define CONFIG_CMD_IMI					/* iminfo                                                     	*/
+#define CONFIG_CMD_IMLS					/* List all found images                                      	*/
+#define CONFIG_CMD_ITEST				/* Integer (and string) test (required for CMD_ENV, CMD_FLASH)	*/
+#define CONFIG_CMD_MEMORY				/* md mm nm mw cp cmp crc base loop mtest                     	*/
+#define CONFIG_CMD_NET					/* bootp, tftpboot, rarpboot                                  	*/
+#define CONFIG_CMD_PING					/* ping support                                               	*/
+#define CONFIG_CMD_USB					/* we wanna have USB-support					*/
+#define CONFIG_CMD_SAVEENV				/* saveenv							*/
+#define CONFIG_CMD_EXT2					/* EXT2 support							*/
+#define CONFIG_CMD_FAT					/* FAT/VFAT support						*/
+#define CONFIG_CMD_JFFS2				/* JFFS2 support						*/
+
+/* default Network configuration */
+#define CONFIG_NETMASK			255.255.255.0
+#define CONFIG_IPADDR			192.168.1.100
+#define CONFIG_SERVERIP			192.168.1.16
+#define CONFIG_BOOTFILE			"uImage"
+
+/* default boot configiguration */
+#define CONFIG_BOOTDELAY        	1
+#define CONFIG_BOOTARGS			"console=ttyRI0 mtdparts=cx2450xflash:384k(U-Boot),128k(Splash),4096k(kernel),28160k(systemFS) root=mtd3 rootfstype=jffs2 rw mem=384M"
+#define CONFIG_BOOTCOMMAND		"bootm 0xF0080000"	/* load and execute the Kernel from Flash at address 0xF0080000 */
+//#define CONFIG_BOOTCOMMAND		"bootp; bootm"		/* load from network (bootp = dhcp + tftp) */
+
+#define CONFIG_NETMASK          255.255.255.0
+#define CONFIG_IPADDR           192.168.1.100
+#define CONFIG_SERVERIP         192.168.1.16
+#define CONFIG_BOOTFILE         "uImage"
+
+/* Miscellaneous configurable options */
+#define CONFIG_SYS_PROMPT 		"HDx> "
+#define CONFIG_SYS_CBSIZE		256				/* Console I/O Buffer Size */
+
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_MAXARGS		16				/* max number of command args */
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE		/* Boot Argument Buffer Size */
+
+#define CONFIG_SYS_MEMTEST_START	0x02000000			/* memtest works on */
+#define CONFIG_SYS_MEMTEST_END		0x02F00000			/* dummy to provide a area for the test. We have more RAM than tested */
+
+#define CONFIG_SYS_LOAD_ADDR		0x0E000000			/* the DEFAULT load address */
+#define CONFIG_SYS_MAXARGS		16				/* maximum number of arguments for the 'go' command */
+
+#define CONFIG_SYS_HZ			1000000				/* system timer is clocked with 54 MHz and divides the clock by 54 which results in 1 MHz or in other words 1us per clock */
+#define CFG_HZ				CONFIG_SYS_HZ
+
+/* Stack sizesn (are set up in start.S using the settings below) */
+#define CONFIG_STACKSIZE		SZ_1M				/* regular stack */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ		SZ_16K				/* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ		SZ_16K				/* FIQ stack */
+#endif
+
+/* Physical Memory Map */
+#define CONFIG_NR_DRAM_BANKS    	2				/* Nevis can handle 2 DDR2-SDRAM banks */
+#define PHYS_FLASH			0xF0000000			/* Flash Bank #1 fixed start address */
+
+/* FLASH and environment organization */
+#define	CONFIG_ENV_IS_IN_FLASH		1				/* we can store a user config into the flash */
+
+#define CONFIG_SYS_FLASH_BASE		PHYS_FLASH
+#define CONFIG_SYS_FLASH_OTP		1				/* we use flash with an additional small OTP sector */
+#define CONFIG_SYS_MAX_FLASH_SECT	(2048)				/* define more than avail to have secure auto detect */
+#define CONFIG_SYS_MAX_FLASH_BANKS	2				/* we limit to 2 banks at CS0 and CS1. CS2 and above are for I/O */
+#define CONFIG_SYS_MONITOR_BASE		CONFIG_SYS_FLASH_BASE		/* u-boot is located at the bottom in the flash */
+#define CONFIG_ENV_ADDR			(CONFIG_SYS_FLASH_BASE + SZ_256K)
+
+#define CFG_EXT_LEGACY_FLASH		1				/* assume we have a little bit more modern flashes than an 29400 ;-) */
+#define CONFIG_SYS_FLASH_PROTECTION	1				/* Use hardware sector protection */
+
+/* USB support */
+#define CONFIG_USB_EHCI			1				/* we have an EHCI USB-Host Controller */
+#define CONFIG_USB_EHCI_CX2450X		1				/* tell the EHCI core to use our CX2450X host controller */
+#define CONFIG_USB_STORAGE		1				/* we wanna have storage support */
+#define CONFIG_EHCI_IS_TDI		1
+#define CONFIG_SYS_USB_EHCI_MAX_ROOT_PORTS 2
+
+/* Filesystems */
+#define CONFIG_DOS_PARTITION		1
+
+/* misc stuff */
+#define BEAUTIFY_CONSOLE		1				/* make the console output nicer by using some ANSI graphics */
+#define CONFIG_DISPLAY_CPUINFO		1
+
+/* New stuff */
+#ifdef CONFIG_CMD_JFFS2
+#undef CONFIG_CMD_MTDPARTS
+#define CONFIG_SYS_FLASH0_BASE		CONFIG_SYS_FLASH_BASE
+#define CONFIG_JFFS2_DEV		"nor0"
+#define CONFIG_JFFS2_PART_SIZE		(0x01B80000)
+#define CONFIG_JFFS2_PART_OFFSET	(0x00480000)
+#define CONFIG_SYS_JFFS2_NUM_BANKS	CONFIG_SYS_MAX_FLASH_BANKS
+#define CONFIG_SYS_JFFS2_SORT_FRAGMENTS
+#endif
+
+#define CONFIG_VIDEO_LOGO
+#define CONFIG_SPLASH_SCREEN		
+#define CONFIG_CFB_CONSOLE		
+#define VIDEO_KBD_INIT_FCT		-1
+#define VIDEO_TSTC_FCT		serial_tstc
+#define VIDEO_GETC_FCT		serial_getc
+#define CONFIG_VIDEO_BMP_GZIP		
+#define CONFIG_SYS_VIDEO_LOGO_MAX_SIZE	(1 << 21)
+
+#define CONFIG_EXTRA_ENV_SETTINGS			\
+		"splashimage=f0060000\0"		\
+		""
+
+#endif /* __CONFIG_H */
diff --git a/include/flash.h b/include/flash.h
index 8b8979e..a56faae 100644
--- a/include/flash.h
+++ b/include/flash.h
@@ -30,32 +30,45 @@
  */
 
 typedef struct {
-	ulong	size;			/* total bank size in bytes		*/
-	ushort	sector_count;		/* number of erase units		*/
-	ulong	flash_id;		/* combined device & manufacturer code	*/
-	ulong	start[CONFIG_SYS_MAX_FLASH_SECT];   /* virtual sector start address */
-	uchar	protect[CONFIG_SYS_MAX_FLASH_SECT]; /* sector protection status	*/
+	ulong   size;                   /* total bank size in bytes               	 */
+	ushort  sector_count;           /* number of erase units                  	 */
+	ulong   flash_id;               /* combined device & manufacturer code    	 */
+	ulong   start[CONFIG_SYS_MAX_FLASH_SECT];   /* physical sector start addresses   */
+	uchar   protect[CONFIG_SYS_MAX_FLASH_SECT]; /* sector protection status          */
 #ifdef CONFIG_SYS_FLASH_CFI
-	uchar	portwidth;		/* the width of the port		*/
-	uchar	chipwidth;		/* the width of the chip		*/
-	ushort	buffer_size;		/* # of bytes in write buffer		*/
-	ulong	erase_blk_tout;		/* maximum block erase timeout		*/
-	ulong	write_tout;		/* maximum write timeout		*/
-	ulong	buffer_write_tout;	/* maximum buffer write timeout		*/
-	ushort	vendor;			/* the primary vendor id		*/
-	ushort	cmd_reset;		/* vendor specific reset command	*/
-	ushort	interface;		/* used for x8/x16 adjustments		*/
-	ushort	legacy_unlock;		/* support Intel legacy (un)locking	*/
-	uchar	manufacturer_id;	/* manufacturer id			*/
-	ushort	device_id;		/* device id				*/
-	ushort	device_id2;		/* extended device id			*/
-	ushort	ext_addr;		/* extended query table address		*/
-	ushort	cfi_version;		/* cfi version				*/
-	ushort	cfi_offset;		/* offset for cfi query			*/
-	ulong   addr_unlock1;		/* unlock address 1 for AMD flash roms  */
-	ulong   addr_unlock2;		/* unlock address 2 for AMD flash roms  */
-	const char *name;		/* human-readable name	                */
+	uchar	portwidth;		/* the width of the port			 */
+	uchar	chipwidth;		/* the width of the chip			 */
+	ushort	buffer_size;		/* # of bytes in write buffer			 */
+	ulong	erase_blk_tout;		/* maximum block erase timeout			 */
+	ulong	write_tout;		/* maximum write timeout			 */
+	ulong	buffer_write_tout;	/* maximum buffer write timeout			 */
+	ushort	vendor;			/* the primary vendor id			 */
+	ushort	cmd_reset;		/* vendor specific reset command		 */
+	ushort	interface;		/* used for x8/x16 adjustments			 */
+	ushort	legacy_unlock;		/* support Intel legacy (un)locking		 */
+	uchar	manufacturer_id;	/* manufacturer id				 */
+	ushort	device_id;		/* device id					 */
+	ushort	device_id2;		/* extended device id				 */
+	ushort	ext_addr;		/* extended query table address			 */
+	ushort	cfi_version;		/* cfi version					 */
+	ushort	cfi_offset;		/* offset for cfi query				 */
+	ulong   addr_unlock1;		/* unlock address 1 for AMD flash roms  	 */
+	ulong   addr_unlock2;		/* unlock address 2 for AMD flash roms  	 */
+	const char *name;		/* human-readable name	                	 */
 #endif
+#ifdef CFG_EXT_LEGACY_FLASH
+	/* newer flashes have multiple ID's... manufactor, device group, deivce id, ...  */
+#ifndef CFG_FLASH_CFI
+	const char *name;               /* human-readable name                    	 */
+	ushort  manufacturer_id;        /* manufacturer id                        	 */
+	ushort  device_id;              /* device id                              	 */
+	ushort  device_id2;             /* extended device id 1                   	 */
+	char    serial[8];              /* serial number, if available            	 */
+#endif
+	ushort  device_id3;             /* extended device id 2                   	 */
+	ulong   sector_size;            /* makes life easier for uniform sector   	 */
+	ulong   bank_number;            /* makes life easier for more than 1 bank 	 */
+#endif /* CFG_EXT_LEGACY_FLASH */
 } flash_info_t;
 
 typedef unsigned long flash_sect_t;
@@ -124,9 +137,6 @@ extern int jedec_flash_match(flash_info_t *info, ulong base);
 #define CFI_CMDSET_AMD_LEGACY		0xFFF0
 #endif
 
-#if defined(CONFIG_SYS_FLASH_CFI)
-extern flash_info_t *flash_get_info(ulong base);
-#endif
 
 /*-----------------------------------------------------------------------
  * return codes from flash_write():
diff --git a/include/flash.h.org b/include/flash.h.org
new file mode 100644
index 0000000..8b8979e
--- /dev/null
+++ b/include/flash.h.org
@@ -0,0 +1,506 @@
+/*
+ * (C) Copyright 2000-2005
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _FLASH_H_
+#define _FLASH_H_
+
+#ifndef CONFIG_SYS_NO_FLASH
+/*-----------------------------------------------------------------------
+ * FLASH Info: contains chip specific data, per FLASH bank
+ */
+
+typedef struct {
+	ulong	size;			/* total bank size in bytes		*/
+	ushort	sector_count;		/* number of erase units		*/
+	ulong	flash_id;		/* combined device & manufacturer code	*/
+	ulong	start[CONFIG_SYS_MAX_FLASH_SECT];   /* virtual sector start address */
+	uchar	protect[CONFIG_SYS_MAX_FLASH_SECT]; /* sector protection status	*/
+#ifdef CONFIG_SYS_FLASH_CFI
+	uchar	portwidth;		/* the width of the port		*/
+	uchar	chipwidth;		/* the width of the chip		*/
+	ushort	buffer_size;		/* # of bytes in write buffer		*/
+	ulong	erase_blk_tout;		/* maximum block erase timeout		*/
+	ulong	write_tout;		/* maximum write timeout		*/
+	ulong	buffer_write_tout;	/* maximum buffer write timeout		*/
+	ushort	vendor;			/* the primary vendor id		*/
+	ushort	cmd_reset;		/* vendor specific reset command	*/
+	ushort	interface;		/* used for x8/x16 adjustments		*/
+	ushort	legacy_unlock;		/* support Intel legacy (un)locking	*/
+	uchar	manufacturer_id;	/* manufacturer id			*/
+	ushort	device_id;		/* device id				*/
+	ushort	device_id2;		/* extended device id			*/
+	ushort	ext_addr;		/* extended query table address		*/
+	ushort	cfi_version;		/* cfi version				*/
+	ushort	cfi_offset;		/* offset for cfi query			*/
+	ulong   addr_unlock1;		/* unlock address 1 for AMD flash roms  */
+	ulong   addr_unlock2;		/* unlock address 2 for AMD flash roms  */
+	const char *name;		/* human-readable name	                */
+#endif
+} flash_info_t;
+
+typedef unsigned long flash_sect_t;
+
+/*
+ * Values for the width of the port
+ */
+#define FLASH_CFI_8BIT		0x01
+#define FLASH_CFI_16BIT		0x02
+#define FLASH_CFI_32BIT		0x04
+#define FLASH_CFI_64BIT		0x08
+/*
+ * Values for the width of the chip
+ */
+#define FLASH_CFI_BY8		0x01
+#define FLASH_CFI_BY16		0x02
+#define FLASH_CFI_BY32		0x04
+#define FLASH_CFI_BY64		0x08
+/* convert between bit value and numeric value */
+#define CFI_FLASH_SHIFT_WIDTH	3
+/*
+ * Values for the flash device interface
+ */
+#define FLASH_CFI_X8		0x00
+#define FLASH_CFI_X16		0x01
+#define FLASH_CFI_X8X16		0x02
+#define FLASH_CFI_X16X32	0x05
+
+/* convert between bit value and numeric value */
+#define CFI_FLASH_SHIFT_WIDTH	3
+
+/* cfi-mtd device name */
+#define	CFI_MTD_DEV_NAME	"cfi-mtd"
+/* Prototypes */
+
+extern unsigned long flash_init (void);
+extern void flash_print_info (flash_info_t *);
+extern int flash_erase	(flash_info_t *, int, int);
+extern int flash_sect_erase (ulong addr_first, ulong addr_last);
+extern int flash_sect_protect (int flag, ulong addr_first, ulong addr_last);
+extern int flash_sect_roundb (ulong *addr);
+extern unsigned long flash_sector_size(flash_info_t *info, flash_sect_t sect);
+extern void flash_set_verbose(uint);
+
+/* common/flash.c */
+extern void flash_protect (int flag, ulong from, ulong to, flash_info_t *info);
+extern int flash_write (char *, ulong, ulong);
+extern flash_info_t *addr2info (ulong);
+extern int write_buff (flash_info_t *info, uchar *src, ulong addr, ulong cnt);
+
+/* drivers/mtd/cfi_mtd.c */
+#ifdef CONFIG_FLASH_CFI_MTD
+extern int cfi_mtd_init(void);
+#endif
+
+/* board/?/flash.c */
+#if defined(CONFIG_SYS_FLASH_PROTECTION)
+extern int flash_real_protect(flash_info_t *info, long sector, int prot);
+extern void flash_read_user_serial(flash_info_t * info, void * buffer, int offset, int len);
+extern void flash_read_factory_serial(flash_info_t * info, void * buffer, int offset, int len);
+#endif	/* CONFIG_SYS_FLASH_PROTECTION */
+
+#ifdef CONFIG_FLASH_CFI_LEGACY
+extern ulong board_flash_get_legacy(ulong base, int banknum, flash_info_t *info);
+extern int jedec_flash_match(flash_info_t *info, ulong base);
+#define CFI_CMDSET_AMD_LEGACY		0xFFF0
+#endif
+
+#if defined(CONFIG_SYS_FLASH_CFI)
+extern flash_info_t *flash_get_info(ulong base);
+#endif
+
+/*-----------------------------------------------------------------------
+ * return codes from flash_write():
+ */
+#define ERR_OK				0
+#define ERR_TIMOUT			1
+#define ERR_NOT_ERASED			2
+#define ERR_PROTECTED			4
+#define ERR_INVAL			8
+#define ERR_ALIGN			16
+#define ERR_UNKNOWN_FLASH_VENDOR	32
+#define ERR_UNKNOWN_FLASH_TYPE		64
+#define ERR_PROG_ERROR			128
+
+/*-----------------------------------------------------------------------
+ * Protection Flags for flash_protect():
+ */
+#define FLAG_PROTECT_SET	0x01
+#define FLAG_PROTECT_CLEAR	0x02
+#define	FLAG_PROTECT_INVALID	0x03
+/*-----------------------------------------------------------------------
+ * Set Environment according to label:
+ */
+#define	FLAG_SETENV		0x80
+
+/*-----------------------------------------------------------------------
+ * Device IDs
+ */
+
+#define AMD_MANUFACT	0x00010001	/* AMD	   manuf. ID in D23..D16, D7..D0 */
+#define FUJ_MANUFACT	0x00040004	/* FUJITSU manuf. ID in D23..D16, D7..D0 */
+#define ATM_MANUFACT	0x001F001F	/* ATMEL */
+#define STM_MANUFACT	0x00200020	/* STM (Thomson) manuf. ID in D23.. -"- */
+#define SST_MANUFACT	0x00BF00BF	/* SST	   manuf. ID in D23..D16, D7..D0 */
+#define MT_MANUFACT	0x00890089	/* MT	   manuf. ID in D23..D16, D7..D0 */
+#define INTEL_MANUFACT	0x00890089	/* INTEL   manuf. ID in D23..D16, D7..D0 */
+#define INTEL_ALT_MANU	0x00B000B0	/* alternate INTEL namufacturer ID	*/
+#define MX_MANUFACT	0x00C200C2	/* MXIC	   manuf. ID in D23..D16, D7..D0 */
+#define TOSH_MANUFACT	0x00980098	/* TOSHIBA manuf. ID in D23..D16, D7..D0 */
+#define MT2_MANUFACT	0x002C002C	/* alternate MICRON manufacturer ID*/
+#define EXCEL_MANUFACT	0x004A004A	/* Excel Semiconductor			*/
+
+					/* Micron Technologies (INTEL compat.)	*/
+#define MT_ID_28F400_T	0x44704470	/* 28F400B3 ID ( 4 M, top boot sector)	*/
+#define MT_ID_28F400_B	0x44714471	/* 28F400B3 ID ( 4 M, bottom boot sect) */
+
+#define AMD_ID_LV040B	0x4F		/* 29LV040B ID				*/
+					/* 4 Mbit, 512K x 8,			*/
+					/* 8 64K x 8 uniform sectors		*/
+#define AMD_ID_F033C	0xA3		/* 29LV033C ID				*/
+					/* 32 Mbit, 4Mbits x 8,			*/
+					/* 64 64K x 8 uniform sectors		*/
+#define AMD_ID_F065D	0x93		/* 29LV065D ID				*/
+					/* 64 Mbit, 8Mbits x 8,			*/
+					/* 126 64K x 8 uniform sectors		*/
+#define ATM_ID_LV040	0x13		/* 29LV040B ID				*/
+					/* 4 Mbit, 512K x 8,			*/
+					/* 8 64K x 8 uniform sectors		*/
+#define AMD_ID_F040B	0xA4		/* 29F040B ID				*/
+					/* 4 Mbit, 512K x 8,			*/
+					/* 8 64K x 8 uniform sectors		*/
+#define STM_ID_M29W040B 0xE3		/* M29W040B ID				*/
+					/* 4 Mbit, 512K x 8,			*/
+					/* 8 64K x 8 uniform sectors		*/
+#define AMD_ID_F080B	0xD5		/* 29F080  ID  ( 1 M)			*/
+					/* 8 Mbit, 512K x 16,			*/
+					/* 8 64K x 16 uniform sectors		*/
+#define AMD_ID_F016D	0xAD		/* 29F016  ID  ( 2 M x 8)		*/
+#define AMD_ID_F032B	0x41		/* 29F032  ID  ( 4 M x 8)		*/
+#define AMD_ID_LV116DT	0xC7		/* 29LV116DT   ( 2 M x 8, top boot sect) */
+#define AMD_ID_LV116DB	0x4C		/* 29LV116DB   ( 2 M x 8, bottom boot sect) */
+#define AMD_ID_LV016B	0xc8		/* 29LV016 ID  ( 2 M x 8)		*/
+
+#define AMD_ID_PL160CB	0x22452245	/* 29PL160CB ID (16 M, bottom boot sect */
+
+#define AMD_ID_LV400T	0x22B922B9	/* 29LV400T ID ( 4 M, top boot sector)	*/
+#define AMD_ID_LV400B	0x22BA22BA	/* 29LV400B ID ( 4 M, bottom boot sect) */
+
+#define AMD_ID_LV033C	0xA3		/* 29LV033C ID ( 4 M x 8)		*/
+#define AMD_ID_LV065D	0x93		/* 29LV065D ID ( 8 M x 8)		*/
+
+#define AMD_ID_LV800T	0x22DA22DA	/* 29LV800T ID ( 8 M, top boot sector)	*/
+#define AMD_ID_LV800B	0x225B225B	/* 29LV800B ID ( 8 M, bottom boot sect) */
+
+#define AMD_ID_LV160T	0x22C422C4	/* 29LV160T ID (16 M, top boot sector)	*/
+#define AMD_ID_LV160B	0x22492249	/* 29LV160B ID (16 M, bottom boot sect) */
+
+#define AMD_ID_DL163T	0x22282228	/* 29DL163T ID (16 M, top boot sector)	*/
+#define AMD_ID_DL163B	0x222B222B	/* 29DL163B ID (16 M, bottom boot sect) */
+
+#define AMD_ID_LV320T	0x22F622F6	/* 29LV320T ID (32 M, top boot sector)	*/
+#define MX_ID_LV320T	0x22A722A7	/* 29LV320T by Macronix, AMD compatible */
+#define AMD_ID_LV320B	0x22F922F9	/* 29LV320B ID (32 M, bottom boot sect) */
+#define MX_ID_LV320B	0x22A822A8	/* 29LV320B by Macronix, AMD compatible */
+
+#define AMD_ID_DL322T	0x22552255	/* 29DL322T ID (32 M, top boot sector)	*/
+#define AMD_ID_DL322B	0x22562256	/* 29DL322B ID (32 M, bottom boot sect) */
+#define AMD_ID_DL323T	0x22502250	/* 29DL323T ID (32 M, top boot sector)	*/
+#define AMD_ID_DL323B	0x22532253	/* 29DL323B ID (32 M, bottom boot sect) */
+#define AMD_ID_DL324T	0x225C225C	/* 29DL324T ID (32 M, top boot sector)	*/
+#define AMD_ID_DL324B	0x225F225F	/* 29DL324B ID (32 M, bottom boot sect) */
+
+#define AMD_ID_DL640	0x227E227E	/* 29DL640D ID (64 M, dual boot sectors)*/
+#define AMD_ID_MIRROR	0x227E227E	/* 1st ID word for MirrorBit family */
+#define AMD_ID_DL640G_2 0x22022202	/* 2nd ID word for AM29DL640G  at 0x38 */
+#define AMD_ID_DL640G_3 0x22012201	/* 3rd ID word for AM29DL640G  at 0x3c */
+#define AMD_ID_LV640U_2 0x220C220C	/* 2nd ID word for AM29LV640M  at 0x38 */
+#define AMD_ID_LV640U_3 0x22012201	/* 3rd ID word for AM29LV640M  at 0x3c */
+#define AMD_ID_LV640MT_2 0x22102210	/* 2nd ID word for AM29LV640MT at 0x38 */
+#define AMD_ID_LV640MT_3 0x22012201	/* 3rd ID word for AM29LV640MT at 0x3c */
+#define AMD_ID_LV640MB_2 0x22102210	/* 2nd ID word for AM29LV640MB at 0x38 */
+#define AMD_ID_LV640MB_3 0x22002200	/* 3rd ID word for AM29LV640MB at 0x3c */
+#define AMD_ID_LV128U_2 0x22122212	/* 2nd ID word for AM29LV128M  at 0x38 */
+#define AMD_ID_LV128U_3 0x22002200	/* 3rd ID word for AM29LV128M  at 0x3c */
+#define AMD_ID_LV256U_2 0x22122212	/* 2nd ID word for AM29LV256M  at 0x38 */
+#define AMD_ID_LV256U_3 0x22012201	/* 3rd ID word for AM29LV256M  at 0x3c */
+#define AMD_ID_GL064M_2 0x22132213	/* 2nd ID word for S29GL064M-R6 */
+#define AMD_ID_GL064M_3 0x22012201	/* 3rd ID word for S29GL064M-R6 */
+#define AMD_ID_GL064MT_2 0x22102210	/* 2nd ID word for S29GL064M-R3 (top boot sector) */
+#define AMD_ID_GL064MT_3 0x22012201	/* 3rd ID word for S29GL064M-R3 (top boot sector) */
+#define AMD_ID_GL128N_2	0x22212221	/* 2nd ID word for S29GL128N */
+#define AMD_ID_GL128N_3	0x22012201	/* 3rd ID word for S29GL128N */
+
+
+#define AMD_ID_LV320B_2 0x221A221A	/* 2d ID word for AM29LV320MB at 0x38 */
+#define AMD_ID_LV320B_3 0x22002200	/* 3d ID word for AM29LV320MB at 0x3c */
+
+#define AMD_ID_LV640U	0x22D722D7	/* 29LV640U ID (64 M, uniform sectors)	*/
+#define AMD_ID_LV650U	0x22D722D7	/* 29LV650U ID (64 M, uniform sectors)	*/
+
+#define ATM_ID_BV1614	0x000000C0	/* 49BV1614  ID */
+#define ATM_ID_BV1614A	0x000000C8	/* 49BV1614A ID */
+#define ATM_ID_BV6416	0x000000D6	/* 49BV6416  ID */
+
+#define FUJI_ID_29F800BA  0x22582258	/* MBM29F800BA ID  (8M) */
+#define FUJI_ID_29F800TA  0x22D622D6	/* MBM29F800TA ID  (8M) */
+#define FUJI_ID_29LV650UE 0x22d722d7	/* MBM29LV650UE/651UE ID (8M = 128 x 32kWord) */
+
+#define SST_ID_xF200A	0x27892789	/* 39xF200A ID ( 2M = 128K x 16 )	*/
+#define SST_ID_xF400A	0x27802780	/* 39xF400A ID ( 4M = 256K x 16 )	*/
+#define SST_ID_xF800A	0x27812781	/* 39xF800A ID ( 8M = 512K x 16 )	*/
+#define SST_ID_xF160A	0x27822782	/* 39xF800A ID (16M =	1M x 16 )	*/
+#define SST_ID_xF1601	0x234B234B	/* 39xF1601 ID (16M =	1M x 16 )	*/
+#define SST_ID_xF1602	0x234A234A	/* 39xF1602 ID (16M =	1M x 16 )	*/
+#define SST_ID_xF3201	0x235B235B	/* 39xF3201 ID (32M =	2M x 16 )	*/
+#define SST_ID_xF3202	0x235A235A	/* 39xF3202 ID (32M =	2M x 16 )	*/
+#define SST_ID_xF6401	0x236B236B	/* 39xF6401 ID (64M =	4M x 16 )	*/
+#define SST_ID_xF6402	0x236A236A	/* 39xF6402 ID (64M =	4M x 16 )	*/
+#define SST_ID_xF020	0xBFD6BFD6	/* 39xF020 ID (256KB = 2Mbit x 8)	*/
+#define SST_ID_xF040	0xBFD7BFD7	/* 39xF040 ID (512KB = 4Mbit x 8)	*/
+
+#define STM_ID_F040B	0xE2		/* M29F040B ID ( 4M = 512K x 8	)	*/
+					/* 8 64K x 8 uniform sectors		*/
+
+#define STM_ID_x800AB	0x005B005B	/* M29W800AB ID (8M = 512K x 16 )	*/
+#define STM_ID_29W320DT 0x22CA22CA	/* M29W320DT ID (32 M, top boot sector) */
+#define STM_ID_29W320DB 0x22CB22CB	/* M29W320DB ID (32 M, bottom boot sect)	*/
+#define STM_ID_29W320ET 0x22562256	/* M29W320ET ID (32 M, top boot sector) */
+#define STM_ID_29W320EB 0x22572257	/* M29W320EB ID (32 M, bottom boot sect)*/
+#define STM_ID_29W040B	0x00E300E3	/* M29W040B ID (4M = 512K x 8)	*/
+#define FLASH_PSD4256GV 0x00E9		/* PSD4256 Flash and CPLD combination	*/
+
+#define INTEL_ID_28F016S    0x66a066a0	/* 28F016S[VS] ID (16M = 512k x 16)	*/
+#define INTEL_ID_28F800B3T  0x88928892	/*  8M = 512K x 16 top boot sector	*/
+#define INTEL_ID_28F800B3B  0x88938893	/*  8M = 512K x 16 bottom boot sector	*/
+#define INTEL_ID_28F160B3T  0x88908890	/*  16M = 1M x 16 top boot sector	*/
+#define INTEL_ID_28F160B3B  0x88918891	/*  16M = 1M x 16 bottom boot sector	*/
+#define INTEL_ID_28F320B3T  0x88968896	/*  32M = 2M x 16 top boot sector	*/
+#define INTEL_ID_28F320B3B  0x88978897	/*  32M = 2M x 16 bottom boot sector	*/
+#define INTEL_ID_28F640B3T  0x88988898	/*  64M = 4M x 16 top boot sector	*/
+#define INTEL_ID_28F640B3B  0x88998899	/*  64M = 4M x 16 bottom boot sector	*/
+#define INTEL_ID_28F160F3B  0x88F488F4	/*  16M = 1M x 16 bottom boot sector	*/
+
+#define INTEL_ID_28F800C3T  0x88C088C0	/*  8M = 512K x 16 top boot sector	*/
+#define INTEL_ID_28F800C3B  0x88C188C1	/*  8M = 512K x 16 bottom boot sector	*/
+#define INTEL_ID_28F160C3T  0x88C288C2	/*  16M = 1M x 16 top boot sector	*/
+#define INTEL_ID_28F160C3B  0x88C388C3	/*  16M = 1M x 16 bottom boot sector	*/
+#define INTEL_ID_28F320C3T  0x88C488C4	/*  32M = 2M x 16 top boot sector	*/
+#define INTEL_ID_28F320C3B  0x88C588C5	/*  32M = 2M x 16 bottom boot sector	*/
+#define INTEL_ID_28F640C3T  0x88CC88CC	/*  64M = 4M x 16 top boot sector	*/
+#define INTEL_ID_28F640C3B  0x88CD88CD	/*  64M = 4M x 16 bottom boot sector	*/
+
+#define INTEL_ID_28F128J3   0x89188918	/*  16M = 8M x 16 x 128 */
+#define INTEL_ID_28F320J5   0x00140014	/*  32M = 128K x  32	*/
+#define INTEL_ID_28F640J5   0x00150015	/*  64M = 128K x  64	*/
+#define INTEL_ID_28F320J3A  0x00160016	/*  32M = 128K x  32	*/
+#define INTEL_ID_28F640J3A  0x00170017	/*  64M = 128K x  64	*/
+#define INTEL_ID_28F128J3A  0x00180018	/* 128M = 128K x 128	*/
+#define INTEL_ID_28F256J3A  0x001D001D	/* 256M = 128K x 256	*/
+#define INTEL_ID_28F256L18T 0x880D880D	/* 256M = 128K x 255 + 32k x 4 */
+#define INTEL_ID_28F64K3    0x88018801	/*  64M =  32K x 255 + 32k x 4 */
+#define INTEL_ID_28F128K3   0x88028802	/* 128M =  64K x 255 + 32k x 4 */
+#define INTEL_ID_28F256K3   0x88038803	/* 256M = 128K x 255 + 32k x 4 */
+#define INTEL_ID_28F64P30T  0x88178817	/*  64M =  32K x 255 + 32k x 4 */
+#define INTEL_ID_28F64P30B  0x881A881A	/*  64M =  32K x 255 + 32k x 4 */
+#define INTEL_ID_28F128P30T 0x88188818	/* 128M =  64K x 255 + 32k x 4 */
+#define INTEL_ID_28F128P30B 0x881B881B	/* 128M =  64K x 255 + 32k x 4 */
+#define INTEL_ID_28F256P30T 0x88198819	/* 256M = 128K x 255 + 32k x 4 */
+#define INTEL_ID_28F256P30B 0x881C881C	/* 256M = 128K x 255 + 32k x 4 */
+
+#define INTEL_ID_28F160S3   0x00D000D0	/*  16M = 512K x  32 (64kB x 32)	*/
+#define INTEL_ID_28F320S3   0x00D400D4	/*  32M = 512K x  64 (64kB x 64)	*/
+
+/* Note that the Sharp 28F016SC is compatible with the Intel E28F016SC */
+#define SHARP_ID_28F016SCL  0xAAAAAAAA	/* LH28F016SCT-L95 2Mx8, 32 64k blocks	*/
+#define SHARP_ID_28F016SCZ  0xA0A0A0A0	/* LH28F016SCT-Z4  2Mx8, 32 64k blocks	*/
+#define SHARP_ID_28F008SC   0xA6A6A6A6	/* LH28F008SCT-L12 1Mx8, 16 64k blocks	*/
+					/* LH28F008SCR-L85 1Mx8, 16 64k blocks	*/
+
+#define TOSH_ID_FVT160	0xC2		/* TC58FVT160 ID (16 M, top )		*/
+#define TOSH_ID_FVB160	0x43		/* TC58FVT160 ID (16 M, bottom )	*/
+#define PHILIPS_LPC2292 0x0401FF13  /* LPC2292 internal FLASH			*/
+
+/*-----------------------------------------------------------------------
+ * Internal FLASH identification codes
+ *
+ * Be careful when adding new type! Odd numbers are "bottom boot sector" types!
+ */
+
+#define FLASH_AM040	0x0001		/* AMD Am29F040B, Am29LV040B		*/
+					/* Bright Micro BM29F040		*/
+					/* Fujitsu MBM29F040A			*/
+					/* STM M29W040B				*/
+					/* SGS Thomson M29F040B			*/
+					/* 8 64K x 8 uniform sectors		*/
+#define FLASH_AM400T	0x0002		/* AMD AM29LV400			*/
+#define FLASH_AM400B	0x0003
+#define FLASH_AM800T	0x0004		/* AMD AM29LV800			*/
+#define FLASH_AM800B	0x0005
+#define FLASH_AM116DT	0x0026		/* AMD AM29LV116DT (2Mx8bit) */
+#define FLASH_AM116DB	0x0027		/* AMD AM29LV116DB (2Mx8bit) */
+#define FLASH_AM160T	0x0006		/* AMD AM29LV160			*/
+#define FLASH_AM160LV	0x0046		/* AMD29LV160DB (2M = 2Mx8bit ) */
+#define FLASH_AM160B	0x0007
+#define FLASH_AM320T	0x0008		/* AMD AM29LV320			*/
+#define FLASH_AM320B	0x0009
+
+#define FLASH_AM080	0x000A		/* AMD Am29F080B			*/
+					/* 16 64K x 8 uniform sectors		*/
+
+#define FLASH_AMDL322T	0x0010		/* AMD AM29DL322			*/
+#define FLASH_AMDL322B	0x0011
+#define FLASH_AMDL323T	0x0012		/* AMD AM29DL323			*/
+#define FLASH_AMDL323B	0x0013
+#define FLASH_AMDL324T	0x0014		/* AMD AM29DL324			*/
+#define FLASH_AMDL324B	0x0015
+
+#define FLASH_AMDLV033C 0x0018
+#define FLASH_AMDLV065D 0x001A
+
+#define FLASH_AMDL640	0x0016		/* AMD AM29DL640D			*/
+#define FLASH_AMD016	0x0018		/* AMD AM29F016D			*/
+#define FLASH_AMDL640MB 0x0019		/* AMD AM29LV640MB (64M, bottom boot sect)*/
+#define FLASH_AMDL640MT 0x001A		/* AMD AM29LV640MT (64M, top boot sect) */
+
+#define FLASH_SST200A	0x0040		/* SST 39xF200A ID (  2M = 128K x 16 )	*/
+#define FLASH_SST400A	0x0042		/* SST 39xF400A ID (  4M = 256K x 16 )	*/
+#define FLASH_SST800A	0x0044		/* SST 39xF800A ID (  8M = 512K x 16 )	*/
+#define FLASH_SST160A	0x0046		/* SST 39xF160A ID ( 16M =   1M x 16 )	*/
+#define FLASH_SST320	0x0048		/* SST 39xF160A ID ( 16M =   1M x 16 )	*/
+#define FLASH_SST640	0x004A		/* SST 39xF160A ID ( 16M =   1M x 16 )	*/
+#define FLASH_SST020	0x0024		/* SST 39xF020 ID (256KB = 2Mbit x 8 )	*/
+#define FLASH_SST040	0x000E		/* SST 39xF040 ID (512KB = 4Mbit x 8 )	*/
+
+#define FLASH_STM800AB	0x0051		/* STM M29WF800AB  (  8M = 512K x 16 )	*/
+#define FLASH_STMW320DT 0x0052		/* STM M29W320DT   (32 M, top boot sector)	*/
+#define FLASH_STMW320DB 0x0053		/* STM M29W320DB   (32 M, bottom boot sect)*/
+#define FLASH_STM320DB	0x00CB		/* STM M29W320DB (4M = 64K x 64, bottom)*/
+#define FLASH_STM800DT	0x00D7		/* STM M29W800DT (1M = 64K x 16, top)	*/
+#define FLASH_STM800DB	0x005B		/* STM M29W800DB (1M = 64K x 16, bottom)*/
+
+#define FLASH_28F400_T	0x0062		/* MT  28F400B3 ID (  4M = 256K x 16 )	*/
+#define FLASH_28F400_B	0x0063		/* MT  28F400B3 ID (  4M = 256K x 16 )	*/
+
+#define FLASH_INTEL800T 0x0074		/* INTEL 28F800B3T (  8M = 512K x 16 )	*/
+#define FLASH_INTEL800B 0x0075		/* INTEL 28F800B3B (  8M = 512K x 16 )	*/
+#define FLASH_INTEL160T 0x0076		/* INTEL 28F160B3T ( 16M =  1 M x 16 )	*/
+#define FLASH_INTEL160B 0x0077		/* INTEL 28F160B3B ( 16M =  1 M x 16 )	*/
+#define FLASH_INTEL320T 0x0078		/* INTEL 28F320B3T ( 32M =  2 M x 16 )	*/
+#define FLASH_INTEL320B 0x0079		/* INTEL 28F320B3B ( 32M =  2 M x 16 )	*/
+#define FLASH_INTEL640T 0x007A		/* INTEL 28F320B3T ( 64M =  4 M x 16 )	*/
+#define FLASH_INTEL640B 0x007B		/* INTEL 28F320B3B ( 64M =  4 M x 16 )	*/
+
+#define FLASH_28F008S5	0x0080		/* Intel 28F008S5  (  1M =  64K x 16 )	*/
+#define FLASH_28F016SV	0x0081		/* Intel 28F016SV  ( 16M = 512k x 32 )	*/
+#define FLASH_28F800_B	0x0083		/* Intel E28F800B  (  1M = ? )		*/
+#define FLASH_AM29F800B 0x0084		/* AMD Am29F800BB  (  1M = ? )		*/
+#define FLASH_28F320J5	0x0085		/* Intel 28F320J5  (  4M = 128K x 32 )	*/
+#define FLASH_28F160S3	0x0086		/* Intel 28F160S3  ( 16M = 512K x 32 )	*/
+#define FLASH_28F320S3	0x0088		/* Intel 28F320S3  ( 32M = 512K x 64 )	*/
+#define FLASH_AM640U	0x0090		/* AMD Am29LV640U  ( 64M = 4M x 16 )	*/
+#define FLASH_AM033C	0x0091		/* AMD AM29LV033   ( 32M = 4M x 8 )	*/
+#define FLASH_LH28F016SCT 0x0092	/* Sharp 28F016SCT ( 8 Meg Flash SIMM ) */
+#define FLASH_28F160F3B 0x0093		/* Intel 28F160F3B ( 16M = 1M x 16 )	*/
+#define FLASH_AM065D	0x0093
+
+#define FLASH_28F640J5	0x0099		/* INTEL 28F640J5  ( 64M = 128K x  64)	*/
+
+#define FLASH_28F800C3T 0x009A		/* Intel 28F800C3T (  8M = 512K x 16 )	*/
+#define FLASH_28F800C3B 0x009B		/* Intel 28F800C3B (  8M = 512K x 16 )	*/
+#define FLASH_28F160C3T 0x009C		/* Intel 28F160C3T ( 16M = 1M x 16 )	*/
+#define FLASH_28F160C3B 0x009D		/* Intel 28F160C3B ( 16M = 1M x 16 )	*/
+#define FLASH_28F320C3T 0x009E		/* Intel 28F320C3T ( 32M = 2M x 16 )	*/
+#define FLASH_28F320C3B 0x009F		/* Intel 28F320C3B ( 32M = 2M x 16 )	*/
+#define FLASH_28F640C3T 0x00A0		/* Intel 28F640C3T ( 64M = 4M x 16 )	*/
+#define FLASH_28F640C3B 0x00A1		/* Intel 28F640C3B ( 64M = 4M x 16 )	*/
+#define FLASH_AMLV320U	0x00A2		/* AMD 29LV320M	   ( 32M = 2M x 16 )	*/
+
+#define FLASH_AM033	0x00A3		/* AMD AmL033C90V1   (32M = 4M x 8)	*/
+#define FLASH_AM065	0x0093		/* AMD AmL065DU12RI  (64M = 8M x 8)	*/
+#define FLASH_AT040	0x00A5		/* Amtel AT49LV040   (4M = 512K x 8)	*/
+
+#define FLASH_AMLV640U	0x00A4		/* AMD 29LV640M	   ( 64M = 4M x 16 )	*/
+#define FLASH_AMLV128U	0x00A6		/* AMD 29LV128M	   ( 128M = 8M x 16 )	*/
+#define FLASH_AMLV320B	0x00A7		/* AMD 29LV320MB   ( 32M = 2M x 16 )	*/
+#define FLASH_AMLV320T	0x00A8		/* AMD 29LV320MT   ( 32M = 2M x 16 )	*/
+#define FLASH_AMLV256U	0x00AA		/* AMD 29LV256M	   ( 256M = 16M x 16 )	*/
+#define FLASH_MXLV320B	0x00AB		/* MX  29LV320MB   ( 32M = 2M x 16 )	*/
+#define FLASH_MXLV320T	0x00AC		/* MX  29LV320MT   ( 32M = 2M x 16 )	*/
+#define FLASH_28F256L18T 0x00B0		/* Intel 28F256L18T 256M = 128K x 255 + 32k x 4 */
+#define FLASH_AMDL163T	0x00B2		/* AMD AM29DL163T (2M x 16 )			*/
+#define FLASH_AMDL163B	0x00B3
+#define FLASH_28F64K3	0x00B4		/* Intel 28F64K3   (  64M)		*/
+#define FLASH_28F128K3	0x00B6		/* Intel 28F128K3  ( 128M = 8M x 16 )	*/
+#define FLASH_28F256K3	0x00B8		/* Intel 28F256K3  ( 256M = 16M x 16 )	*/
+
+#define FLASH_28F320J3A 0x00C0		/* INTEL 28F320J3A ( 32M = 128K x  32)	*/
+#define FLASH_28F640J3A 0x00C2		/* INTEL 28F640J3A ( 64M = 128K x  64)	*/
+#define FLASH_28F128J3A 0x00C4		/* INTEL 28F128J3A (128M = 128K x 128)	*/
+#define FLASH_28F256J3A 0x00C6		/* INTEL 28F256J3A (256M = 128K x 256)	*/
+
+#define FLASH_FUJLV650	0x00D0		/* Fujitsu MBM 29LV650UE/651UE		*/
+#define FLASH_MT28S4M16LC 0x00E1	/* Micron MT28S4M16LC			*/
+#define FLASH_S29GL064M 0x00F0		/* Spansion S29GL064M-R6		*/
+#define FLASH_S29GL128N 0x00F1		/* Spansion S29GL128N			*/
+
+#define FLASH_UNKNOWN	0xFFFF		/* unknown flash type			*/
+
+
+/* manufacturer offsets
+ */
+#define FLASH_MAN_AMD	0x00000000	/* AMD					*/
+#define FLASH_MAN_FUJ	0x00010000	/* Fujitsu				*/
+#define FLASH_MAN_BM	0x00020000	/* Bright Microelectronics		*/
+#define FLASH_MAN_MX	0x00030000	/* MXIC					*/
+#define FLASH_MAN_STM	0x00040000
+#define FLASH_MAN_TOSH	0x00050000	/* Toshiba				*/
+#define FLASH_MAN_EXCEL 0x00060000	/* Excel Semiconductor			*/
+#define FLASH_MAN_SST	0x00100000
+#define FLASH_MAN_INTEL 0x00300000
+#define FLASH_MAN_MT	0x00400000
+#define FLASH_MAN_SHARP 0x00500000
+#define FLASH_MAN_ATM	0x00600000
+#define FLASH_MAN_CFI	0x01000000
+
+
+#define FLASH_TYPEMASK	0x0000FFFF	/* extract FLASH type	information	*/
+#define FLASH_VENDMASK	0xFFFF0000	/* extract FLASH vendor information	*/
+
+#define FLASH_AMD_COMP	0x000FFFFF	/* Up to this ID, FLASH is compatible	*/
+					/* with AMD, Fujitsu and SST		*/
+					/* (JEDEC standard commands ?)		*/
+
+#define FLASH_BTYPE	0x0001		/* mask for bottom boot sector type	*/
+
+/*-----------------------------------------------------------------------
+ * Timeout constants:
+ *
+ * We can't find any specifications for maximum chip erase times,
+ * so these values are guestimates.
+ */
+#define FLASH_ERASE_TIMEOUT	120000	/* timeout for erasing in ms		*/
+#define FLASH_WRITE_TIMEOUT	500	/* timeout for writes  in ms		*/
+
+#endif /* !CONFIG_SYS_NO_FLASH */
+
+#endif /* _FLASH_H_ */
diff --git a/include/usb_defs.h b/include/usb_defs.h
index 8032e57..1aa7fae 100644
--- a/include/usb_defs.h
+++ b/include/usb_defs.h
@@ -148,6 +148,20 @@
 #define USB_REQ_SET_INTERFACE       0x0B
 #define USB_REQ_SYNCH_FRAME         0x0C
 
+#define USB_REQ_SET_ENCRYPTION      0x0D    /* Wireless USB */
+#define USB_REQ_GET_ENCRYPTION      0x0E
+#define USB_REQ_RPIPE_ABORT         0x0E
+#define USB_REQ_SET_HANDSHAKE       0x0F
+#define USB_REQ_RPIPE_RESET         0x0F
+#define USB_REQ_GET_HANDSHAKE       0x10
+#define USB_REQ_SET_CONNECTION      0x11
+#define USB_REQ_SET_SECURITY_DATA   0x12
+#define USB_REQ_GET_SECURITY_DATA   0x13
+#define USB_REQ_SET_WUSB_DATA       0x14
+#define USB_REQ_LOOPBACK_DATA_WRITE 0x15
+#define USB_REQ_LOOPBACK_DATA_READ  0x16
+#define USB_REQ_SET_INTERFACE_DS    0x17
+
 /* HID requests */
 #define USB_REQ_GET_REPORT          0x01
 #define USB_REQ_GET_IDLE            0x02
diff --git a/lib_arm/board.c b/lib_arm/board.c
index 09eaaf2..b54a1c3 100644
--- a/lib_arm/board.c
+++ b/lib_arm/board.c
@@ -123,19 +123,33 @@ void *sbrk (ptrdiff_t increment)
  * May be supplied by boards if desired
  */
 void inline __coloured_LED_init (void) {}
-void inline coloured_LED_init (void) __attribute__((weak, alias("__coloured_LED_init")));
+void coloured_LED_init (void) __attribute__((weak, alias("__coloured_LED_init")));
 void inline __red_LED_on (void) {}
-void inline red_LED_on (void) __attribute__((weak, alias("__red_LED_on")));
+void red_LED_on (void) __attribute__((weak, alias("__red_LED_on")));
 void inline __red_LED_off(void) {}
-void inline red_LED_off(void)	     __attribute__((weak, alias("__red_LED_off")));
+void red_LED_off(void)	     __attribute__((weak, alias("__red_LED_off")));
 void inline __green_LED_on(void) {}
-void inline green_LED_on(void) __attribute__((weak, alias("__green_LED_on")));
+void green_LED_on(void) __attribute__((weak, alias("__green_LED_on")));
 void inline __green_LED_off(void) {}
-void inline green_LED_off(void)__attribute__((weak, alias("__green_LED_off")));
+void green_LED_off(void)__attribute__((weak, alias("__green_LED_off")));
 void inline __yellow_LED_on(void) {}
-void inline yellow_LED_on(void)__attribute__((weak, alias("__yellow_LED_on")));
+void yellow_LED_on(void)__attribute__((weak, alias("__yellow_LED_on")));
 void inline __yellow_LED_off(void) {}
-void inline yellow_LED_off(void)__attribute__((weak, alias("__yellow_LED_off")));
+void yellow_LED_off(void)__attribute__((weak, alias("__yellow_LED_off")));
+
+#ifdef BEAUTIFY_CONSOLE
+static const char *hline =     {"\xCC\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD"
+                                "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD"
+                               "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD"
+                                "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xB9\n"};
+
+static const char *dbtmline =  {"\xC8\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD"
+                               "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD"
+                               "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD"
+                               "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xBC\n"};
+
+#endif
+
 
 /************************************************************************
  * Init Utilities							*
@@ -161,15 +175,22 @@ static int init_baudrate (void)
 
 static int display_banner (void)
 {
-	printf ("\n\n%s\n\n", version_string);
-	debug ("U-Boot code: %08lX -> %08lX  BSS: -> %08lX\n",
-	       _armboot_start, _bss_start, _bss_end);
+#ifdef BEAUTIFY_CONSOLE
+#ifndef PRODUCT_NAME
+#error PRODUCT_NAME not defined
+#endif
+        printf("\xBA %-51s %-24s \xBA\n%s", version_string, PRODUCT_NAME, hline);
+#else
+        printf ("\n\n%s\n\n", version_string);
+#endif
+        debug ("U-Boot code: %08lX -> %08lX  BSS: -> %08lX\n",
+               _armboot_start, _bss_start, _bss_end);
 #ifdef CONFIG_MODEM_SUPPORT
-	debug ("Modem Support enabled\n");
+        debug ("Modem Support enabled\n");
 #endif
 #ifdef CONFIG_USE_IRQ
-	debug ("IRQ Stack: %08lx\n", IRQ_STACK_START);
-	debug ("FIQ Stack: %08lx\n", FIQ_STACK_START);
+        debug ("IRQ Stack: %08lx\n", IRQ_STACK_START);
+        debug ("FIQ Stack: %08lx\n", FIQ_STACK_START);
 #endif
 
 	return (0);
@@ -186,6 +207,21 @@ static int display_dram_config (void)
 {
 	int i;
 
+#ifdef BEAUTIFY_CONSOLE
+        printf("\xBA Memory configuration                                                         \xBA\n");
+        printf("\xBA Start    \xB3 End      \xB3 Type  \xB3 Description                                    \xBA\n");
+        printf("\xBA\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC5" \
+               "\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC5" \
+               "\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC5"
+               "\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xC4\xBA\n");
+
+        for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++)
+        {
+            printf("\xBA %.8lX \xB3 %.8lX \xB3 RAM   \xB3 ", gd->bd->bi_dram[i].start, gd->bd->bi_dram[i].start + gd->bd->bi_dram[i].size - 1);
+            printf("System main memory bank #%.1d                     \xBA\n", i);
+        }
+#else
+
 #ifdef DEBUG
 	puts ("RAM Configuration:\n");
 
@@ -202,15 +238,19 @@ static int display_dram_config (void)
 	puts("DRAM:  ");
 	print_size(size, "\n");
 #endif
-
+#endif
 	return (0);
 }
 
 #ifndef CONFIG_SYS_NO_FLASH
 static void display_flash_config (ulong size)
 {
+#if defined (BEAUTIFY_CONSOLE) && (CFG_EXT_LEGACY_FLASH)
+	/* because the flash_info is not exported, this output is done by flash_detect directly */
+#else
 	puts ("Flash: ");
 	print_size (size, "\n");
+#endif
 }
 #endif /* CONFIG_SYS_NO_FLASH */
 
@@ -407,6 +447,15 @@ void start_armboot (void)
 #endif
 	}
 
+#if defined(CONFIG_MISC_INIT_P)
+        /* miscellaneous platform dependent initialisations before devices_init(),
+           but after the enviroment is available. */
+#ifdef BEAUTIFY_CONSOLE
+        printf("%s", hline);
+#endif
+        misc_init_p ();
+#endif
+
 	devices_init ();	/* get the devices list going. */
 
 #ifdef CONFIG_CMC_PU2
@@ -471,6 +520,10 @@ extern void davinci_eth_set_mac_addr (const u_int8_t *addr);
 	reset_phy();
 #endif
 #endif
+
+#ifdef BEAUTIFY_CONSOLE
+        printf("%s", dbtmline);
+#endif
 	/* main_loop() can return to retry autoboot, if so just run it again. */
 	for (;;) {
 		main_loop ();
diff --git a/lib_arm/bootm.c b/lib_arm/bootm.c
index 7dbde7d..6acd6ff 100644
--- a/lib_arm/bootm.c
+++ b/lib_arm/bootm.c
@@ -35,7 +35,9 @@ DECLARE_GLOBAL_DATA_PTR;
     defined (CONFIG_SERIAL_TAG) || \
     defined (CONFIG_REVISION_TAG) || \
     defined (CONFIG_VFD) || \
-    defined (CONFIG_LCD)
+    defined (CONFIG_LCD) || \
+    defined (CONFIG_MAC_TAG)
+
 static void setup_start_tag (bd_t *bd);
 
 # ifdef CONFIG_SETUP_MEMORY_TAGS
@@ -43,6 +45,10 @@ static void setup_memory_tags (bd_t *bd);
 # endif
 static void setup_commandline_tag (bd_t *bd, char *commandline);
 
+#ifdef CONFIG_MAC_TAG
+static void setup_mac_tag (bd_t *bd);
+#endif
+
 # ifdef CONFIG_INITRD_TAG
 static void setup_initrd_tag (bd_t *bd, ulong initrd_start,
 			      ulong initrd_end);
@@ -89,7 +95,8 @@ int do_bootm_linux(int flag, int argc, char *argv[], bootm_headers_t *images)
     defined (CONFIG_SERIAL_TAG) || \
     defined (CONFIG_REVISION_TAG) || \
     defined (CONFIG_LCD) || \
-    defined (CONFIG_VFD)
+    defined (CONFIG_VFD) || \
+    defined (CONFIG_MAC_TAG)
 	setup_start_tag (bd);
 #ifdef CONFIG_SERIAL_TAG
 	setup_serial_tag (&params);
@@ -103,6 +110,9 @@ int do_bootm_linux(int flag, int argc, char *argv[], bootm_headers_t *images)
 #ifdef CONFIG_CMDLINE_TAG
 	setup_commandline_tag (bd, commandline);
 #endif
+#ifdef CONFIG_MAC_TAG
+        setup_mac_tag (bd);
+#endif
 #ifdef CONFIG_INITRD_TAG
 	if (images->rd_start && images->rd_end)
 		setup_initrd_tag (bd, images->rd_start, images->rd_end);
@@ -255,6 +265,17 @@ void setup_serial_tag (struct tag **tmp)
 }
 #endif
 
+#ifdef CONFIG_MAC_TAG
+static void setup_mac_tag (bd_t *bd)
+{
+        params->hdr.tag = ATAG_MAC;
+        params->hdr.size = (sizeof (struct tag_header) + 6 + 4) >> 2;
+        memcpy(params->u.mac.mac_address, gd->bd->bi_enetaddr, 6);
+        params = tag_next (params);
+}
+#endif
+
+
 #ifdef CONFIG_REVISION_TAG
 void setup_revision_tag(struct tag **in_params)
 {
diff --git a/net/bootp.c b/net/bootp.c
index 83465e4..8531278 100644
--- a/net/bootp.c
+++ b/net/bootp.c
@@ -28,6 +28,9 @@
 #ifdef CONFIG_STATUS_LED
 #include <status_led.h>
 #endif
+#ifdef HAVE_COOLSTREAM_VFD_CONTROLLER
+#include <asm/arch/sys_proto.h>
+#endif
 
 #define BOOTP_VENDOR_MAGIC	0x63825363	/* RFC1048 Magic Cookie		*/
 
@@ -649,7 +652,9 @@ BootpRequest (void)
 		udelay(1000); /*Wait 1ms*/
 	}
 #endif	/* CONFIG_BOOTP_RANDOM_DELAY */
-
+#ifdef HAVE_COOLSTREAM_VFD_CONTROLLER
+	display_set_text("BOOTP...    ");
+#endif
 	printf("BOOTP broadcast %d\n", ++BootpTry);
 	pkt = NetTxPacket;
 	memset ((void*)pkt, 0, PKTSIZE);
diff --git a/net/nfs.c b/net/nfs.c
index f290014..3c6c619 100644
--- a/net/nfs.c
+++ b/net/nfs.c
@@ -29,6 +29,10 @@
 #include "nfs.h"
 #include "bootp.h"
 
+#ifdef HAVE_COOLSTREAM_VFD_CONTROLLER
+#include <asm/arch/sys_proto.h>
+#endif
+
 /*#define NFS_DEBUG*/
 
 #if defined(CONFIG_CMD_NET) && defined(CONFIG_CMD_NFS)
@@ -737,6 +741,9 @@ NfsStart (void)
 	nfs_filename = basename (nfs_path);
 	nfs_path     = dirname (nfs_path);
 
+#ifdef HAVE_COOLSTREAM_VFD_CONTROLLER
+	display_set_text("NFS...    ");
+#endif
 #if defined(CONFIG_NET_MULTI)
 	printf ("Using %s device\n", eth_get_name());
 #endif
diff --git a/net/tftp.c b/net/tftp.c
index 3dac3d8..56b11a0 100644
--- a/net/tftp.c
+++ b/net/tftp.c
@@ -10,6 +10,10 @@
 #include "tftp.h"
 #include "bootp.h"
 
+#ifdef HAVE_COOLSTREAM_VFD_CONTROLLER
+#include <asm/arch/sys_proto.h>
+#endif
+
 #undef	ET_DEBUG
 
 #if defined(CONFIG_CMD_NET)
@@ -504,7 +508,9 @@ TftpStart (void)
 			tftp_filename[MAX_LEN-1] = 0;
 		}
 	}
-
+#ifdef HAVE_COOLSTREAM_VFD_CONTROLLER
+	display_set_text("TFTP...     ");
+#endif
 #if defined(CONFIG_NET_MULTI)
 	printf ("Using %s device\n", eth_get_name());
 #endif
