    directfb 1.3.0 from coolstream

 DirectFB-1.3.0/BUGS                                |   25 +
 DirectFB-1.3.0/CODING_STYLE                        |   69 +
 DirectFB-1.3.0/ChangeLog                           | 1153 ---------------
 DirectFB-1.3.0/NEWS                                |  273 ----
 DirectFB-1.3.0/README                              |    8 +-
 DirectFB-1.3.0/README.COOLSTREAM                   |    4 +
 DirectFB-1.3.0/README.OSX                          |   41 +
 DirectFB-1.3.0/aclocal.m4                          |  284 ++---
 DirectFB-1.3.0/autogen.sh                          |    8 +-
 DirectFB-1.3.0/config.h.in                         |    3 -
 DirectFB-1.3.0/configure.in                        |   34 +-
 DirectFB-1.3.0/debian/changelog                    |   11 +
 DirectFB-1.3.0/debian/control                      |   61 +
 DirectFB-1.3.0/debian/copyright                    |   30 +
 DirectFB-1.3.0/debian/dirs                         |    2 +
 DirectFB-1.3.0/debian/docs                         |    5 +
 DirectFB-1.3.0/debian/libdirectfb-bin.files        |    6 +
 DirectFB-1.3.0/debian/libdirectfb-cvs.dirs         |    1 +
 DirectFB-1.3.0/debian/libdirectfb-cvs.files        |    3 +
 DirectFB-1.3.0/debian/libdirectfb-dev.dirs         |    2 +
 DirectFB-1.3.0/debian/libdirectfb-dev.files        |    8 +
 DirectFB-1.3.0/debian/libdirectfb-extra.files      |    2 +
 DirectFB-1.3.0/debian/rules                        |  100 ++
 DirectFB-1.3.0/docs/DirectFB Core Architecture.pdf |  Bin 0 -> 109449 bytes
 DirectFB-1.3.0/docs/DirectFB Core Architecture.sxi |  Bin 0 -> 13921 bytes
 DirectFB-1.3.0/docs/GeneFX.odp                     |  Bin 0 -> 14497 bytes
 DirectFB-1.3.0/docs/GeneFX.pdf                     |  Bin 0 -> 36145 bytes
 DirectFB-1.3.0/docs/README.mga-tv                  |  533 +++++++
 DirectFB-1.3.0/docs/ReferenceMaps.txt              |  131 ++
 DirectFB-1.3.0/docs/direct/DirectList.eps          |  392 ++++++
 DirectFB-1.3.0/docs/direct/DirectList.pdf          |  Bin 0 -> 22734 bytes
 DirectFB-1.3.0/docs/direct/DirectList.sxd          |  Bin 0 -> 6733 bytes
 DirectFB-1.3.0/docs/initialization.txt             |   86 ++
 DirectFB-1.3.0/gfxdrivers/Makefile.am              |   15 +-
 DirectFB-1.3.0/gfxdrivers/cle266/Installation.txt  |   17 +
 DirectFB-1.3.0/gfxdrivers/cle266/Patching.txt      |   27 +
 DirectFB-1.3.0/gfxdrivers/cle266/Readme.txt        |  136 ++
 DirectFB-1.3.0/gfxdrivers/cle266/changelog.txt     |   56 +
 DirectFB-1.3.0/gfxdrivers/cle266/cle266vgaio.c     |  291 ++++
 DirectFB-1.3.0/gfxdrivers/cle266/cle266vgaio.mk    |   45 +
 DirectFB-1.3.0/gfxdrivers/cle266/cle266vgaio.patch |   24 +
 DirectFB-1.3.0/gfxdrivers/cle266/hwdoc.txt         |  549 ++++++++
 DirectFB-1.3.0/gfxdrivers/cle266/rops.h            |  296 ++++
 DirectFB-1.3.0/gfxdrivers/cle266/uc_probe.c        |  209 +++
 DirectFB-1.3.0/gfxdrivers/cle266/uc_probe.h        |   34 +
 DirectFB-1.3.0/gfxdrivers/cx2450x/Makefile.am      |   33 +
 DirectFB-1.3.0/gfxdrivers/cx2450x/cx2450x-accel.c  |  195 +++
 DirectFB-1.3.0/gfxdrivers/cx2450x/cx2450x-state.c  |  360 +++++
 DirectFB-1.3.0/gfxdrivers/cx2450x/cx2450x-tables.h |  169 +++
 DirectFB-1.3.0/gfxdrivers/cx2450x/cx2450x.c        |  254 ++++
 DirectFB-1.3.0/gfxdrivers/cx2450x/cx2450x.h        |   96 ++
 DirectFB-1.3.0/gfxdrivers/davinci/davinci_2d.c     |   16 +-
 .../gfxdrivers/davinci/davinci_osd_pool.c          |    7 +-
 DirectFB-1.3.0/gfxdrivers/davinci/davinci_screen.c |    2 +-
 .../gfxdrivers/davinci/davinci_video_pool.c        |    5 +-
 DirectFB-1.3.0/gfxdrivers/omap/omapfb.h            |  163 +++
 .../gfxdrivers/savage/savage_streams_old.c         | 1033 ++++++++++++++
 DirectFB-1.3.0/gfxdrivers/sh7722/Makefile.am       |   13 +-
 DirectFB-1.3.0/gfxdrivers/sh7722/Makefile.kernel   |   36 +-
 DirectFB-1.3.0/gfxdrivers/sh7722/directfbrc.sh7722 |   11 +-
 .../gfxdrivers/sh7722/kernel-module/Makefile       |    4 +-
 .../gfxdrivers/sh7722/kernel-module/sh7722gfx.c    | 1104 +++++++++++++++
 .../gfxdrivers/sh7722/kernel-module/sh7722gfx.h    |   99 ++
 DirectFB-1.3.0/gfxdrivers/sh7722/sh7722.c          |  174 +--
 DirectFB-1.3.0/gfxdrivers/sh7722/sh7722.h          |   64 +-
 DirectFB-1.3.0/gfxdrivers/sh7722/sh7722_blt.c      |   29 +-
 DirectFB-1.3.0/gfxdrivers/sh7722/sh7722_jpeg.c     |   32 +-
 DirectFB-1.3.0/gfxdrivers/sh7722/sh7722_jpeglib.c  |  217 +--
 DirectFB-1.3.0/gfxdrivers/sh7722/sh7722_jpeglib.h  |    1 +
 DirectFB-1.3.0/gfxdrivers/sh7722/sh7722_layer.c    |    3 -
 DirectFB-1.3.0/gfxdrivers/sh7722/sh7722_regs.h     |    2 +-
 DirectFB-1.3.0/gfxdrivers/sh7722/sh7722_types.h    |   11 +-
 DirectFB-1.3.0/gfxdrivers/unichrome/Readme.txt     |  101 ++
 .../gfxdrivers/unichrome/find_revision.sh          |   26 +
 DirectFB-1.3.0/gfxdrivers/unichrome/ucio.c         |  424 ++++++
 DirectFB-1.3.0/gfxdrivers/unichrome/ucio.mk        |   46 +
 DirectFB-1.3.0/hd1_config                          |   24 +
 DirectFB-1.3.0/include/directfb.h                  |   54 +-
 DirectFB-1.3.0/include/directfb_util.h             |  139 --
 DirectFB-1.3.0/inputdrivers/gunze/dfb-calib.c      |  469 +++++++
 .../interfaces/IDirectFBFont/default_font.png      |  Bin 0 -> 3774 bytes
 .../IDirectFBFont/idirectfbfont_default.c          |    2 +-
 .../interfaces/IDirectFBFont/idirectfbfont_ft2.c   |    2 +-
 .../idirectfbimageprovider_gif.c                   |    2 +-
 .../idirectfbimageprovider_jpeg.c                  |   25 +-
 .../idirectfbimageprovider_png.c                   |   20 +-
 .../idirectfbvideoprovider_gif.c                   |    2 +-
 .../idirectfbvideoprovider_v4l.c                   | 1481 ++++++++++++++++++++
 DirectFB-1.3.0/lib/direct/interface.c              |   13 -
 DirectFB-1.3.0/lib/direct/thread.c                 |  106 +--
 DirectFB-1.3.0/lib/direct/thread.h                 |   19 -
 DirectFB-1.3.0/lib/direct/trace.c                  |   50 +-
 DirectFB-1.3.0/lib/direct/trace.h                  |   55 -
 DirectFB-1.3.0/lib/direct/util.h                   |    5 -
 DirectFB-1.3.0/lib/fusion/call.c                   |   24 -
 DirectFB-1.3.0/lib/fusion/fusion.c                 |  250 ++---
 DirectFB-1.3.0/lib/fusion/fusion.h                 |    3 -
 DirectFB-1.3.0/lib/fusion/fusion_internal.h        |    1 -
 DirectFB-1.3.0/mkchlog                             |   80 ++
 DirectFB-1.3.0/patches/README.radeonfb-r300fix     |    2 +
 .../patches/agpgart-noroot-2.6.10.patch.bz2        |  Bin 0 -> 359 bytes
 .../matroxfb-full-memory-linux-2.6.6.patch.bz2     |  Bin 0 -> 372 bytes
 .../patches/matroxfb-g400-clock-2.6.6.patch.bz2    |  Bin 0 -> 1999 bytes
 .../patches/radeonfb-r300fix-2.6.17.patch.bz2      |  Bin 0 -> 5930 bytes
 .../patches/radeonfb-r300fix-2.6.18.patch.bz2      |  Bin 0 -> 4124 bytes
 .../patches/radeonfb-r300fix-2.6.22.patch.bz2      |  Bin 0 -> 3858 bytes
 .../patches/rivafb-nv2030fix-2.6.10.patch.bz2      |  Bin 0 -> 1892 bytes
 .../patches/rivafb-nv2030fix-2.6.9.patch.bz2       |  Bin 0 -> 1876 bytes
 .../patches/rivafb-nv20fix-2.4.28.patch.bz2        |  Bin 0 -> 2066 bytes
 .../proxy/dispatcher/idirectfbfoo_dispatcher.c     |  178 +++
 .../proxy/dispatcher/idirectfbfoo_dispatcher.h     |   48 +
 .../proxy/requestor/idirectfbfoo_requestor.c       |  129 ++
 .../proxy/requestor/idirectfbfoo_requestor.h       |   45 +
 DirectFB-1.3.0/src/core/Makefile.am                |    2 -
 DirectFB-1.3.0/src/core/core.c                     |    2 -
 DirectFB-1.3.0/src/core/coredefs.h                 |   13 +-
 DirectFB-1.3.0/src/core/coretypes.h                |    4 -
 DirectFB-1.3.0/src/core/fonts.c                    |    4 +-
 DirectFB-1.3.0/src/core/gfxcard.c                  |  110 +--
 DirectFB-1.3.0/src/core/layer_context.c            |   93 +--
 DirectFB-1.3.0/src/core/layer_region.c             |   50 +-
 DirectFB-1.3.0/src/core/local_surface_pool.c       |    8 +-
 DirectFB-1.3.0/src/core/prealloc_surface_pool.c    |    8 +-
 DirectFB-1.3.0/src/core/shared_surface_pool.c      |    8 +-
 DirectFB-1.3.0/src/core/surface.c                  |   30 +-
 DirectFB-1.3.0/src/core/surface.h                  |   41 +-
 DirectFB-1.3.0/src/core/surface_buffer.c           |  779 +++++------
 DirectFB-1.3.0/src/core/surface_buffer.h           |   39 +-
 DirectFB-1.3.0/src/core/surface_pool.c             |  166 +--
 DirectFB-1.3.0/src/core/surface_pool.h             |   25 +-
 DirectFB-1.3.0/src/core/windows.c                  |   58 +-
 DirectFB-1.3.0/src/core/windows.h                  |    8 +-
 DirectFB-1.3.0/src/core/windows_internal.h         |    6 -
 DirectFB-1.3.0/src/core/windowstack.c              |   46 +-
 DirectFB-1.3.0/src/core/windowstack.h              |    3 +-
 DirectFB-1.3.0/src/core/wm.c                       |   75 +-
 DirectFB-1.3.0/src/display/idirectfbdisplaylayer.c |   27 -
 DirectFB-1.3.0/src/display/idirectfbsurface.c      |    8 +-
 DirectFB-1.3.0/src/gfx/convert.c                   |  516 ++------
 DirectFB-1.3.0/src/gfx/convert.h                   |   78 +-
 DirectFB-1.3.0/src/gfx/generic/generic.c           |  569 +++------
 DirectFB-1.3.0/src/gfx/generic/generic.h           |    3 -
 DirectFB-1.3.0/src/gfx/generic/generic_dummy.c     |    3 +
 DirectFB-1.3.0/src/gfx/generic/generic_mmx.h       |   31 +-
 .../src/gfx/generic/stretch_up_down_16_indexed.h   |   82 ++
 DirectFB-1.3.0/src/gfx/generic/template_acc_16.h   |   30 +-
 DirectFB-1.3.0/src/gfx/generic/template_acc_32.h   |   29 +-
 .../src/gfx/generic/template_colorkey_32.h         |   42 +-
 DirectFB-1.3.0/src/gfx/util.c                      |   35 +-
 DirectFB-1.3.0/src/gfx/util.h                      |    2 +-
 DirectFB-1.3.0/src/idirectfb.c                     |   11 +-
 DirectFB-1.3.0/src/misc/conf.c                     |  113 ++-
 DirectFB-1.3.0/src/misc/conf.h                     |    2 -
 DirectFB-1.3.0/src/misc/gfx_util.c                 |   18 -
 DirectFB-1.3.0/src/misc/util.c                     |   47 -
 DirectFB-1.3.0/src/windows/idirectfbwindow.c       |   11 -
 .../systems/devmem/devmem_surface_pool.c           |   19 +-
 DirectFB-1.3.0/systems/fbdev/fb.h                  |    2 +
 DirectFB-1.3.0/systems/fbdev/fbdev.c               |    5 +
 DirectFB-1.3.0/systems/fbdev/fbdev_surface_pool.c  |   19 +-
 DirectFB-1.3.0/systems/sdl/primary.c               |   50 +-
 DirectFB-1.3.0/systems/sdl/sdl_surface_pool.c      |    9 +-
 DirectFB-1.3.0/systems/vnc/primary.c               |    2 +-
 DirectFB-1.3.0/systems/x11/Makefile.am             |   15 +-
 DirectFB-1.3.0/systems/x11/primary.c               |  231 ++--
 DirectFB-1.3.0/systems/x11/vpsmem_surface_pool.c   |   28 +-
 DirectFB-1.3.0/systems/x11/x11.c                   |  307 ++---
 DirectFB-1.3.0/systems/x11/x11.h                   |   45 +-
 DirectFB-1.3.0/systems/x11/x11_surface_pool.c      |   52 +-
 DirectFB-1.3.0/systems/x11/x11image.c              |   64 +-
 DirectFB-1.3.0/systems/x11/x11image.h              |   12 +-
 DirectFB-1.3.0/systems/x11/x11input.c              |  142 ++-
 DirectFB-1.3.0/systems/x11/xwindow.c               |  101 +-
 DirectFB-1.3.0/systems/x11/xwindow.h               |   64 +-
 DirectFB-1.3.0/tests/Makefile.am                   |    4 -
 DirectFB-1.3.0/tools/dfbdump.c                     |   62 +-
 DirectFB-1.3.0/tools/dfbsummon.c                   |  241 ++++
 DirectFB-1.3.0/tools/mknames.sh                    |   11 +-
 DirectFB-1.3.0/wm/default/default.c                |  598 +++------
 DirectFB-1.3.0/wm/unique/FLOW                      |   15 +
 DirectFB-1.3.0/wm/unique/IDEAS                     |   71 +
 DirectFB-1.3.0/wm/unique/STRET                     |   34 +
 DirectFB-1.3.0/wm/unique/classes/foo.c             |    4 +-
 DirectFB-1.3.0/wm/unique/internal.h                |    1 -
 DirectFB-1.3.0/wm/unique/test_foo.c                |   74 +-
 DirectFB-1.3.0/wm/unique/unique.c                  |    6 +-
 DirectFB-1.3.0/wm/unique/uniquewm.c                |   26 +-
 187 files changed, 12297 insertions(+), 6184 deletions(-)

diff --git a/DirectFB-1.3.0/BUGS b/DirectFB-1.3.0/BUGS
new file mode 100644
index 0000000..4f3ef3e
--- /dev/null
+++ b/DirectFB-1.3.0/BUGS
@@ -0,0 +1,25 @@
+different bugs and issues
+-------------------------
+- sometimes a deadlock occurs in deinitialization done by the signal handler
+- fix late software fallback for emulated triangles and clipping in some cases
+
+
+LSB violations
+--------------
+
+http://www.linuxbase.org/spec/gLSB/gLSB/libpthread.html
+
+- Applications must disconnect from the controlling tty before calling
+  pthread_create.
+
+- Threaded applications cannot use SIGUSR1 or SIGUSR2.
+
+
+demo problems
+-------------
+- some demos work incredible slower with hardware drivers that do not support
+  every blitting function (all except matrox) than with the generic driver. 
+  This is because the surfaces are loaded into offscreen video memory, but
+  cannot be blitted by hardware afterwards because of the non-supported
+  blitting effects (modulation etc). All demos should query the hardware
+  drivers' capabilities, and decide where the surfaces should go.
diff --git a/DirectFB-1.3.0/CODING_STYLE b/DirectFB-1.3.0/CODING_STYLE
new file mode 100644
index 0000000..b4319ee
--- /dev/null
+++ b/DirectFB-1.3.0/CODING_STYLE
@@ -0,0 +1,69 @@
+DirectFB Coding Style
+---------------------
+
+   The purpose of this document is to give developers a brief description
+   of the preferred coding style for the DirectFB source code.
+   
+   
+Indentation
+-----------
+
+   Each new level of code is indented by using 5 spaces, no tabulations at all.
+   Tabulations have a different meaning for different editors and we want to
+   keep uniformity.
+   
+   A line of code should not be longer than 120 columns.
+   
+ 
+Functions
+---------
+
+   Refer to the following prototypes:
+
+   type
+   function( args )
+   {
+        do_something( args );
+   }
+
+   type
+   function( very_long_argument1,
+             very_long_argument2,
+             very_long_argument3 )
+   {
+        do_something( very_long_argument1, 
+                      very_long_argument2,
+                      very_long_argument3 );
+   }
+
+   
+Braces
+------
+
+   We use a bracing style similar to K&R style:
+   
+   if (condition) {
+        do_this();
+        do_that();
+   }
+   else {
+        do_other();
+   }
+
+   if (condition_1 && condition_2 && condition_3 &&
+       condition_4 && condition_5 && condition_6)
+   {
+        do_this();
+        do_that();
+   }
+   else {
+        do_other();
+   }
+
+
+Final Recommendations
+---------------------
+
+   Do not take these hints as strict rules for coding, we rely on your
+   good taste.
+
diff --git a/DirectFB-1.3.0/ChangeLog b/DirectFB-1.3.0/ChangeLog
index f33c471..6e7c353 100644
--- a/DirectFB-1.3.0/ChangeLog
+++ b/DirectFB-1.3.0/ChangeLog
@@ -1,1156 +1,3 @@
-commit 375e21f904ae1b17aad9bfeadcd3422b92b19377
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Mon Sep 29 15:11:44 2008 +0200
-
-    [options] Set default font format to A8 for new surface hint code to always work.
-
-commit 1837deea823d728cab760b3d340470ce2cc592e7
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Mon Sep 29 13:39:45 2008 +0200
-
-    updated ChangeLog once more
-
-commit e53b0eb0b2906255d95c4b7ac35ac7406311658e
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Mon Sep 29 13:39:12 2008 +0200
-
-    [NEWS] Added more news...
-
-commit f45abff01200c7dcf090530234f446906909aa12
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Mon Sep 29 13:09:48 2008 +0200
-
-    Updated ChangeLog and NEWS for DirectFB 1.3.0!
-
-commit 96b8e12ff8436f0bb7d111325085c4377d20ee6e
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Mon Sep 29 11:21:46 2008 +0200
-
-    [IDirectFBSurface] Added DFBSurfaceHintFlags for optimized allocation, format selection etc.
-    
-    Added DSDESC_HINTS to DFBSurfaceDescriptionFlags.
-    
-    Added 'hints' to DFBSurfaceDescription.
-    
-    Implemented DSHF_FONT by selecting the configured font format and premultiplication.
-
-commit 7296d476f6691dc727782e9ba33fb325f6742ff6
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Mon Sep 29 02:49:25 2008 +0200
-
-    [x11] Optimized locking for lock-free case when nothing has changed.
-
-commit 4e2d62d344f9e6b7a5fd7686a1cddf25c8e67ebb
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Mon Sep 29 02:26:25 2008 +0200
-
-    [x11] Fixed GLX texture corruption by making sure ReleaseTexImageEXT() is called *after* glXMakeContextCurrent()
-    
-    when the pixmap was bound as a texture before, especially from another thread/context.
-
-commit ac2a3c267652bfaf95867e43ad687c237d06c8be
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Sun Sep 28 23:54:05 2008 +0200
-
-    [dispatcher] Use direct_thread_lock()/unlock() in dispatcher and stopping function to fix remaining issues.
-
-commit 533e1cb6bfd5974d1f011332eb9926d00031b64b
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Sun Sep 28 23:33:55 2008 +0200
-
-    [x11] Use XShmCreatePixmap() and XCopyArea() instead of XShmGet/PutImage() allowing partial transfers in both directions!
-
-commit 41d7d3cab148b3e53607597c69dd79bc2125074b
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Sun Sep 28 23:33:19 2008 +0200
-
-    [x11] Evil error handling...
-
-commit 8eafc86b91340200050bbb0de7c0dabe9c99e269
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Sun Sep 28 23:32:22 2008 +0200
-
-    [x11] Fixed remaining crash with expose events that ran into a NULL window.
-
-commit 67a367273916fbd4cdba6e46d434e07ee6188346
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Sun Sep 28 23:31:25 2008 +0200
-
-    [wm] Lots of useful debug messages.
-
-commit 7de055f41796e32dfef59f97f5c4c8b8f7e876e7
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Sun Sep 28 23:30:39 2008 +0200
-
-    [core] Call fusion_stop_dispatcher() before destroying pools to fix lots of shutdown issues.
-
-commit 744a03d368e5ee3d2b1cf371190a08764c0a29d1
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Sun Sep 28 23:29:45 2008 +0200
-
-    [fusion] Added fusion_stop_dispatcher() to be called before destroying pools etc... fixing lots of shutdown issues!
-
-commit 7bcddc09975447dca83e86bbe22d0dcbbd2fb49a
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Sun Sep 28 21:25:38 2008 +0200
-
-    [interfaces] Added some debug messages to DirectInterface code.
-
-commit e9b0350475504a535f4db6c85a5085403cfaf946
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Sun Sep 28 21:24:47 2008 +0200
-
-    [util] Added dfb_updates_get_rectangles() for convenience, doing bounding box trade off etc...
-
-commit b9962de77dc15dfe31c4ab51c1ef8b88ea3b6f13
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Sun Sep 28 21:21:41 2008 +0200
-
-    [UniQuE] A debug message and a minor safety check.
-
-commit 589179f256a2426759b4888b89cb369f7be84a34
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Sun Sep 28 21:20:35 2008 +0200
-
-    [UniQuE] Unload foo surface (border tiles) during master shutdown.
-
-commit 778d6a7d28e15d25d089a15051dfe1b2e2477270
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Sun Sep 28 21:19:34 2008 +0200
-
-    [OpenGL] Don't switch to ARGB fonts if acceleration is disabled.
-
-commit f7f22e3df68a0b1e18b5497ed5e233af40c51aae
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Sun Sep 28 14:04:20 2008 +0200
-
-    [thread] Added direct_thread_wait() / _notify(), _lock(), _unlock() and _terminate().
-
-commit 82e0198724ff2a4caa301b3cdd89d5bb8760f433
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Sun Sep 28 01:54:36 2008 +0200
-
-    [software] Disable MMX functions not supporting rotation (Ostep/Dstep) properly.
-
-commit 3e2919e719f3592bd9d2904e1b348c299a5e2168
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Sun Sep 28 01:48:07 2008 +0200
-
-    [default wm] Implement stack rotation and window rotation, thanks to Young Hoon for the original patch!
-
-commit 8339b0644ac6a2ec1ca31c73a357e048364c4c59
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Sun Sep 28 01:45:38 2008 +0200
-
-    [layers] Implement layer rotation using DSCAPS_ROTATED if available, otherwise using rotated window stack.
-    
-    With just a single buffer (frontonly), it always uses rotation of the window stack.
-    
-    Thanks to Young Hoon for the original patch!
-
-commit 09bc7acb42ee21eeb053483f99a67f859c668272
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Sun Sep 28 01:44:27 2008 +0200
-
-    [dfbdump] Show layer and window rotation.
-
-commit b7da6d0e033d85e3ef74e27d15babd73e84db135
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Sun Sep 28 01:43:08 2008 +0200
-
-    [IDirectFBWindow] Added SetRotation() for 90, 180 and 270 degree rotation per window.
-    
-    Thanks to Young Hoon for the original patch!
-
-commit 6d4e5b8b08c8085215d4b01654641265b0bdeb08
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Sun Sep 28 01:26:36 2008 +0200
-
-    [IDirectFBSurface] Added (unimplemented!) DSCAPS_ROTATED to allocate back buffers with width/height swapped.
-
-commit 0826c71717a168423395b27405cfa49291f7db75
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Sun Sep 28 01:20:30 2008 +0200
-
-    [IDirectFBDisplayLayer] Added GetRotation() to query the layer rotation.
-
-commit a42d0243b668376006e673781722bd7f11549857
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Sun Sep 28 01:17:29 2008 +0200
-
-    [graphics] Implement proper clipping for rotated blits of 90, 180 or 270 degree.
-
-commit b265d72582f5b230bf35676e8c1f83a3f86bd01a
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Sun Sep 28 01:16:08 2008 +0200
-
-    [options] Allow '90' and '270' for "layer-rotate" option.
-
-commit 8525bb01605913ccefc82963cfd95ee7989f50fa
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Sun Sep 28 01:12:16 2008 +0200
-
-    [util] Replaced dfb_back_to_front_copy_180() by dfb_back_to_front_copy_rotation() with extra argument.
-    
-    Thanks to Young Hoon for the original patch!
-
-commit 96842fc12394e4a89a66a05f5cf083a5d3441595
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Sun Sep 28 01:05:30 2008 +0200
-
-    [IDirectFBSurface] Added DSBLIT_ROTATE90 and DSBLIT_ROTATE270. Thanks to Young Hoon for original patch!
-
-commit 44c300ddb9d5d8e003c06eb8d5e49572f40e3df7
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Sun Sep 28 00:59:22 2008 +0200
-
-    [util] Added dfb_region_from_rotated(), dfb_rectangle_from_rotated() and dfb_point_from_rotated_region().
-
-commit 55b46effe7f19ef554ba09517e556105fd21ed74
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Sun Sep 28 00:55:07 2008 +0200
-
-    [util] Added D_UTIL_SWAP(a,b) to exchange values.
-
-commit e1c2174e4aa0519bc8463df2c0d3981096aefc1e
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Fri Sep 26 22:12:20 2008 +0200
-
-    [layers] Fixed missing lock on surface structure around dfb_surface_allocation_update() call.
-
-commit 66387ba7565804a12be2b102a392f78cb56f38cf
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Fri Sep 26 22:07:21 2008 +0200
-
-    [surfaces] Fixed wrong allocations being used for locks due to a copy'n'paste error during last cleanup.
-
-commit 0e8877d5706e824b5a2d48b1cdf5e48b24462851
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Fri Sep 26 21:50:21 2008 +0200
-
-    ignore
-
-commit 2a91a14e8171c374ff712b1605a26a69c108e86e
-Author: Niels Roest <niels@directfb.org>
-Date:   Thu Sep 25 19:34:40 2008 +0200
-
-    [sh772x] for JPEG encoding: horz/vert up/downscaling + offset
-    scaling is without n-line mode, so there are artefacts visible vertically
-    (since there operation is handled in 16-pixel steps)
-    todo: if enough memory is available, perform full-picture malloc and scale in 1 step
-
-commit c1e82561ca9ca338fcaf4964d9e6ea54dde0536a
-Author: Niels Roest <niels@directfb.org>
-Date:   Mon Sep 22 20:06:12 2008 +0200
-
-    [sh772x] fix JPEG encoding.
-    n-line mode impossible because destination addresses of VEU cannot be updated intermediately.
-    current implementation generates ints every 16 lines to reprogram VEU.
-    Disadvantage: phase is lost when scaling. (scaling not tested yet)
-
-commit 6c32f67dc024d80dd72fe32c9922a21a82248dc2
-Author: Nikita Egorov <nikego@geos.varma-el.com>
-Date:   Thu Sep 25 13:52:52 2008 +0400
-
-    Set glyph alignment of 8 bytes for all font formats
-
-commit 53f333bd8c44a2aabe1062dda6792df288ce3b35
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Thu Sep 25 01:10:20 2008 +0200
-
-    [fonts] Fixed alignment on eight byte boundary, thanks to Nikita Egorov for spotting!
-
-commit 5fcc55be33005938b2b8c891542ab542bdfbfd56
-Author: Niels Roest <niels@directfb.org>
-Date:   Tue Sep 23 12:42:48 2008 +0200
-
-    [x11] build fixes for people without GLX
-
-commit 11f7f8d45a3b09fb1eb58c57db3dc58066172e65
-Author: Nikita Egorov <nikego@geos.varma-el.com>
-Date:   Mon Sep 22 15:41:00 2008 +0400
-
-    Don't switch to fill rectangle in DrawLine() if matrix is used.
-
-commit cce58cd1c1cce5d0708db3cfd0c8ca1fcb8d43c5
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Mon Sep 22 12:39:18 2008 +0200
-
-    [sh772x] Build fix for 1.3.x.
-
-commit 255907bd76c9e8af7390944bb87715a2d12bedf1
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Sat Sep 20 10:03:59 2008 +0200
-
-    [default wm] In window_at_pointer() use dfb_surface_read_buffer() with 1x1 rectangle instead of lock/unlock.
-
-commit f13337b3bb9ea83881ebccbd98e2ab2a6912d15f
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Sat Sep 20 10:00:30 2008 +0200
-
-    [x11] Use new dfb_surface_buffer_lock_deinit() rather than clearing the magic.
-
-commit 539cec381cf29413df91e3ec72d88bb2134af81c
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Sat Sep 20 09:57:08 2008 +0200
-
-    [surfaces] Implemented dfb_surface_buffer_read(), added dfb_surface_buffer_lock_deinit(), moved out format conversion.
-    
-    Added dfb_convert_to_rgb24() and dfb_convert_to_a8(), used for surface dumps to .ppm files.
-
-commit d9aaad3f6a8e8ed3cb19ef0afebb8d531057e261
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Sat Sep 20 09:41:41 2008 +0200
-
-    [UniQuE] Added experimental border event handling in test_foo program to move/raise any window :)
-    
-    Try running:
-    	./test_foo &
-    and
-    	gtk-demo
-    
-    Note: Raising windows confuses GDK-DirectFB and moving a window over another has grabbing issues,
-    but this was just a quick test and the solution to these issues is clear ;)
-
-commit 05ac679d7d23d59cc20dbea93211c1f43bfbdddd
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Sat Sep 20 09:40:07 2008 +0200
-
-    [UniQuE] Use dfb_surface_write_buffer() instead of lock/memcpy/unlock for border images (foo).
-
-commit 3f2dadcee38044fe6c40d194551db004c093076f
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Fri Sep 19 04:04:48 2008 +0200
-
-    [x11] Fixed missing x11types.h in SOURCES definition.
-
-commit 6952526a54a4adf7c2e0f43d3a2f47d4a4cfbc5d
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Fri Sep 19 04:03:06 2008 +0200
-
-    [sh7722] Fixed EXTRA_DIST.
-
-commit 6b258d60b619c26f5483234894513e4272608402
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Thu Sep 18 22:11:55 2008 +0200
-
-    [x11] In glxDeallocateBuffer() don't use GetLocalPixmap(), but only direct_hash_lookup().
-    
-    This avoids creating the pixmap if it did not exist, yet, e.g. no Lock() happened.
-
-commit 6e34c52a52e0b0136a50fad63f719c59ee614c84
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Thu Sep 18 21:27:18 2008 +0200
-
-    [x11] When update goes directly from XShmImage without copy/convert (single buffer layer), do an XSync()!
-
-commit 8cc7a4021cf98db2730b3bf0de4effd1cb98c984
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Thu Sep 18 21:26:50 2008 +0200
-
-    [x11] Hotfix missing update queue...
-
-commit 2df15476a32f2a795446a4b51e090114b972e4f8
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Thu Sep 18 21:01:02 2008 +0200
-
-    [x11] Lookup visual in master where XShmCreateImage is actually called.
-
-commit 53ad404266ece35e6e6e625ec5d87c6a57c56ee3
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Thu Sep 18 19:43:30 2008 +0200
-
-    [windowstack] Set background mode of new contexts to DLBM_DONTCARE.
-
-commit 286730ed5ed1358aae77946ff7c827b94be9b727
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Thu Sep 18 19:10:57 2008 +0200
-
-    [thread] Fixed missing magic value in thread structure created for non-direct threads.
-
-commit 8e34df9400f6161c1885de710e5df5d64dcd6c98
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Thu Sep 18 19:02:27 2008 +0200
-
-    [layers] Fixed unlocking of destroyed skirmish in context destructor.
-    
-    [merged from release_1_2_x]
-
-commit cdc9cae71ce7ac43f73ed919d853ff0f471289be
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Thu Sep 18 17:28:44 2008 +0200
-
-    [x11] Implemented Surface Pool Bridge for fast transfer between XShmImage and GLX pool.
-    
-    Using XShmPutImage/XShmGetImage instead of using XPutImage/XGetImage speeds up df_andi
-    by more than 100% in my tests.
-
-commit 9a65e7235b619396096bc01fcb02b3dffc51ef27
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Thu Sep 18 17:23:56 2008 +0200
-
-    [surfaces] Added Surface Pool Bridge[tm] technology to speed up transfer between pools.
-    
-    New API can be implemented to do optimized transfer from one surface pool to another.
-    
-    CheckTransfer() is called to probe each registered CoreSurfacePoolBridge.
-    
-    CoreSurfacePoolTransfer is allocated with one or more rectangles to be transfered.
-    
-    StartTransfer() and FinishTransfer() are used to actually execute the transfer
-    which could be queued, but is synchronous at the moment (Start+Finish).
-
-commit b0c0ba9446ca0fe67ab940433b149fc7a1d4fb85
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Thu Sep 18 00:04:38 2008 +0200
-
-    [IDirectFBImageProvider_PNG] Use dfb_surface_write_buffer() if possible.
-
-commit b737a1bc975555ad1b897975803808f0cfce3dd6
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Thu Sep 18 00:00:29 2008 +0200
-
-    [surfaces] Implemented dfb_surface_buffer_write() using Write() on allocation.
-    
-    New algorithm for finding the allocation which to Write() to, using last read
-    allocation or other up to date allocation.
-    
-    Remember last read allocation for better negotiation in case of multiple up to
-    date allocations.
-
-commit 0c5e8ec043a25184bd2d501417985fa122ec9596
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Wed Sep 17 23:55:27 2008 +0200
-
-    [dfbtest_blit] Added option "-R" to rerender image to surface before every blit (benchmark).
-
-commit 73e61e0fd4fb4b0ac69882b6a9c94e1ee061be7b
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Wed Sep 17 21:00:47 2008 +0200
-
-    [x11] Move definition of USE_GLX to configure.
-
-commit 89b08b7254cd4d56b20b8205a1770aec2b687c49
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Wed Sep 17 20:56:50 2008 +0200
-
-    [x11] Fixed another 'missing separator' error in Makefile.
-
-commit fde10fcaad76bfd25081936a082eef5223e580af
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Wed Sep 17 20:55:39 2008 +0200
-
-    [x11] Fixed 'missing separator' error in Makefile.
-
-commit 3a60e628798ca0df33779c4b68c631a50007c060
-Merge: dec7005... ab2b4d7...
-Author: Niels Roest <niels@directfb.org>
-Date:   Wed Sep 17 20:39:26 2008 +0200
-
-    Merge branch 'master' of git+ssh://git.directfb.org/git/directfb/core/DirectFB
-
-commit dec70057d72dcf7f0f5a1b62d8fc848ab1ddace8
-Author: Niels Roest <niels@directfb.org>
-Date:   Wed Sep 17 20:39:15 2008 +0200
-
-    [x11] x11 should not rely on gl.h header file presence.
-
-commit ab2b4d7568053c963d15083f798cded3448d1d4a
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Wed Sep 17 20:16:36 2008 +0200
-
-    [davinci] Update driver for 1.3.0 changes in surface pools.
-
-commit ad2f11641d2a23c00a0917c4060858edc1c73413
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Wed Sep 17 16:11:12 2008 +0200
-
-    [davinci] Workaround broken DSP cache invalidation function.
-
-commit 8403a7fd6d6d79885aa5e62a38929185b589cf4a
-Merge: d1b2807... 5c71f6f...
-Author: Niels Roest <niels@directfb.org>
-Date:   Wed Sep 17 19:09:06 2008 +0200
-
-    Merge branch 'master' of git+ssh://git.directfb.org/git/directfb/core/DirectFB
-
-commit d1b2807efab53fcd30b0cd3c0d5e0a099555b5b0
-Author: Niels Roest <niels@directfb.org>
-Date:   Wed Sep 17 19:08:48 2008 +0200
-
-    [core] check and handle return value of get_layer_dimension().
-    Can go wrong with davinci driver without GET_TIMING patches.
-
-commit 6d1f4e5ea2166f68270230f779b07203aba581db
-Author: Niels Roest <niels@directfb.org>
-Date:   Wed Sep 17 19:06:07 2008 +0200
-
-    [davinci] param missing in debug print
-
-commit 9c2808bf55f36d96326f170057a3c4225c9a50bf
-Author: Niels Roest <niels@directfb.org>
-Date:   Wed Sep 17 19:05:19 2008 +0200
-
-    [x11 input] possible lock at shutdown due to thread trying to kill itself
-
-commit 5c71f6f7fb98166c0224e5141e7df6f88fb34aa6
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Wed Sep 17 18:32:50 2008 +0200
-
-    [x11] Added missing header from last major cleanup.
-
-commit e08c004f94228c022cc78e91b12d9df3f5aa3641
-Merge: b67d7df... 69ecb59...
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Wed Sep 17 18:27:56 2008 +0200
-
-    Merge branch 'master' of git+ssh://git.directfb.org/git/directfb/core/DirectFB
-
-commit b67d7df1780848705949b7a8819534079ea4be68
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Wed Sep 17 18:26:03 2008 +0200
-
-    [OpenGL] Restructured surface pool and graphics driver, leaving GLX in the system module...
-    
-    Also tried to make multi application working, but it seems that for an X11 Pixmap there can
-    only be one process doing a glXCreatePixmap() which also does not allow the GLXPixmap to be
-    shared :(
-
-commit 2b63196cd9e93f492cc1c9058c92cfe8d691a9b8
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Wed Sep 17 18:25:06 2008 +0200
-
-    [surfaces] Assert that pitch is != 0 only if virtual or physical address is present.
-
-commit 69ecb59725ec375da89ee57218afccf56d8bfdc4
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Wed Sep 17 12:16:49 2008 +0200
-
-    [davinci] Raise OSD surface pool priority to allocate in frame buffer rather than /dev/mem.
-
-commit e10cb3822ac5d0842a0e489fb30ffdcac0532700
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Wed Sep 17 12:05:43 2008 +0200
-
-    [trace] Fixed static build.
-
-commit ddae89777f9350ce5a5ff754f5909cc950bd08c5
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Sun Sep 14 16:33:59 2008 +0200
-
-    [x11] MAJOR cleanup of system module code. Every slave connects to the server now as well!
-    
-    Separated shared and local parts in the setup to avoid code duplication.
-    
-    It looks like all processes can have their own DirectFB windows and render to them via OpenGL,
-    but putting them on the screen (X window) fails. It seems binding another process' GLXPixmap
-    is not allowed. Hopefully I can just create each process own GLXPixmap wrapper around the real
-    XPixmap...
-
-commit ca33e763a6881d36902bf04da0b7b5a376992250
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Sun Sep 14 11:37:44 2008 +0200
-
-    [OpenGL] GLX to be precise... full featured GL based acceleration on top of X11 system module!
-    
-    Some changes have been necessary to make this happen... a few at least :)
-    
-    $ df_dok --dfb:mode=800x600 --dump --accelonly
-    
-       ~~~~~~~~~~~~~~~~~~~~~~~~~~| DirectFB 1.3.0 |~~~~~~~~~~~~~~~~~~~~~~~~~~
-            (c) 2001-2008  The world wide DirectFB Open Source Community
-            (c) 2000-2004  Convergence (integrated media) GmbH
-          ----------------------------------------------------------------
-    
-    (*) DirectFB/Core: Single Application Core. (2008-09-14 09:06)
-    (*) Direct/Memcpy: Using libc memcpy()
-    (*) GLX/Surfaces: Using visual 0x2e (24bit) and 0x64 (32bit)
-    (*) Direct/Thread: Started 'X11 Input' (29248) [INPUT OTHER/OTHER 0/0] <8388608>...
-    (*) DirectFB/Input: X11 Input 0.1 (directfb.org)
-    (*) DirectFB/Genefx: MMX detected and enabled
-    (*) DirectFB/Graphics: OpenGL Acceleration - GeForce 8800 GTX/PCI/SSE2 0.5 (Denis Oliver Kropp)
-    (*) DirectFB/Core/WM: Default 0.3 (directfb.org)
-    (*) X11/Window: Creating  800x 600 RGB32 window...
-    (*) X11/Display: Using XShm.
-    (*) Direct/Interface: Loaded 'PNG' implementation of 'IDirectFBImageProvider'.
-    (*) Direct/Interface: Loaded 'FT2' implementation of 'IDirectFBFont'.
-    (*) Direct/Interface: Using 'GIF' implementation of 'IDirectFBImageProvider'.
-    
-    Benchmarking 256x256 on 800x580 RGB32 (32bit)...
-    
-    Anti-aliased Text                              3.000 secs (*4736.400 KChars/sec) [ 99.6%]
-    Anti-aliased Text (blend)                      3.000 secs (*4724.400 KChars/sec) [ 99.3%]
-    Fill Rectangle                                 4.288 secs (*13269.205 MPixel/sec) [100.0%]
-    Fill Rectangle (blend)                         5.495 secs (*6860.110 MPixel/sec) [100.0%]
-    Fill Rectangles [10]                           4.614 secs (*13280.485 MPixel/sec) [100.0%]
-    Fill Rectangles [10] (blend)                   6.125 secs (*6858.543 MPixel/sec) [100.0%]
-    Fill Triangles                                 4.841 secs (*13359.001 MPixel/sec) [100.0%]
-    Fill Triangles (blend)                         6.565 secs (*6908.482 MPixel/sec) [ 99.8%]
-    Draw Rectangle                                 3.000 secs (*1206.566 KRects/sec) [ 99.3%]
-    Draw Rectangle (blend)                         3.000 secs (*1205.933 KRects/sec) [ 99.3%]
-    Draw Lines [10]                                3.000 secs (*4576.000 KLines/sec) [ 99.6%]
-    Draw Lines [10] (blend)                        3.000 secs (*4582.333 KLines/sec) [ 99.6%]
-    Fill Spans                                     3.002 secs (*2021.530 MPixel/sec) [ 99.6%]
-    Fill Spans (blend)                             3.001 secs (*2026.571 MPixel/sec) [ 99.3%]
-    Blit                                           4.867 secs (*9148.378 MPixel/sec) [ 99.5%]
-    Blit 180                                       4.867 secs (*9167.230 MPixel/sec) [100.0%]
-    Blit with colorizing                           4.872 secs (*9133.609 MPixel/sec) [ 99.7%]
-    Blit from 32bit (blend)                        5.906 secs (*5886.699 MPixel/sec) [100.0%]
-    Blit from 32bit (blend) with colorizing        5.917 secs (*5869.110 MPixel/sec) [ 99.8%]
-    Stretch Blit                                   4.677 secs (*11836.563 MPixel/sec) [ 99.7%]
-    
-    http://www.directfb.org/tests/benchmarks/DirectFB_OpenGL_GeForce_8800_GTX/
-
-commit 806763a3e190ec55357175197fb01597bf79c874
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Sun Sep 14 05:35:40 2008 +0200
-
-    [call] Added debug messages.
-
-commit 29b4f65de808fe56d0315a518a251342157849df
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Sat Sep 13 20:53:37 2008 +0200
-
-    [options] Fixed pixel format parsing code, first check for exact, then for partial matches.
-
-commit 7872de5113e4ca56c281d585d5b164215c276b56
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Sat Sep 13 20:49:22 2008 +0200
-
-    [graphics] Only have DSRO_MATRIX be mandatory for now. Other flags no longer prohibit acceleration.
-    
-    Worst case was when DSRO_SMOOTH_UP/DOWNSCALE was turned on globally via "smooth-upscale" or "smooth-downscale"
-    runtime option which caused all operations to use software fallbacks, not only StretchBlit()!
-
-commit aeb008fe40f57fbad4572c077c0ee529e5890538
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Thu Sep 11 02:41:22 2008 +0200
-
-    [generic] Added optimized Bop_argb_blend_alphachannel_one_invsrc_Aop_argb() -> 6x speed
-
-commit 7683d221c355d432c62456e40af85dadd5274840
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Wed Sep 10 22:11:03 2008 +0200
-
-    [SH7722] Follow device name change in JPEG code, too.
-
-commit 0a47e5fecb45cf9cb30ee5bcc897d7a4de369b06
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Wed Sep 10 21:38:14 2008 +0200
-
-    ignore
-
-commit 898e42cc05c2b306de1f11658a884b5bf79573af
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Wed Sep 10 21:33:30 2008 +0200
-
-    [SH7723] Added support for SH7723 to SH7722 driver and kernel module.
-    
-    (*) DirectFB/Graphics: Renesas SH7723 0.9 (Denis & Janine Kropp)
-    (*) DirectFB/Core/WM: SaWMan 0.2 (directfb.org)
-    (*) SaWMan/Config: Parsing config file '/etc/sawmanrc'.
-    (*) SaWMan: Initializing stack 0x432078 for tier 0x431a48, 0x0, layer 0, context 0x431e78 [1]...
-    (*) SaWMan/Init: Layer  0:  800x480, RGB16, options: 1
-    (*) SaWMan/Init: Border 0:  800x480, RGB16, options: 8
-    (*) Direct/Interface: Using 'PNG' implementation of 'IDirectFBImageProvider'.
-    (*) Direct/Interface: Using 'FT2' implementation of 'IDirectFBFont'.
-    (*) Direct/Interface: Using 'GIF' implementation of 'IDirectFBImageProvider'.
-    
-    Benchmarking 256x256 on 800x464 RGB16 (16bit)...
-    
-    Fill Rectangle                                 5.350 secs (* 200.895 MPixel/sec) [  3.9%]
-    Fill Rectangle (blend)                         8.590 secs (*  78.582 MPixel/sec) [  1.7%]
-    Fill Rectangles [10]                           5.226 secs (* 200.646 MPixel/sec) [  1.1%]
-    Fill Rectangles [10] (blend)                  11.699 secs (*  78.425 MPixel/sec) [  0.3%]
-    Fill Triangles                                14.254 secs (*  26.436 MPixel/sec) [  1.1%]
-    Fill Triangles (blend)                        26.657 secs (*   8.727 MPixel/sec) [  0.4%]
-    Draw Rectangle                                 3.127 secs (*  30.444 KRects/sec) [ 44.8%]
-    Draw Lines [10]                                3.062 secs (* 122.468 KLines/sec) [ 35.9%]
-    Fill Spans                                     3.013 secs (* 147.907 MPixel/sec) [ 73.4%]
-    Fill Spans (blend)                             3.037 secs (*  73.369 MPixel/sec) [ 27.0%]
-    Blit                                          11.698 secs (*  56.023 MPixel/sec) [  1.4%]
-    Blit colorkeyed                                8.376 secs (*  59.464 MPixel/sec) [  1.6%]
-    
-    TODO: more acceleration work...
-
-commit 19629048a342561cbaa3052eece6d2e75fbc3db2
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Wed Sep 10 13:39:32 2008 +0200
-
-    [SH7722] Fixed missing update of rendering destination buffer.
-
-commit b9080ea41cc5b711fa91269a0839d9fe5e0f4b35
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Wed Sep 10 13:39:02 2008 +0200
-
-    [windows] Set magic value in CoreWindow before calling WM functions.
-
-commit 7a005609bc7d15564dd11fe75476e71ba8659d74
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Wed Sep 10 11:07:57 2008 +0200
-
-    [SH7722] Fixed software fallback for JPEG decoding to unsupported formats.
-
-commit 09affae4b0301cca29b96305b473995d652e427f
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Wed Sep 10 10:38:48 2008 +0200
-
-    [trace] Added missing dummies of new lookup functions for non-trace builds.
-
-commit 230ff7fdd3a660a19f1b06f664e7ac3f33630524
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Wed Sep 10 10:24:22 2008 +0200
-
-    [util] Added exported dfb_pixelformat_names[] and replaced relevant code.
-
-commit 6c311c746f706373dd19d043e6c4065c739c864d
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Wed Sep 10 10:22:42 2008 +0200
-
-    [mknames] Generate separate declaration of value/name pair structures.
-
-commit 3869d4e007c82cfe58d094072dcbb81179e53410
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Wed Sep 10 09:30:32 2008 +0200
-
-    [generic] Get rid of YUV tables saving 5k binary size!
-
-commit 67a89c7383af3c49d7de0ea78904a82e693b4bf6
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Wed Sep 10 09:05:37 2008 +0200
-
-    [header] tab->space
-
-commit 1179e5c81de1312064d0c9475389e6c7b9e39e13
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Wed Sep 10 09:04:21 2008 +0200
-
-    [SDL] Replaced code in commented section by using dfb_convert_to_rgb16().
-
-commit 392b6dfbd6ff69e54e6f31e81422e2da2e863e20
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Wed Sep 10 09:03:07 2008 +0200
-
-    [formats] Fixed many NV12, NV16 and NV21 code areas, mostly for big endian.
-
-commit edb133bd9b26baa21c641acaa0e05f2724260109
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Wed Sep 10 08:59:59 2008 +0200
-
-    [JPEG] Fix direct decoding to NV16 (no to+from RGB) for little endian.
-
-commit feb307b7c28a52ba38353e96a5816cd374909705
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Wed Sep 10 08:59:18 2008 +0200
-
-    [formats] Clarify definition of NV12, NV16 and NV21.
-
-commit c723856a84d1892eca64c5b7c3227e665a288c4b
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Wed Sep 10 06:46:45 2008 +0200
-
-    [dfbtest_blit] Added test program for (Stretch)Blit with an image from file.
-    
-    Options:
-      -h, --help                        Show this help message
-      -v, --version                     Print version information
-      -s, --source    <pixelformat>     Source pixel format
-      -d, --dest      <pixelformat>     Destination pixel format
-      -r, --resize                      Set destination from source size
-      -b, --benchmark                   Enable benchmarking mode
-
-commit 391cf2c4c33738c114a40c0ba0edfffcdac24233
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Wed Sep 10 06:45:03 2008 +0200
-
-    [generic] Rewrote Dacc_RGB_to_YCbCr_C and Dacc_YCbCr_to_RGB_C using Duff's device with macros.
-    
-    Conversion also supports 4:4:4 by this change, not optimizing for 4:2:x cases.
-
-commit 687dd974b9531e71115dbf833ac7ec0c6e3b9bc3
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Wed Sep 10 06:42:51 2008 +0200
-
-    [convert] Fix missing parentheses around macro parameters in YCBCR_TO_RGB().
-
-commit ce7dc5e548faef36201be5beb51d1311ef41c78a
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Wed Sep 10 06:35:15 2008 +0200
-
-    [convert] Rewrote YCbCr<->RGB conversion routines without lookups which are much more expensive on embedded devices.
-
-commit 13425aeb1e3f28e7d595f578047f4dc3f069a5b4
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Wed Sep 10 03:26:18 2008 +0200
-
-    [options] New option "[no-]software-trace" to show every stage of the software rendering pipeline.
-
-commit 01ab1f314edb281b30913d9295a8571f450eca80
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Wed Sep 10 03:24:30 2008 +0200
-
-    [direct] Added file and symbol lookup functions to trace code for external usage.
-    
-    New functions are direct_trace_lookup_file(), direct_trace_lookup_symbol() and
-    a convenience function combining the above called direct_trace_lookup_symbol_at().
-
-commit 59bbf8d99d59a9e6cf706bf4c4ad3f312905e019
-Author: Denis Oliver Kropp <dok@debian.(none)>
-Date:   Thu Sep 4 01:02:36 2008 +0900
-
-    [README] Added some packages for autofoo...
-
-commit a37835f7cddd8920086d0f7aff812937f9c79368
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Sun Aug 24 21:24:06 2008 +0200
-
-    [default wm] Fixed crash with DWCAPS_NOFOCUS implementation.
-
-commit 47b59c53b7ca42c63b82710fd872081f8e82ed93
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Sun Aug 24 17:10:45 2008 +0200
-
-    [default wm] Implemented DWCAPS_NOFOCUS.
-
-commit 7ca1f65b1b5b9648c136ad60530199a63ac51648
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Sun Aug 24 17:10:19 2008 +0200
-
-    [IDirectFBWindow] Added DWCAPS_NOFOCUS: window will never get focus or receive key events, unless it grabs them.
-
-commit df96caeb46881c266cbd871d0ff8ef182e1eb2ff
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Sat Aug 23 13:58:10 2008 +0200
-
-    [configure] Switch to pkg-config for SDL and FreeType2, thanks to Keith Mok!
-
-commit a812539bf6af796fb236762e75982b5d45b87eff
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Fri Aug 22 20:32:30 2008 +0200
-
-    [input] Fixed boundary check for axis info array access.
-
-commit 967af1280ad5d103c086e8cdfa0200e31bf00892
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Fri Aug 22 20:01:45 2008 +0200
-
-    [sh7722] Build only for SH4.
-
-commit 2b7886ff4e966a3a9a8df499991092058019fc7d
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Fri Aug 22 19:46:45 2008 +0200
-
-    [default wm] Use min/max values from absolute axis motion events if present.
-
-commit a7b2e45fa92d1914277bd25e44f2ea9a8703dad5
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Fri Aug 22 19:46:05 2008 +0200
-
-    [input] Query axis information from driver and put it into events.
-
-commit 615d54cfea5becdefd4bd388b7f61b7a9b3dcd3f
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Fri Aug 22 19:41:40 2008 +0200
-
-    [IDirectFBInputDevice] Added DIEF_MIN/MAX and min/max to DFBInputEvent, e.g. for axis boundaries.
-
-commit 698d68a5c0afbf3e4e5f477c4da8e705d78adae8
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Fri Aug 22 16:44:26 2008 +0200
-
-    [input] Added GetAxisInfo() to InputDriverFuncs to query information about one axis.
-    
-    Make use of it in input_driver.h only if driver has defined DFB_INPUTDRIVER_HAS_AXIS_INFO
-    to avoid having to change all input drivers.
-
-commit 043cf5674b99087df7ceebe3749edf7f2268b68d
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Fri Aug 22 16:44:10 2008 +0200
-
-    [IDirectFBInputDevice] Added DFBInputDeviceAxisInfo(Flags) with DIAIF_ABS_MIN/MAX flags and abs_min/max fields.
-
-commit b12044ecd6f738bfa28052fcc8b36c520dffe578
-Merge: 6832da9... 8d5f445...
-Author: Niels Roest <niels@directfb.org>
-Date:   Thu Aug 21 17:29:30 2008 +0200
-
-    Merge branch 'master' of git+ssh://git.directfb.org/git/directfb/core/DirectFB
-
-commit 6832da9ae538d5d062e820782e96114757ed8c3b
-Author: Niels Roest <niels@directfb.org>
-Date:   Thu Aug 21 17:27:34 2008 +0200
-
-    [davinci] In ARGB OSD dithering use task buffer and add missing locks.
-
-commit 8d5f44551430c5e4005fd9b60edd27e9f383d00b
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Thu Aug 21 11:34:08 2008 +0200
-
-    [sh7722] Fixes for JPEG encoding with conversion, cleanups...
-
-commit a29676ac604b3e3f9fa00543330464f77442c9a5
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Thu Aug 21 08:21:34 2008 +0200
-
-    [interfaces] Important fix for having multiple interface implementations in one module.
-
-commit 5b80d5d1bdec3e3334b4f9119d92f1cb3fcbcea1
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Tue Aug 19 11:21:52 2008 +0200
-
-    [windows] Added magic value to CoreWindow.
-
-commit 294a40d71c8173ba2e539721d8988e58ff5c9436
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Sat Aug 16 02:08:45 2008 +0200
-
-    [IDirectFBWindow] Added DWOP_FOLLOW_BOUNDS to make bounds follow the parent window.
-
-commit ca9c9600e0f1a8f1cb243eb7ecf22115c98669ec
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Sat Aug 16 01:57:03 2008 +0200
-
-    [x11] Fixed new bug with reopening X11 window when layer resizes.
-
-commit b2611d5352b1548900202cc9418e6e83b4b81ca8
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Sat Aug 16 00:36:31 2008 +0200
-
-    [dfbtest_window] Implemented selection of individual tests for top/sub window and added option to wait at the end.
-
-commit e0a02568469a1325de9a5c4a3e9447571f390a1b
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Fri Aug 15 22:59:18 2008 +0200
-
-    [dfbtest_window] Added options for setting window options and for window association.
-
-commit 63c4da3b3a720fd41a59e07c1344614f3956c9eb
-Merge: 779b31c... 0148ec4...
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Fri Aug 15 21:00:33 2008 +0200
-
-    Merge branch 'master' of git+ssh://git.directfb.org/git/directfb/core/DirectFB
-
-commit 779b31c4fbddfc8890d4fb57bbf9ef93ebde62cc
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Fri Aug 15 21:00:04 2008 +0200
-
-    [strings] Generate name/value pairs for DFBWindowOptions.
-
-commit 0148ec4dacbe599d9b10e0075237e87a8f064578
-Author: Niels Roest <niels@directfb.org>
-Date:   Fri Aug 15 20:09:50 2008 +0200
-
-    [x11] improve shutdown behaviour of X11 module.
-    
-    Certain race conditions at shutdown prevented, leading to lock or crash.
-    x11input and x11 modules combined into 1.
-
-commit 0b090e40b85160ce947d7b931f9a6ece54862d29
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Fri Aug 15 18:54:59 2008 +0200
-
-    [interfaces] Fix previous commit for unregistering interfaces, removing the proto type which had the old name.
-
-commit af62273b41eab8d66d6ff1cafe1941ef6f7f836d
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Fri Aug 15 18:31:34 2008 +0200
-
-    [interfaces] Added DirectUnregisterInterface() and destructor to call it.
-    
-    Added magic value to interface implementation structure and use D_CALLOC/D_FREE.
-
-commit 47ec69f0cb945a74269859a91c2b359deb6d0660
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Fri Aug 15 16:40:50 2008 +0200
-
-    [dfbtest_window] Added advanced window geometry tests.
-
-commit f6b440a1b7beb0ccb6984930422c2ae65accb7e3
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Wed Aug 13 19:12:04 2008 +0200
-
-    [dfbtest_window] Enhanced testing and logging code. Run most tests on sub window, too.
-
-commit 4124b63f7f897408c9c5ef7b62fed029dd62a64e
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Wed Aug 13 19:08:55 2008 +0200
-
-    [dfbmaster] Added very simple dedicated master for safety, stability or enhanced testing pleasure.
-
-commit 4a3d91bc149d25a6dfaf77b58418d86295033ae1
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Wed Aug 13 06:14:49 2008 +0200
-
-    [default wm] Build fix for previous commit that reduces recursion.
-
-commit 4596df5e093d5b054f38780577a5fb02252792e5
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Wed Aug 13 06:05:55 2008 +0200
-
-    [default wm] Make sure window has a surface before restoring its size when disabling scaling.
-
-commit efb4e64a74157b65458ed4c4e297ab3a2b307fca
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Wed Aug 13 06:05:02 2008 +0200
-
-    [strings] Generate name/value pairs for DFBWindowCapabilities.
-
-commit e27b49141e988748b059f1672a6d98a3baf02389
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Wed Aug 13 06:04:07 2008 +0200
-
-    [dfbtest_window] New option to pass window caps for top or sub window.
-    
-    Fixes for input only windows, e.g. don't try to grab surface :)
-
-commit 6b6803f94de9da390c32e029211d8c10aba1113e
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Wed Aug 13 05:07:11 2008 +0200
-
-    [x11] Implemented primaryRemoveRegion() with a new call to destroy the X11 window.
-    
-    Also cleaned up name of window creation call (set_video_mode -> create_window).
-
-commit e66998a2459aca790752a7511eab41239112c372
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Wed Aug 13 05:06:20 2008 +0200
-
-    [dfbtest_window] Added test that hides the top level window and shows it again.
-
-commit 603158aaa73dbf713cf1b66692ec179c6668f8ce
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Wed Aug 13 04:27:31 2008 +0200
-
-    [subwindows] Destroy all sub windows first in window destruction code.
-
-commit fcb4bd03e2dda669f8c221d236a3828af50f58f7
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Wed Aug 13 04:24:46 2008 +0200
-
-    [dfbtest_window] Added more options, window destroy test and proper cleanup.
-    
-    Added -p / --pos for top level position and added a sub window version of each top level option.
-    
-    New test at the end destroys the top level window.
-    
-    Remember top level (if created) and sub window and release them before exit.
-
-commit 285b2ccbbcb41c5e6655edd7ebb1974a6bb89cf9
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Wed Aug 13 03:27:54 2008 +0200
-
-    [default wm] Avoid most of the recursive calls of wind_of_change().
-
-commit ebfdb3cf9d20b43475ad9375e028e965ae2cc7e6
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Wed Aug 13 00:55:38 2008 +0200
-
-    [x11] Fixed race condition and X error when switching resolution quickly.
-
-commit d934bdd21fb0ca42e86e5c7e0c2c146fa2e1c820
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Tue Aug 12 14:25:28 2008 +0200
-
-    [x11] More X locking and checks for input thread exit... still not satisfied...
-
-commit da6fcf72c6b101f8890a1d08d513eda67935343c
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Tue Aug 12 14:23:19 2008 +0200
-
-    [dfbtest_window] Added new program for testing window and sub window features :)
-    
-    Tests done right now:
-    	- create top level
-    	- create sub window
-    	- move top level
-    	- scale top level
-
-commit d1072e7e22013eb0a12f997950499da0b5d2b5eb
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Tue Aug 12 14:18:11 2008 +0200
-
-    [IDirectFBWindow] Initial checkin of sub window support (one level only for DirectFB 1.4)...
-    
-    Added DWCAPS_SUBWINDOW, DWDESC_TOPLEVEL_ID and "toplevel_id" to DFBWindowDescription.
-    
-    Manage ref to top level window and vector of sub windows in window core, but leave scaling,
-    translation and clipping of sub window bounds based on top level bounds to the WM module.
-    
-    Cleaned up IDirectFBWindow method order...
-
-commit 0ad26c8f57494bca399f09133e04bef17f9f0521
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Tue Aug 12 14:15:54 2008 +0200
-
-    [windows] Added lock and ref around dfb_wm_close_stack() in dfb_wm_close_all_stacks(), added context magic and lock assertions everywhere!
-
-commit 535061197082f993d05f9dd28c3b231cfdf49423
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Tue Aug 12 14:14:46 2008 +0200
-
-    [windows] Added missing locks around direct dfb_wm_... calls...
-
-commit e9ba4041cea208c442d6a5d0b1f0a5fd9a46fb1f
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Tue Aug 12 14:13:37 2008 +0200
-
-    [layers] Added magic vaue to CoreLayerContext structure, improved debug messages.
-
-commit 9422d85f922a740ec06a0f5e0955a9eaf419e194
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Tue Aug 12 14:08:37 2008 +0200
-
-    [version] 1.3.0 :-)
-
-commit 85f0417c8392b37ec9543e64e1a1c3a2d2f5703d
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Tue Aug 12 10:56:35 2008 +0200
-
-    [layers] Added debug message to print context being returned by dfb_layer_get_active_context().
-
-commit 21067461e719feaafbb404dfd0fe18f61ac01138
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Tue Aug 12 10:47:03 2008 +0200
-
-    [IDirectFBSurface_Window] Added missing layer context locking around dfb_wm_get_insets() in IDirectFBSurface_Window_Construct().
-
-commit 43cc1713fd9dee2e6c8f9d65ef0d6192187b6a37
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Tue Aug 12 10:20:27 2008 +0200
-
-    [layers] Fixed failing context lock assertion in dfb_wm_close_stack() by locking in context destructor.
-
-commit b00124a5811ba90ca84dab646d42ef8f6a5b184f
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Tue Aug 12 10:15:21 2008 +0200
-
-    [fusion] Fixed single app skirmish lock counting (copy'n'paste bug).
-
-commit a21e4cd136e7b293eb3c2d2f4b8e1426db8b195f
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Tue Aug 12 08:27:39 2008 +0200
-
-    [windows] Avoid recursive dfb_wm_close_stack() caused by SaWMan's CloseStack() unref on the layer region.
-    
-    This issue happens only in single app build, where the layer region constructor gets called synchronously
-    and destroys the window stack structure before the dfb_wm_close_stack() has finished.
-    
-    Fixed by calling CloseStack() at the end dfb_wm_close_stack(), moving the list removal and flag clearing
-    before the call and freeing the stack data in dfb_windowstack_destroy() or recurring dfb_wm_init_stack().
-
-commit b15eb23d6e53f9bb1638575f97e1a6c31a8ef690
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Fri Aug 8 16:39:50 2008 +0200
-
-    updated TODO
-
-commit 550bb3a859161a6ce613dfebebe8b0c86b5701b3
-Author: Denis Oliver Kropp <dok@cyto.(none)>
-Date:   Fri Aug 8 16:00:31 2008 +0200
-
-    updated ChangeLog
-
 commit 8881c385160ebb1fbf20093755866c1f29b1993f
 Author: Denis Oliver Kropp <dok@cyto.(none)>
 Date:   Fri Aug 8 15:59:01 2008 +0200
diff --git a/DirectFB-1.3.0/NEWS b/DirectFB-1.3.0/NEWS
index 64da3b5..096e229 100644
--- a/DirectFB-1.3.0/NEWS
+++ b/DirectFB-1.3.0/NEWS
@@ -1,276 +1,3 @@
-1.3.0
------
-
-API | IDirectFBDisplayLayer
-- Added GetRotation() to query the layer rotation.
-
-API | IDirectFBSurface
-- Added DSBLIT_ROTATE90 and DSBLIT_ROTATE270. Thanks to Young Hoon for original patch!
-- Added DFBSurfaceHintFlags for optimized allocation, format selection etc.
-- Added DSDESC_HINTS to DFBSurfaceDescriptionFlags and 'hints' to DFBSurfaceDescription.
-- Implemented DSHF_FONT by selecting the configured font format and premultiplication.
-- Added DSCAPS_ROTATED to allocate back buffers with width/height swapped (unimplemented).
-
-API | IDirectFBWindow
-- Added SetRotation() for 90, 180 and 270 degree rotation per window.
-  Thanks to Young Hoon for the original patch!
-- Added sub window support with each sub window having its own surface (one level only for DirectFB 1.4)...
-- Added DWCAPS_SUBWINDOW, DWDESC_TOPLEVEL_ID and "toplevel_id" to DFBWindowDescription.
-  Manage ref to top level window and vector of sub windows in window core, but leave scaling,
-  translation and clipping of sub window bounds based on top level bounds to the WM module.
-- Added DWOP_FOLLOW_BOUNDS to make bounds follow the parent window (only for window association, sub windows always follow).
-
-Runtime Options
-- Allow '90' and '270' for "layer-rotate" option.
-
-Graphics Core
-- Implement proper clipping for rotated blits of 90, 180 or 270 degree.
-
-Layer Core
-- Implement layer rotation using DSCAPS_ROTATED if available, otherwise using rotated window stack.
-  With just a single buffer (frontonly), it always uses rotation of the window stack.
-  Thanks to Young Hoon for the original patch!
-- Added magic value to CoreLayerContext structure, improved debug messages.
-- Fixed missing lock on surface structure around dfb_surface_allocation_update() call.
-
-Surface Core
-- Added Surface Pool Bridge[tm] technology to speed up transfer between pools.
-  New API can be implemented to do optimized transfer from one surface pool to another.
-  CheckTransfer() is called to probe each registered CoreSurfacePoolBridge.
-  CoreSurfacePoolTransfer is allocated with one or more rectangles to be transfered.
-  StartTransfer() and FinishTransfer() are used to actually execute the transfer
-  which could be queued, but is synchronous at the moment (Start+Finish).
-- Implemented dfb_surface_buffer_write() using Write() on allocation.
-- New algorithm for finding the allocation which to Write() to, using last read
-  allocation or other up to date allocation.
-- Remember last read allocation for better negotiation in case of multiple up to
-  date allocations.
-- Implemented dfb_surface_buffer_read() using Read() on allocation
-- Added dfb_surface_buffer_lock_deinit(), moved out format conversion.
-
-Window Core
-- Added magic value to CoreWindow.
-- Set magic value in CoreWindow before calling WM functions.
-- Added lock and ref around dfb_wm_close_stack() in dfb_wm_close_all_stacks(), added context magic and lock assertions everywhere!
-
-Pixel Formats
-- Added dfb_convert_to_rgb24() and dfb_convert_to_a8(), used for surface dumps to .ppm files.
-
-Software Rendering
-- Started implementation of DSBLIT_ROTATE90, DSBLIT_ROTATE180 and DSBLIT_ROTATE270 for all blitting flags...
-- Disable MMX functions not supporting rotation (Ostep/Dstep) properly.
-
-Utilities
-- Added D_UTIL_SWAP(a,b) to exchange values.
-- Added dfb_region_from_rotated(), dfb_rectangle_from_rotated() and dfb_point_from_rotated_region().
-- Replaced dfb_back_to_front_copy_180() by dfb_back_to_front_copy_rotation() with extra argument.
-  Thanks to Young Hoon for the original patch!
-
-OpenGL Driver
-- New accelerated driver using OpenGL!
-
-PNG Image Provider
-- Use dfb_surface_write_buffer() if possible.
-
-Default WM
-- Implement stack rotation and window rotation, thanks to Young Hoon for the original patch!
-- In window_at_pointer() use dfb_surface_read_buffer() with 1x1 rectangle instead of lock/unlock.
-
-UniQuE WM
-- Added experimental border event handling in test_foo program to move/raise any window :)
-- Use dfb_surface_write_buffer() instead of lock/memcpy/unlock for border images (foo).
-- Unload foo surface (border tiles) during master shutdown.
-
-X11 System
-- Full featured OpenGL based acceleration via GLX!
-- Implemented Surface Pool Bridge for fast transfer between XShmImage and GLX pool.
-- Use XShmCreatePixmap() and XCopyArea() instead of XShmGet/PutImage() allowing partial transfers in both directions!
-- Also tried to make multi application working, but it seems that for an X11 Pixmap there can
-  only be one process doing a glXCreatePixmap() which also does not allow the GLXPixmap to be shared :(
-
-dfbdump tool
-- Show layer and window rotation.
-
-dfbtest_window tool
-- Added new program for testing window and sub window features :)
-- Added more options, window destroy test and proper cleanup.
-- Added test that hides the top level window and shows it again.
-- New option to pass window caps for top or sub window.
-- Enhanced testing and logging code. Run most tests on sub window, too.
-- Added advanced window geometry tests.
-- Added options for setting window options and for window association.
-- Implemented selection of individual tests for top/sub window and added option to wait at the end.
-
-
-1.2.6
------
-
-Core
-- Call fusion_stop_dispatcher() before destroying pools to fix lots of shutdown issues.
-
-WM Core
-- Lots of useful debug messages.
-
-libfusion
-- Added fusion_stop_dispatcher() to be called before destroying pools etc... fixing lots of shutdown issues!
-
-libdirect
-- Added direct_thread_wait() / _notify(), _lock(), _unlock() and _terminate().
-- Added some debug messages to DirectInterface code.
-
-Utilities
-- Added dfb_updates_get_rectangles() for convenience, doing bounding box trade off etc...
-
-X11 System
-- Fixed remaining crash with expose events that ran into a NULL window.
-
-
-1.2.5
------
-
-Fonts
-- Fixed alignment on eight byte boundary, thanks to Nikita Egorov!
-
-Software Rendering
-- Don't switch to fill rectangle in DrawLine() if matrix is used.
-
-SH772x
-- More fixes for JPEG encoding with up/down scaling and offset.
-
-
-1.2.4
------
-
-API | IDirectFBInputDevice
-- Added DFBInputDeviceAxisInfo(Flags) with DIAIF_ABS_MIN/MAX flags and abs_min/max fields.
-- Added DIEF_MIN/MAX and min/max to DFBInputEvent, e.g. for axis boundaries.
-
-API | IDirectFBWindow
-- Added DWCAPS_NOFOCUS: window will never get focus or receive key events, unless it grabs them.
-
-Runtime Options
-- New option "[no-]software-trace" to show every stage of the software rendering pipeline.
-
-Build Options
-- Switch to pkg-config for SDL and FreeType2, thanks to Keith Mok!
-
-Graphics Core
-- Only have DSRO_MATRIX be mandatory for now. Other flags no longer prohibit acceleration.
-  Worst case was when DSRO_SMOOTH_UP/DOWNSCALE was turned on globally via "smooth-upscale" or "smooth-downscale"
-  runtime option which caused all operations to use software fallbacks, not only StretchBlit()!
-
-Input Core
-- Added GetAxisInfo() to InputDriverFuncs to query information about one axis.
-  Make use of it in input_driver.h only if driver has defined DFB_INPUTDRIVER_HAS_AXIS_INFO
-  to avoid having to change all input drivers.
-- Query axis information from driver and put it into events.
-
-Layer Core
-- Set background mode of new contexts to DLBM_DONTCARE.
-
-Pixel Formats
-- Rewrote YCbCr<->RGB conversion routines without lookups which are much more expensive on embedded devices.
-- Fixed many NV12, NV16 and NV21 code areas, mostly for big endian.
-
-Software Rendering
-- Rewrote Dacc_RGB_to_YCbCr_C and Dacc_YCbCr_to_RGB_C using Duff's device with macros.
-  Conversion also supports 4:4:4 by this change, not optimizing for 4:2:x cases.
-- Get rid of YUV tables saving 5k binary size!
-- Added optimized Bop_argb_blend_alphachannel_one_invsrc_Aop_argb() -> 6x speed
-
-Utilities
-- Added exported dfb_pixelformat_names[] and replaced relevant code.
-
-libdirect
-- Important fix for having multiple interface implementations in one module.
-- Added file and symbol lookup functions to trace code for external usage.
-  New functions are direct_trace_lookup_file(), direct_trace_lookup_symbol() and
-  a convenience function combining the above called direct_trace_lookup_symbol_at().
-- Fixed missing magic value in thread structure created for non-direct threads.
-
-Davinci Driver
-- In ARGB OSD dithering use task buffer and add missing locks.
-- Raise OSD surface pool priority to allocate in frame buffer rather than /dev/mem.
-- Workaround broken DSP cache invalidation function.
-
-SH7722 Driver
-- Build only for SH4.
-- Fixed missing update of rendering destination buffer.
-- Fixes for JPEG encoding with conversion, cleanups...
-- Fixed software fallback for JPEG decoding to unsupported formats.
-
-SH7723 Driver
-- Added support for SH7723 to SH7722 driver and kernel module.
-
-Default WM
-- Use min/max values from absolute axis motion events if present.
-- Implemented DWCAPS_NOFOCUS.
-
-X11 System
-- Update X11 system module with cleaned up code from 1.3.x.
-- Fixes in input driver and layer output.
-
-JPEG Image Provider
-- Fix direct decoding to NV16 (no to+from RGB) for little endian.
-
-dfbtest_blit
-- Added test program for (Stretch)Blit with an image from file.
-
-
-1.2.3
------
-
-X11 System
-- Fixed new bug with reopening X11 window when layer resizes.
-
-
-1.2.2
------
-
-API | IDirectFBSurface
-- Added missing layer context locking around dfb_wm_get_insets() in IDirectFBSurface_Window_Construct().
-
-API | IDirectFBWindow
-- Added missing locks around direct dfb_wm_... calls...
-
-API | Utilities
-- Generate name/value pairs for DFBWindowCapabilities and DFBWindowOptions.
-
-Layer Core
-- Fixed failing context lock assertion in dfb_wm_close_stack() by locking in context destructor.
-- Added debug message to print context being returned by dfb_layer_get_active_context().
-
-Window Core
-- Avoid recursive dfb_wm_close_stack() caused by SaWMan's CloseStack() unref on the layer region.
-  This issue happens only in single app build, where the layer region constructor gets called synchronously
-  and destroys the window stack structure before the dfb_wm_close_stack() has finished.
-  Fixed by calling CloseStack() at the end dfb_wm_close_stack(), moving the list removal and flag clearing
-  before the call and freeing the stack data in dfb_windowstack_destroy() or recurring dfb_wm_init_stack().
-- Fixed crash in window destructor caused by (un)locking the stack.
-- In dfb_wm_close_all_stacks() lock each context and temporarily ref it for following unlock.
-
-libdirect
-- Added DirectUnregisterInterface() and destructor to call it.
-- Added magic value to interface implementation structure and use D_CALLOC/D_FREE.
-
-libfusion
-- Fixed single app skirmish lock counting (copy'n'paste bug).
-
-Default WM
-- Avoid most of the recursive calls of wind_of_change().
-- Make sure window has a surface before restoring its size when disabling scaling.
-
-X11 System
-- Fixed race condition and X error when switching resolution quickly.
-- Implemented primaryRemoveRegion() with a new call to destroy the X11 window.
-- Improve shutdown behaviour of X11 module.
-  Certain race conditions at shutdown prevented, leading to lock or crash.
-  x11input and x11 modules combined into one.
-
-dfbmaster tool
-- Added very simple dedicated master for safety, stability or enhanced testing pleasure.
-
-
 1.2.1
 -----
 
diff --git a/DirectFB-1.3.0/README b/DirectFB-1.3.0/README
index e9ab518..9feffb2 100644
--- a/DirectFB-1.3.0/README
+++ b/DirectFB-1.3.0/README
@@ -45,12 +45,7 @@ Build Requirements
      - libpthread
      - libm
      - libdl
-
-   For regenerating autofoo (./autogen.sh or autoreconf)
-     - autoconf
-     - automake
-     - libtool
-     - pkg-config
+     - pkg-config (for regenerating configure script)
 
    Optionally, depending on the configuration you want:
 
@@ -407,7 +402,6 @@ Thanks to
    Phil Endecott <spam_from_directfb_dev@chezphil.org>
    Brian Austin <brian.austin@cirrus.com>
    Keith Mok <ek9852@gmail.com>
-   Young Hoon <jcybha@hanmail.net>
 
 Special thanks to Ville Syrjala for his great work on the
 Matrox TV-Out support and for his several patches including
diff --git a/DirectFB-1.3.0/README.COOLSTREAM b/DirectFB-1.3.0/README.COOLSTREAM
new file mode 100644
index 0000000..cd15d88
--- /dev/null
+++ b/DirectFB-1.3.0/README.COOLSTREAM
@@ -0,0 +1,4 @@
+This directory contains DirectFB 1.3.0 including all patches done by Coolstream Intl. Ltd.
+
+Before compiling please check the PREFIX in hd1_configure to fit your local requirements.
+To compile DirectFB for HD-1 just run autogen.sh, hd1_config make and make install.
diff --git a/DirectFB-1.3.0/README.OSX b/DirectFB-1.3.0/README.OSX
new file mode 100644
index 0000000..d5c8b1b
--- /dev/null
+++ b/DirectFB-1.3.0/README.OSX
@@ -0,0 +1,41 @@
+Contents
+--------
+1. Creating a build environment for DirectFB unter Mac OS X
+2. Compiling DirectFB and DirectFB-examples
+3. Running the examples
+
+
+1. Creating a build environment for DirectFB unter Mac OS X 10.3
+
+  - install the developer cd that came with Mac OS X 10.3 (newer versions may
+    also work), make sure to install the X11 developer package which is needed
+    for freetype)
+  - install fink 0.7.0 (http://fink.sourceforce.net), fink is a distribution
+    which contains precompiled packages of many open source projects and uses
+    debian package tools (apt-get, dselect, dpkg, etc).
+       - install the following fink packages:
+        * automake1.7
+        * autoconf2.5
+        * llbtool14
+        * pkgconfig
+        * libjpeg
+        * libpng3
+
+  - edit ~/.profile and add the follwing line:
+    export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig
+
+2. Compiling DirectFB
+      cd DirectFB
+      ./autogen.sh
+      make
+      sudo make install
+      cd ../DirectFB-examples
+      ./autogen.sh
+      make
+      sudo make install
+
+3. Running the examples
+      If your screen is garbled, try to specity your OSX desktop resolution
+      in /etc/directfbrc
+      eg.:
+       mode = 1280x1024
diff --git a/DirectFB-1.3.0/aclocal.m4 b/DirectFB-1.3.0/aclocal.m4
index d1c0d75..298b842 100644
--- a/DirectFB-1.3.0/aclocal.m4
+++ b/DirectFB-1.3.0/aclocal.m4
@@ -1,7 +1,7 @@
-# generated automatically by aclocal 1.10.1 -*- Autoconf -*-
+# generated automatically by aclocal 1.10 -*- Autoconf -*-
 
 # Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
-# 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# 2005, 2006  Free Software Foundation, Inc.
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -11,17 +11,14 @@
 # even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 # PARTICULAR PURPOSE.
 
-m4_ifndef([AC_AUTOCONF_VERSION],
-  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl
-m4_if(AC_AUTOCONF_VERSION, [2.61],,
-[m4_warning([this file was generated for autoconf 2.61.
-You have another version of autoconf.  It may work, but is not guaranteed to.
-If you have problems, you may need to regenerate the build system entirely.
-To do so, use the procedure documented by the package, typically `autoreconf'.])])
+m4_if(m4_PACKAGE_VERSION, [2.61],,
+[m4_fatal([this file was generated for autoconf 2.61.
+You have another version of autoconf.  If you want to use that,
+you should regenerate the build system entirely.], [63])])
 
 # libtool.m4 - Configure libtool for the host system. -*-Autoconf-*-
 
-# serial 52 Debian 1.5.26-1ubuntu1 AC_PROG_LIBTOOL
+# serial 51 AC_PROG_LIBTOOL
 
 
 # AC_PROVIDE_IFELSE(MACRO-NAME, IF-PROVIDED, IF-NOT-PROVIDED)
@@ -109,6 +106,7 @@ AC_REQUIRE([AC_DEPLIBS_CHECK_METHOD])dnl
 AC_REQUIRE([AC_OBJEXT])dnl
 AC_REQUIRE([AC_EXEEXT])dnl
 dnl
+
 AC_LIBTOOL_SYS_MAX_CMD_LEN
 AC_LIBTOOL_SYS_GLOBAL_SYMBOL_PIPE
 AC_LIBTOOL_OBJDIR
@@ -210,8 +208,6 @@ file_magic*)
   ;;
 esac
 
-_LT_REQUIRED_DARWIN_CHECKS
-
 AC_PROVIDE_IFELSE([AC_LIBTOOL_DLOPEN], enable_dlopen=yes, enable_dlopen=no)
 AC_PROVIDE_IFELSE([AC_LIBTOOL_WIN32_DLL],
 enable_win32_dll=yes, enable_win32_dll=no)
@@ -291,80 +287,9 @@ ac_outfile=conftest.$ac_objext
 echo "$lt_simple_link_test_code" >conftest.$ac_ext
 eval "$ac_link" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
 _lt_linker_boilerplate=`cat conftest.err`
-$rm -r conftest*
+$rm conftest*
 ])# _LT_LINKER_BOILERPLATE
 
-# _LT_REQUIRED_DARWIN_CHECKS
-# --------------------------
-# Check for some things on darwin
-AC_DEFUN([_LT_REQUIRED_DARWIN_CHECKS],[
-  case $host_os in
-    rhapsody* | darwin*)
-    AC_CHECK_TOOL([DSYMUTIL], [dsymutil], [:])
-    AC_CHECK_TOOL([NMEDIT], [nmedit], [:])
-
-    AC_CACHE_CHECK([for -single_module linker flag],[lt_cv_apple_cc_single_mod],
-      [lt_cv_apple_cc_single_mod=no
-      if test -z "${LT_MULTI_MODULE}"; then
-   # By default we will add the -single_module flag. You can override
-   # by either setting the environment variable LT_MULTI_MODULE
-   # non-empty at configure time, or by adding -multi_module to the
-   # link flags.
-   echo "int foo(void){return 1;}" > conftest.c
-   $LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \
-     -dynamiclib ${wl}-single_module conftest.c
-   if test -f libconftest.dylib; then
-     lt_cv_apple_cc_single_mod=yes
-     rm -rf libconftest.dylib*
-   fi
-   rm conftest.c
-      fi])
-    AC_CACHE_CHECK([for -exported_symbols_list linker flag],
-      [lt_cv_ld_exported_symbols_list],
-      [lt_cv_ld_exported_symbols_list=no
-      save_LDFLAGS=$LDFLAGS
-      echo "_main" > conftest.sym
-      LDFLAGS="$LDFLAGS -Wl,-exported_symbols_list,conftest.sym"
-      AC_LINK_IFELSE([AC_LANG_PROGRAM([],[])],
-   [lt_cv_ld_exported_symbols_list=yes],
-   [lt_cv_ld_exported_symbols_list=no])
-   LDFLAGS="$save_LDFLAGS"
-    ])
-    case $host_os in
-    rhapsody* | darwin1.[[0123]])
-      _lt_dar_allow_undefined='${wl}-undefined ${wl}suppress' ;;
-    darwin1.*)
-     _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;
-    darwin*)
-      # if running on 10.5 or later, the deployment target defaults
-      # to the OS version, if on x86, and 10.4, the deployment
-      # target defaults to 10.4. Don't you love it?
-      case ${MACOSX_DEPLOYMENT_TARGET-10.0},$host in
-   10.0,*86*-darwin8*|10.0,*-darwin[[91]]*)
-     _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;
-   10.[[012]]*)
-     _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;
-   10.*)
-     _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;
-      esac
-    ;;
-  esac
-    if test "$lt_cv_apple_cc_single_mod" = "yes"; then
-      _lt_dar_single_mod='$single_module'
-    fi
-    if test "$lt_cv_ld_exported_symbols_list" = "yes"; then
-      _lt_dar_export_syms=' ${wl}-exported_symbols_list,$output_objdir/${libname}-symbols.expsym'
-    else
-      _lt_dar_export_syms="~$NMEDIT -s \$output_objdir/\${libname}-symbols.expsym \${lib}"
-    fi
-    if test "$DSYMUTIL" != ":"; then
-      _lt_dsymutil="~$DSYMUTIL \$lib || :"
-    else
-      _lt_dsymutil=
-    fi
-    ;;
-  esac
-])
 
 # _LT_AC_SYS_LIBPATH_AIX
 # ----------------------
@@ -689,11 +614,7 @@ sparc*-*solaris*)
     *64-bit*)
       case $lt_cv_prog_gnu_ld in
       yes*) LD="${LD-ld} -m elf64_sparc" ;;
-      *)
-        if ${LD-ld} -64 -r -o conftest2.o conftest.o >/dev/null 2>&1; then
-	  LD="${LD-ld} -64"
-	fi
-	;;
+      *)    LD="${LD-ld} -64" ;;
       esac
       ;;
     esac
@@ -786,7 +707,7 @@ AC_CACHE_CHECK([$1], [$2],
        $2=yes
      fi
    fi
-   $rm -r conftest*
+   $rm conftest*
    LDFLAGS="$save_LDFLAGS"
 ])
 
@@ -1057,7 +978,7 @@ else
     AC_CHECK_FUNC([shl_load],
 	  [lt_cv_dlopen="shl_load"],
       [AC_CHECK_LIB([dld], [shl_load],
-	    [lt_cv_dlopen="shl_load" lt_cv_dlopen_libs="-ldld"],
+	    [lt_cv_dlopen="shl_load" lt_cv_dlopen_libs="-dld"],
 	[AC_CHECK_FUNC([dlopen],
 	      [lt_cv_dlopen="dlopen"],
 	  [AC_CHECK_LIB([dl], [dlopen],
@@ -1065,7 +986,7 @@ else
 	    [AC_CHECK_LIB([svld], [dlopen],
 		  [lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-lsvld"],
 	      [AC_CHECK_LIB([dld], [dld_link],
-		    [lt_cv_dlopen="dld_link" lt_cv_dlopen_libs="-ldld"])
+		    [lt_cv_dlopen="dld_link" lt_cv_dlopen_libs="-dld"])
 	      ])
 	    ])
 	  ])
@@ -1382,7 +1303,7 @@ aix3*)
   soname_spec='${libname}${release}${shared_ext}$major'
   ;;
 
-aix[[4-9]]*)
+aix4* | aix5*)
   version_type=linux
   need_lib_prefix=no
   need_version=no
@@ -1723,18 +1644,6 @@ linux* | k*bsd*-gnu)
   dynamic_linker='GNU/Linux ld.so'
   ;;
 
-netbsdelf*-gnu)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=no
-  hardcode_into_libs=yes
-  dynamic_linker='NetBSD ld.elf_so'
-  ;;
-
 netbsd*)
   version_type=sunos
   need_lib_prefix=no
@@ -1915,13 +1824,6 @@ esac
 AC_MSG_RESULT([$dynamic_linker])
 test "$dynamic_linker" = no && can_build_shared=no
 
-AC_CACHE_VAL([lt_cv_sys_lib_search_path_spec],
-[lt_cv_sys_lib_search_path_spec="$sys_lib_search_path_spec"])
-sys_lib_search_path_spec="$lt_cv_sys_lib_search_path_spec"
-AC_CACHE_VAL([lt_cv_sys_lib_dlsearch_path_spec],
-[lt_cv_sys_lib_dlsearch_path_spec="$sys_lib_dlsearch_path_spec"])
-sys_lib_dlsearch_path_spec="$lt_cv_sys_lib_dlsearch_path_spec"
-
 variables_saved_for_relink="PATH $shlibpath_var $runpath_var"
 if test "$GCC" = yes; then
   variables_saved_for_relink="$variables_saved_for_relink GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH"
@@ -2421,7 +2323,7 @@ lt_cv_deplibs_check_method='unknown'
 # whether `pass_all' will *always* work, you probably want this one.
 
 case $host_os in
-aix[[4-9]]*)
+aix4* | aix5*)
   lt_cv_deplibs_check_method=pass_all
   ;;
 
@@ -2516,7 +2418,7 @@ linux* | k*bsd*-gnu)
   lt_cv_deplibs_check_method=pass_all
   ;;
 
-netbsd* | netbsdelf*-gnu)
+netbsd*)
   if echo __ELF__ | $CC -E - | grep __ELF__ > /dev/null; then
     lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\.so\.[[0-9]]+\.[[0-9]]+|_pic\.a)$'
   else
@@ -2857,7 +2759,7 @@ aix3*)
   fi
   ;;
 
-aix[[4-9]]*)
+aix4* | aix5*)
   if test "$host_cpu" != ia64 && test "$aix_use_runtimelinking" = no ; then
     test "$enable_shared" = yes && enable_static=no
   fi
@@ -2914,7 +2816,6 @@ _LT_AC_TAGVAR(postdep_objects, $1)=
 _LT_AC_TAGVAR(predeps, $1)=
 _LT_AC_TAGVAR(postdeps, $1)=
 _LT_AC_TAGVAR(compiler_lib_search_path, $1)=
-_LT_AC_TAGVAR(compiler_lib_search_dirs, $1)=
 
 # Source file extension for C++ test sources.
 ac_ext=cpp
@@ -3024,7 +2925,7 @@ case $host_os in
     # FIXME: insert proper C++ library support
     _LT_AC_TAGVAR(ld_shlibs, $1)=no
     ;;
-  aix[[4-9]]*)
+  aix4* | aix5*)
     if test "$host_cpu" = ia64; then
       # On IA64, the linker does run time linking by default, so we don't
       # have to do anything special.
@@ -3037,7 +2938,7 @@ case $host_os in
       # Test if we are trying to use run time linking or normal
       # AIX style linking. If -brtl is somewhere in LDFLAGS, we
       # need to do runtime linking.
-      case $host_os in aix4.[[23]]|aix4.[[23]].*|aix[[5-9]]*)
+      case $host_os in aix4.[[23]]|aix4.[[23]].*|aix5*)
 	for ld_flag in $LDFLAGS; do
 	  case $ld_flag in
 	  *-brtl*)
@@ -3183,23 +3084,51 @@ case $host_os in
     fi
   ;;
       darwin* | rhapsody*)
+        case $host_os in
+        rhapsody* | darwin1.[[012]])
+         _LT_AC_TAGVAR(allow_undefined_flag, $1)='${wl}-undefined ${wl}suppress'
+         ;;
+       *) # Darwin 1.3 on
+         if test -z ${MACOSX_DEPLOYMENT_TARGET} ; then
+           _LT_AC_TAGVAR(allow_undefined_flag, $1)='${wl}-flat_namespace ${wl}-undefined ${wl}suppress'
+         else
+           case ${MACOSX_DEPLOYMENT_TARGET} in
+             10.[[012]])
+               _LT_AC_TAGVAR(allow_undefined_flag, $1)='${wl}-flat_namespace ${wl}-undefined ${wl}suppress'
+               ;;
+             10.*)
+               _LT_AC_TAGVAR(allow_undefined_flag, $1)='${wl}-undefined ${wl}dynamic_lookup'
+               ;;
+           esac
+         fi
+         ;;
+        esac
       _LT_AC_TAGVAR(archive_cmds_need_lc, $1)=no
       _LT_AC_TAGVAR(hardcode_direct, $1)=no
       _LT_AC_TAGVAR(hardcode_automatic, $1)=yes
       _LT_AC_TAGVAR(hardcode_shlibpath_var, $1)=unsupported
       _LT_AC_TAGVAR(whole_archive_flag_spec, $1)=''
       _LT_AC_TAGVAR(link_all_deplibs, $1)=yes
-      _LT_AC_TAGVAR(allow_undefined_flag, $1)="$_lt_dar_allow_undefined"
-      if test "$GXX" = yes ; then
+
+    if test "$GXX" = yes ; then
+      lt_int_apple_cc_single_mod=no
       output_verbose_link_cmd='echo'
-      _LT_AC_TAGVAR(archive_cmds, $1)="\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring $_lt_dar_single_mod${_lt_dsymutil}"
-      _LT_AC_TAGVAR(module_cmds, $1)="\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dsymutil}"
-      _LT_AC_TAGVAR(archive_expsym_cmds, $1)="sed 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring ${_lt_dar_single_mod}${_lt_dar_export_syms}${_lt_dsymutil}"
-      _LT_AC_TAGVAR(module_expsym_cmds, $1)="sed -e 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dar_export_syms}${_lt_dsymutil}"
-      if test "$lt_cv_apple_cc_single_mod" != "yes"; then
-        _LT_AC_TAGVAR(archive_cmds, $1)="\$CC -r -keep_private_externs -nostdlib -o \${lib}-master.o \$libobjs~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \${lib}-master.o \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring${_lt_dsymutil}"
-        _LT_AC_TAGVAR(archive_expsym_cmds, $1)="sed 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC -r -keep_private_externs -nostdlib -o \${lib}-master.o \$libobjs~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \${lib}-master.o \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring${_lt_dar_export_syms}${_lt_dsymutil}"
+      if $CC -dumpspecs 2>&1 | $EGREP 'single_module' >/dev/null ; then
+       lt_int_apple_cc_single_mod=yes
       fi
+      if test "X$lt_int_apple_cc_single_mod" = Xyes ; then
+       _LT_AC_TAGVAR(archive_cmds, $1)='$CC -dynamiclib -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring'
+      else
+          _LT_AC_TAGVAR(archive_cmds, $1)='$CC -r -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs~$CC -dynamiclib $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name $rpath/$soname $verstring'
+        fi
+        _LT_AC_TAGVAR(module_cmds, $1)='$CC $allow_undefined_flag -o $lib -bundle $libobjs $deplibs$compiler_flags'
+        # Don't fix this by using the ld -exported_symbols_list flag, it doesn't exist in older darwin lds
+          if test "X$lt_int_apple_cc_single_mod" = Xyes ; then
+            _LT_AC_TAGVAR(archive_expsym_cmds, $1)='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym~$CC -dynamiclib -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring~nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+          else
+            _LT_AC_TAGVAR(archive_expsym_cmds, $1)='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym~$CC -r -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs~$CC -dynamiclib $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name $rpath/$soname $verstring~nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+          fi
+            _LT_AC_TAGVAR(module_expsym_cmds, $1)='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym~$CC $allow_undefined_flag  -o $lib -bundle $libobjs $deplibs$compiler_flags~nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
       else
       case $cc_basename in
         xlc*)
@@ -3450,7 +3379,7 @@ case $host_os in
 	_LT_AC_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'
 	_LT_AC_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive$convenience ${wl}--no-whole-archive'
 	;;
-      pgCC* | pgcpp*)
+      pgCC*)
         # Portland Group C++ compiler
 	_LT_AC_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname -o $lib'
   	_LT_AC_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname ${wl}-retain-symbols-file ${wl}$export_symbols -o $lib'
@@ -3523,7 +3452,7 @@ case $host_os in
 	;;
     esac
     ;;
-  netbsd* | netbsdelf*-gnu)
+  netbsd*)
     if echo __ELF__ | $CC -E - | grep __ELF__ >/dev/null; then
       _LT_AC_TAGVAR(archive_cmds, $1)='$LD -Bshareable  -o $lib $predep_objects $libobjs $deplibs $postdep_objects $linker_flags'
       wlarc=
@@ -3885,8 +3814,7 @@ lt_cv_prog_gnu_ld=$lt_save_with_gnu_ld
 # compiler output when linking a shared library.
 # Parse the compiler output and extract the necessary
 # objects, libraries and library flags.
-AC_DEFUN([AC_LIBTOOL_POSTDEP_PREDEP],
-[AC_REQUIRE([LT_AC_PROG_SED])dnl
+AC_DEFUN([AC_LIBTOOL_POSTDEP_PREDEP],[
 dnl we can't use the lt_simple_compile_test_code here,
 dnl because it contains code intended for an executable,
 dnl not a library.  It's possible we should let each
@@ -4011,11 +3939,6 @@ fi
 
 $rm -f confest.$objext
 
-_LT_AC_TAGVAR(compiler_lib_search_dirs, $1)=
-if test -n "$_LT_AC_TAGVAR(compiler_lib_search_path, $1)"; then
-  _LT_AC_TAGVAR(compiler_lib_search_dirs, $1)=`echo " ${_LT_AC_TAGVAR(compiler_lib_search_path, $1)}" | ${SED} -e 's! -L! !g' -e 's!^ !!'`
-fi
-
 # PORTME: override above test on systems where it is broken
 ifelse([$1],[CXX],
 [case $host_os in
@@ -4072,6 +3995,7 @@ solaris*)
   ;;
 esac
 ])
+
 case " $_LT_AC_TAGVAR(postdeps, $1) " in
 *" -lc "*) _LT_AC_TAGVAR(archive_cmds_need_lc, $1)=no ;;
 esac
@@ -4156,7 +4080,7 @@ aix3*)
     postinstall_cmds='$RANLIB $lib'
   fi
   ;;
-aix[[4-9]]*)
+aix4* | aix5*)
   if test "$host_cpu" != ia64 && test "$aix_use_runtimelinking" = no ; then
     test "$enable_shared" = yes && enable_static=no
   fi
@@ -4333,7 +4257,6 @@ if test -f "$ltmain"; then
     _LT_AC_TAGVAR(predeps, $1) \
     _LT_AC_TAGVAR(postdeps, $1) \
     _LT_AC_TAGVAR(compiler_lib_search_path, $1) \
-    _LT_AC_TAGVAR(compiler_lib_search_dirs, $1) \
     _LT_AC_TAGVAR(archive_cmds, $1) \
     _LT_AC_TAGVAR(archive_expsym_cmds, $1) \
     _LT_AC_TAGVAR(postinstall_cmds, $1) \
@@ -4396,7 +4319,7 @@ ifelse([$1], [],
 # Generated automatically by $PROGRAM (GNU $PACKAGE $VERSION$TIMESTAMP)
 # NOTE: Changes made to this file will be lost: look at ltmain.sh.
 #
-# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
 # Free Software Foundation, Inc.
 #
 # This file is part of GNU Libtool:
@@ -4633,10 +4556,6 @@ predeps=$lt_[]_LT_AC_TAGVAR(predeps, $1)
 # shared library.
 postdeps=$lt_[]_LT_AC_TAGVAR(postdeps, $1)
 
-# The directories searched by this compiler when creating a shared
-# library
-compiler_lib_search_dirs=$lt_[]_LT_AC_TAGVAR(compiler_lib_search_dirs, $1)
-
 # The library search path used internally by the compiler when linking
 # a shared library.
 compiler_lib_search_path=$lt_[]_LT_AC_TAGVAR(compiler_lib_search_path, $1)
@@ -4986,7 +4905,7 @@ EOF
     echo "$progname: failed program was:" >&AS_MESSAGE_LOG_FD
     cat conftest.$ac_ext >&5
   fi
-  rm -rf conftest* conftst*
+  rm -f conftest* conftst*
 
   # Do not use the global_symbol_pipe unless it works.
   if test "$pipe_works" = yes; then
@@ -5043,8 +4962,7 @@ AC_MSG_CHECKING([for $compiler option to produce PIC])
       # built for inclusion in a dll (and should export symbols for example).
       # Although the cygwin gcc ignores -fPIC, still need this for old-style
       # (--disable-auto-import) libraries
-      m4_if([$1], [GCJ], [],
-	[_LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])
+      _LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'
       ;;
     darwin* | rhapsody*)
       # PIC is the default on this platform
@@ -5081,7 +4999,7 @@ AC_MSG_CHECKING([for $compiler option to produce PIC])
     esac
   else
     case $host_os in
-      aix[[4-9]]*)
+      aix4* | aix5*)
 	# All AIX code is PIC.
 	if test "$host_cpu" = ia64; then
 	  # AIX 5 now supports IA64 processor
@@ -5177,7 +5095,7 @@ AC_MSG_CHECKING([for $compiler option to produce PIC])
 	    _LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
 	    _LT_AC_TAGVAR(lt_prog_compiler_static, $1)='-static'
 	    ;;
-	  pgCC* | pgcpp*)
+	  pgCC*)
 	    # Portland Group C++ compiler.
 	    _LT_AC_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
 	    _LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='-fpic'
@@ -5215,7 +5133,7 @@ AC_MSG_CHECKING([for $compiler option to produce PIC])
 	    ;;
 	esac
 	;;
-      netbsd* | netbsdelf*-gnu)
+      netbsd*)
 	;;
       osf3* | osf4* | osf5*)
 	case $cc_basename in
@@ -5328,8 +5246,7 @@ AC_MSG_CHECKING([for $compiler option to produce PIC])
       # built for inclusion in a dll (and should export symbols for example).
       # Although the cygwin gcc ignores -fPIC, still need this for old-style
       # (--disable-auto-import) libraries
-      m4_if([$1], [GCJ], [],
-	[_LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])
+      _LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'
       ;;
 
     darwin* | rhapsody*)
@@ -5399,8 +5316,7 @@ AC_MSG_CHECKING([for $compiler option to produce PIC])
     mingw* | cygwin* | pw32* | os2*)
       # This hack is so that the source file can tell whether it is being
       # built for inclusion in a dll (and should export symbols for example).
-      m4_if([$1], [GCJ], [],
-	[_LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])
+      _LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'
       ;;
 
     hpux9* | hpux10* | hpux11*)
@@ -5537,7 +5453,7 @@ AC_MSG_RESULT([$_LT_AC_TAGVAR(lt_prog_compiler_pic, $1)])
 #
 if test -n "$_LT_AC_TAGVAR(lt_prog_compiler_pic, $1)"; then
   AC_LIBTOOL_COMPILER_OPTION([if $compiler PIC flag $_LT_AC_TAGVAR(lt_prog_compiler_pic, $1) works],
-    _LT_AC_TAGVAR(lt_cv_prog_compiler_pic_works, $1),
+    _LT_AC_TAGVAR(lt_prog_compiler_pic_works, $1),
     [$_LT_AC_TAGVAR(lt_prog_compiler_pic, $1)ifelse([$1],[],[ -DPIC],[ifelse([$1],[CXX],[ -DPIC],[])])], [],
     [case $_LT_AC_TAGVAR(lt_prog_compiler_pic, $1) in
      "" | " "*) ;;
@@ -5561,7 +5477,7 @@ esac
 #
 wl=$_LT_AC_TAGVAR(lt_prog_compiler_wl, $1) eval lt_tmp_static_flag=\"$_LT_AC_TAGVAR(lt_prog_compiler_static, $1)\"
 AC_LIBTOOL_LINKER_OPTION([if $compiler static flag $lt_tmp_static_flag works],
-  _LT_AC_TAGVAR(lt_cv_prog_compiler_static_works, $1),
+  _LT_AC_TAGVAR(lt_prog_compiler_static_works, $1),
   $lt_tmp_static_flag,
   [],
   [_LT_AC_TAGVAR(lt_prog_compiler_static, $1)=])
@@ -5577,7 +5493,7 @@ AC_MSG_CHECKING([whether the $compiler linker ($LD) supports shared libraries])
 ifelse([$1],[CXX],[
   _LT_AC_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
   case $host_os in
-  aix[[4-9]]*)
+  aix4* | aix5*)
     # If we're using GNU nm, then we don't want the "-C" option.
     # -C means demangle to AIX nm, but means don't demangle with GNU nm
     if $NM -V 2>&1 | grep 'GNU' > /dev/null; then
@@ -5592,14 +5508,10 @@ ifelse([$1],[CXX],[
   cygwin* | mingw*)
     _LT_AC_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\([[^ ]]*\)/\1 DATA/;/^.*[[ ]]__nm__/s/^.*[[ ]]__nm__\([[^ ]]*\)[[ ]][[^ ]]*/\1 DATA/;/^I[[ ]]/d;/^[[AITW]][[ ]]/s/.*[[ ]]//'\'' | sort | uniq > $export_symbols'
   ;;
-  linux* | k*bsd*-gnu)
-    _LT_AC_TAGVAR(link_all_deplibs, $1)=no
-  ;;
   *)
     _LT_AC_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
   ;;
   esac
-  _LT_AC_TAGVAR(exclude_expsyms, $1)=['_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*']
 ],[
   runpath_var=
   _LT_AC_TAGVAR(allow_undefined_flag, $1)=
@@ -5630,14 +5542,12 @@ ifelse([$1],[CXX],[
   # it will be wrapped by ` (' and `)$', so one must not match beginning or
   # end of line.  Example: `a|bc|.*d.*' will exclude the symbols `a' and `bc',
   # as well as any symbol that contains `d'.
-  _LT_AC_TAGVAR(exclude_expsyms, $1)=['_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*']
+  _LT_AC_TAGVAR(exclude_expsyms, $1)="_GLOBAL_OFFSET_TABLE_"
   # Although _GLOBAL_OFFSET_TABLE_ is a valid symbol C name, most a.out
   # platforms (ab)use it in PIC code, but their linkers get confused if
   # the symbol is explicitly referenced.  Since portable code cannot
   # rely on this symbol name, it's probably fine to never include it in
   # preloaded symbol tables.
-  # Exclude shared library initialization/finalization symbols.
-dnl Note also adjust exclude_expsyms for C++ above.
   extract_expsyms_cmds=
   # Just being paranoid about ensuring that cc_basename is set.
   _LT_CC_BASENAME([$compiler])
@@ -5687,7 +5597,7 @@ dnl Note also adjust exclude_expsyms for C++ above.
 
     # See if GNU ld supports shared libraries.
     case $host_os in
-    aix[[3-9]]*)
+    aix3* | aix4* | aix5*)
       # On AIX/PPC, the GNU linker is very broken
       if test "$host_cpu" != ia64; then
 	_LT_AC_TAGVAR(ld_shlibs, $1)=no
@@ -5803,13 +5713,12 @@ EOF
   $echo "local: *; };" >> $output_objdir/$libname.ver~
 	  $CC '"$tmp_sharedflag""$tmp_addflag"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'
 	fi
-	_LT_AC_TAGVAR(link_all_deplibs, $1)=no
       else
 	_LT_AC_TAGVAR(ld_shlibs, $1)=no
       fi
       ;;
 
-    netbsd* | netbsdelf*-gnu)
+    netbsd*)
       if echo __ELF__ | $CC -E - | grep __ELF__ >/dev/null; then
 	_LT_AC_TAGVAR(archive_cmds, $1)='$LD -Bshareable $libobjs $deplibs $linker_flags -o $lib'
 	wlarc=
@@ -5907,7 +5816,7 @@ _LT_EOF
       fi
       ;;
 
-    aix[[4-9]]*)
+    aix4* | aix5*)
       if test "$host_cpu" = ia64; then
 	# On IA64, the linker does run time linking by default, so we don't
 	# have to do anything special.
@@ -5927,7 +5836,7 @@ _LT_EOF
 	# Test if we are trying to use run time linking or normal
 	# AIX style linking. If -brtl is somewhere in LDFLAGS, we
 	# need to do runtime linking.
-	case $host_os in aix4.[[23]]|aix4.[[23]].*|aix[[5-9]]*)
+	case $host_os in aix4.[[23]]|aix4.[[23]].*|aix5*)
 	  for ld_flag in $LDFLAGS; do
   	  if (test $ld_flag = "-brtl" || test $ld_flag = "-Wl,-brtl"); then
   	    aix_use_runtimelinking=yes
@@ -6087,10 +5996,11 @@ _LT_EOF
       _LT_AC_TAGVAR(link_all_deplibs, $1)=yes
     if test "$GCC" = yes ; then
     	output_verbose_link_cmd='echo'
-        _LT_AC_TAGVAR(archive_cmds, $1)="\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring $_lt_dar_single_mod${_lt_dsymutil}"
-        _LT_AC_TAGVAR(module_cmds, $1)="\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dsymutil}"
-        _LT_AC_TAGVAR(archive_expsym_cmds, $1)="sed 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring ${_lt_dar_single_mod}${_lt_dar_export_syms}${_lt_dsymutil}"
-        _LT_AC_TAGVAR(module_expsym_cmds, $1)="sed -e 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dar_export_syms}${_lt_dsymutil}"
+        _LT_AC_TAGVAR(archive_cmds, $1)='$CC -dynamiclib $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring'
+      _LT_AC_TAGVAR(module_cmds, $1)='$CC $allow_undefined_flag -o $lib -bundle $libobjs $deplibs$compiler_flags'
+      # Don't fix this by using the ld -exported_symbols_list flag, it doesn't exist in older darwin lds
+      _LT_AC_TAGVAR(archive_expsym_cmds, $1)='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym~$CC -dynamiclib $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring~nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+      _LT_AC_TAGVAR(module_expsym_cmds, $1)='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym~$CC $allow_undefined_flag  -o $lib -bundle $libobjs $deplibs$compiler_flags~nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
     else
       case $cc_basename in
         xlc*)
@@ -6240,7 +6150,7 @@ _LT_EOF
       _LT_AC_TAGVAR(link_all_deplibs, $1)=yes
       ;;
 
-    netbsd* | netbsdelf*-gnu)
+    netbsd*)
       if echo __ELF__ | $CC -E - | grep __ELF__ >/dev/null; then
 	_LT_AC_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'  # a.out
       else
@@ -6809,8 +6719,7 @@ installed software in a non-standard prefix.
 
 _PKG_TEXT
 ])],
-		[AC_MSG_RESULT([no])
-                $4])
+		[$4])
 elif test $pkg_failed = untried; then
 	ifelse([$4], , [AC_MSG_FAILURE(dnl
 [The pkg-config script could not be found or is too old.  Make sure it
@@ -6819,7 +6728,7 @@ path to pkg-config.
 
 _PKG_TEXT
 
-To get pkg-config, see <http://pkg-config.freedesktop.org/>.])],
+To get pkg-config, see <http://www.freedesktop.org/software/pkgconfig>.])],
 		[$4])
 else
 	$1[]_CFLAGS=$pkg_cv_[]$1[]_CFLAGS
@@ -6829,7 +6738,7 @@ else
 fi[]dnl
 ])# PKG_CHECK_MODULES
 
-# Copyright (C) 2002, 2003, 2005, 2006, 2007  Free Software Foundation, Inc.
+# Copyright (C) 2002, 2003, 2005, 2006  Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -6844,7 +6753,7 @@ AC_DEFUN([AM_AUTOMAKE_VERSION],
 [am__api_version='1.10'
 dnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to
 dnl require some minimum version.  Point them to the right macro.
-m4_if([$1], [1.10.1], [],
+m4_if([$1], [1.10], [],
       [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl
 ])
 
@@ -6860,10 +6769,8 @@ m4_define([_AM_AUTOCONF_VERSION], [])
 # Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.
 # This function is AC_REQUIREd by AC_INIT_AUTOMAKE.
 AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],
-[AM_AUTOMAKE_VERSION([1.10.1])dnl
-m4_ifndef([AC_AUTOCONF_VERSION],
-  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl
-_AM_AUTOCONF_VERSION(AC_AUTOCONF_VERSION)])
+[AM_AUTOMAKE_VERSION([1.10])dnl
+_AM_AUTOCONF_VERSION(m4_PACKAGE_VERSION)])
 
 # Figure out how to run the assembler.                      -*- Autoconf -*-
 
@@ -7157,7 +7064,7 @@ AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],
   # each Makefile.in and add a new line on top of each file to say so.
   # Grep'ing the whole file is not good either: AIX grep has a line
   # limit of 2048, but all sed's we know have understand at least 4000.
-  if sed -n 's,^#.*generated by automake.*,X,p' "$mf" | grep X >/dev/null 2>&1; then
+  if sed 10q "$mf" | grep '^#.*generated by automake' > /dev/null 2>&1; then
     dirpart=`AS_DIRNAME("$mf")`
   else
     continue
@@ -7217,13 +7124,13 @@ AU_DEFUN([AM_CONFIG_HEADER], [AC_CONFIG_HEADERS($@)])
 # Do all the work for Automake.                             -*- Autoconf -*-
 
 # Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
-# 2005, 2006, 2008 Free Software Foundation, Inc.
+# 2005, 2006 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 13
+# serial 12
 
 # This macro actually does too much.  Some checks are only needed if
 # your package does certain things.  But this isn't really a big deal.
@@ -7328,17 +7235,16 @@ AC_PROVIDE_IFELSE([AC_PROG_OBJC],
 # our stamp files there.
 AC_DEFUN([_AC_AM_CONFIG_HEADER_HOOK],
 [# Compute $1's index in $config_headers.
-_am_arg=$1
 _am_stamp_count=1
 for _am_header in $config_headers :; do
   case $_am_header in
-    $_am_arg | $_am_arg:* )
+    $1 | $1:* )
       break ;;
     * )
       _am_stamp_count=`expr $_am_stamp_count + 1` ;;
   esac
 done
-echo "timestamp for $_am_arg" >`AS_DIRNAME(["$_am_arg"])`/stamp-h[]$_am_stamp_count])
+echo "timestamp for $1" >`AS_DIRNAME([$1])`/stamp-h[]$_am_stamp_count])
 
 # Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.
 #
@@ -7673,7 +7579,7 @@ AC_SUBST([INSTALL_STRIP_PROGRAM])])
 
 # _AM_SUBST_NOTMAKE(VARIABLE)
 # ---------------------------
-# Prevent Automake from outputting VARIABLE = @VARIABLE@ in Makefile.in.
+# Prevent Automake from outputing VARIABLE = @VARIABLE@ in Makefile.in.
 # This macro is traced by Automake.
 AC_DEFUN([_AM_SUBST_NOTMAKE])
 
diff --git a/DirectFB-1.3.0/autogen.sh b/DirectFB-1.3.0/autogen.sh
index 456d565..dcd2fd3 100755
--- a/DirectFB-1.3.0/autogen.sh
+++ b/DirectFB-1.3.0/autogen.sh
@@ -137,11 +137,11 @@ autoconf
 (autoheader --version)  < /dev/null > /dev/null 2>&1 && echo Running autoheader... && autoheader
 
 echo Running automake ...
-automake -Wno-portability --add-missing $am_opt
+automake --add-missing $am_opt
 
 cd $ORIGDIR
 
-echo Running configure --enable-maintainer-mode "$@" ...
-$srcdir/configure --enable-maintainer-mode "$@" || exit 1
+#echo Running configure --enable-maintainer-mode "$@" ...
+#$srcdir/configure --enable-maintainer-mode "$@" || exit 1
 
-echo "Now type 'make' to compile $PROJECT."
+#echo "Now type 'make' to compile $PROJECT."
diff --git a/DirectFB-1.3.0/config.h.in b/DirectFB-1.3.0/config.h.in
index 1baaa60..c81593b 100644
--- a/DirectFB-1.3.0/config.h.in
+++ b/DirectFB-1.3.0/config.h.in
@@ -120,9 +120,6 @@
 /* Define to 1 if you have the ANSI C header files. */
 #undef STDC_HEADERS
 
-/* Define to 1 if GLX has been selected or detected */
-#undef USE_GLX
-
 /* Define to 1 if compiling on KallistiOS. */
 #undef USE_KOS
 
diff --git a/DirectFB-1.3.0/configure.in b/DirectFB-1.3.0/configure.in
index 9def5a4..2eaf7ba 100644
--- a/DirectFB-1.3.0/configure.in
+++ b/DirectFB-1.3.0/configure.in
@@ -854,8 +854,6 @@ cle266=no
 cyber5k=no
 davinci=no
 ep9x=no
-gl=no
-glx=no
 i810=no
 i830=no
 mach64=no
@@ -871,6 +869,7 @@ sis315=no
 tdfx=no
 unichrome=no
 vmware=no
+cx2450x=no
 
 if test "$have_linux" = "yes"; then
 
@@ -880,7 +879,7 @@ AC_ARG_WITH(gfxdrivers,
 [                               gfxdrivers may be comma separated ]
 [                               'all' builds all drivers (default), 'none' builds none ]
 [                               Possible gfxdrivers are: ]
-[                               ati128, cle266, cyber5k, davinci, ep9x, gl, i810, i830, mach64,]
+[                               ati128, cle266, cyber5k, davinci, ep9x, i810, i830, mach64,]
 [                               matrox, neomagic, nsc, nvidia, omap, radeon, savage, sh7722,]
 [                               sis315, tdfx, unichrome, vmware], gfxdrivers="$withval",[gfxdrivers="all"])
 
@@ -890,7 +889,6 @@ if test "$gfxdrivers" = "all"; then
   checkfor_cyber5k=yes
   checkfor_davinci="$have_arm"
   checkfor_ep9x=yes
-  checkfor_gl=yes
   checkfor_i810=yes
   checkfor_i830=yes
   checkfor_mach64=yes
@@ -929,9 +927,6 @@ else
           ep9x)
                   checkfor_ep9x=yes
                   ;;
-          gl)
-                  checkfor_gl=yes
-                  ;;
           i810)
                   checkfor_i810=yes
                   ;;
@@ -977,7 +972,10 @@ else
           vmware)
                   checkfor_vmware=yes
                   ;;
-          *)
+          cx2450x)
+		  checkfor_cx2450x=yes
+		  ;;
+	  *)
                   echo "Unknown gfxdriver $gfxdriver, exiting!"
                   exit 1
                   ;;
@@ -1007,14 +1005,6 @@ if test "$checkfor_ep9x" = "yes"; then
   ep9x=yes
 fi
 
-if test "$checkfor_gl" = "yes"; then
-  AC_CHECK_HEADER(GL/gl.h, gl=yes)
-  AC_CHECK_HEADER(GL/glx.h, [
-                  glx=yes
-                  AC_DEFINE(USE_GLX,1,[Define to 1 if GLX has been selected or detected])
-                  ])
-fi
-
 if test "$checkfor_i810" = "yes" && test "$have_sysio" = "yes"; then
   i810=yes
 fi
@@ -1075,6 +1065,10 @@ if test "$checkfor_vmware" = "yes"; then
   vmware=yes
 fi
 
+if test "$checkfor_cx2450x" = "yes"; then
+  cx2450x=yes
+fi
+
 # lets check for input driver
 
 checkfor_dbox2remote=no
@@ -1392,8 +1386,6 @@ AM_CONDITIONAL(GFX_CLE266, test "$cle266" = "yes")
 AM_CONDITIONAL(GFX_CYBER5K, test "$cyber5k" = "yes")
 AM_CONDITIONAL(GFX_DAVINCI, test "$davinci" = "yes")
 AM_CONDITIONAL(GFX_EP9X, test "$ep9x" = "yes")
-AM_CONDITIONAL(GFX_GL, test "$gl" = "yes")
-AM_CONDITIONAL(GFX_GLX, test "$glx" = "yes")
 AM_CONDITIONAL(GFX_I810, test "$i810" = "yes")
 AM_CONDITIONAL(GFX_I830, test "$i830" = "yes")
 AM_CONDITIONAL(GFX_MACH64, test "$mach64" = "yes")
@@ -1409,6 +1401,7 @@ AM_CONDITIONAL(GFX_SIS315, test "$sis315" = "yes")
 AM_CONDITIONAL(GFX_TDFX, test "$tdfx" = "yes")
 AM_CONDITIONAL(GFX_UNICHROME, test "$unichrome" = "yes")
 AM_CONDITIONAL(GFX_VMWARE, test "$vmware" = "yes")
+AM_CONDITIONAL(GFX_CX2450X, test "$cx2450x" = "yes")
 
 AM_CONDITIONAL(DBOX2REMOTE, test "$enable_dbox2remote" = "yes")
 AM_CONDITIONAL(DREAMBOXREMOTE, test "$enable_dreamboxremote" = "yes")
@@ -1557,7 +1550,6 @@ gfxdrivers/cle266/Makefile
 gfxdrivers/cyber5k/Makefile
 gfxdrivers/davinci/Makefile
 gfxdrivers/ep9x/Makefile
-gfxdrivers/gl/Makefile
 gfxdrivers/i810/Makefile
 gfxdrivers/i830/Makefile
 gfxdrivers/mach64/Makefile
@@ -1574,6 +1566,7 @@ gfxdrivers/sis315/Makefile
 gfxdrivers/tdfx/Makefile
 gfxdrivers/unichrome/Makefile
 gfxdrivers/vmware/Makefile
+gfxdrivers/cx2450x/Makefile
 
 inputdrivers/Makefile
 inputdrivers/dbox2remote/Makefile
@@ -1700,8 +1693,7 @@ Building Graphics Drivers:
   VIA CLE266                $cle266
   VIA UniChrome             $unichrome
   VMWare                    $vmware
-  --
-  OpenGL                    $gl (GLX: $glx)
+  CX2450X                   $cx2450x
 
 Building Input Drivers:
   DBox2 Remote              $enable_dbox2remote
diff --git a/DirectFB-1.3.0/debian/changelog b/DirectFB-1.3.0/debian/changelog
new file mode 100644
index 0000000..c9e9e90
--- /dev/null
+++ b/DirectFB-1.3.0/debian/changelog
@@ -0,0 +1,11 @@
+directfb (0.9.19+0.9.20WIP-1) unstable; urgency=low
+
+  * no changes to debian package, just changed version number.
+
+ -- Andreas Hundt <andi@fischlustig.de>  Tue,  29 Jul 2003 15:00:00 +0200
+
+directfb (0.9.18+0.9.19WIP-1) unstable; urgency=low
+
+  * unofficial debian packages
+
+ -- Andreas Hundt <andi@fischlustig.de>  Sun,  21 Apr 2003 08:33:49 +0200
diff --git a/DirectFB-1.3.0/debian/control b/DirectFB-1.3.0/debian/control
new file mode 100644
index 0000000..6905130
--- /dev/null
+++ b/DirectFB-1.3.0/debian/control
@@ -0,0 +1,61 @@
+Source: directfb
+Priority: optional
+Maintainer: Andreas Hundt <andi@fischlustig.de>
+Build-Depends: debhelper (>> 3.0.0), libflash-dev, libfreetype6-dev,
+	libjpeg62-dev, libpng3-dev, zlib1g-dev (>= 1:1.1.3), libmpeg3-dev, autoconf,
+	xlibs-dev, libflash-dev
+Standards-Version: 3.5.6
+
+Package: libdirectfb-cvs
+Section: libs
+Architecture: any
+Replaces: directfb0, libdirectfb8
+Conflicts: directfb0, libdirectfb8
+Depends: ${shlibs:Depends}
+Description: frame buffer graphics library (for 2.4+ kernels)
+ DirectFB is a graphics library which was designed with embedded systems
+ in mind. It offers maximum hardware accelerated performance at a minimum
+ of resource usage and overhead.
+
+Package: libdirectfb-bin
+Section: libs
+Architecture: any
+Conflicts: libdirectfb-0.9-15
+Depends: libdirectfb-cvs (= ${Source-Version}), ${shlibs:Depends}
+Description: binaries for libdirectfb
+ DirectFB is a graphics library which was designed with embedded systems
+ in mind. It offers maximum hardware accelerated performance at a minimum
+ of resource usage and overhead.
+ .
+ This packages contains the DirectFB background configuration tool
+ and the directfbrc man page.
+
+Package: libdirectfb-extra
+Section: libs
+Architecture: any
+Depends: libdirectfb-cvs (= ${Source-Version}), ${shlibs:Depends}
+Description: extra image/video providers for libdirectfb
+ DirectFB is a graphics library which was designed with embedded systems
+ in mind. It offers maximum hardware accelerated performance at a minimum
+ of resource usage and overhead.
+ .
+ This packages contains the following image/video providers:
+ .
+   * MPEG video
+   * Flash
+
+Package: libdirectfb-dev
+Section: libs
+Architecture: any
+Replaces: directfb-dev, libdirectfb8
+Conflicts: directfb-dev, libdirectfb8
+Depends: libdirectfb-cvs (= ${Source-Version}), libc6-dev, libflash-dev, libpng3-dev
+Section: devel
+Description: frame buffer graphics library, development files
+ DirectFB is a graphics library which was designed with embedded systems 
+ in mind. It offers maximum hardware accelerated performance at a minimum 
+ of resource usage and overhead. 
+ .
+ This package contains the files needed to compile and link 
+ programs which use DirectFB.
+
diff --git a/DirectFB-1.3.0/debian/copyright b/DirectFB-1.3.0/debian/copyright
new file mode 100644
index 0000000..8eb3aba
--- /dev/null
+++ b/DirectFB-1.3.0/debian/copyright
@@ -0,0 +1,30 @@
+This package was debianized by Fredrik Hallenberg <hallon@debian.org> on
+Tue, 17 Apr 2001 15:28:35 +0200.
+
+It was downloaded from http://www.directfb.org
+
+Upstream Authors:
+
+Denis Oliver Kropp <dok@convergence.de>
+Andreas Hundt <andi@convergence.de>
+Sven Neumann <sven@convergence.de>
+
+Copyright:
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+On Debian GNU/Linux systems, the complete text of the GNU Lesser General
+Public License can be found in `/usr/share/common-licenses/LGPL'.
+
diff --git a/DirectFB-1.3.0/debian/dirs b/DirectFB-1.3.0/debian/dirs
new file mode 100644
index 0000000..ca882bb
--- /dev/null
+++ b/DirectFB-1.3.0/debian/dirs
@@ -0,0 +1,2 @@
+usr/bin
+usr/sbin
diff --git a/DirectFB-1.3.0/debian/docs b/DirectFB-1.3.0/debian/docs
new file mode 100644
index 0000000..8745af0
--- /dev/null
+++ b/DirectFB-1.3.0/debian/docs
@@ -0,0 +1,5 @@
+README
+TODO
+docs/README.screenshots
+docs/README.mga-tv
+docs/initialization.txt
diff --git a/DirectFB-1.3.0/debian/libdirectfb-bin.files b/DirectFB-1.3.0/debian/libdirectfb-bin.files
new file mode 100644
index 0000000..2633eef
--- /dev/null
+++ b/DirectFB-1.3.0/debian/libdirectfb-bin.files
@@ -0,0 +1,6 @@
+usr/share/man/man5/*
+usr/bin/dfbg
+usr/bin/dfbinfo
+usr/bin/dfbdump
+usr/bin/dfblayer
+usr/share/man/man1/dfbg*
diff --git a/DirectFB-1.3.0/debian/libdirectfb-cvs.dirs b/DirectFB-1.3.0/debian/libdirectfb-cvs.dirs
new file mode 100644
index 0000000..6845771
--- /dev/null
+++ b/DirectFB-1.3.0/debian/libdirectfb-cvs.dirs
@@ -0,0 +1 @@
+usr/lib
diff --git a/DirectFB-1.3.0/debian/libdirectfb-cvs.files b/DirectFB-1.3.0/debian/libdirectfb-cvs.files
new file mode 100644
index 0000000..f98b0cf
--- /dev/null
+++ b/DirectFB-1.3.0/debian/libdirectfb-cvs.files
@@ -0,0 +1,3 @@
+usr/lib/lib*.so.*
+usr/lib/directfb*
+usr/share/directfb*
diff --git a/DirectFB-1.3.0/debian/libdirectfb-dev.dirs b/DirectFB-1.3.0/debian/libdirectfb-dev.dirs
new file mode 100644
index 0000000..4418816
--- /dev/null
+++ b/DirectFB-1.3.0/debian/libdirectfb-dev.dirs
@@ -0,0 +1,2 @@
+usr/lib
+usr/include
diff --git a/DirectFB-1.3.0/debian/libdirectfb-dev.files b/DirectFB-1.3.0/debian/libdirectfb-dev.files
new file mode 100644
index 0000000..a0fca67
--- /dev/null
+++ b/DirectFB-1.3.0/debian/libdirectfb-dev.files
@@ -0,0 +1,8 @@
+usr/include/*
+usr/lib/lib*.a
+usr/lib/lib*.so
+usr/lib/lib*.la
+usr/bin/directfb-config
+usr/bin/directfb-csource
+usr/lib/pkgconfig
+usr/share/man/man1/directfb-csource*
diff --git a/DirectFB-1.3.0/debian/libdirectfb-extra.files b/DirectFB-1.3.0/debian/libdirectfb-extra.files
new file mode 100644
index 0000000..493c39f
--- /dev/null
+++ b/DirectFB-1.3.0/debian/libdirectfb-extra.files
@@ -0,0 +1,2 @@
+usr/lib/directfb-0.9.18cvs/interfaces/IDirectFBVideoProvider/*mpeg*
+usr/lib/directfb-0.9.18cvs/interfaces/IDirectFBVideoProvider/*swf*
diff --git a/DirectFB-1.3.0/debian/rules b/DirectFB-1.3.0/debian/rules
new file mode 100755
index 0000000..6ea77ec
--- /dev/null
+++ b/DirectFB-1.3.0/debian/rules
@@ -0,0 +1,100 @@
+#!/usr/bin/make -f
+
+# Uncomment this to turn on verbose mode.
+#export DH_VERBOSE=1
+
+# This is the debhelper compatability version to use.
+export DH_COMPAT=3
+
+# shared library versions, option 1
+#version=2.0.5
+#major=2
+# option 2, assuming the library is created as src/.libs/libfoo.so.2.0.5 or so
+#version=`ls src/.libs/lib*.so.* | \
+# awk '{if (match($$0,/[0-9]+\.[0-9]+\.[0-9]+$$/)) print substr($$0,RSTART)}'`
+#major=`ls src/.libs/lib*.so.* | \
+# awk '{if (match($$0,/\.so\.[0-9]+$$/)) print substr($$0,RSTART+4)}'`
+
+DEVPACKAGE=$(shell dh_listpackages | grep -- -udeb.*dev$$)
+VERSION=$(shell dpkg-parsechangelog | grep ^Version: | cut -d ' ' -f 2)
+ARCH=$(shell dpkg --print-architecture)
+BUILD_DIST=directfb-build
+
+
+configure: configure-dist
+
+configure-dist: $(BUILD_DIST)/configure-stamp
+
+
+$(BUILD_DIST)/configure-stamp:
+	dh_testdir
+
+	mkdir -p $(BUILD_DIST)
+
+	cd $(BUILD_DIST) && \
+	../configure --prefix=/usr --mandir=\$${prefix}/share/man --infodir=\$${prefix}/share/info --disable-avifile
+
+	touch $@
+
+build: build-dist
+
+build-dist: configure-dist $(BUILD_DIST)/build-stamp
+
+$(BUILD_DIST)/build-stamp:
+	dh_testdir
+
+	$(MAKE) -C $(BUILD_DIST)
+
+	touch $@
+
+clean:
+	dh_testdir
+	dh_testroot
+
+	-$(MAKE) distclean
+	-rm -f install-test-stamp
+	-rm -rf $(BUILD_DIST)
+
+	dh_clean
+
+install: install-dist
+
+install-test: install-test-stamp
+install-test-stamp:
+	dh_testdir
+	dh_testroot
+	dh_clean -k
+	dh_installdirs
+
+	touch $@
+
+install-dist: build-dist install-test
+
+	$(MAKE) -C $(BUILD_DIST) install prefix=$(CURDIR)/debian/tmp/usr
+
+# Build architecture-independent files here.
+binary-indep: build install
+# We have nothing to do by default.
+
+# Build architecture-dependent files here.
+binary-arch: build install
+	dh_testdir
+	dh_testroot
+
+	dh_movefiles -plibdirectfb-extra
+	dh_movefiles
+	dh_installdocs
+	dh_installchangelogs ChangeLog
+	dh_link
+	dh_strip 
+	dh_compress
+	dh_fixperms
+	dh_makeshlibs
+	dh_installdeb
+	dh_shlibdeps -Xdfbg
+	dh_gencontrol
+	dh_md5sums
+	dh_builddeb
+
+binary: binary-indep binary-arch
+.PHONY: build clean binary-indep binary-arch binary install configure
diff --git a/DirectFB-1.3.0/docs/DirectFB Core Architecture.pdf b/DirectFB-1.3.0/docs/DirectFB Core Architecture.pdf
new file mode 100644
index 0000000..3c5fbc4
Binary files /dev/null and b/DirectFB-1.3.0/docs/DirectFB Core Architecture.pdf differ
diff --git a/DirectFB-1.3.0/docs/DirectFB Core Architecture.sxi b/DirectFB-1.3.0/docs/DirectFB Core Architecture.sxi
new file mode 100644
index 0000000..22ed034
Binary files /dev/null and b/DirectFB-1.3.0/docs/DirectFB Core Architecture.sxi differ
diff --git a/DirectFB-1.3.0/docs/GeneFX.odp b/DirectFB-1.3.0/docs/GeneFX.odp
new file mode 100644
index 0000000..550cff6
Binary files /dev/null and b/DirectFB-1.3.0/docs/GeneFX.odp differ
diff --git a/DirectFB-1.3.0/docs/GeneFX.pdf b/DirectFB-1.3.0/docs/GeneFX.pdf
new file mode 100644
index 0000000..6d16812
Binary files /dev/null and b/DirectFB-1.3.0/docs/GeneFX.pdf differ
diff --git a/DirectFB-1.3.0/docs/README.mga-tv b/DirectFB-1.3.0/docs/README.mga-tv
new file mode 100644
index 0000000..ec81b6a
--- /dev/null
+++ b/DirectFB-1.3.0/docs/README.mga-tv
@@ -0,0 +1,533 @@
+	DIRECTFB MATROX G400/G450/G550 TV-OUT -HOWTO
+
+	Pekka Tiittanen, peti at kauhajoki.fi
+
+	Ville Syrjl, syrjala at sci.fi
+
+  	v0.1, 5 April 2003
+
+  	This document describes how to set up tv-output with DirectFB when using
+  	Matrox Dualhead hardware. It tries to be an easy guide to set up DirectFB and
+	possible software alongside it.
+	
+  	-----------------------------------------------------------------------------
+
+	Table of Contents
+
+
+
+	1.	Introduction
+	
+		1.1 Copyright of this document
+	  	1.2 Where to get this document
+	  		1.2.1 Version history
+		1.3 Acknowledgments
+	  	1.4 Disclaimer
+		
+  	2. Hardware requirements
+
+  	3. Software requirements
+
+  	4. System configuration
+
+	  	4.1 Unpacking sources and patching the kernel
+	  	4.2 Configuring and compiling the kernel
+	  	4.3 Installing new kernel and modules
+	  	4.4 Installing DirectFB
+	
+  	5. Applications
+	
+	  	5.1 Compiling MPlayer
+
+	6. How to make it even better.
+
+  	-----------------------------------------------------------------------------
+
+  	1. Introduction
+
+	If you own a Matrox G400/450/550 video card with dualhead, you
+	probably know the feature Matrox calls "DVDMax". The main purpose 
+	of this feature is to display a videofile that is playing to a television.
+	That videofile can be almost anything mpeg, avi or a DVD (but not
+	Quicktime or RealMedia AFAIK).
+
+	Hre's the  part you may know if you're reading this document. Matrox 
+	has been  reluctant of giving information how to use this feature in 
+	other OS's,  for example they have given information on how to use 
+	this feature with a G400 card but not with G450 or G550. Luckily we
+	have people who are capable to figure these things out. I'm refering 
+	to Ville Syrjl who has contributed to the DirectFB project with
+	code that enables the use of tv-out with these cards. Some of the 
+	main benefits of DirectFB include:
+	
+	- interlaced picture
+	- 720x576 50Hz PAL and 720x480 60Hz NTSC
+	- ARGB1555, RGB16, RGB32, ARGB, YUY2, UYVY, I420, YV12 pixel formats
+	- hardware blended sub-picure in I420 and YV12 modes
+	- brightness, contrast, hue, saturation adjustments
+	- no more tweaking sessions with fbset to get the image centered :)
+
+	On the downside is that you are not able to use your console while
+	watching movies. And probably your X Window System is not going
+	to work properly when booting to kernel with all the patches. (atleast
+	i'm not able to do that, but when I'm watching a movie, I don't need
+	X.)
+	
+	This document is intended to people with atleast some knowledge on 
+	how to configure and compile the Linux kernel and other 	software. I
+	do not recommend it to newbies or people who are not comfortable
+	and sure of what they are doing. If you feel uncertain about your skills, 
+	please do not continue further. But if you feel that you are able to do
+	things described above, you can continue reading.
+	
+	Please read this document fully through before actually doing anything.
+	
+	Also note that I won't always say should you do some operations as
+	root or not. Some operations do need root privileges.
+	
+	All notes, complaints, corrections, money, hardware or broadband
+	Internet connection donations are welcome.
+	
+	
+	1.1 Copyright of this document
+	
+	This HOWTO is copyrighted 2003 Pekka Tiittanen, Ville Syrjl.
+	
+	Unless otherwise stated, Linux HOWTO documents are copyrighted by
+  	their respective authors. Linux HOWTO documents may be reproduced 
+	and distributed in whole or in part, in any medium physical or electronic,
+  	as long as this copyright notice is retained on all copies. Commercial
+  	redistribution is allowed and encouraged; however, the author would
+  	like to be notified of any such distributions.
+
+  	All translations, derivative works, or aggregate works incorporating any 
+	Linux HOWTO documents must be covered under this copyright notice.
+  	That is, you may not produce a derivative work from a HOWTO and impose
+  	additional restrictions on its distribution. Exceptions to these rules
+  	may be granted under certain conditions; please contact the Linux
+  	HOWTO co-ordinator at the address given below.
+  	In short, we wish to promote dissemination of this information through
+  	as many channels as possible. However, we do wish to retain copyright
+  	on the HOWTO documents, and would like to be notified of any plans to
+  	redistribute the HOWTOs.
+
+
+	1.2 Where to get this document
+	
+	The most recent official document can be obtained from here:
+	
+	plain-text:
+	
+		http://www.sci.fi/~syrjala/directfb/matrox-tv-out-howto
+	
+		http://www.kauhajoki.fi/~peti/directfb/matrox-tv-out-howto
+
+	gzipped, plain text:
+
+		http://www.sci.fi/~syrjala/directfb/matrox-tv-out-howto.gz
+
+		http://www.kauhajoki.fi/~peti/directfb/matrox-tv-out-howto.gz
+	
+	
+	1.2.1 Version history
+	
+	v0.1, 5 April 2003
+		
+	o Initial release. May contain a LOT of mistakes and errors.
+
+
+	1.3 Acknowledgements
+	
+	All copyrights are owned by their owners, unless specifically noted
+  	otherwise.  Use of a term in this document should not be regarded 
+	as affecting the validity of any trademark or service mark.
+		
+	Thank you for Ville Syrjl for making this possible and for writing 
+	the  original document. Thanks also go to all the people behind the
+	DirectFB project and to everyone who have contributed making this
+	possible.
+	
+	MPlayer team needs also a big thank you, without them we wouldn't
+	have MPlayer.
+	
+	
+	1.4 Disclaimer
+	
+	Use the information in this document at your own risk. I disavow any
+  	potential liability for the contents of this document. Use of the
+  	concepts, examples, and/or other content of this document is entirely
+  	at your own risk. This document most likely has some serious errors
+  	but I think that it is better than nothing.
+  	
+  	  	
+  	2. Hardware requirements
+  	
+	You obviously need a Matrox G400, G450 or G550 with DualHead capability, 
+	all proper cables and a television :-) to take full advantage of this HOWTO.
+	
+	
+	3. Software requirements
+	
+	The Linux kernel source, preferably most recent one or atleast 2.4.20.
+
+	DirectFB version 0.9.16 or later. (NOTE! version 0.9.17 has a serious 
+	bug and you probably can't use the tv-out -feature in that version. 
+	DO NOT USE IT). Or you can use it and get the patches from Ville's site
+		
+	MPlayer 0.90*, if you're planning to watch movies. Which you obviously are
+	trying to do.
+	
+	
+	4. System configuration
+	
+	4.1 Unpacking sources and patching kernel
+	
+	I strongly recommend that you use a different kernel source tree for 
+	this, because you have to apply couple of patches to the kernel and
+	that may interfere with other patches that you've earlier applied. 
+	
+	It isn't necessary to patch the kernel, but it's recommended, because you
+	get many features that otherwise won't be available.
+	
+	Unpack the kernel-package and DirectFB source package where ever you 
+	like. After unpacking, there's a subdirectory in the DirectFB named 'patches',
+	there you'll find three patches.
+	
+		fusion-full-linux-2.4.20.patch.bz2
+		matroxfb-32mb.diff.bz2
+		matroxfb-vsync-c2vline-irq-patch-2.4.19.bz2
+	
+	Apply these patches, while you are in the root of the kernel sources (eg.
+	/usr/src/linux-directfb/linux-2.4.20/). There are a couple of ways to do this,
+	either by first copying these files to the root of kernel sources or just
+	going there and applying from there. You can do like this:
+	
+	--------------------------------------------------------------------------------------------
+	NOTE! At the moment of writing it seems that the patchfile 
+	'matroxfb-32mb.diff.bz2' that is delivered with the DirectFB 0.9.17
+	has a bug in it and it requires a bit of  tweaking to get it to apply. 
+	Here are the instructions: (Or go and get a working one from Ville's site.)
+	
+		'bunzip2 matroxfb-32mb.diff.bz2'
+		
+	now edit the file 'matroxfb-32mb.diff' with your favorite editor and replace the
+	following two lines at the top of the file:
+	
+	--- matroxfb_base.c.old 2002-11-14 20:52:42.000000000 +0100
+	+++ matroxfb_base.c     2002-11-14 20:53:00.000000000 +0100
+
+	with these two lines:
+	
+	--- linux/drivers/video/matrox/matroxfb_base.c.old      2002-11-14 20:52:42.000000000 +0100
+	+++ linux/drivers/video/matrox/matroxfb_base.c  2002-11-14 20:53:00.000000000 +0100
+
+	And apply the patch with this command:
+	
+		patch -p1 < matroxfb-32mb.diff 
+		
+	and it should say 'patching file drivers/video/matrox/matroxfb_base.c'
+	--------------------------------------------------------------------------------------------
+
+	To apply the other two patches do this:
+	
+		'bzcat fusion-full-linux-2.4.20.patch.bz2 | patch -p1'
+		'bzcat matroxfb-vsync-c2vline-irq-patch-2.4.19.bz2 | patch -p1'		
+	
+	Patch-command outputs some lines saying 'patching file ...', if 
+	everything worked fine.
+
+	Here's a short description of what these patches do.
+	
+	fusion-full-linux-2.4.20.patch.bz2:
+	Enables the use of multiple DirectFB applications.
+	
+	matroxfb-32mb.diff.bz2:
+	Use this patch if you have a 32MB card and you want DirectFB to use
+	all the memory instead of just 16MB. It won't hurt anything with a
+	16MB card either.
+	
+	matroxfb-vsync-c2vline-irq-patch-2.4.19.bz2:
+	This patch enables IRQ based vblank waiting. Make sure your card has
+	an IRQ assigned to it. You may have an option in the BIOS setup for
+	this.
+		
+
+	4.2 Configuring and compiling kernel
+	
+	Here I will only tell you what options to compile to get the framebuffer
+	and directfb working, you must also select many other things depending 
+	on your system. IDE-support, etc. Remember to select them also.
+	
+	I like to use 'make menuconfig' when selecting what to compile, I 
+	recommend you also use it.
+	
+	If not otherwise mentioned, these options are for all the cards (G400, 
+	G450 and G550). Also these options can be either modules or compiled 
+	directly in your kernel.
+	
+	Enable these:
+	
+	Processor type and features  --->
+		[*] MTRR (Memory Type Range Register) support
+	
+	Code maturity level options  --->
+		Prompt for development and/or incomplete code/drivers
+		
+	Character devices  --->
+		Fusion Kernel Device (NEW)
+	
+	-------------------------------------------------------------
+	For G400 only:
+
+	Character devices  --->
+		I2C support  --->
+			I2C support
+			I2C bit-banging interfaces (NEW)
+			I2C device interface (NEW)
+			I2C /proc interface (required for hardware sensors) (NEW)	
+	-------------------------------------------------------------
+	
+	Console drivers  --->
+		Frame-buffer support  --->
+			Support for frame buffer devices (EXPERIMENTAL) (NEW)
+			Matrox acceleration (EXPERIMENTAL) (NEW)
+			G100/G200/G400/G450/G550 support (NEW)
+			
+	This is only for G450/G550:
+			G450/G550 second head support (mandatory for G550)		
+			
+	This is only for G400:
+			Matrox I2C support (NEW)
+			
+	And you _must_ enable this:
+	
+		File systems  --->
+			Virtual memory file system support (former shm fs)
+			
+	NOTE! Some of these options aren't available until you have enabled
+	some other options. For example 'Matrox I2C support (NEW)' is  available 
+	after you've enabled all the options under the 'I2C support  --->'.
+	
+	NOTE! Do not build 'G400 second head support' into the kernel. It 
+	will prevent DirectFB from controlling the TV-out. If you really need
+	it make it a module so you can remove it before using DirectFB.
+	
+	NOTE! You must also create the fusion device file:
+
+		'mknod /dev/fusion c 10 23'
+	
+	After you've enable all the options you need, you can compile the kernel
+	(Do this in '/usr/src/linux-direcfb/linux-x.x.xx/'):
+	
+		'make dep; make bzImage modules'
+	
+	Depending on the speed of your machine this can take from a few minutes 
+	to about 30 minutes. Now it's a good time to go and make some coffee or 
+	tea (or whaterver you prefer to drink).
+	
+	
+	4.3 Installing new kernel and modules
+	
+	After kernel has compiled, you can go ahead and install it (On my 
+	system I copy it to /boot, your system may differ. x.x.xx represents 
+	the kernel version number):
+
+		'cp /usr/src/linux-directfb/linux-x.x.xx/arch/i386/boot/bzImage /boot/vmlinuz-directfb-1'
+			
+	Make a backup of your existing modules:
+	
+		'cp -a /lib/modules/x.x.xx/ /lib/modules/x.x.xx-backup'
+			
+	After that install modules (Do this in '/usr/src/linux-direcfb/linux-x.x.xx/'):
+	
+		'make modules_install'
+			
+	Now it's time to edit '/etc/lilo.conf' and add the new kernel there:
+	
+		image=/boot/vmlinuz-directfb-1
+		label=DirectFB
+		read-only						# read-only for ext2/3, read-write for reiserfs
+
+	Remember to run command 'lilo' after editing lilo.conf.
+	
+	Also add this row to '/etc/fstab' if it isn't there already:
+	
+		tmpfs           /dev/shm        tmpfs   defaults                                0       0
+		
+	Make sure you have the proper /dev/i2c-N device file in place. After 
+	loading i2c-matroxfb module you should see MAVEN in /proc/bus/i2c. 
+	You must have the corresponding device file. To create these files 
+	use:
+   	
+		'mknod /dev/i2c-N c 89 N' where N is 0,1,2...
+   	
+	The number might change depending on the order you load i2c modules
+   	so you may want to create some extra files.
+	
+	Now everything should be in order, so boot to the framebuffer enabled
+	kernel.
+	
+	
+	4.4 Installing DirectFB
+	
+	Compiling DirectFB should be very straight-forward operation.
+	
+		'cd /usr/src/DirectFB-x.x.xx'
+		
+		'./configure --enable-multi'
+		
+		'make'
+		
+		'make install'
+		
+	Use the option '--enable-multi' if you applied the fusion-patch.
+	
+	After installing, edit the file '/etc/directfbrc' or '~/.directfbrc' and
+	add these options:
+	
+		matrox-crtc2
+		matrox-tv-standard=pal
+		or
+		matrox-tv-standard=ntsc
+		
+
+	Pal is used in many european countries and ntsc in USA, Canada
+	and Japan, if I remember corretcly. Newer pal-televisions accept
+	also ntsc, but IMO pal gives you better image.
+	
+	You may want to also do a 'ldconfig'.
+	
+	
+	5. Applications
+	
+	5.1 MPlayer
+	
+	First You probably want to have w32codecs and other codecs installed, so
+	take all the packages you want, and install them under '/usr/local' or
+	where ever you want to put them. I recommend that you download
+	w32codecs, rp9codecs and qtcodecs, so you can also view RealMedia
+	and Quicktime formats.
+	
+	When configuring MPlayer, use the DVD specific options if you're planning
+	to watch DVDs.
+	
+	Unpack MPlayer somewhere, go there and use this:
+	
+		'./configure --enable-dvdnav --with-win32libdir=/usr/local/w32libdir \
+		--with-reallibdir=/usr/local/rp9codecs --enable-gui --enable-menu'
+		
+	These are probably the options you want to have. If you want any other
+	options you can get a list of all options with './configure --help'.
+	
+	After configure has finished, you might want to check a couple of things
+	from it's output (this is what it outputs on my machine, you might get
+	different output):
+	
+		Enabled optional drivers:
+    	Input: edl dvdnav mpdvdkit2 vcd
+    	Codecs: qtx libavcodec real dshow/dmo win32 libvorbis libmad liblzo gif
+    	Audio output: esd oss mpegpes(file)
+    	Video output: xvidix vesa gif89a jpeg png mpegpes(file) fbdev aa xmga mga dfbmga directfb
+
+		Disabled optional drivers:
+    	Input: streaming tv-v4l tv-bsdbt848 tv cdda dvdread dvdcss
+    	Codecs: opendivx xvid libdv xanim
+    	Audio output: sgi sun alsa arts dxr2 nas win32 sdl
+    	Video output: bl zr dxr3 dxr2 directx sdl svga ggi tdfxfb 3dfx
+
+	From this output we clearly see, that it has found the qtx, win32 and 
+	real dshow/dmo codecs
+	
+	Now take a closer look at the 'Video output:' at the end of that line
+	it says 'dfbmga direcfb' which means that it has found the DirectFB 
+	installation we did earlier. Good. Also notice that you have to compile
+	mplayer after you've installed new version of DirectFB, but there might
+	be a possibility, that mplayer doesn't always work with the newest
+	version of DirectFB. So you might want to consider the benefits of the
+	new version.
+	
+	If everything is fine:
+	
+		'make'
+		
+	This takes also a while to compile, so do something useful, perhaps
+	you could make your partner (if you have one) happy by washing 
+	the dishes. Who knows, maybe you'll get lucky later... ;)
+	
+	After it has compiled:
+	
+		'make install'
+	
+		'cp etc/input.conf ~/.mplayer/'
+		'cp etc/menu.conf ~/.mplayer/'
+		
+	Remember to create '.mplayer' first if it doesn't exist. MPlayer
+	creates it when you run it for the first time.
+	
+	Now we can give it a go, connect all the cables you want, turn 
+	on your television select the correct channel and type this:
+	
+	(file.avi is the file you want to play.)
+	
+		'mplayer file.avi -vo dfbmga -ao oss -fs' 
+		
+	It should change the resolution on your monitor and output the
+	video to your tv. Now the file should be playing on your tv. If
+	it worked congratulations! If not, you probably missed something.
+	
+	If you want to play a dvd, use this command:
+	
+		'mplayer -dvd 1 -vo dfbmga -ao oss -fs'
+		
+	'-fs' is optional, use it if seems that mplayer is playing the dvd, but
+	the tv is just black. You can also use these options:
+	
+		'mplayer -dvd 1 -vo dfbmga -ao oss -fs -autosync 30 -cache 16384'
+		'mplayer -dvd 1 -vo dfbmga -ao oss -fs -autosync 30 -cache 16384 -framedrop'
+		
+	'-framedrop' does just what it says, it drops frames if playback slows too much.
+	This option is on by default if you use the Matrox DVD Player, so it probably
+	isn't a bad idea to use it also here.
+	
+	'man mplayer' tells you more about it's options.
+	
+	If you play a video file with a small resolution, you may want to use this:
+	
+		'mplayer file.avi -vo dfbmga -ao oss -fs -vsync'
+		
+	And that's it. Hopefully you got it working and this document was any
+	help to you. If you have problems you can always ask me or Ville about
+	them. Just email us and we'll try to help you out.
+	
+	And now if it didn't work out or you noticed that i've done something
+	horribly wrong, please let me know, so I can correct those errors.
+	
+	
+	6. How to make it even better.
+	
+	If you tried out the above, here's something you might like to try. It
+	improves the video playback a LOT and you don't have to use the 
+	-vsync switch anymore. 
+	
+	Go get the CVS-version of DirectFB. Instructions on how to get the
+	CVS-version of DirectFB are at www.directfb.org, developers-section.
+	
+	Go grab these files from Ville Syrjl's website:
+	
+		dfbmga_update.patch
+		mplayer_triple_option.patch
+		
+	And apply these patches to mplayer 0.90rc5.
+	
+	Compile the CVS-version of DirectFB and MPlayer, use the same options
+	as mentioned above, install and try this:
+	
+		'mplayer -vo dfbmga -ao oss -triple -fs file.avi'
+	
+	You should see a perfect, triple-buffered video file playing on your TV,
+	without any vsync-problems. You don't need to use the -vsync switch
+	anymore, because if you use -triple -vsync, it acts like -double -vsync,
+	but uses a lot more memory.
+	
+	If you don't like messing with CVS-versions of software, you can always
+	wait for the 0.9.18-version of DirectFB scheduled somewhere in the future.
diff --git a/DirectFB-1.3.0/docs/ReferenceMaps.txt b/DirectFB-1.3.0/docs/ReferenceMaps.txt
new file mode 100644
index 0000000..d450c2d
--- /dev/null
+++ b/DirectFB-1.3.0/docs/ReferenceMaps.txt
@@ -0,0 +1,131 @@
+
+This file contains visualizations of the references used
+for life cycle determination.
+
+The job of a reference is to keep a relevant object alive
+as long as it's required to implement a certain functionality.
+
+There are different types of references:
+
+*      Global reference, for Objects using other Objects
+|      (removed during destruction of the using object)
+
+--{    Local reference, for Applications using Objects
+       (removed by the application or by release() in the kernel)
+
+|      Inherit locals, e.g. for "Extensions" to other Objects
+^      (added/removed by adding/removing to/from the other object)
+
+One requirement is that local references should be removable in
+any order without disturbing "functional groups". However, such
+an object group should be destroyed if the last local reference to
+any object of the group is removed.
+
+Cyclic global references are not detected! Inheritance has been
+introduced to solve problems that would have required cyclic globals.
+
+
+
+With Default WM
+----------------
+
+
+  1. DirectFBCreate()
+
+---------{  Layer Context (primary)
+
+
+  2. GetDisplayLayer()
+
+--------{{  Layer Context (primary)
+                     *
+                     |
+                   Layer Region  }---------
+
+
+  3a. EnableCursor()
+
+--------{{  Layer Context (primary)
+              |      *
+              |      |
+              |    Layer Region  }---------
+              |      *
+              ^      |
+            Cursor Window
+
+
+  3b. CreateWindow()
+
+--------{{  Layer Context (primary)
+                     *
+                     |
+                   Layer Region  }---------
+                            *
+                            |
+                          Window  }---------
+
+
+
+
+With Unique WM
+---------------
+
+
+  1. DirectFBCreate()
+
+---------{  Layer Context (primary)
+              |      *
+              |      |
+              |    Layer Region
+              |      *
+              ^      |
+            Unique Context
+
+
+  2. GetDisplayLayer()
+
+--------{{  Layer Context (primary)
+              |      *
+              |      |
+              |    Layer Region  }---------
+              |      *
+              ^      |
+            Unique Context
+
+
+  3a. EnableCursor()
+
+--------{{  Layer Context (primary)
+              |      *       |........
+              |      |               |
+              |    Layer Region  }-- | -------
+              |      *      *        |
+              |      |      |        ^
+              |      |    Cursor Window
+              |      |      *
+              ^      |      |
+            Unique Context  |
+                     *      |
+                     |      ^
+                   Unique Window
+
+
+  3b. CreateWindow()
+
+--------{{  Layer Context (primary)
+              |      *
+              |      |
+              |    Layer Region  }---------
+              |      *      *
+              |      |      |
+              |      |    Window  }---------
+              |      |      *
+              ^      |      |
+            Unique Context  |
+                     *      |
+                     |      ^
+                   Unique Window
+                            *
+                            |
+                            ^
+                   Unique Decoration
diff --git a/DirectFB-1.3.0/docs/direct/DirectList.eps b/DirectFB-1.3.0/docs/direct/DirectList.eps
new file mode 100644
index 0000000..7d9f863
--- /dev/null
+++ b/DirectFB-1.3.0/docs/direct/DirectList.eps
@@ -0,0 +1,392 @@
+%!PS-Adobe-3.0 EPSF-3.0 
+%%BoundingBox: 0 0 575 755
+%%Pages: 0
+%%Creator: Sun Microsystems, Inc.
+%%Title: none
+%%CreationDate: none
+%%LanguageLevel: 2
+%%EndComments
+%%BeginProlog
+%%BeginResource: SDRes
+/b4_inc_state save def
+/dict_count countdictstack def
+/op_count count 1 sub def
+userdict begin
+0 setgray 0 setlinecap 1 setlinewidth 0 setlinejoin 10 setmiterlimit[] 0 setdash newpath
+/languagelevel where {pop languagelevel 1 ne {false setstrokeadjust false setoverprint} if} if
+/bdef {bind def} bind def
+/c {setrgbcolor} bdef
+/l {neg lineto} bdef
+/rl {neg rlineto} bdef
+/lc {setlinecap} bdef
+/lj {setlinejoin} bdef
+/lw {setlinewidth} bdef
+/ml {setmiterlimit} bdef
+/ld {setdash} bdef
+/m {neg moveto} bdef
+/ct {6 2 roll neg 6 2 roll neg 6 2 roll neg curveto} bdef
+/r {rotate} bdef
+/t {neg translate} bdef
+/s {scale} bdef
+/sw {show} bdef
+/gs {gsave} bdef
+/gr {grestore} bdef
+/f {findfont dup length dict begin
+{1 index /FID ne {def} {pop pop} ifelse} forall /Encoding ISOLatin1Encoding def
+currentdict end /NFont exch definefont pop /NFont findfont} bdef
+/p {closepath} bdef
+/sf {scalefont setfont} bdef
+/ef {eofill}bdef
+/pc {closepath stroke}bdef
+/ps {stroke}bdef
+/pum {matrix currentmatrix}bdef
+/pom {setmatrix}bdef
+/bs {/aString exch def /nXOfs exch def /nWidth exch def currentpoint nXOfs 0 rmoveto pum nWidth aString stringwidth pop div 1 scale aString show pom moveto} bdef
+%%EndResource
+%%EndProlog
+%%BeginSetup
+%%EndSetup
+%%Page: 1 1
+%%BeginPageSetup
+%%EndPageSetup
+pum
+0.02833 0.02834 s 
+0 -26640 t
+/tm matrix currentmatrix def
+gs
+tm setmatrix
+-635 -635 t 
+1 1 s 
+635 635 m 20924 635 l 20924 27274 l 635 27274 l 635 635 l eoclip newpath
+1.000 0.601 0.402 c 10795 8255 m  10094 8255 9525 7686 9525 6985 ct 9525 6284 10094 5715 10795 5715 ct 
+11496 5715 12065 6284 12065 6985 ct 12065 7686 11496 8255 10795 8255 ct 10795 8255 l 
+p ef
+0 lw 1 lj 0.003 0.003 0.003 c 10795 8255 m  10094 8255 9525 7686 9525 6985 ct 
+9525 6284 10094 5715 10795 5715 ct 11496 5715 12065 6284 12065 6985 ct 12065 7686 11496 8255 10795 8255 ct 
+10795 8255 l  pc
+gs
+pum
+10134 7263 t
+174 -348 m  174 -99 l  174 -64 178 -42 185 -33 ct 196 -20 209 -14 226 -14 ct 
+261 -14 l  261 0 l  35 0 l  35 -14 l  52 -14 l  63 -14 73 -17 82 -23 ct 91 -28 97 -36 101 -45 ct 
+104 -54 106 -72 106 -99 ct 106 -348 l  32 -348 l  32 -378 l  106 -378 l  106 -403 l 
+106 -440 112 -472 124 -499 ct 136 -525 154 -546 179 -562 ct 204 -578 232 -586 263 -586 ct 
+292 -586 319 -577 343 -558 ct 359 -546 367 -532 367 -516 ct 367 -508 364 -500 356 -493 ct 
+349 -486 342 -482 333 -482 ct 327 -482 320 -484 313 -489 ct 306 -493 298 -503 287 -518 ct 
+277 -533 268 -543 259 -548 ct 251 -554 241 -556 231 -556 ct 218 -556 207 -553 199 -546 ct 
+190 -539 183 -529 180 -515 ct 176 -501 174 -464 174 -405 ct 174 -378 l  271 -378 l 
+271 -348 l  p ef
+401 -587 m  413 -587 423 -583 431 -575 ct 439 -567 443 -557 443 -545 ct 443 -534 439 -524 431 -515 ct 
+423 -507 413 -503 401 -503 ct 390 -503 380 -507 371 -515 ct 363 -524 359 -534 359 -545 ct 
+359 -557 363 -567 371 -575 ct 379 -583 l  389 -587 l  p
+435 -389 m  435 -85 l  435 -61 437 -46 441 -38 ct 444 -30 449 -24 456 -20 ct 
+463 -16 475 -14 493 -14 ct 493 0 l  309 0 l  309 -14 l  328 -14 340 -16 346 -20 ct 
+353 -23 358 -29 361 -38 ct 365 -46 367 -62 367 -85 ct 367 -231 l  367 -272 366 -298 363 -311 ct 
+361 -319 358 -325 354 -329 ct 350 -332 344 -334 337 -334 ct 329 -334 320 -332 309 -328 ct 
+303 -343 l  417 -389 l  p ef
+645 -389 m  645 -304 l  676 -361 709 -389 742 -389 ct 757 -389 770 -384 780 -375 ct 
+790 -366 795 -355 795 -343 ct 795 -332 791 -323 784 -316 ct 777 -308 768 -305 758 -305 ct 
+749 -305 738 -310 726 -319 ct 714 -329 705 -333 699 -333 ct 694 -333 689 -331 683 -325 ct 
+671 -314 658 -295 645 -269 ct 645 -88 l  645 -67 647 -51 653 -40 ct 656 -33 662 -27 671 -22 ct 
+681 -17 694 -14 711 -14 ct 711 0 l  517 0 l  517 -14 l  536 -14 551 -17 560 -23 ct 
+567 -28 572 -35 574 -45 ct 576 -49 576 -63 576 -85 ct 576 -231 l  576 -275 576 -302 574 -310 ct 
+572 -318 569 -324 564 -328 ct 559 -332 553 -334 546 -334 ct 537 -334 528 -332 517 -328 ct 
+513 -343 l  627 -389 l  p ef
+1053 -389 m  1053 -260 l  1040 -260 l  1029 -301 1016 -328 1000 -343 ct 983 -357 962 -365 937 -365 ct 
+918 -365 902 -360 890 -349 ct 878 -339 873 -328 873 -316 ct 873 -300 877 -287 886 -276 ct 
+894 -265 912 -253 938 -240 ct 998 -211 l  1054 -183 1082 -147 1082 -103 ct 1082 -68 1069 -41 1043 -20 ct 
+1017 1 988 11 956 11 ct 932 11 906 7 876 0 ct 867 -3 860 -4 854 -4 ct 848 -4 843 -1 839 5 ct 
+825 5 l  825 -129 l  839 -129 l  847 -90 862 -61 883 -42 ct 905 -22 929 -12 956 -12 ct 
+975 -12 991 -18 1003 -29 ct 1015 -40 1021 -54 1021 -69 ct 1021 -88 1014 -104 1001 -117 ct 
+987 -130 961 -147 921 -166 ct 881 -186 855 -204 842 -220 ct 830 -236 824 -256 824 -280 ct 
+824 -311 834 -337 856 -358 ct 877 -379 905 -389 939 -389 ct 954 -389 972 -386 993 -380 ct 
+1007 -375 1016 -373 1021 -373 ct 1025 -373 1029 -374 1031 -376 ct 1034 -378 1037 -382 1040 -389 ct 
+p ef
+1245 -502 m  1245 -378 l  1333 -378 l  1333 -349 l  1245 -349 l  1245 -104 l 
+1245 -79 1248 -63 1255 -54 ct 1262 -45 1271 -41 1282 -41 ct 1292 -41 1300 -44 1309 -50 ct 
+1317 -55 1324 -64 1329 -75 ct 1345 -75 l  1335 -48 1322 -27 1304 -14 ct 1286 0 1268 6 1249 6 ct 
+1237 6 1224 2 1212 -4 ct 1200 -11 1191 -21 1185 -34 ct 1180 -47 1177 -67 1177 -95 ct 
+1177 -349 l  1117 -349 l  1117 -363 l  1132 -369 1147 -379 1163 -393 ct 1179 -408 1193 -425 1206 -445 ct 
+1212 -455 1221 -474 1232 -502 ct p ef
+pom
+gr
+1.000 0.601 0.402 c 15875 13335 m  15174 13335 14605 12766 14605 12065 ct 
+14605 11364 15174 10795 15875 10795 ct 16576 10795 17145 11364 17145 12065 ct 
+17145 12766 16576 13335 15875 13335 ct 15875 13335 l  p ef
+0.003 0.003 0.003 c 15875 13335 m  15174 13335 14605 12766 14605 12065 ct 14605 11364 15174 10795 15875 10795 ct 
+16576 10795 17145 11364 17145 12065 ct 17145 12766 16576 13335 15875 13335 ct 
+15875 13335 l  pc
+gs
+pum
+14896 12299 t
+225 -324 m  225 -217 l  214 -217 l  205 -250 194 -273 180 -286 ct 167 -298 149 -304 128 -304 ct 
+112 -304 99 -300 89 -291 ct 79 -283 75 -273 75 -263 ct 75 -250 78 -239 86 -230 ct 
+93 -220 107 -210 129 -200 ct 179 -175 l  226 -153 249 -123 249 -86 ct 249 -57 238 -34 217 -16 ct 
+195 0 171 9 144 9 ct 124 9 102 6 78 0 ct 70 -2 64 -4 59 -4 ct 54 -4 50 -1 47 4 ct 
+35 4 l  35 -107 l  47 -107 l  53 -75 65 -51 83 -35 ct 102 -18 122 -10 144 -10 ct 
+160 -10 173 -15 183 -24 ct 193 -33 198 -45 198 -58 ct 198 -74 193 -87 181 -98 ct 
+170 -108 148 -122 115 -139 ct 82 -155 60 -170 49 -183 ct 39 -196 34 -213 34 -233 ct 
+34 -259 43 -281 61 -298 ct 78 -315 101 -324 130 -324 ct 142 -324 157 -321 175 -316 ct 
+186 -313 194 -311 198 -311 ct 202 -311 205 -312 207 -313 ct 209 -315 211 -319 214 -324 ct 
+p ef
+350 -196 m  349 -149 361 -113 384 -86 ct 407 -59 434 -46 465 -46 ct 485 -46 503 -52 518 -63 ct 
+534 -74 546 -94 557 -121 ct 567 -114 l  563 -83 549 -54 525 -29 ct 502 -3 473 9 438 9 ct 
+401 9 368 -5 341 -34 ct 314 -64 301 -103 301 -153 ct 301 -207 314 -249 342 -279 ct 
+370 -309 405 -324 446 -324 ct 482 -324 511 -313 533 -290 ct 556 -266 567 -235 567 -196 ct 
+p
+350 -216 m  496 -216 l  494 -236 492 -250 488 -259 ct 483 -272 474 -282 463 -289 ct 
+451 -296 439 -300 427 -300 ct 408 -300 391 -293 376 -278 ct 361 -263 l  352 -242 l 
+p ef
+877 -119 m  869 -78 852 -46 827 -23 ct 803 -1 775 9 745 9 ct 709 9 678 -5 652 -35 ct 
+625 -65 612 -106 612 -157 ct 612 -206 626 -247 656 -278 ct 685 -309 721 -324 762 -324 ct 
+793 -324 818 -316 838 -300 ct 858 -283 868 -266 868 -248 ct 868 -240 866 -233 860 -227 ct 
+854 -222 846 -219 836 -219 ct 823 -219 813 -223 806 -232 ct 802 -237 799 -246 798 -260 ct 
+797 -273 792 -284 784 -291 ct 776 -298 765 -301 751 -301 ct 728 -301 709 -293 695 -276 ct 
+677 -253 667 -223 667 -186 ct 667 -149 677 -116 695 -87 ct 714 -58 739 -44 770 -44 ct 
+792 -44 813 -51 831 -67 ct 843 -77 855 -96 867 -124 ct p ef
+1082 -324 m  1129 -324 1168 -306 1197 -270 ct 1221 -239 1234 -203 1234 -163 ct 
+1234 -135 1227 -106 1213 -77 ct 1200 -48 1181 -27 1157 -12 ct 1134 2 1107 9 1078 9 ct 
+1030 9 993 -9 965 -47 ct 941 -79 929 -114 929 -154 ct 929 -183 936 -212 951 -240 ct 
+965 -269 984 -290 1007 -304 ct 1031 -317 l  1056 -324 l  p
+1071 -302 m  1059 -302 1047 -298 1034 -291 ct 1022 -284 1012 -271 1005 -253 ct 
+997 -235 993 -211 993 -183 ct 993 -137 1002 -97 1021 -64 ct 1039 -31 1063 -14 1093 -14 ct 
+1115 -14 1133 -23 1148 -42 ct 1162 -60 1170 -92 1170 -137 ct 1170 -193 1157 -237 1133 -269 ct 
+1117 -291 l  1096 -302 l  p ef
+1375 -257 m  1412 -302 1448 -324 1481 -324 ct 1498 -324 1513 -320 1526 -311 ct 
+1538 -303 1548 -288 1555 -269 ct 1560 -255 1563 -234 1563 -205 ct 1563 -71 l 
+1563 -51 1564 -37 1568 -30 ct 1570 -24 1574 -20 1580 -17 ct 1585 -14 1596 -12 1611 -12 ct 
+1611 0 l  1455 0 l  1455 -12 l  1462 -12 l  1476 -12 1486 -14 1492 -19 ct 
+1498 -23 1502 -30 1505 -38 ct 1505 -42 1506 -53 1506 -71 ct 1506 -200 l  1506 -229 1502 -249 1495 -262 ct 
+1487 -275 1475 -282 1457 -282 ct 1430 -282 1403 -267 1375 -237 ct 1375 -71 l 
+1375 -49 1377 -36 1379 -31 ct 1382 -25 1387 -20 1392 -17 ct 1398 -13 1410 -12 1427 -12 ct 
+1427 0 l  1271 0 l  1271 -12 l  1278 -12 l  1294 -12 1305 -16 1310 -24 ct 
+1316 -32 1319 -48 1319 -71 ct 1319 -188 l  1319 -226 1318 -249 1316 -257 ct 
+1314 -265 1312 -271 1308 -274 ct 1305 -277 1300 -278 1294 -278 ct 1287 -278 1280 -277 1271 -273 ct 
+1266 -286 l  1361 -324 l  1375 -324 l  p ef
+1861 -35 m  1846 -19 1831 -7 1816 0 ct 1801 6 1786 9 1769 9 ct 1734 9 1704 -4 1678 -33 ct 
+1653 -62 1640 -99 1640 -144 ct 1640 -189 1654 -231 1683 -268 ct 1711 -306 1748 -324 1792 -324 ct 
+1820 -324 1843 -316 1861 -298 ct 1861 -356 l  1861 -392 1860 -414 1859 -423 ct 
+1857 -431 1854 -436 1851 -439 ct 1847 -442 1842 -444 1837 -444 ct 1831 -444 1823 -442 1813 -438 ct 
+1809 -450 l  1903 -489 l  1918 -489 l  1918 -124 l  1918 -88 1919 -65 1921 -57 ct 
+1922 -49 1925 -43 1929 -40 ct 1933 -37 1937 -35 1942 -35 ct 1948 -35 1957 -37 1967 -41 ct 
+1971 -29 l  1877 9 l  1861 9 l  p
+1861 -59 m  1861 -222 l  1860 -237 1856 -251 1849 -264 ct 1842 -277 1833 -287 1821 -293 ct 
+1810 -300 1799 -303 1788 -303 ct 1768 -303 1750 -294 1734 -276 ct 1713 -252 1703 -217 1703 -171 ct 
+1703 -125 1713 -89 1733 -65 ct 1753 -40 1776 -28 1801 -28 ct 1822 -28 l  1842 -38 l 
+p ef
+pom
+gr
+0.003 0.503 0.003 c 12700 6985 m  12965 7516 l  13231 7250 l  12700 6985 l 
+p ef
+15856 10178 m  13001 7322 l  13037 7286 l  15893 10141 l  15856 10178 l 
+p ef
+1.000 0.003 0.003 c 13970 11430 m  13704 10898 l  13438 11164 l  13970 11430 l 
+p ef
+11448 8871 m  13668 11092 l  13632 11128 l  11411 8908 l  11448 8871 l 
+p ef
+1.000 0.601 0.402 c 10795 18415 m  10094 18415 9525 17846 9525 17145 ct 9525 16444 10094 15875 10795 15875 ct 
+11496 15875 12065 16444 12065 17145 ct 12065 17846 11496 18415 10795 18415 ct 
+10795 18415 l  p ef
+0.003 0.003 0.003 c 10795 18415 m  10094 18415 9525 17846 9525 17145 ct 9525 16444 10094 15875 10795 15875 ct 
+11496 15875 12065 16444 12065 17145 ct 12065 17846 11496 18415 10795 18415 ct 
+10795 18415 l  pc
+gs
+pum
+10134 17379 t
+113 -418 m  113 -315 l  187 -315 l  187 -291 l  113 -291 l  113 -86 l 
+113 -66 116 -52 122 -45 ct 128 -38 135 -34 144 -34 ct 152 -34 159 -37 166 -41 ct 
+174 -46 179 -53 183 -62 ct 196 -62 l  188 -40 177 -23 162 -11 ct 148 0 133 5 117 5 ct 
+106 5 96 2 86 -3 ct 76 -9 68 -17 64 -28 ct 59 -39 56 -56 56 -79 ct 56 -291 l  6 -291 l 
+6 -302 l  19 -307 32 -316 45 -328 ct 58 -340 70 -354 80 -371 ct 86 -379 93 -395 102 -418 ct 
+p ef
+313 -489 m  313 -258 l  339 -286 359 -304 374 -312 ct 389 -320 404 -324 418 -324 ct 
+436 -324 452 -319 465 -309 ct 477 -299 487 -284 493 -263 ct 498 -248 500 -221 500 -182 ct 
+500 -71 l  500 -51 501 -37 505 -30 ct 507 -24 511 -20 516 -17 ct 522 -14 532 -12 547 -12 ct 
+547 0 l  392 0 l  392 -12 l  399 -12 l  414 -12 424 -14 429 -19 ct 435 -23 439 -30 442 -38 ct 
+442 -42 443 -53 443 -71 ct 443 -182 l  443 -217 441 -239 437 -250 ct 434 -261 428 -269 420 -274 ct 
+412 -280 403 -282 392 -282 ct 381 -282 369 -279 357 -274 ct 345 -268 330 -256 313 -237 ct 
+313 -71 l  313 -49 314 -36 317 -30 ct 319 -25 324 -21 330 -17 ct 337 -14 348 -12 364 -12 ct 
+364 0 l  208 0 l  208 -12 l  222 -12 233 -14 241 -18 ct 245 -21 249 -25 252 -32 ct 
+255 -38 256 -51 256 -71 ct 256 -356 l  256 -392 255 -414 253 -423 ct 252 -431 249 -436 245 -439 ct 
+242 -442 237 -444 231 -444 ct 226 -444 219 -442 208 -438 ct 203 -450 l  297 -489 l 
+p ef
+652 -489 m  661 -489 670 -486 676 -479 ct 683 -472 687 -464 687 -454 ct 687 -445 683 -436 676 -429 ct 
+670 -423 661 -419 652 -419 ct 642 -419 634 -423 627 -429 ct 620 -436 617 -445 617 -454 ct 
+617 -464 620 -472 627 -479 ct 634 -486 l  642 -489 l  p
+680 -324 m  680 -71 l  680 -51 682 -38 685 -31 ct 687 -25 692 -20 697 -17 ct 
+703 -14 713 -12 728 -12 ct 728 0 l  575 0 l  575 -12 l  590 -12 601 -13 606 -16 ct 
+611 -19 615 -24 619 -31 ct 622 -38 623 -51 623 -71 ct 623 -192 l  623 -226 622 -249 620 -259 ct 
+618 -266 616 -271 612 -274 ct 609 -277 604 -278 598 -278 ct 592 -278 584 -277 575 -273 ct 
+570 -286 l  665 -324 l  p ef
+859 -324 m  859 -253 l  885 -300 912 -324 940 -324 ct 953 -324 963 -320 971 -313 ct 
+980 -305 984 -296 984 -286 ct 984 -277 981 -269 975 -263 ct 969 -257 962 -254 953 -254 ct 
+945 -254 936 -258 926 -266 ct 916 -274 909 -278 904 -278 ct 900 -278 896 -275 891 -271 ct 
+880 -261 870 -246 859 -224 ct 859 -73 l  859 -56 861 -43 865 -34 ct 868 -27 874 -22 881 -18 ct 
+889 -14 900 -12 914 -12 ct 914 0 l  752 0 l  752 -12 l  768 -12 780 -14 788 -19 ct 
+794 -23 798 -29 800 -37 ct 801 -41 802 -52 802 -70 ct 802 -193 l  802 -229 801 -251 800 -258 ct 
+798 -265 796 -270 791 -274 ct 787 -277 782 -278 777 -278 ct 769 -278 761 -277 752 -273 ct 
+749 -286 l  844 -324 l  p ef
+1226 -35 m  1211 -19 1196 -7 1181 0 ct 1166 6 1151 9 1134 9 ct 1099 9 1069 -4 1043 -33 ct 
+1018 -62 1005 -99 1005 -144 ct 1005 -189 1019 -231 1048 -268 ct 1076 -306 1113 -324 1157 -324 ct 
+1185 -324 1208 -316 1226 -298 ct 1226 -356 l  1226 -392 1225 -414 1224 -423 ct 
+1222 -431 1219 -436 1216 -439 ct 1212 -442 1207 -444 1202 -444 ct 1196 -444 1188 -442 1178 -438 ct 
+1174 -450 l  1268 -489 l  1283 -489 l  1283 -124 l  1283 -88 1284 -65 1286 -57 ct 
+1287 -49 1290 -43 1294 -40 ct 1298 -37 1302 -35 1307 -35 ct 1313 -35 1322 -37 1332 -41 ct 
+1336 -29 l  1242 9 l  1226 9 l  p
+1226 -59 m  1226 -222 l  1225 -237 1221 -251 1214 -264 ct 1207 -277 1198 -287 1186 -293 ct 
+1175 -300 1164 -303 1153 -303 ct 1133 -303 1115 -294 1099 -276 ct 1078 -252 1068 -217 1068 -171 ct 
+1068 -125 1078 -89 1098 -65 ct 1118 -40 1141 -28 1166 -28 ct 1187 -28 l  1207 -38 l 
+p ef
+pom
+gr
+1.000 0.601 0.402 c 5715 13335 m  5014 13335 4445 12766 4445 12065 ct 4445 11364 5014 10795 5715 10795 ct 
+6416 10795 6985 11364 6985 12065 ct 6985 12766 6416 13335 5715 13335 ct 5715 13335 l 
+p ef
+0.003 0.003 0.003 c 5715 13335 m  5014 13335 4445 12766 4445 12065 ct 4445 11364 5014 10795 5715 10795 ct 
+6416 10795 6985 11364 6985 12065 ct 6985 12766 6416 13335 5715 13335 ct 5715 13335 l 
+pc
+gs
+pum
+5133 12343 t
+156 -587 m  156 -85 l  156 -61 158 -46 161 -38 ct 165 -30 170 -24 177 -20 ct 
+184 -16 198 -14 217 -14 ct 217 0 l  32 0 l  32 -14 l  49 -14 61 -16 67 -20 ct 
+74 -23 79 -29 82 -38 ct 86 -46 87 -62 87 -85 ct 87 -429 l  87 -471 87 -498 85 -507 ct 
+83 -517 80 -524 75 -527 ct 71 -531 66 -533 59 -533 ct 52 -533 43 -531 32 -526 ct 
+25 -541 l  137 -587 l  p ef
+469 -54 m  431 -24 406 -7 396 -2 ct 381 4 366 7 349 7 ct 323 7 301 -1 284 -19 ct 
+267 -36 259 -60 259 -89 ct 259 -108 263 -124 271 -137 ct 282 -156 302 -173 330 -190 ct 
+358 -206 404 -227 469 -250 ct 469 -265 l  469 -303 463 -329 451 -343 ct 439 -357 422 -364 399 -364 ct 
+382 -364 368 -359 358 -350 ct 347 -340 342 -330 342 -318 ct 343 -294 l  343 -281 340 -271 333 -264 ct 
+327 -257 318 -254 308 -254 ct 298 -254 289 -258 283 -265 ct 276 -272 273 -282 273 -294 ct 
+273 -318 285 -339 309 -359 ct 334 -379 368 -389 412 -389 ct 445 -389 473 -383 494 -372 ct 
+510 -364 522 -350 530 -332 ct 535 -320 537 -296 537 -259 ct 537 -131 l  537 -95 538 -73 540 -65 ct 
+541 -56 543 -51 546 -48 ct 550 -45 553 -44 557 -44 ct 562 -44 566 -45 569 -47 ct 
+575 -51 586 -61 602 -77 ct 602 -54 l  572 -13 542 7 514 7 ct 500 7 490 2 482 -6 ct 
+474 -15 l  470 -31 l  p
+469 -81 m  469 -225 l  428 -209 401 -197 389 -190 ct 367 -178 351 -165 342 -152 ct 
+333 -139 328 -124 328 -109 ct 328 -89 334 -72 346 -59 ct 358 -46 371 -40 387 -40 ct 
+408 -40 l  435 -53 l  p ef
+867 -389 m  867 -260 l  854 -260 l  843 -301 830 -328 814 -343 ct 797 -357 776 -365 751 -365 ct 
+732 -365 716 -360 704 -349 ct 692 -339 687 -328 687 -316 ct 687 -300 691 -287 700 -276 ct 
+708 -265 726 -253 752 -240 ct 812 -211 l  868 -183 896 -147 896 -103 ct 896 -68 883 -41 857 -20 ct 
+831 1 802 11 770 11 ct 746 11 720 7 690 0 ct 681 -3 674 -4 668 -4 ct 662 -4 657 -1 653 5 ct 
+639 5 l  639 -129 l  653 -129 l  661 -90 676 -61 697 -42 ct 719 -22 743 -12 770 -12 ct 
+789 -12 805 -18 817 -29 ct 829 -40 835 -54 835 -69 ct 835 -88 828 -104 815 -117 ct 
+801 -130 775 -147 735 -166 ct 695 -186 669 -204 656 -220 ct 644 -236 638 -256 638 -280 ct 
+638 -311 648 -337 670 -358 ct 691 -379 719 -389 753 -389 ct 768 -389 786 -386 807 -380 ct 
+821 -375 830 -373 835 -373 ct 839 -373 843 -374 845 -376 ct 848 -378 851 -382 854 -389 ct 
+p ef
+1059 -502 m  1059 -378 l  1147 -378 l  1147 -349 l  1059 -349 l  1059 -104 l 
+1059 -79 1062 -63 1069 -54 ct 1076 -45 1085 -41 1096 -41 ct 1106 -41 1114 -44 1123 -50 ct 
+1131 -55 1138 -64 1143 -75 ct 1159 -75 l  1149 -48 1136 -27 1118 -14 ct 1100 0 1082 6 1063 6 ct 
+1051 6 1038 2 1026 -4 ct 1014 -11 1005 -21 999 -34 ct 994 -47 991 -67 991 -95 ct 
+991 -349 l  931 -349 l  931 -363 l  946 -369 961 -379 977 -393 ct 993 -408 1007 -425 1020 -445 ct 
+1026 -455 1035 -474 1046 -502 ct p ef
+pom
+gr
+0.003 0.503 0.003 c 15875 13970 m  15343 14235 l  15609 14501 l  15875 13970 l 
+p ef
+12681 17126 m  15537 14271 l  15573 14307 l  12718 17163 l  12681 17126 l 
+p ef
+8889 17145 m  8624 16613 l  8358 16879 l  8889 17145 l  p ef
+5733 13951 m  8588 16807 l  8552 16843 l  5696 13988 l  5733 13951 l  p ef
+5715 10160 m  6246 9894 l  5980 9628 l  5715 10160 l  p ef
+8908 7003 m  6052 9858 l  6016 9822 l  8871 6966 l  8908 7003 l  p ef
+1.000 0.003 0.003 c 11430 15240 m  11961 14974 l  11695 14708 l  11430 15240 l 
+p ef
+13988 12718 m  11767 14938 l  11731 14902 l  13951 12681 l  13988 12718 l 
+p ef
+7620 12700 m  7885 13231 l  8151 12965 l  7620 12700 l  p ef
+10141 15258 m  7921 13037 l  7957 13001 l  10178 15221 l  10141 15258 l 
+p ef
+gs
+pum
+7428 3412 t
+0.003 0.003 0.003 c 28 0 m  28 -30 l  71 -30 l  118 -30 152 -45 171 -76 ct 184 -94 190 -135 190 -198 ct 
+190 -922 l  190 -992 182 -1036 166 -1053 ct 145 -1078 113 -1090 71 -1090 ct 
+28 -1090 l  28 -1120 l  485 -1120 l  652 -1120 780 -1101 867 -1063 ct 954 -1025 1025 -962 1078 -873 ct 
+1131 -785 1158 -682 1158 -566 ct 1158 -410 1110 -279 1015 -175 ct 909 -58 747 0 529 0 ct 
+p
+348 -81 m  418 -65 477 -57 524 -57 ct 652 -57 758 -102 843 -192 ct 927 -282 969 -404 969 -558 ct 
+969 -712 927 -834 843 -924 ct 758 -1013 650 -1058 518 -1058 ct 468 -1058 412 -1050 348 -1034 ct 
+p ef
+1443 -1175 m  1466 -1175 1486 -1167 1502 -1151 ct 1518 -1134 1527 -1115 1527 -1092 ct 
+1527 -1068 1518 -1049 1502 -1032 ct 1486 -1015 1466 -1007 1443 -1007 ct 1420 -1007 1400 -1015 1384 -1032 ct 
+1367 -1049 1359 -1068 1359 -1092 ct 1359 -1115 1367 -1134 1383 -1151 ct 1399 -1167 l 
+1419 -1175 l  p
+1512 -779 m  1512 -171 l  1512 -123 1515 -92 1522 -76 ct 1529 -60 1539 -49 1553 -41 ct 
+1566 -33 1591 -29 1627 -29 ct 1627 0 l  1259 0 l  1259 -29 l  1296 -29 1320 -33 1333 -40 ct 
+1346 -47 1356 -59 1363 -76 ct 1371 -92 1374 -124 1374 -171 ct 1374 -462 l  1374 -545 1372 -598 1367 -622 ct 
+1363 -640 1357 -652 1349 -659 ct 1341 -666 1329 -669 1315 -669 ct 1299 -669 1281 -665 1259 -657 ct 
+1247 -686 l  1475 -779 l  p ef
+1933 -779 m  1933 -609 l  1996 -722 2061 -779 2128 -779 ct 2158 -779 2183 -770 2203 -751 ct 
+2223 -733 2233 -712 2233 -687 ct 2233 -666 2226 -648 2212 -633 ct 2197 -618 2180 -610 2160 -610 ct 
+2141 -610 2119 -620 2095 -639 ct 2071 -658 2054 -667 2042 -667 ct 2032 -667 2021 -662 2010 -651 ct 
+1985 -628 1959 -591 1933 -539 ct 1933 -176 l  1933 -135 1938 -103 1949 -81 ct 
+1956 -66 1969 -54 1987 -44 ct 2005 -34 2031 -29 2065 -29 ct 2065 0 l  1678 0 l 
+1678 -29 l  1716 -29 1745 -35 1763 -47 ct 1777 -56 1787 -70 1792 -90 ct 1795 -99 1797 -126 1797 -170 ct 
+1797 -463 l  1797 -551 1795 -604 1791 -621 ct 1788 -638 1781 -650 1771 -658 ct 
+1762 -665 1750 -669 1735 -669 ct 1718 -669 1699 -665 1678 -657 ct 1669 -686 l 
+1898 -779 l  p ef
+2394 -472 m  2393 -359 2420 -271 2476 -207 ct 2531 -143 2595 -111 2670 -111 ct 
+2719 -111 2763 -125 2799 -152 ct 2836 -179 2867 -226 2891 -292 ct 2917 -276 l 
+2905 -200 2872 -131 2816 -69 ct 2760 -7 2691 23 2607 23 ct 2516 23 2438 -12 2373 -83 ct 
+2309 -153 2276 -249 2276 -368 ct 2276 -498 2310 -599 2376 -671 ct 2442 -744 2526 -780 2626 -780 ct 
+2711 -780 2781 -752 2835 -696 ct 2890 -640 2917 -565 2917 -472 ct p
+2394 -519 m  2744 -519 l  2741 -568 2736 -602 2727 -622 ct 2713 -653 2693 -677 2665 -695 ct 
+2638 -712 2609 -721 2580 -721 ct 2534 -721 2493 -703 2457 -668 ct 2421 -632 l 
+2400 -583 l  p ef
+3651 -287 m  3630 -187 3590 -111 3531 -57 ct 3471 -3 3405 23 3333 23 ct 3247 23 3172 -12 3108 -85 ct 
+3044 -157 3012 -254 3012 -377 ct 3012 -496 3048 -593 3119 -667 ct 3189 -742 3274 -779 3374 -779 ct 
+3448 -779 3509 -759 3557 -720 ct 3605 -681 3629 -640 3629 -597 ct 3629 -576 3622 -559 3609 -546 ct 
+3595 -533 3576 -527 3552 -527 ct 3520 -527 3495 -537 3479 -558 ct 3469 -570 3463 -592 3460 -624 ct 
+3457 -657 3446 -682 3427 -699 ct 3407 -715 3381 -724 3346 -724 ct 3291 -724 3247 -703 3213 -662 ct 
+3169 -608 3146 -537 3146 -448 ct 3146 -358 3168 -278 3213 -209 ct 3257 -140 3317 -105 3393 -105 ct 
+3447 -105 3495 -124 3538 -161 ct 3568 -186 3598 -232 3627 -299 ct p ef
+3963 -1006 m  3963 -757 l  4140 -757 l  4140 -699 l  3963 -699 l  3963 -208 l 
+3963 -159 3970 -126 3984 -109 ct 3998 -92 4016 -83 4039 -83 ct 4057 -83 4074 -89 4091 -100 ct 
+4109 -111 4122 -128 4131 -150 ct 4163 -150 l  4144 -96 4117 -55 4082 -28 ct 
+4046 -1 4010 12 3972 12 ct 3947 12 3922 5 3898 -8 ct 3874 -22 3856 -42 3844 -69 ct 
+3833 -95 3827 -135 3827 -190 ct 3827 -699 l  3707 -699 l  3707 -726 l  3737 -738 3768 -759 3800 -788 ct 
+3832 -817 3860 -851 3885 -891 ct 3897 -912 3915 -950 3938 -1006 ct p ef
+5123 -310 m  5150 -304 l  5054 0 l  4186 0 l  4186 -30 l  4229 -30 l  4276 -30 4310 -46 4330 -76 ct 
+4342 -94 4348 -135 4348 -199 ct 4348 -922 l  4348 -992 4340 -1036 4324 -1053 ct 
+4303 -1078 4271 -1090 4229 -1090 ct 4186 -1090 l  4186 -1120 l  4694 -1120 l 
+4694 -1090 l  4634 -1090 4593 -1085 4569 -1073 ct 4545 -1062 4528 -1047 4520 -1030 ct 
+4511 -1012 4506 -970 4506 -903 ct 4506 -199 l  4506 -153 4511 -122 4520 -104 ct 
+4526 -93 4536 -84 4550 -79 ct 4564 -73 4607 -71 4679 -71 ct 4761 -71 l  4847 -71 4907 -77 4942 -90 ct 
+4977 -102 5008 -125 5037 -157 ct 5066 -189 l  5094 -240 l  p ef
+5414 -1175 m  5437 -1175 5457 -1167 5473 -1151 ct 5489 -1134 5498 -1115 5498 -1092 ct 
+5498 -1068 5489 -1049 5473 -1032 ct 5457 -1015 5437 -1007 5414 -1007 ct 5391 -1007 5371 -1015 5355 -1032 ct 
+5338 -1049 5330 -1068 5330 -1092 ct 5330 -1115 5338 -1134 5354 -1151 ct 5370 -1167 l 
+5390 -1175 l  p
+5483 -779 m  5483 -171 l  5483 -123 5486 -92 5493 -76 ct 5500 -60 5510 -49 5524 -41 ct 
+5537 -33 5562 -29 5598 -29 ct 5598 0 l  5230 0 l  5230 -29 l  5267 -29 5291 -33 5304 -40 ct 
+5317 -47 5327 -59 5334 -76 ct 5342 -92 5345 -124 5345 -171 ct 5345 -462 l  5345 -545 5343 -598 5338 -622 ct 
+5334 -640 5328 -652 5320 -659 ct 5312 -666 5300 -669 5286 -669 ct 5270 -669 5252 -665 5230 -657 ct 
+5218 -686 l  5446 -779 l  p ef
+6172 -779 m  6172 -521 l  6145 -521 l  6124 -602 6097 -657 6064 -686 ct 6031 -716 5989 -730 5939 -730 ct 
+5900 -730 5869 -720 5845 -700 ct 5822 -679 5810 -657 5810 -632 ct 5810 -601 5819 -575 5836 -553 ct 
+5853 -530 5888 -506 5940 -481 ct 6061 -422 l  6173 -367 6229 -295 6229 -206 ct 
+6229 -137 6203 -82 6151 -40 ct 6099 2 6040 23 5976 23 ct 5930 23 5877 14 5817 -1 ct 
+5799 -7 5784 -9 5773 -9 ct 5760 -9 5750 -2 5743 11 ct 5715 11 l  5715 -258 l 
+5743 -258 l  5758 -181 5788 -123 5831 -84 ct 5875 -45 5924 -25 5978 -25 ct 6016 -25 6047 -36 6071 -59 ct 
+6095 -81 6106 -108 6106 -139 ct 6106 -177 6093 -209 6066 -235 ct 6040 -261 5986 -294 5906 -333 ct 
+5827 -373 5774 -409 5749 -441 ct 5725 -472 5712 -512 5712 -560 ct 5712 -622 5734 -674 5776 -716 ct 
+5819 -758 5874 -779 5942 -779 ct 5972 -779 6008 -773 6050 -760 ct 6078 -752 6097 -748 6106 -748 ct 
+6115 -748 6122 -750 6127 -753 ct 6132 -757 6138 -766 6145 -779 ct p ef
+6546 -1006 m  6546 -757 l  6723 -757 l  6723 -699 l  6546 -699 l  6546 -208 l 
+6546 -159 6553 -126 6567 -109 ct 6581 -92 6599 -83 6622 -83 ct 6640 -83 6657 -89 6674 -100 ct 
+6692 -111 6705 -128 6714 -150 ct 6746 -150 l  6727 -96 6700 -55 6665 -28 ct 
+6629 -1 6593 12 6555 12 ct 6530 12 6505 5 6481 -8 ct 6457 -22 6439 -42 6427 -69 ct 
+6416 -95 6410 -135 6410 -190 ct 6410 -699 l  6290 -699 l  6290 -726 l  6320 -738 6351 -759 6383 -788 ct 
+6415 -817 6443 -851 6468 -891 ct 6480 -912 6498 -950 6521 -1006 ct p ef
+pom
+gr
+gr
+0 26640 t 
+pom
+count op_count sub {pop} repeat countdictstack dict_count sub {end} repeat b4_inc_state restore
+%%PageTrailer
+%%Trailer
+%%EOF
diff --git a/DirectFB-1.3.0/docs/direct/DirectList.pdf b/DirectFB-1.3.0/docs/direct/DirectList.pdf
new file mode 100644
index 0000000..3dd7576
Binary files /dev/null and b/DirectFB-1.3.0/docs/direct/DirectList.pdf differ
diff --git a/DirectFB-1.3.0/docs/direct/DirectList.sxd b/DirectFB-1.3.0/docs/direct/DirectList.sxd
new file mode 100644
index 0000000..a5c2b34
Binary files /dev/null and b/DirectFB-1.3.0/docs/direct/DirectList.sxd differ
diff --git a/DirectFB-1.3.0/docs/initialization.txt b/DirectFB-1.3.0/docs/initialization.txt
new file mode 100644
index 0000000..f7970ea
--- /dev/null
+++ b/DirectFB-1.3.0/docs/initialization.txt
@@ -0,0 +1,86 @@
+Initialization map  (outdated !!)
+----------------------------------
+
+- normal entry
+- (optional entry)
+* function call
+= loop (generally for each like)
+X entering arena (like switch)
+: possible way of entering (like case)
++ new arena field allocated
+# reactor related
+O object pool related
+$ property related
+
+
+DirectFBInit
+  * dfb_config_init
+    - allocate config
+    - read config from files and command line
+  * dfb_core_init
+    - dlopen ourself if linked dynamically
+    * dfb_system_lookup
+
+DirectFBCreate
+  * dfb_core_ref
+    - (atexit)
+    - (sync)
+    - (block all signals)
+    * dfb_system_thread_init if multi app
+    * dfb_find_best_memcpy
+    * fusion_init
+    - init local core data
+    X arena_enter
+      : dfb_core_initialize
+        - (install signal handlers)
+        + core clip field
+        * dfb_colorhash_initialize
+          + color hash field
+        * dfb_system_initialize (fbdev)
+          + fbdev field
+          - open framebuffer device
+          * dfb_vt_initialize
+            - open /dev/tty0
+            - (switch to new vt)
+            - open /dev/ttyN
+            - (set graphics mode)
+          - get fixed screen info
+          - mmap framebuffer
+          - get variable screen info
+          - get color map
+          # new/attach to rpc reactor
+          * dfb_layers_register
+            - add to local layer list
+            - initialize local state for drawing
+        * dfb_input_initialize
+          + input field
+          - explore driver module directory
+          * init_devices
+            - ask each driver for devices
+            - unload unused driver modules
+            = for each device
+              - init local and shared data
+              # new input device reactor
+              * OpenDevice
+              - (allocate device keymap)
+              - add to local and shared input device list
+        * dfb_gfxcard_initialize
+          + card field
+          - explore driver module directory
+          - (load/init graphics driver)
+          - create surface manager
+          O palette pool
+          O surface pool
+        * dfb_layers_initialize
+          + layers field
+          = for each registered layer
+            - init shared data
+            $ layer property
+            * InitLayer
+          * dfb_layer_enable (primary layer)
+            - ... (TODO)
+  * apply_configuration
+    - set buffer mode of primary layer
+    - set background color of primary layer
+    - (set background image of primary layer)
+    - (enable mouse cursor)
diff --git a/DirectFB-1.3.0/gfxdrivers/Makefile.am b/DirectFB-1.3.0/gfxdrivers/Makefile.am
index 5032af6..4475218 100644
--- a/DirectFB-1.3.0/gfxdrivers/Makefile.am
+++ b/DirectFB-1.3.0/gfxdrivers/Makefile.am
@@ -24,12 +24,6 @@ else
 DAVINCI_DIR =
 endif
 
-if GFX_GL
-GL_DIR = gl
-else
-GL_DIR =
-endif
-
 if GFX_I810
 I810_DIR = i810
 else
@@ -126,6 +120,11 @@ else
 EP9X_DIR =
 endif
 
+if GFX_CX2450X
+CX2450X_DIR = cx2450x
+else
+CX2450X_DIR =
+endif
 
 SUBDIRS = \
 	$(ATI128_DIR)	\
@@ -133,7 +132,6 @@ SUBDIRS = \
 	$(CYBER5K_DIR)	\
 	$(DAVINCI_DIR)	\
 	$(EP9X_DIR)	\
-	$(GL_DIR)	\
 	$(I810_DIR)	\
 	$(I830_DIR)	\
 	$(MACH64_DIR)	\
@@ -148,4 +146,5 @@ SUBDIRS = \
 	$(SIS315_DIR)	\
 	$(TDFX_DIR)	\
 	$(UNICHROME_DIR) \
-	$(VMWARE_DIR)
+	$(VMWARE_DIR)	\
+	$(CX2450X_DIR)
diff --git a/DirectFB-1.3.0/gfxdrivers/cle266/Installation.txt b/DirectFB-1.3.0/gfxdrivers/cle266/Installation.txt
new file mode 100644
index 0000000..5070d23
--- /dev/null
+++ b/DirectFB-1.3.0/gfxdrivers/cle266/Installation.txt
@@ -0,0 +1,17 @@
+# How to compile the cle266 driver:
+
+# 1a. Build the kernel module. You will have to install it
+# (with insmod) before you run a directfb application.
+# Your kernel must also use devfs.
+# The module file is named cle266vgaio.o (or .ko on 2.6 kernels)
+
+# If you use a 2.4 kernel, write
+
+make -f cle266vgaio.mk v24 
+
+# If you use a 2.6 kernel, write
+
+make -f cle266vgaio.mk v26
+
+# 1b. Optionally, you can patch your 2.4 kernel. (Sorry, I have no patch
+for 2.6) See Patching.txt
diff --git a/DirectFB-1.3.0/gfxdrivers/cle266/Patching.txt b/DirectFB-1.3.0/gfxdrivers/cle266/Patching.txt
new file mode 100644
index 0000000..1aae3a4
--- /dev/null
+++ b/DirectFB-1.3.0/gfxdrivers/cle266/Patching.txt
@@ -0,0 +1,27 @@
+#Patching instructions for the cle266vgaio module and the 2.4 kernel
+#This procedure is optional. It is only for those who want to make the
+#module a part of the kernel. See Installation.txt.
+
+# 1. Copy the files into your kernel source tree
+
+cp cle266vgaio.c /usr/src/linux/drivers/char/
+cp cle266vgaio.patch /usr/src/linux
+cd /usr/src/linux
+
+# 2. Test the patch without applying it (optional)
+#2.4.21 should work without warnings, 2.4.20 may print some messages,
+#but otherwise work. Later versions should/may work as well...
+
+patch -p1 --dry-run < cle266vgaio.patch
+
+# 3. Do the actual patching
+
+patch -p1 < ../cle266dfb.patch
+
+# 4. Run make menuconfig and enable the module.
+
+#You find it under "Character devices", right before
+#the AGP support settings. It is labeled
+#"DirectFB CLE266 Support (EXPERIMENTAL)"
+
+# 5. Build the kernel as usual, eg write: make dep bzImage
diff --git a/DirectFB-1.3.0/gfxdrivers/cle266/Readme.txt b/DirectFB-1.3.0/gfxdrivers/cle266/Readme.txt
new file mode 100644
index 0000000..6c49683
--- /dev/null
+++ b/DirectFB-1.3.0/gfxdrivers/cle266/Readme.txt
@@ -0,0 +1,136 @@
+How to use it
+-------------
+
+Note:
+This is for Linux 2.4 only, for now. v2.6 and BSD patches are welcome.
+
+1. Configure the kernel for the VESA framebuffer.
+This is done by adding parameters to the kernel command line.
+Here is one example:
+
+vga=789 video=vesa:ywrap,vram:32
+
+vga=789 sets 800x600 pixels, 32 bits per pixel.
+vesa:ywrap is makes it possible to flip the primary surface.
+vram:32 forces the VESA framebuffer to use 32Mb video RAM.
+Adjust 32 to match your BIOS settings, eg 64 or 128.
+
+(Note: VIA's viafb also works. See its documentation for more info.)
+
+2. Configure the kernel for the device file system (devfs)
+This is now optional. Read cle266vgaio.c for more information.
+
+3. Install the cle266vgaio module.
+
+Compilation: Locate cle266vgaio.mk and cle266vgaio.c then read cle266vgaio.c
+for more information.
+
+Installation: The module probes the PCI subsystem and won't install itself
+unless it finds the right hardware device. Either dmesg or lsmod will tell
+you if it worked.
+
+Then, the DirectFB driver simply makes sure that /dev/cle266vgaio exists and
+asks it to mmap the IO registers to user space.
+
+This way, we avoid all the trouble of writing a whole framebuffer driver or
+patching the kernel.  And, if you want to go back to software-only rendering,
+simply uninstall the cle266vgaio module.
+
+Reporting bugs
+--------------
+
+If you want to report any problem, please make an effort to figure
+out what is going on. Please also provide a small code example that
+reliably replicates your problem and only relies on DirectFB.
+
+A single .c file + makefile is preferred, so that it can be built and
+tested easily.
+
+Just stating that "this or that doesn't work" is a way of giving the
+developer a load of work, beyond fixing the actual problem.
+
+Implemented features
+--------------------
+
+* Drawing and blitting in opaque and blended surfaces.
+  Supported surface formats are roughly as follows:
+  Source: 8-bit (indexed), 16 or 32-bit (A)RGB
+  Destination: 16 or 32-bit (A)RGB
+* One video overlay surface.
+* Special feature: Video underlay mode. Enable it by moving the video
+  layer below the primary layer (e.g SetLayer(-1)).
+  In this mode, the primary layer's alpha channel controls what parts
+  of the video that will be visible, on a per-pixel basis.
+  Note: There is a hardware bug see "known bugs and quirks" below.
+
+Unimplemented features (TODOs)
+------------------------------
+
+* Hardware revision check. The revision number is currently hardcoded.
+  Yes, this is bad! If you get strange looking video, try changing the
+  revision number to 0x10 in unichrome.c, driver_init_driver().
+
+* 2.4 and 2.6 kernel patches for cle266vgaio, for people who don't want
+  to use modules.
+
+* Blitting into overlay surfaces.
+* Colorkeyed stretch blits.
+* Support for interlaced surfaces.
+* Video surface color keying.
+* DVD subsurface (subtitling) layer.
+* Video alpha layer.
+* Second video overlay (for picture-in-picture video)
+* HQV video blitter support.
+
+* System->Video RAM blits. (AGPGART support)
+(* Drawing and blitting into 8-bit (indexed color) surfaces.)
+
+Limitations (of the hardware)
+-----------------------------
+
+* These drawing and blitting flags are not supported:
+  DSDRAW_DST_PREMULTIPLY, DSDRAW_DEMULTIPLY
+  DSBLIT_SRC_PREMULTIPLY, DSBLIT_DST_PREMULTIPLY, DSBLIT_DEMULTIPLY
+
+* You can not combine source and destination color keying when
+  blitting opaque surfaces. Both functions work, just not at the
+  same time.
+  
+* The hardware does not support 24-bit (3 bytes/pixel) surfaces. 
+
+* The blitter does not support YUV->RGB pixel-format conversion.
+  Video surfaces does the conversion automatically.
+
+Known bugs and quirks
+---------------------
+
+* In underlay mode (see "implemented features", above), the video
+  is fully visible where the primary layer's alpha is 255, and
+  invisible (= graphics visible) where the alpha is 0.
+
+  In other words: the video layer using the primary layer's alpha
+  channel as its own alpha channel, and that is not very practical.
+
+  Fortunately, there is an easy workaround. The following function
+  XOR's the alpha channel of a surface. Use it just before flipping
+  the primary surface, for example.
+
+  void InvertSurfaceAlpha(IDirectFBSurface* surface)
+  {
+      int w,h;
+
+      surface->SetColor(surface, 0, 0, 0, 0xff);
+      surface->SetDrawingFlags(surface, DSDRAW_XOR);
+      surface->GetSize(surface, &w, &h);
+      surface->FillRectangle(surface, 0, 0, w, h);
+  }
+
+* Do not use the CPU to write into VRAM surfaces, unless where
+  absolutely needed (ie system -> video blits). CPU accesses
+  into VRAM run at 1/4 speed.
+
+* Colorkeyed stretched blits are not supported => will be software
+  rendered => will be very slow, if the source surface is in VRAM.
+
+* Blitting outside the screen is buggy (e.g with negative surface
+  coordinates). The result is clipped, but does not look right.
diff --git a/DirectFB-1.3.0/gfxdrivers/cle266/changelog.txt b/DirectFB-1.3.0/gfxdrivers/cle266/changelog.txt
new file mode 100644
index 0000000..5632f50
--- /dev/null
+++ b/DirectFB-1.3.0/gfxdrivers/cle266/changelog.txt
@@ -0,0 +1,56 @@
+v0.3.0 - changes from v0.2.1
+----------------------------
+This release is mostly bugfixes.
+
+* Bugfix: Made the driver work with VIA drivers. Needs testing. (Andreas)
+* Bugfix: Numerous state handling bugs. (Andi)
+* Bugfix: Surface pitch and offset alignments were incorrect. (Andi)
+* Bugfix: 3D-engine blit problem. Only 2^n by 2^m sizes worked. (Andreas)
+* Bugfix: Off-by-one rectangle and surface sizes. (Andi)
+* Bugfix: Video overlay: YUV planar mode. (Andreas)
+* Bugfix: Incorrect color handling during blended operations. (Andi)
+* Bugfix: LUT8->LUT8 stretch blits unsupported - removed (Andreas)
+* Bugfix: Blended FillRectangle(), DrawRectangle() and DrawLine()
+  in non 32-bit modes. (Andi)
+* Bugfix: DSBLIT_COLORIZE and DSBLIT_BLEND_COLORALPHA. (Andreas)
+* Bugfix: Workaround for font rendering in some applications. (Andi)
+* Bugfix: Fixed problems with gcc 2.95, and a missing header file. (dok)
+
+* Change: Added "void *device_data" to InitDriver() (dok)
+* Change: Added multi-application support, by allowing the cle266vgaio
+  device to be opened more than once and moving around some code. (Andi)
+* Change: Added new function EmitCommands() (Andreas)
+
+
+v0.2.1 - changes from v0.2.0
+----------------------------
+
+* Bugfix: 2D/3D engine synchronization.
+  Operations performed by the DirectFB software renderer weren't
+  always written to VRAM, because the GPU was still working.
+
+* Bugfix: Added graphics device name (VIA/S3G UniChrome).
+
+* Andr Kriehn contributed 2.6 kernel support for the cle266vgaio
+  module. Thanks!
+
+* Added cle266vgaio module kernel 2.4 patch. Works without warnings
+  on 2.4.21 - with warnings on 2.4.20. Other versions untested.
+  
+* Added DirectFB 0.9.19 configure.in
+
+
+v0.2.0 - changes from v0.1.0
+----------------------------
+
+* Got the 3D GPU working
+
+* Added a video overlay layer
+
+
+v0.1.0 - changes from v0.0.1
+----------------------------
+
+* Added color-keying for opaque blitting and drawing.
+
+* Added code for blended blitting and drawing etc.
diff --git a/DirectFB-1.3.0/gfxdrivers/cle266/cle266vgaio.c b/DirectFB-1.3.0/gfxdrivers/cle266/cle266vgaio.c
new file mode 100644
index 0000000..dfe6269
--- /dev/null
+++ b/DirectFB-1.3.0/gfxdrivers/cle266/cle266vgaio.c
@@ -0,0 +1,291 @@
+/*
+   Copyright (c) 2003 Andreas Robinson, All rights reserved.
+   Kernel v2.6 code by Andr Kriehn.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+*/
+
+/* Standalone CLE266 IO-registers mmap driver.
+ * Tested on Linux 2.4.20 and 2.6.0-test3.
+ * 
+ * Compilation:
+ *
+ * make -f cle266vgaio.mk v24
+ * make -f cle266vgaio.mk v24-static
+ * make -f cle266vgaio.mk v26
+ * make -f cle266vgaio.mk v26-static
+ *
+ * Explanation
+ *
+ * v24 compiles for a 2.4 kernel, relying on devfs.
+ * v24-static compiles for a 2.4 kernel, without relying on devfs.
+ * v26 compiles for a 2.6 kernel, relying on devfs.
+ * v26-static compiles for a 2.6 kernel, without relying on devfs.
+ *
+ * If in doubt use v24-static or v26-static.
+ * Devfs is not a standard kernel feature.
+ *
+ * If you select v24-static or v26 static, you must create a
+ * device node in your /dev directory, by executing the following
+ * command: (If you have devfs and select v24 or v26, you should
+ * not do this.)
+ *
+ * mknod -m 666 /dev/cle266vgaio c 245 0
+ * (You need to have root privileges)
+ *
+ * IMPORTANT: If you forget to do this, DirectFB programs will
+ * run, but won't be accelerated, even if you install the module
+ * properly.
+ *
+ * All but the v24 option allocates a major device number, 245.
+ * This number is for experimental use only, and can possibly conflict
+ * with something else if you have other experimental drivers installed.
+ * If you need to change it, edit VIADEV_MAJOR below and adjust your
+ * mknod command if you use it.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/major.h>
+#include <linux/pci.h>
+#include <linux/devfs_fs_kernel.h>
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+#include <linux/vermagic.h>
+#endif
+
+// Module configuration ------------------------------------------------------
+
+#define VIADEV_MAJOR 245
+
+// VIA register declarations -------------------------------------------------
+
+/* defines for VIA 3D registers */
+#define VIA_REG_STATUS          0x400
+
+/* VIA_REG_STATUS(0x400): Engine Status */
+#define VIA_CMD_RGTR_BUSY       0x00000080  /* Command Regulator is busy */
+#define VIA_2D_ENG_BUSY         0x00000001  /* 2D Engine is busy */
+#define VIA_3D_ENG_BUSY         0x00000002  /* 3D Engine is busy */
+#define VIA_VR_QUEUE_BUSY       0x00020000 /* Virtual Queue is busy */
+
+#define VIA_IN(hwregs, reg)  *(volatile u32 *)((hwregs) + (reg))
+#define MAXLOOP 0xffffff
+
+// Private declarations ------------------------------------------------------
+
+#define MODULE_NAME "cle266vgaio"
+#define _PCI_DEVICE_ID_VIA_CLE3122  0x3122
+#define MY_ASSERT(test, msg, exitcode) if (!test) { printk(msg); return exitcode; }
+
+
+struct via_devinfo
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+#ifndef CLE266_STATIC_DEVNUM
+    devfs_handle_t devhnd;
+#endif
+#endif
+    struct pci_dev* pcidev;     // PCI device (see linux/pci.h)
+    u32 io_base_phy;            // Physical IO register address
+    u8* iobase;                 // Kernel-mapped IO register address
+    u32 size;                   // IO memory size in bytes
+};
+
+// ----------------------------------------------------------------------------
+
+/// Global device info
+static struct via_devinfo di;
+
+/// Get chipset revision
+
+static int via_get_revision(void)
+{
+    u8 rev;
+    struct pci_dev* dev;
+
+    dev = pci_find_slot(0,0);
+    if (dev == NULL) return 0;
+
+    pci_read_config_byte(dev, 0xf6, &rev);
+
+    return rev;
+}
+
+static void via_enable_mmio(void)
+{
+    // in/out only works when the CLE266 VGA is the primary device.
+    // Refer to the XFree86 VIA driver for info on how to set it up
+    // when used as secondary driver.
+
+    //outb(inb(0x3c3) | 0x01, 0x3c3);
+    //outb(inb(0x3cc) | 0x01, 0x3c2);
+
+    // Unlock Extended IO Space
+
+    outb(0x10, 0x3c4);
+    outb(0x01, 0x3c5);
+
+    // Enable MMIO
+
+    outb(0x1a, 0x3c4);
+    //outb(inb(0x3c5) | 0x68, 0x3c5);
+}
+
+static int via_wait_idle(void)
+{
+    int loop = 0;
+
+    while (!(VIA_IN(di.iobase, VIA_REG_STATUS) 
+        & VIA_VR_QUEUE_BUSY) && 
+        (loop++ < MAXLOOP));
+
+    while ((VIA_IN(di.iobase, VIA_REG_STATUS) &
+      (VIA_CMD_RGTR_BUSY | VIA_2D_ENG_BUSY | VIA_3D_ENG_BUSY)) &&
+      (loop++ < MAXLOOP));
+
+    return loop >= MAXLOOP;
+}
+
+// Module and device file I/O functions --------------------------------------
+
+static int viadev_open(struct inode *inode, struct file *filp)
+{
+    return 0; 
+}
+        
+static int viadev_release(struct inode *inode, struct file *filp)
+{
+    return 0;
+}   
+
+static int viadev_mmap(struct file* filp, struct vm_area_struct* vma)
+{
+    unsigned long off = vma->vm_pgoff << PAGE_SHIFT;
+    unsigned long phy = di.io_base_phy + off;
+    unsigned long vsize = vma->vm_end - vma->vm_start;
+    unsigned long psize = di.size - off;
+
+    if (vsize > psize) return -EINVAL;
+
+    vma->vm_pgoff = phy >> PAGE_SHIFT;
+
+    if (boot_cpu_data.x86 > 3)
+        pgprot_val(vma->vm_page_prot) |= _PAGE_PCD;
+
+    vma->vm_flags |= VM_IO | VM_RESERVED | VM_DONTEXPAND;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+    if (io_remap_page_range(vma,vma->vm_start, phy, vsize, vma->vm_page_prot))
+       return -EAGAIN;
+#else
+    if (io_remap_page_range(vma->vm_start, phy, vsize, vma->vm_page_prot))
+       return -EAGAIN;
+#endif
+
+    return 0;
+}
+
+static struct file_operations viadev_fops = {
+    .owner = THIS_MODULE,
+    .mmap = viadev_mmap,
+    .open = viadev_open,
+    .release = viadev_release,
+};
+
+static int __init viadev_init(void)
+{
+    // Find the device
+
+    di.pcidev = pci_find_device(PCI_VENDOR_ID_VIA,
+        _PCI_DEVICE_ID_VIA_CLE3122, NULL);
+    MY_ASSERT(di.pcidev,
+        MODULE_NAME ": VIA CLE266 graphics device not found.", -ENODEV);
+    MY_ASSERT(!di.pcidev->driver,
+        MODULE_NAME ": There is already a driver installed.", -EBUSY);
+
+    // Map physical IO memory address into kernel space.
+
+    di.io_base_phy = pci_resource_start(di.pcidev, 1);
+    di.size = pci_resource_len(di.pcidev, 1);
+    MY_ASSERT(request_mem_region(di.io_base_phy, di.size, MODULE_NAME),
+        MODULE_NAME ": Memory mapping failed (1).", -EBUSY);
+
+    di.iobase = ioremap(di.io_base_phy, di.size);
+    MY_ASSERT(di.iobase, MODULE_NAME ": Memory mapping failed (2).", -EBUSY);
+
+    // TODO: Register PCI device driver. Or not. We don't really need to.
+
+    // Register a character device. Uses devfs
+
+#if CLE266_STATIC_DEVNUM
+    int result;
+    result = register_chrdev(VIADEV_MAJOR, MODULE_NAME, &viadev_fops);
+    MY_ASSERT(!result, MODULE_NAME " Unable to register driver\n", result);
+#else
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+    int result;
+    result = register_chrdev(VIADEV_MAJOR, MODULE_NAME, &viadev_fops);
+    MY_ASSERT(!result, MODULE_NAME " Unable to register driver\n", result);
+	devfs_mk_cdev(MKDEV(VIADEV_MAJOR, 0), S_IFCHR | S_IRUSR | S_IWUSR, MODULE_NAME);
+#else
+    di.devhnd = devfs_register(NULL, MODULE_NAME, DEVFS_FL_AUTO_DEVNUM,
+        0, 0, S_IFCHR | S_IRUGO | S_IWUGO, &viadev_fops, &di);
+    MY_ASSERT(di.devhnd, MODULE_NAME ": Could not register a /dev entry.", -EAGAIN);
+#endif
+
+#endif // CLE266_STATIC_DEVNUM
+
+	printk(MODULE_NAME " installed. Hardware rev %d detected.\n",
+		via_get_revision());
+
+	via_enable_mmio();
+    
+    return 0;
+}
+
+static void __exit viadev_exit(void)
+{
+
+#if CLE266_STATIC_DEVNUM
+	unregister_chrdev(VIADEV_MAJOR, MODULE_NAME);
+#else
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+    unregister_chrdev(VIADEV_MAJOR, MODULE_NAME);
+    devfs_remove(MODULE_NAME);
+#else
+    devfs_unregister(di.devhnd);
+#endif
+
+#endif // CLE266_STATIC_DEVNUM
+
+    via_wait_idle();
+    iounmap(di.iobase);
+    release_mem_region(di.io_base_phy, di.size);
+
+    printk(MODULE_NAME " removed.\n");
+}
+
+module_init(viadev_init);
+module_exit(viadev_exit);
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+
+MODULE_INFO(vermagic, VERMAGIC_STRING);
+
+static const char __module_depends[]
+__attribute_used__
+__attribute__((section(".modinfo"))) =
+"depends=";
+
+#endif
+
+MODULE_AUTHOR("Andreas Robinson");
+MODULE_DESCRIPTION("VIA UniChrome Driver");
+MODULE_LICENSE("GPL");
diff --git a/DirectFB-1.3.0/gfxdrivers/cle266/cle266vgaio.mk b/DirectFB-1.3.0/gfxdrivers/cle266/cle266vgaio.mk
new file mode 100644
index 0000000..a756bf5
--- /dev/null
+++ b/DirectFB-1.3.0/gfxdrivers/cle266/cle266vgaio.mk
@@ -0,0 +1,45 @@
+# The makefile for the cle266 VGA IO module.
+# Build-command: make -f cle266vgaio.mk
+
+.SILENT:
+
+all:
+	echo Usage:
+	echo     make -f cle266vgaio.mk v24
+	echo     make -f cle266vgaio.mk v24-static
+	echo     make -f cle266vgaio.mk v26
+	echo     make -f cle266vgaio.mk v26-static
+	echo
+	echo v24: Compile for a 2.4 kernel.
+	echo v26: Compile for a 2.6 kernel.
+	echo
+	echo -static suffix: Module will not depend on devfs
+	echo   You will need to manually create a /dev device entry if you use it.
+	echo
+	echo See cle266vgaio.c for more details.
+	echo
+	echo You need to have kernel header files matching the version you
+	echo are trying to compile to, in /usr/src/linux/include.
+	echo
+	echo ... the kernel driver has not been built.
+
+v24:
+	echo Compiling v2.4 kernel module.
+	gcc -D__KERNEL__  -DMODULE -O2 -Wall -I/usr/src/linux/include -c cle266vgaio.c
+
+v24-static:
+	echo Compiling v2.4 kernel module not depending on devfs.
+	gcc -D__KERNEL__  -DMODULE -DCLE266_STATIC_DEVNUM -O2 -Wall -I/usr/src/linux/include -c cle266vgaio.c
+
+v26:
+	echo Compiling v2.6 kernel module.
+	gcc -Wall -Wstrict-prototypes -Wno-trigraphs -O2 -fno-strict-aliasing -fno-common -pipe -mpreferred-stack-boundary=2 -march=i486 -falign-functions=0 -falign-jumps=0 -falign-loops=0 -D__KERNEL__  -DMODULE -DKBUILD_MODNAME=cle266vgaio -DKBUILD_BASENAME=cle266vgaio -I/usr/src/linux/include -c cle266vgaio.c -o cle266vgaio.o
+	ld -m elf_i386 -r -o cle266vgaio.ko cle266vgaio.o
+
+v26-static:
+	echo Compiling v2.6 kernel module.
+	gcc -Wall -Wstrict-prototypes -Wno-trigraphs -O2 -fno-strict-aliasing -fno-common -pipe -mpreferred-stack-boundary=2 -march=i486 -falign-functions=0 -falign-jumps=0 -falign-loops=0 -DCLE266_STATIC_DEVNUM -D__KERNEL__  -DMODULE -DKBUILD_MODNAME=cle266vgaio -DKBUILD_BASENAME=cle266vgaio -I/usr/src/linux/include -c cle266vgaio.c -o cle266vgaio.o
+	ld -m elf_i386 -r -o cle266vgaio.ko cle266vgaio.o
+
+clean:
+	rm -f cle266vgaio.o cle266vgaio.ko
diff --git a/DirectFB-1.3.0/gfxdrivers/cle266/cle266vgaio.patch b/DirectFB-1.3.0/gfxdrivers/cle266/cle266vgaio.patch
new file mode 100644
index 0000000..8e7573d
--- /dev/null
+++ b/DirectFB-1.3.0/gfxdrivers/cle266/cle266vgaio.patch
@@ -0,0 +1,24 @@
+diff -urP linux-2.4.21/drivers/char/Config.in linux-2.4.21-cle266/drivers/char/Config.in
+--- linux-2.4.21/drivers/char/Config.in	2003-08-14 11:04:16.000000000 +0200
++++ linux-2.4.21-cle266/drivers/char/Config.in	2003-09-07 00:30:30.000000000 +0200
+@@ -289,6 +289,8 @@
+ fi
+ endmenu
+ 
++dep_tristate 'DirectFB CLE266 Support (EXPERIMENTAL)' CONFIG_CLE266VGAIO $CONFIG_DEVFS_FS
++
+ if [ "$CONFIG_GART_IOMMU" = "y" ]; then
+ 	bool '/dev/agpgart (AGP Support)' CONFIG_AGP
+ 	define_bool CONFIG_AGP_AMD_8151 y
+
+diff -urP linux-2.4.21/drivers/char/Makefile linux-2.4.21-cle266/drivers/char/Makefile
+--- linux-2.4.21/drivers/char/Makefile	2003-08-14 11:04:16.000000000 +0200
++++ linux-2.4.21-cle266/drivers/char/Makefile	2003-09-06 23:45:45.000000000 +0200
+@@ -265,6 +265,7 @@
+ obj-y       += ftape/ftape.o
+ endif
+ 
++obj-$(CONFIG_CLE266VGAIO) += cle266vgaio.o
+ obj-$(CONFIG_H8) += h8.o
+ obj-$(CONFIG_PPDEV) += ppdev.o
+ obj-$(CONFIG_DZ) += dz.o
diff --git a/DirectFB-1.3.0/gfxdrivers/cle266/hwdoc.txt b/DirectFB-1.3.0/gfxdrivers/cle266/hwdoc.txt
new file mode 100644
index 0000000..ab49eab
--- /dev/null
+++ b/DirectFB-1.3.0/gfxdrivers/cle266/hwdoc.txt
@@ -0,0 +1,549 @@
+// Misc. reverse-engineered hardware information.
+
+Open GL man pages: http://www.3dlabs.com/support/developer/index.htm
+
+/* Supported alpha-test operations
+ *
+ * If the result of a test is true, a pixel is passed
+ * to the destination, otherwise it is discarded.
+ *
+ * This may or may not come in handy for some DirectFB operations...
+ * Is alpha-keying supported in DFB?
+ *
+ * OpenGL -> Unichrome-register mapping is done by (x - GL_NEVER) << 8
+ * The value goes into regHATMD. HC_HenAT_MASK must be set in regEnable.
+ * The default should be GL_ALWAYS...
+ *
+ * GL name				Passes if
+ *
+ * GL_NEVER				Never
+ * GL_LESS				alpha < ref
+ * GL_EQUAL				alpha = ref
+ * GL_LEQUAL			alpha <= ref
+ * GL_GREATER			alpha > ref
+ * GL_NOTEQUAL			alpha != ref
+ * GL_GEQUAL			alpha >= ref
+ * GL_ALWAYS			Always (default)
+ */
+ 
+ /* GL -> UC ROP mapping
+const u32 UC_ROP[16] =
+{
+	HC_HROP_BLACK,    // GL_CLEAR           0
+	HC_HROP_DPa,      // GL_AND             s & d
+	HC_HROP_PDna,     // GL_AND_REVERSE     s & ~d
+	HC_HROP_P,        // GL_COPY            s
+	HC_HROP_DPna,     // GL_AND_INVERTED    ~s & d
+	HC_HROP_D,        // GL_NOOP            d
+	HC_HROP_DPx,      // GL_XOR             s ^ d
+	HC_HROP_DPo,      // GL_OR              s | d
+	HC_HROP_DPon,     // GL_NOR             ~(s | d)
+	HC_HROP_DPxn,     // GL_EQUIV           ~(s ^ d)
+	HC_HROP_Dn,       // GL_INVERT          ~d
+	HC_HROP_PDno,     // GL_OR_REVERSE      s | ~d
+	HC_HROP_Pn,       // GL_COPY_INVERTED   ~s
+	HC_HROP_DPno,     // GL_OR_INVERTED     ~s | d
+	HC_HROP_DPan,     // GL_NAND            ~(s & d)
+	HC_HROP_WHITE     // GL_SET             1
+};
+*/
+
+/* Using the texture environment
+
+// The following is based on a lot of guesses and is probably partly wrong.
+
+// Texture unit 0 or 1, generic blending function:
+//
+// C = (Ca * Op(Cb, Cc) + Cbias) << Cshift
+// A = (Aa * Op(Ab, Ac) + Abias) << Ashift
+// Op() is addition, subtraction, max or min
+//
+// Cx (where x = {a, b, c}) can in turn have one of three functions;
+//
+// Cx = src, Cx = 1 - src and a third named "p5", whatever that is
+// The same applies to Ax = src, Ax = 1 - src, Ax = p5(src)
+//
+// src is one of several sources:
+//
+// 0:			zero
+// Dif:			diffuse vertex color
+// Spec:		specular vertex color                         
+// Tex:			texture color (i.e a pixel in a texture)
+// Cur:			Guess: Color from tex unit 0, if using unit 1.
+// Adif:		diffuse vertex alpha
+// Fog:			fog color
+// Atex:		texture alpha
+// Acur:		Same as cur (only the alpha part)
+// HTXnBLRC:	A constant stored in HC_SubA_HTXnTBLRCa, *Cb, *Cc, *Aa or, *Fog
+// Ctexnext:	--- Unknown --- 
+//
+// Not all sources can be used for all parameters, e.g Cbias.
+// See the register listing from where it says "Define the input texture"
+// and onwards.
+//
+// Finally, the Cshift/Ashift operation has a number of settings
+// either shift_1, shift_2, shift_No or shift_DotP
+//
+// Guessing: shift_1 and shift_2 = multiply by two and four
+// shift_No = disable
+// shift_DotP = --- Unknown --- Maybe DotP = Dot product, but with
+// what? Itself or another parameter? Anyway, we're not doing
+// bump mapping in DirectFB, so it's not needed here.
+//
+// As is indicated above, you can (probably) chain together the texture
+// blending functions for the two texture units by using the Cur and Acur
+// sources, allowing more complex shading.
+
+*/
+
+Unichrome partial register map
+
+Register: Command A
+
+Section HC_HCmdHeader_MASK      0xfe000000
+==========================================
+
+Section HC_HE3Fire_MASK         0x00100000
+
+Section HC_HPMType_MASK         0x000f0000
+==========================================
+        HC_HPMType_Point        0x00000000		Draw point
+        HC_HPMType_Line         0x00010000		Draw line
+        HC_HPMType_Tri          0x00020000		Draw triangle
+        HC_HPMType_TriWF        0x00040000		????
+
+Section HC_HEFlag_MASK          0x0000e000
+==========================================
+        HC_HEFlag_NoAA          0x00000000		No anti-aliasing
+        HC_HEFlag_ab            0x00008000		Guess: Enable AA on triangle line ab
+        HC_HEFlag_bc            0x00004000		Guess: Enable AA on triangle line bc
+        HC_HEFlag_ca            0x00002000		Guess: Enable AA on triangle line ca
+
+Section HC_HShading_MASK        0x00001c00
+==========================================
+        HC_HShading_Solid       0x00000000
+        HC_HShading_FlatA       0x00000400		No shading: Use vertex A color	
+		HC_HShading_FlatB       0x00000800		No shading: Use vertex B color
+        HC_HShading_FlatC       0x00000c00		No shading: Use vertex C color
+        HC_HShading_Gouraud     0x00001000		Enable Gouraud shading
+        
+Notes on HC_HShading:
+
+The _Flat[A,B,C] options select what vertex has the color when you draw
+flat shaded objects
+
+Section HC_HPMValidN_MASK       0x00000200
+Section HC_HPLEND_MASK          0x00000100
+
+Section HC_HVCycle_MASK         0x000000ff	These settings control how vertices
+==========================================	are handled and let you draw several
+Section HC_HVCycle_Style_MASK   0x000000c0	primitives (eg a triangle fan) with
+------------------------------------------	only one command.
+        HC_HVCycle_Full         0x00000000
+        HC_HVCycle_AFP          0x00000040
+        HC_HVCycle_One          0x000000c0
+										
+										
+Section HC_HVCycle_ChgA_MASK    0x00000030
+------------------------------------------
+        HC_HVCycle_NewA         0x00000000	Replace vertex A
+        HC_HVCycle_AA           0x00000010	Old vertex A is new vertex A
+        HC_HVCycle_AB           0x00000020	Old vertex A is new vertex B
+        HC_HVCycle_AC           0x00000030	Old vertex A is new vertex C
+
+Section HC_HVCycle_ChgB_MASK    0x0000000c
+------------------------------------------
+        HC_HVCycle_NewB         0x00000000	...
+        HC_HVCycle_BA           0x00000004
+        HC_HVCycle_BB           0x00000008
+        HC_HVCycle_BC           0x0000000c
+
+Section HC_HVCycle_ChgC_MASK    0x00000003
+------------------------------------------
+        HC_HVCycle_NewC         0x00000000	...
+        HC_HVCycle_CA           0x00000001
+        HC_HVCycle_CB           0x00000002
+        HC_HVCycle_CC           0x00000003
+
+***********************************************************
+
+Register: Command B
+
+Section HC_HLPrst_MASK          0x00010000
+Section HC_HLLastP_MASK         0x00008000
+
+Section HC_HVPMSK_MASK          0x00007f80	Marks what data fields are present in a vertex.
+==========================================	
+        HC_HVPMSK_X             0x00004000	Vertex has X coordinate
+        HC_HVPMSK_Y             0x00002000	Vertex has Y coordinate
+        HC_HVPMSK_Z             0x00001000	Vertex has Z coordinate
+        HC_HVPMSK_W             0x00000800	Vertex has W coordinate
+        HC_HVPMSK_Cd            0x00000400	Vertex has diffuse color
+        HC_HVPMSK_Cs            0x00000200	Vertex has specular/fog color
+        HC_HVPMSK_S             0x00000100	Vertex has S (hor.) texture coordinate
+        HC_HVPMSK_T             0x00000080	Vertex has T (vert.) texture coordinate
+
+Section HC_HBFace_MASK          0x00000040
+Section HC_H2nd1VT_MASK         0x0000003f
+
+***********************************************************
+
+Register: Enable (HC_SubA_HEnable)
+
+==========================================
+
+        HC_HenTXEnvMap_MASK     0x00200000		????
+        HC_HenVertexCNT_MASK    0x00100000		????
+        HC_HenCPUDAZ_MASK       0x00080000		????
+        HC_HenDASZWC_MASK       0x00040000		????
+        HC_HenFBCull_MASK       0x00020000		Polygon culling
+        HC_HenCW_MASK           0x00010000		???? Is always on in the DRI code.
+        HC_HenAA_MASK           0x00008000		Drawing anti-aliasing
+        HC_HenST_MASK           0x00004000		Stencil test
+        HC_HenZT_MASK           0x00002000		Z test
+        HC_HenZW_MASK           0x00001000		Z buffer
+        HC_HenAT_MASK           0x00000800		Alpha test
+        HC_HenAW_MASK           0x00000400		Alpha buffer
+        HC_HenSP_MASK           0x00000200		Polygon stipple
+        HC_HenLP_MASK           0x00000100		Line stipple
+        HC_HenTXCH_MASK         0x00000080		???? Texture related ...
+        HC_HenTXMP_MASK         0x00000040		???? Texture related ...
+        HC_HenTXPP_MASK         0x00000020		???? Texture related ...
+        HC_HenTXTR_MASK         0x00000010		???? Texture related ...
+        HC_HenCS_MASK           0x00000008		????
+        HC_HenFOG_MASK          0x00000004		Fog
+        HC_HenABL_MASK          0x00000002		Alpha blending
+        HC_HenDT_MASK           0x00000001		Color dithering
+
+***********************************************************
+
+Stencil function
+
+Reg.	HC_SubA_HSBBasL			????			Should exist...
+Reg.	HC_SubA_HSBBasH			????			Should exist...
+
+Reg.	HC_SubA_HSBFM			????
+==========================================
+Section HC_HSBFM_MASK           0x00030000		Buffer data format
+------------------------------------------
+???
+
+Section HC_HSBLoc_MASK          0x0000c000		Buffer memory type
+------------------------------------------		(agp, or video etc)
+????
+
+Section HC_HSBPit_MASK          0x00003fff		Buffer row pitch
+
+Reg.    HC_SubA_HSTREF          0x0023
+==========================================
+        HC_HSTREF_MASK          0x00ff0000		???? Reference value
+
+Section HC_HSTOPMSK_MASK        0x0000ff00		???? Operation?
+------------------------------------------
+????
+
+Section HC_HSTBMSK_MASK         0x000000ff		???? Destination bitmask
+------------------------------------------
+????
+
+Reg.    HC_SubA_HSTMD           0x0024
+==========================================
+Section HC_HSTMD_MASK           0x00070000		Test function
+------------------------------------------
+        HC_HSTMD_NeverPass      0x00000000
+        HC_HSTMD_LT             0x00010000
+        HC_HSTMD_EQ             0x00020000
+        HC_HSTMD_LE             0x00030000
+        HC_HSTMD_GT             0x00040000
+        HC_HSTMD_NE             0x00050000
+        HC_HSTMD_GE             0x00060000
+        HC_HSTMD_AllPass        0x00070000
+
+Section HC_HSTOPSF_MASK         0x000001c0		Fail operation
+------------------------------------------
+        HC_HSTOPSF_KEEP         0x00000000
+        HC_HSTOPSF_ZERO         0x00000040
+        HC_HSTOPSF_REPLACE      0x00000080
+        HC_HSTOPSF_INCRSAT      0x000000c0
+        HC_HSTOPSF_DECRSAT      0x00000100
+        HC_HSTOPSF_INVERT       0x00000140
+        HC_HSTOPSF_INCR         0x00000180
+        HC_HSTOPSF_DECR         0x000001c0
+
+Section HC_HSTOPSPZF_MASK       0x00000038		Z-fail operation
+------------------------------------------
+        HC_HSTOPSPZF_KEEP       0x00000000
+        HC_HSTOPSPZF_ZERO       0x00000008
+        HC_HSTOPSPZF_REPLACE    0x00000010
+        HC_HSTOPSPZF_INCRSAT    0x00000018
+        HC_HSTOPSPZF_DECRSAT    0x00000020
+        HC_HSTOPSPZF_INVERT     0x00000028
+        HC_HSTOPSPZF_INCR       0x00000030
+        HC_HSTOPSPZF_DECR       0x00000038
+
+Section HC_HSTOPSPZP_MASK       0x00000007		Z-pass operation 
+------------------------------------------
+        HC_HSTOPSPZP_KEEP       0x00000000
+        HC_HSTOPSPZP_ZERO       0x00000001
+        HC_HSTOPSPZP_REPLACE    0x00000002
+        HC_HSTOPSPZP_INCRSAT    0x00000003
+        HC_HSTOPSPZP_DECRSAT    0x00000004
+        HC_HSTOPSPZP_INVERT     0x00000005
+        HC_HSTOPSPZP_INCR       0x00000006
+        HC_HSTOPSPZP_DECR       0x00000007
+
+***********************************************************
+
+Destination buffer (e.g the frame buffer)
+
+Reg.    HC_SubA_HDBBasL         0x0040			Physical address, low 24 bits
+Reg.    HC_SubA_HDBBasH         0x0041			Physical address, high 8 bits
+
+Reg.    HC_SubA_HDBFM           0x0042			Pixel format and row pitch
+==========================================
+Section HC_HDBFM_MASK           0x001f0000		Pixel format
+------------------------------------------
+        HC_HDBFM_RGB555         0x00000000
+        HC_HDBFM_RGB565         0x00010000
+        HC_HDBFM_ARGB4444       0x00020000
+        HC_HDBFM_ARGB1555       0x00030000
+        HC_HDBFM_BGR555         0x00040000
+        HC_HDBFM_BGR565         0x00050000
+        HC_HDBFM_ABGR4444       0x00060000
+        HC_HDBFM_ABGR1555       0x00070000
+        HC_HDBFM_ARGB0888       0x00080000
+        HC_HDBFM_ARGB8888       0x00090000
+        HC_HDBFM_ABGR0888       0x000a0000
+        HC_HDBFM_ABGR8888       0x000b0000
+
+Section HC_HDBLoc_MASK          0x0000c000
+------------------------------------------
+        HC_HDBLoc_Local         0x00000000
+        HC_HDBLoc_Sys           0x00004000
+
+Section HC_HDBPit_MASK          0x00003fff		Row pitch
+
+Reg.    HC_SubA_HFBBMSKL        0x0043			Bitmask, low 24 bits.
+												Pixels are ANDed with this
+												value before being written.
+
+Reg.    HC_SubA_HROP            0x0044
+==========================================
+Section HC_HROP_MASK            0x00000f00		Raster operation
+------------------------------------------
+        HC_HROP_BLACK           0x00000000
+        HC_HROP_DPon            0x00000100
+        HC_HROP_DPna            0x00000200
+        HC_HROP_Pn              0x00000300
+        HC_HROP_PDna            0x00000400
+        HC_HROP_Dn              0x00000500
+        HC_HROP_DPx             0x00000600
+        HC_HROP_DPan            0x00000700
+        HC_HROP_DPa             0x00000800
+        HC_HROP_DPxn            0x00000900
+        HC_HROP_D               0x00000a00
+        HC_HROP_DPno            0x00000b00
+        HC_HROP_P               0x00000c00
+        HC_HROP_PDno            0x00000d00
+        HC_HROP_DPo             0x00000e00
+        HC_HROP_WHITE           0x00000f00
+
+Section HC_HFBBMSKH_MASK        0x000000ff		High 8 bits of HFBBMSKL
+
+***********************************************************
+
+Alpha buffer
+
+Reg.    HC_SubA_HABBasL         0x0030			Physical address, low 24 bits
+Reg.    HC_SubA_HABBasH         0x0031			Physical address, high 8 bits
+Reg.    HC_SubA_HABFM           0x0032			Pixel format and row pitch
+==========================================
+Section HC_HABFM_MASK           0x00030000
+Section HC_HABLoc_MASK          0x0000c000
+Section HC_HABPit_MASK          0x000007ff
+
+Alpha test
+
+Reg.    HC_SubA_HATMD           0x0033			Alpha test function and reference
+==========================================
+Section HC_HATMD_MASK           0x00000700		Alpha-test function
+------------------------------------------
+        HC_HATMD_NeverPass      0x00000000
+        HC_HATMD_LT             0x00000100
+        HC_HATMD_EQ             0x00000200
+        HC_HATMD_LE             0x00000300
+        HC_HATMD_GT             0x00000400
+        HC_HATMD_NE             0x00000500
+        HC_HATMD_GE             0x00000600
+        HC_HATMD_AllPass        0x00000700
+
+Section HC_HATREF_MASK          0x000000ff		Reference value to compare with.
+------------------------------------------
+
+Alpha blend
+
+Reg.    HC_SubA_HABLCsat        0x0034
+==========================================
+#define HC_HABLCsat_MASK        0x00010000
+#define HC_HABLCa_MASK          0x0000fc00
+#define HC_HABLCa_C_MASK        0x0000c000
+#define HC_HABLCa_OPC_MASK      0x00003c00
+#define HC_HABLFCa_MASK         0x000003f0
+#define HC_HABLFCa_C_MASK       0x00000300
+#define HC_HABLFCa_OPC_MASK     0x000000f0
+#define HC_HABLCbias_MASK       0x0000000f
+#define HC_HABLCbias_C_MASK     0x00000008
+#define HC_HABLCbias_OPC_MASK   0x00000007
+
+Reg.    HC_SubA_HABLCop         0x0035
+==========================================
+#define HC_HABLdot_MASK         0x00010000
+#define HC_HABLCop_MASK         0x00004000
+#define HC_HABLCb_MASK          0x00003f00
+#define HC_HABLCb_C_MASK        0x00003000
+#define HC_HABLCb_OPC_MASK      0x00000f00
+#define HC_HABLFCb_MASK         0x000000fc
+#define HC_HABLFCb_C_MASK       0x000000c0
+#define HC_HABLFCb_OPC_MASK     0x0000003c
+#define HC_HABLCshift_MASK      0x00000003
+
+Reg.    HC_SubA_HABLAsat        0x0036
+==========================================
+#define HC_HABLAsat_MASK        0x00010000
+#define HC_HABLAa_MASK          0x0000fc00
+#define HC_HABLAa_A_MASK        0x0000c000
+#define HC_HABLAa_OPA_MASK      0x00003c00
+#define HC_HABLFAa_MASK         0x000003f0
+#define HC_HABLFAa_A_MASK       0x00000300
+#define HC_HABLFAa_OPA_MASK     0x000000f0
+#define HC_HABLAbias_MASK       0x0000000f
+#define HC_HABLAbias_A_MASK     0x00000008
+#define HC_HABLAbias_OPA_MASK   0x00000007
+
+Reg.    HC_SubA_HABLAop         0x0037
+==========================================
+#define HC_HABLAop_MASK         0x00004000
+#define HC_HABLAb_MASK          0x00003f00
+#define HC_HABLAb_OPA_MASK      0x00000f00
+#define HC_HABLFAb_MASK         0x000000fc
+#define HC_HABLFAb_OPA_MASK     0x0000003c
+#define HC_HABLAshift_MASK      0x00000003
+
+Reg.    HC_SubA_HABLRCa         0x0038
+Reg.    HC_SubA_HABLRFCa        0x0039
+Reg.    HC_SubA_HABLRCbias      0x003a
+Reg.    HC_SubA_HABLRCb         0x003b
+Reg.    HC_SubA_HABLRFCb        0x003c
+
+Reg.    HC_SubA_HABLRAa         0x003d
+==========================================
+#define HC_HABLRAa_MASK         0x00ff0000
+#define HC_HABLRFAa_MASK        0x0000ff00
+#define HC_HABLRAbias_MASK      0x000000ff
+
+Reg.    HC_SubA_HABLRAb         0x003e
+==========================================
+#define HC_HABLRAb_MASK         0x0000ff00
+#define HC_HABLRFAb_MASK        0x000000ff
+
+
+***********************************************************
+
+Texture engine
+
+/* Attribute of texture n
+ */
+
+Reg.    HC_SubA_HTXnLiBasL      0x0000+i	Low 24-bits of base address i
+======================================
+There are 18 registers. Replace i with a value i = [0, 11] hex.
+
+MSB 8 bits of texture addresses
+
+Reg.    HC_SubA_HTXnL012BasH    0x0020	Map 0 - 2
+Reg.    HC_SubA_HTXnL345BasH    0x0021	Map 3 - 5
+Reg.    HC_SubA_HTXnL678BasH    0x0022	Map 6 - 8
+Reg.    HC_SubA_HTXnL9abBasH    0x0023	Map 9 - b
+Reg.    HC_SubA_HTXnLcdeBasH    0x0024	Map c - e
+Reg.    HC_SubA_HTXnLf1011BasH  0x0025	Map f - 11
+
+Reg.    HC_SubA_HTXnL0Pit       0x002b + i
+==========================================
+There are 18 registers. Replace i with a value i = [0, 11] hex.
+
+Section HC_HTXnLnPit_MASK       0x00003fff	Byte-pitch (map 0 only)
+Section HC_HTXnEnPit_MASK       0x00080000	Enable byte-pitch
+Section HC_HTXnLnPitE_MASK      0x00f00000	Log2 pitch
+
+Width exponents (log2 of texture width)
+
+Reg.    HC_SubA_HTXnL0_5WE      0x004b		Map 0 - 5
+Reg.    HC_SubA_HTXnL6_bWE      0x004c		Map 6 - b
+Reg.    HC_SubA_HTXnLc_11WE     0x004d		Map c - 11
+
+Height exponents (log2 of texture width)
+
+Reg.    HC_SubA_HTXnL0_5HE      0x0051		Map 0 - 5
+Reg.    HC_SubA_HTXnL6_bHE      0x0052		Map 6 - b
+Reg.    HC_SubA_HTXnLc_11HE     0x0053		Map c - 11
+
+
+
+Reg.    HC_SubA_HTXnL0OS        0x0077
+Reg.    HC_SubA_HTXnTB          0x0078
+Reg.    HC_SubA_HTXnMPMD        0x0079		Texture mapping params
+==========================================
+Section HC_HTXnMPMD_SMASK       0x00070000	S axis wrapping function
+------------------------------------------
+        HC_HTXnMPMD_Ssingle     0x00000000
+        HC_HTXnMPMD_Sclamp      0x00010000
+        HC_HTXnMPMD_Srepeat     0x00020000
+        HC_HTXnMPMD_Smirror     0x00030000
+        HC_HTXnMPMD_Swrap       0x00040000
+
+Section HC_HTXnMPMD_TMASK       0x00380000	T axis wrapping function
+------------------------------------------
+        HC_HTXnMPMD_Tsingle     0x00000000
+        HC_HTXnMPMD_Tclamp      0x00080000
+        HC_HTXnMPMD_Trepeat     0x00100000
+        HC_HTXnMPMD_Tmirror     0x00180000
+        HC_HTXnMPMD_Twrap       0x00200000
+
+Section HC_HTXnLODDTf_MASK      0x00000007	????
+Section HC_HTXnXY2ST_MASK       0x00000008	????
+
+Reg.    HC_SubA_HTXnCLODu       0x007a
+
+Reg.    HC_SubA_HTXnFM          0x007b		Texture pixel format and mem type
+==========================================
+Section HC_HTXnFM_MASK          0x00ff0000	Texture pixel format, see HC_HTXnFM_MASK
+											in regs3d.h for a list of formats.
+Section HC_HTXnLoc_MASK         0x00000003
+------------------------------------------
+        HC_HTXnLoc_Local        0x00000000
+        HC_HTXnLoc_Sys          0x00000002
+        HC_HTXnLoc_AGP          0x00000003
+
+Reg.    HC_SubA_HTXnTRCH        0x007c
+Reg.    HC_SubA_HTXnTRCL        0x007d
+Reg.    HC_SubA_HTXnTBC         0x007e
+Reg.    HC_SubA_HTXnTRAH        0x007f
+
+Blending, fog etc.
+
+Reg.    HC_SubA_HTXnTBLCsat     0x0080
+Reg.    HC_SubA_HTXnTBLCop      0x0081
+Reg.    HC_SubA_HTXnTBLMPfog    0x0082
+Reg.    HC_SubA_HTXnTBLAsat     0x0083
+Reg.    HC_SubA_HTXnTBLRCa      0x0085
+Reg.    HC_SubA_HTXnTBLRCb      0x0086
+Reg.    HC_SubA_HTXnTBLRCc      0x0087
+Reg.    HC_SubA_HTXnTBLRCbias   0x0088
+Reg.    HC_SubA_HTXnTBLRAa      0x0089
+Reg.    HC_SubA_HTXnTBLRFog     0x008a
+Reg.    HC_SubA_HTXnBumpM00     0x0090
+Reg.    HC_SubA_HTXnBumpM01     0x0091
+Reg.    HC_SubA_HTXnBumpM10     0x0092
+Reg.    HC_SubA_HTXnBumpM11     0x0093
+Reg.    HC_SubA_HTXnLScale      0x0094
+Reg.    HC_SubA_HTXSMD          0x0000
diff --git a/DirectFB-1.3.0/gfxdrivers/cle266/rops.h b/DirectFB-1.3.0/gfxdrivers/cle266/rops.h
new file mode 100644
index 0000000..fcc55e7
--- /dev/null
+++ b/DirectFB-1.3.0/gfxdrivers/cle266/rops.h
@@ -0,0 +1,296 @@
+/* Adapted version of xc/programs/Xserver/hw/xfree86/xaa/xaarop.h v1.1
+
+Copyright (c) The XFree86 Project, Inc 199?
+No copyright is given in the original file...
+
+-----------------
+
+Key for raster operation names:
+
+This is based on guesswork, so it may be inaccurate and incomplete. :-)
+
+D = Destination, S = Source, P = Pattern
+n = logical not, o = logical or, a = logical and, x = logical exclusive or
+0 = all zeros (black), 1 = all ones (white)
+
+When forming a ROP name, the data sources and destination preceeds the operations.
+
+Example: ROP_DSPDSanaxxn 
+
+It can be decoded as follows:
+DSPDSanaxxn => D an S a P x D xn S =>
+Destination (and not) Source (and) Pattern (xor) Destination (xor not) Source.
+
+When blitting or drawing, the result of the raster operation will copied to
+the destination.
+
+Common examples:
+
+ROP_P => destination = pattern, i.e drawing.
+ROP_S => destination = source, i.e copying.
+ROP_DSx => destination = source (xor) destination
+ROP_D => destination = destination, i.e does nothing.
+
+*/
+
+#ifndef _XFREE86_ROPS_H
+#define _XFREE86_ROPS_H
+
+#define ROP_0           0x00
+#define ROP_DPSoon      0x01
+#define ROP_DPSona      0x02
+#define ROP_PSon        0x03
+#define ROP_SDPona      0x04
+#define ROP_DPon        0x05
+#define ROP_PDSxnon     0x06
+#define ROP_PDSaon      0x07
+#define ROP_SDPnaa      0x08
+#define ROP_PDSxon      0x09
+#define ROP_DPna        0x0A
+#define ROP_PSDnaon     0x0B
+#define ROP_SPna        0x0C
+#define ROP_PDSnaon     0x0D
+#define ROP_PDSonon     0x0E
+#define ROP_Pn          0x0F
+#define ROP_PDSona      0x10
+#define ROP_DSon        0x11
+#define ROP_SDPxnon     0x12
+#define ROP_SDPaon      0x13
+#define ROP_DPSxnon     0x14
+#define ROP_DPSaon      0x15
+#define ROP_PSDPSanaxx  0x16
+#define ROP_SSPxDSxaxn  0x17
+#define ROP_SPxPDxa     0x18
+#define ROP_SDPSanaxn   0x19
+#define ROP_PDSPaox     0x1A
+#define ROP_SDPSxaxn    0x1B
+#define ROP_PSDPaox     0x1C
+#define ROP_DSPDxaxn    0x1D
+#define ROP_PDSox       0x1E
+#define ROP_PDSoan      0x1F
+#define ROP_DPSnaa      0x20
+#define ROP_SDPxon      0x21
+#define ROP_DSna        0x22
+#define ROP_SPDnaon     0x23
+#define ROP_SPxDSxa     0x24
+#define ROP_PDSPanaxn   0x25
+#define ROP_SDPSaox     0x26
+#define ROP_SDPSxnox    0x27
+#define ROP_DPSxa       0x28
+#define ROP_PSDPSaoxxn  0x29
+#define ROP_DPSana      0x2A
+#define ROP_SSPxPDxaxn  0x2B
+#define ROP_SPDSoax     0x2C
+#define ROP_PSDnox      0x2D
+#define ROP_PSDPxox     0x2E
+#define ROP_PSDnoan     0x2F
+#define ROP_PSna        0x30
+#define ROP_SDPnaon     0x31
+#define ROP_SDPSoox     0x32
+#define ROP_Sn          0x33
+#define ROP_SPDSaox     0x34
+#define ROP_SPDSxnox    0x35
+#define ROP_SDPox       0x36
+#define ROP_SDPoan      0x37
+#define ROP_PSDPoax     0x38
+#define ROP_SPDnox      0x39
+#define ROP_SPDSxox     0x3A
+#define ROP_SPDnoan     0x3B
+#define ROP_PSx         0x3C
+#define ROP_SPDSonox    0x3D
+#define ROP_SPDSnaox    0x3E
+#define ROP_PSan        0x3F
+#define ROP_PSDnaa      0x40
+#define ROP_DPSxon      0x41
+#define ROP_SDxPDxa     0x42
+#define ROP_SPDSanaxn   0x43
+#define ROP_SDna        0x44
+#define ROP_DPSnaon     0x45
+#define ROP_DSPDaox     0x46
+#define ROP_PSDPxaxn    0x47
+#define ROP_SDPxa       0x48
+#define ROP_PDSPDaoxxn  0x49
+#define ROP_DPSDoax     0x4A
+#define ROP_PDSnox      0x4B
+#define ROP_SDPana      0x4C
+#define ROP_SSPxDSxoxn  0x4D
+#define ROP_PDSPxox     0x4E
+#define ROP_PDSnoan     0x4F
+#define ROP_PDna        0x50
+#define ROP_DSPnaon     0x51
+#define ROP_DPSDaox     0x52
+#define ROP_SPDSxaxn    0x53
+#define ROP_DPSonon     0x54
+#define ROP_Dn          0x55
+#define ROP_DPSox       0x56
+#define ROP_DPSoan      0x57
+#define ROP_PDSPoax     0x58
+#define ROP_DPSnox      0x59
+#define ROP_DPx         0x5A
+#define ROP_DPSDonox    0x5B
+#define ROP_DPSDxox     0x5C
+#define ROP_DPSnoan     0x5D
+#define ROP_DPSDnaox    0x5E
+#define ROP_DPan        0x5F
+#define ROP_PDSxa       0x60
+#define ROP_DSPDSaoxxn  0x61
+#define ROP_DSPDoax     0x62
+#define ROP_SDPnox      0x63
+#define ROP_SDPSoax     0x64
+#define ROP_DSPnox      0x65
+#define ROP_DSx         0x66
+#define ROP_SDPSonox    0x67
+#define ROP_DSPDSonoxxn 0x68
+#define ROP_PDSxxn      0x69
+#define ROP_DPSax       0x6A
+#define ROP_PSDPSoaxxn  0x6B
+#define ROP_SDPax       0x6C
+#define ROP_PDSPDoaxxn  0x6D
+#define ROP_SDPSnoax    0x6E
+#define ROP_PDSxnan     0x6F
+#define ROP_PDSana      0x70
+#define ROP_SSDxPDxaxn  0x71
+#define ROP_SDPSxox     0x72
+#define ROP_SDPnoan     0x73
+#define ROP_DSPDxox     0x74
+#define ROP_DSPnoan     0x75
+#define ROP_SDPSnaox    0x76
+#define ROP_DSan        0x77
+#define ROP_PDSax       0x78
+#define ROP_DSPDSoaxxn  0x79
+#define ROP_DPSDnoax    0x7A
+#define ROP_SDPxnan     0x7B
+#define ROP_SPDSnoax    0x7C
+#define ROP_DPSxnan     0x7D
+#define ROP_SPxDSxo     0x7E
+#define ROP_DPSaan      0x7F
+#define ROP_DPSaa       0x80
+#define ROP_SPxDSxon    0x81
+#define ROP_DPSxna      0x82
+#define ROP_SPDSnoaxn   0x83
+#define ROP_SDPxna      0x84
+#define ROP_PDSPnoaxn   0x85
+#define ROP_DSPDSoaxx   0x86
+#define ROP_PDSaxn      0x87
+#define ROP_DSa         0x88
+#define ROP_SDPSnaoxn   0x89
+#define ROP_DSPnoa      0x8A
+#define ROP_DSPDxoxn    0x8B
+#define ROP_SDPnoa      0x8C
+#define ROP_SDPSxoxn    0x8D
+#define ROP_SSDxPDxax   0x8E
+#define ROP_PDSanan     0x8F
+#define ROP_PDSxna      0x90
+#define ROP_SDPSnoaxn   0x91
+#define ROP_DPSDPoaxx   0x92
+#define ROP_SPDaxn      0x93
+#define ROP_PSDPSoaxx   0x94
+#define ROP_DPSaxn      0x95
+#define ROP_DPSxx       0x96
+#define ROP_PSDPSonoxx  0x97
+#define ROP_SDPSonoxn   0x98
+#define ROP_DSxn        0x99
+#define ROP_DPSnax      0x9A
+#define ROP_SDPSoaxn    0x9B
+#define ROP_SPDnax      0x9C
+#define ROP_DSPDoaxn    0x9D
+#define ROP_DSPDSaoxx   0x9E
+#define ROP_PDSxan      0x9F
+#define ROP_DPa         0xA0
+#define ROP_PDSPnaoxn   0xA1
+#define ROP_DPSnoa      0xA2
+#define ROP_DPSDxoxn    0xA3
+#define ROP_PDSPonoxn   0xA4
+#define ROP_PDxn        0xA5
+#define ROP_DSPnax      0xA6
+#define ROP_PDSPoaxn    0xA7
+#define ROP_DPSoa       0xA8
+#define ROP_DPSoxn      0xA9
+#define ROP_D           0xAA
+#define ROP_DPSono      0xAB
+#define ROP_SPDSxax     0xAC
+#define ROP_DPSDaoxn    0xAD
+#define ROP_DSPnao      0xAE
+#define ROP_DPno        0xAF
+#define ROP_PDSnoa      0xB0
+#define ROP_PDSPxoxn    0xB1
+#define ROP_SSPxDSxox   0xB2
+#define ROP_SDPanan     0xB3
+#define ROP_PSDnax      0xB4
+#define ROP_DPSDoaxn    0xB5
+#define ROP_DPSDPaoxx   0xB6
+#define ROP_SDPxan      0xB7
+#define ROP_PSDPxax     0xB8
+#define ROP_DSPDaoxn    0xB9
+#define ROP_DPSnao      0xBA
+#define ROP_DSno        0xBB
+#define ROP_SPDSanax    0xBC
+#define ROP_SDxPDxan    0xBD
+#define ROP_DPSxo       0xBE
+#define ROP_DPSano      0xBF
+#define ROP_PSa         0xC0
+#define ROP_SPDSnaoxn   0xC1
+#define ROP_SPDSonoxn   0xC2
+#define ROP_PSxn        0xC3
+#define ROP_SPDnoa      0xC4
+#define ROP_SPDSxoxn    0xC5
+#define ROP_SDPnax      0xC6
+#define ROP_PSDPoaxn    0xC7
+#define ROP_SDPoa       0xC8
+#define ROP_SPDoxn      0xC9
+#define ROP_DPSDxax     0xCA
+#define ROP_SPDSaoxn    0xCB
+#define ROP_S           0xCC
+#define ROP_SDPono      0xCD
+#define ROP_SDPnao      0xCE
+#define ROP_SPno        0xCF
+#define ROP_PSDnoa      0xD0
+#define ROP_PSDPxoxn    0xD1
+#define ROP_PDSnax      0xD2
+#define ROP_SPDSoaxn    0xD3
+#define ROP_SSPxPDxax   0xD4
+#define ROP_DPSanan     0xD5
+#define ROP_PSDPSaoxx   0xD6
+#define ROP_DPSxan      0xD7
+#define ROP_PDSPxax     0xD8
+#define ROP_SDPSaoxn    0xD9
+#define ROP_DPSDanax    0xDA
+#define ROP_SPxDSxan    0xDB
+#define ROP_SPDnao      0xDC
+#define ROP_SDno        0xDD
+#define ROP_SDPxo       0xDE
+#define ROP_SDPano      0xDF
+#define ROP_PDSoa       0xE0
+#define ROP_PDSoxn      0xE1
+#define ROP_DSPDxax     0xE2
+#define ROP_PSDPaoxn    0xE3
+#define ROP_SDPSxax     0xE4
+#define ROP_PDSPaoxn    0xE5
+#define ROP_SDPSanax    0xE6
+#define ROP_SPxPDxan    0xE7
+#define ROP_SSPxDSxax   0xE8
+#define ROP_DSPDSanaxxn 0xE9
+#define ROP_DPSao       0xEA
+#define ROP_DPSxno      0xEB
+#define ROP_SDPao       0xEC
+#define ROP_SDPxno      0xED
+#define ROP_DSo         0xEE
+#define ROP_SDPnoo      0xEF
+#define ROP_P           0xF0
+#define ROP_PDSono      0xF1
+#define ROP_PDSnao      0xF2
+#define ROP_PSno        0xF3
+#define ROP_PSDnao      0xF4
+#define ROP_PDno        0xF5
+#define ROP_PDSxo       0xF6
+#define ROP_PDSano      0xF7
+#define ROP_PDSao       0xF8
+#define ROP_PDSxno      0xF9
+#define ROP_DPo         0xFA
+#define ROP_DPSnoo      0xFB
+#define ROP_PSo         0xFC
+#define ROP_PSDnoo      0xFD
+#define ROP_DPSoo       0xFE
+#define ROP_1           0xFF
+
+#endif // _XFREE86_ROPS_H
diff --git a/DirectFB-1.3.0/gfxdrivers/cle266/uc_probe.c b/DirectFB-1.3.0/gfxdrivers/cle266/uc_probe.c
new file mode 100755
index 0000000..7bfd21b
--- /dev/null
+++ b/DirectFB-1.3.0/gfxdrivers/cle266/uc_probe.c
@@ -0,0 +1,209 @@
+/*
+   Copyright (c) 2003 Andreas Robinson, All rights reserved.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+*/
+
+#include <stdio.h>
+#include <fcntl.h>
+#include <string.h>
+#include <errno.h>
+#include <asm/types.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/mman.h>
+#include <directfb.h>
+#include <core/coredefs.h>
+#include "uc_probe.h"
+
+/**
+* Match a device string with a device ID.
+*
+* @param s          Device string read from /proc/bus/pci/devices
+* @param devinfo    Output: device information.
+*
+* @returns 1: success, 0: line too short, -1: parse error.
+*/
+
+int uc_parse_vga_device(char* s, struct uc_vga_device* devinfo)
+{
+    int i;
+    int item[17];
+
+    /* Build list of item start positions. */
+
+    item[0] = 0;
+    item[1] = 5;
+    item[2] = 14;
+
+    for (i = 3; i < 18; i++) {
+        item[i] = (i - 3) * 9 + 16;
+    }
+
+    /* Perform some basic sanity checks */
+
+    if (strlen(s) < 142) return 0;
+
+    for (i = 1; i < 17; i++) {  /* Verify tab positions. */
+        if (s[item[i]-1] != 9) return -1;
+    }
+
+    /* Read data. */
+
+    devinfo->devid = strtoul(s + item[1], NULL, 16);
+    devinfo->busid = strtoul(s + item[0], NULL, 16);
+    devinfo->irq = strtoul(s + item[2], NULL, 16);
+    devinfo->fbmem = strtoul(s + item[3], NULL, 16) & ~0xf;
+    devinfo->iomem = strtoul(s + item[4], NULL, 16) & ~0xf;
+    devinfo->fbsize = strtoul(s + item[3 + 7], NULL, 16);
+    devinfo->iosize = strtoul(s + item[4 + 7], NULL, 16);
+
+    /* More sanity checks */
+
+    if ((devinfo->fbmem == 0) || (devinfo->iomem == 0) ||
+        (devinfo->fbsize == 0) || (devinfo->iosize == 0))
+        return 0;
+
+    return 1;
+}
+
+/**
+ * Probe the PCI bus for the first matching device.
+ *
+ * @param vendor    Vendor ID
+ * @param device    Device ID
+ * @param name      Device name, used for error messages.
+ *                  Example: "UniChrome graphics controller"
+ * @param devinfo   Output.
+ *
+ * @returns DFB_OK or DFB_FAILURE
+ */
+
+DFBResult uc_probe_vga_device(u16 vendor, u16 device, char* name,
+                        struct uc_vga_device* devinfo)
+{
+    char fbuf[256];
+    FILE* file;
+    char* s;
+    int r;
+    int n;
+
+    memset(devinfo, 0, sizeof(struct uc_vga_device));
+
+    file = fopen("/proc/bus/pci/devices", "r");
+    if (!file) {
+        D_ERROR("Can not open /proc/bus/pci/devices. "
+            "Will not probe for %s.\n", name);
+        return DFB_FAILURE;
+    }
+
+    n = 0;
+
+    while (1)
+    {
+        errno = 0;
+        s = fgets(fbuf, 256, file);
+        if (s == NULL) {
+            if (errno > 0) {
+                D_ERROR("Error reading /proc/bus/pci/devices. "
+                    "Probing for %s failed.\n", name);
+            }
+            fclose(file);
+            return DFB_FAILURE;
+        }
+        s[255] = 0;
+        n++;
+
+        r = uc_parse_vga_device(s, devinfo);
+
+        if (r == 1) {
+            if (devinfo->devid == ((vendor << 16) | device)) {
+                fclose(file);
+                return DFB_OK;
+            }
+        }
+        else if (r == -1) {
+            D_ERROR("Error parsing /proc/bus/pci/devices on line %d. "
+                "Probing for %s failed.\n", n, name);
+            fclose(file);
+            return DFB_FAILURE;
+        }
+    }
+}
+
+/**
+ * Mmap the IO memory area of a VGA device.
+ *
+ * @param devinfo   result from probing function
+ * @param name      Device name, used for error messges.
+ *
+ * @returns DFB_OK or DFB_FAILURE
+ */
+
+DFBResult uc_mmap_vga_device(struct uc_vga_device* devinfo, char* name)
+{
+    int fd;
+    void* result;
+
+    fd = open("/dev/mem", O_RDWR);
+    if (fd < 0) {
+        D_ERROR("Cannot open /dev/mem: %s.\n", strerror(errno));
+        return DFB_FAILURE;
+    }
+
+    result = mmap(NULL, devinfo->iosize, PROT_READ | PROT_WRITE,
+        MAP_SHARED, fd, devinfo->iomem);
+
+    close(fd);  
+    
+    if (result == MAP_FAILED) {
+        D_ERROR("Cannot mmap %s hardware registers. "
+            "Initialization failed.\n", name);
+        return DFB_FAILURE;
+    }
+
+    devinfo->iomap = result;
+    return DFB_OK;
+}
+
+void uc_munmap_vga_device(struct uc_vga_device* devinfo)
+{
+    if (devinfo->iomap) munmap(devinfo->iomap, devinfo->iosize);
+    devinfo->iomap = NULL;
+}
+
+/* Usage example / test program */
+
+/*
+
+int main()
+{
+    char* name = "CLE266 VGA adapter";
+
+    int r;
+    struct uc_vga_device devinfo;
+
+    r = uc_probe_vga_device(0x1106, 0x3122, name, &devinfo);
+
+    if (r == DFB_OK) {
+        printf("%s found at %02x:%02x.%x. Using IRQ %d.\n",
+            name,
+            devinfo.busid >> 8, (devinfo.busid >> 3) & 0x1f,
+            devinfo.busid & 3, devinfo.irq);
+        printf("FB: %dMB @ 0x%x  ", devinfo.fbsize >> 20, devinfo.fbmem);
+        printf("MMIO: %dKB @ 0x%x\n", devinfo.iosize >> 10, devinfo.iomem);
+
+        r = uc_mmap_vga_device(&devinfo, name);
+        if (r == DFB_OK) {
+            printf("IO area mmapped to 0x%x.\n", (u32) devinfo.iomap);
+        }
+    }
+
+    uc_munmap_vga_device(&devinfo);
+    return 0;
+}
+
+*/
diff --git a/DirectFB-1.3.0/gfxdrivers/cle266/uc_probe.h b/DirectFB-1.3.0/gfxdrivers/cle266/uc_probe.h
new file mode 100755
index 0000000..e2d01e4
--- /dev/null
+++ b/DirectFB-1.3.0/gfxdrivers/cle266/uc_probe.h
@@ -0,0 +1,34 @@
+/*
+   Copyright (c) 2003 Andreas Robinson, All rights reserved.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+*/
+
+#ifndef __UC_PROBE_H__
+#define __UC_PROBE_H__
+
+struct uc_vga_device 
+{
+    u32 busid;      /* bus<8>:dev<5>:sub<3> */
+    u32 devid;      /* mfr<16>:device<16> */
+    u32 irq;        /* IRQ number */
+
+    u32 fbmem;      /* Framebuffer base address */
+    u32 fbsize;     /* Framebuffer size in bytes */
+    void* fbmap;    /* Mmapped frambuffer address */
+
+    u32 iomem;      /* IO area base address */
+    u32 iosize;     /* IO area size in bytes */
+    void* iomap;    /* Mmapped IO area address */
+};
+
+int uc_parse_vga_device(char* s, struct uc_vga_device* devinfo);
+DFBResult uc_probe_vga_device(u16 vendor, u16 device, char* name,
+                        struct uc_vga_device* devinfo);
+DFBResult uc_mmap_vga_device(struct uc_vga_device* devinfo, char* name);
+void uc_munmap_vga_device(struct uc_vga_device* devinfo);
+
+#endif /* __UC_PROBE_H__ */
diff --git a/DirectFB-1.3.0/gfxdrivers/cx2450x/Makefile.am b/DirectFB-1.3.0/gfxdrivers/cx2450x/Makefile.am
new file mode 100644
index 0000000..2c563a1
--- /dev/null
+++ b/DirectFB-1.3.0/gfxdrivers/cx2450x/Makefile.am
@@ -0,0 +1,33 @@
+## Makefile.am for DirectFB/src/core/gfxcards/cx2450x
+
+INCLUDES = \
+	-I$(top_srcdir)/include	\
+	-I$(top_builddir)/lib	\
+	-I$(top_srcdir)/lib	\
+	-I$(top_srcdir)/src	\
+	-I$(top_srcdir)/systems
+
+cx2450x_LTLIBRARIES = libdirectfb_cx2450x.la
+
+if BUILD_STATIC
+cx2450x_DATA = $(cx2450x_LTLIBRARIES:.la=.o)
+endif
+
+cx2450xdir = $(MODULEDIR)/gfxdrivers
+
+libdirectfb_cx2450x_la_SOURCES =	\
+	cx2450x.c			\
+	cx2450x.h
+
+libdirectfb_cx2450x_la_LDFLAGS = 	\
+	-export-dynamic			\
+	-avoid-version			\
+	$(DFB_LDFLAGS)
+
+libdirectfb_cx2450x_la_LIBADD = 	\
+	$(top_builddir)/lib/direct/libdirect.la \
+	$(top_builddir)/src/libdirectfb.la
+
+
+include $(top_srcdir)/rules/libobject.make
+	
diff --git a/DirectFB-1.3.0/gfxdrivers/cx2450x/cx2450x-accel.c b/DirectFB-1.3.0/gfxdrivers/cx2450x/cx2450x-accel.c
new file mode 100644
index 0000000..04f541d
--- /dev/null
+++ b/DirectFB-1.3.0/gfxdrivers/cx2450x/cx2450x-accel.c
@@ -0,0 +1,195 @@
+/*******************************************************************************/
+/* fuction block for accessing the GXA registers                               */
+/*******************************************************************************/
+
+static u32 _read_gxa(volatile u8 *base_addr, u32 offset)
+{
+    return *(volatile u32 *)(base_addr + offset);
+}
+
+/*******************************************************************************/
+
+static void _write_gxa(volatile u8 *base_addr, u32 offset, u32 value)
+{
+//    if (offset & 0x0003F800)            /* it's not a register access, so check the queue */
+    while( (*(volatile u32 *)(base_addr + GXA_DEPTH_REG)) & 0x40000000);
+
+    *(volatile u32 *)(base_addr + offset) = value;
+}
+
+/*******************************************************************************/
+/* all the accelleration functions                                             */
+/*******************************************************************************/
+
+bool _cx2450x_draw_line(void *driver_data, void *device_data, DFBRegion *line)
+{
+    CX2450XDriverData *drv = (CX2450XDriverData *)driver_data;
+    CX2450XDeviceData *dev = (CX2450XDeviceData *)device_data;
+
+    u32 cmd = GXA_CMD_NOT_TEXT | GXA_SRC_BMP_SEL(2) | GXA_DST_BMP_SEL(2) | dev->d_cmd_opts;
+
+    _write_gxa(drv->gxa_base, GXA_LINE_CONTROL_REG, 0x00000000);
+    _write_gxa(drv->gxa_base, cmd | GXA_PARAM_COUNT(2), GXA_POINT(line->x1, line->y1));
+    _write_gxa(drv->gxa_base, cmd | GXA_PARAM_COUNT(1), GXA_POINT(line->x2, line->y2));
+
+//    _write_gxa(drv->gxa_base, GXA_CMD_QMARK | (1 << 8), 0);
+
+    return true;
+}
+
+/*******************************************************************************/
+
+static bool _cx2450x_draw_rectangle(void *driver_data, void *device_data, DFBRectangle *rect)
+{
+    /* the accelerator can handle multi lines. This means, with the first command, we setup
+       the start and endpoint for the first line to draw. The GXA will automatically setup
+       end point as the start point of the new line. So we only need to setup the new end point. */
+
+    CX2450XDriverData *drv = (CX2450XDriverData *)driver_data;
+    CX2450XDeviceData *dev = (CX2450XDeviceData *)device_data;
+
+    u32 cmd = GXA_CMD_NOT_TEXT | GXA_SRC_BMP_SEL(2) | GXA_DST_BMP_SEL(2) | dev->d_cmd_opts;
+
+    /* first line (upper left to upper right) */
+    _write_gxa(drv->gxa_base, GXA_LINE_CONTROL_REG, 0x00000404);        /* X is major, skip last pixel */
+    _write_gxa(drv->gxa_base, cmd | GXA_PARAM_COUNT(2), GXA_POINT(rect->x + rect->w, rect->y));         /* endig point */
+    _write_gxa(drv->gxa_base, cmd | GXA_PARAM_COUNT(2), GXA_POINT(rect->x, rect->y));                   /* start point */
+
+    /* second line (upper right to lower right) */
+    _write_gxa(drv->gxa_base, GXA_LINE_CONTROL_REG, 0x00000004);        /* Y is major, skip last pixel */
+    _write_gxa(drv->gxa_base, cmd | GXA_PARAM_COUNT(1), GXA_POINT(rect->x + rect->w, rect->y + rect->h));
+
+    /* third line (lower right to lower left) */
+    _write_gxa(drv->gxa_base, GXA_LINE_CONTROL_REG, 0x00000404);        /* X is major, skip last pixel */
+    _write_gxa(drv->gxa_base, cmd | GXA_PARAM_COUNT(1), GXA_POINT(rect->x, rect->y + rect->h));
+
+    /* 4. line (lower left to uper left) */
+    _write_gxa(drv->gxa_base, GXA_LINE_CONTROL_REG, 0x00000004);        /* Y is major, skip last pixel */
+    _write_gxa(drv->gxa_base, cmd | GXA_PARAM_COUNT(1), GXA_POINT(rect->x, rect->y));
+
+//    _write_gxa(drv->gxa_base, GXA_CMD_QMARK | (1 << 8), 0);
+
+    return true;
+}
+
+/*******************************************************************************/
+
+static bool _cx2450x_fill_rectangle(void *driver_data, void *device_data, DFBRectangle *rect)
+{
+    CX2450XDriverData *drv = (CX2450XDriverData *)driver_data;
+    CX2450XDeviceData *dev = (CX2450XDeviceData *)device_data;
+
+    u32 cmd = GXA_CMD_NOT_TEXT | GXA_SRC_BMP_SEL(2) | GXA_DST_BMP_SEL(2) | GXA_PARAM_COUNT(2) | dev->d_cmd_opts;
+    u32 line = 0;
+
+    _write_gxa(drv->gxa_base, GXA_LINE_CONTROL_REG, 0x00000404);        /* X is major, skip last pixel */
+
+    while (line < rect->h)
+    {
+        _write_gxa(drv->gxa_base, cmd, GXA_POINT(rect->x + rect->w, rect->y + line));      /* endig point */
+        _write_gxa(drv->gxa_base, cmd, GXA_POINT(rect->x, rect->y + line));                /* start point */
+//        if (line % 32)
+//            _write_gxa(drv->gxa_base, GXA_CMD_QMARK | (1 << 8), 0);
+        line++;
+    }
+//    _write_gxa(drv->gxa_base, GXA_CMD_QMARK | (1 << 8), 0);
+
+//usleep(100000);
+
+    return true;
+}
+
+/*******************************************************************************/
+
+static bool _cx2450x_fill_triangle(void *driver_data, void *device_data, DFBTriangle *tri)
+{
+    /* unsupported */
+    return true;
+}
+
+/*******************************************************************************/
+
+static bool _cx2450x_blit(void *driver_data, void *device_data, DFBRectangle *rect, int dx, int dy)
+{
+    CX2450XDriverData *drv = (CX2450XDriverData *)driver_data;
+    CX2450XDeviceData *dev = (CX2450XDeviceData *)device_data;
+    u32 cmd = GXA_CMD_BLT | GXA_CMD_NOT_TEXT | GXA_SRC_BMP_SEL(1) | GXA_DST_BMP_SEL(2) | GXA_PARAM_COUNT(3) | dev->b_cmd_opts;
+
+    if (dev->b_soft)
+	return false;
+
+    _write_gxa(drv->gxa_base, cmd, GXA_POINT(dx, dy));             /* destination x/y */
+    _write_gxa(drv->gxa_base, cmd, GXA_POINT(rect->w, rect->h));   /* source width/hight */
+    _write_gxa(drv->gxa_base, cmd, GXA_POINT(rect->x, rect->y));   /* source x/y */
+
+//    _write_gxa(drv->gxa_base, GXA_CMD_QMARK | (1 << 8), 0);
+
+//usleep(50000);
+
+    return true;
+}
+
+/*******************************************************************************/
+
+static bool _cx2450x_stretchblit(void *driver_data, void *device_data, DFBRectangle *srect, DFBRectangle *drect)
+{
+    CX2450XDriverData *drv = (CX2450XDriverData *)driver_data;
+    CX2450XDeviceData *dev = (CX2450XDeviceData *)device_data;
+    u32 cmd = GXA_CMD_STRETCH_BLT | GXA_CMD_BLT | GXA_CMD_NOT_TEXT | GXA_SRC_BMP_SEL(1) | GXA_DST_BMP_SEL(2) | GXA_PARAM_COUNT(7) | dev->b_cmd_opts;
+    u32 ys = 1, xs = 1, sp = 1;
+    u32 hco, vco;
+
+    if ((dev->b_flags & DSBLIT_SRC_COLORKEY) || (dev->b_soft))	/* we can not stretch blit with color keying (source transparency) */
+	return false;
+
+    if (dev->b_cmd_opts & GXA_CMD_NOT_ALPHA)
+    {
+        cmd |= GXA_CMD_ROP;
+	u32 cfgreg = _read_gxa(drv->gxa_base, GXA_CFG_REG);
+	cfgreg &= 0xFFFFCFE0;
+	_write_gxa(drv->gxa_base, GXA_CFG_REG, cfgreg);
+    }
+
+    /* prevent divide by 0 */
+    if (drect->h)
+        ys = ((srect->h << 16) / drect->h) & 0x00FFFFFF;
+    if (drect->w)
+        xs = ((srect->w << 16) / drect->w) & 0x00FFFFFF;
+    if (srect->w)
+        sp = (((drect->w << 20) / srect->w) * 3) & 0x0FFFFFFF;
+
+    if (srect->w <= drect->w)
+	hco = 0;
+    else if (srect->w <= (drect->w << 1))
+	hco = 0x0100;
+    else if (srect->w <= (drect->w << 2))
+	hco = 0x0200;
+    else
+	hco = 0x0300;
+
+    if (srect->h <= drect->h)
+	vco = 0;
+    else if (srect->h <= (drect->h << 1))
+	vco = 0x0100;
+    else if (srect->h <= (drect->h << 2))
+	vco = 0x0200;
+    else
+	vco = 0x0300;
+
+    _write_gxa(drv->gxa_base, GXA_CMD_HFILTER | GXA_SRC_BMP_SEL(1) | GXA_DST_BMP_SEL(2) | GXA_PARAM_COUNT(1), (u32)(drv->coeff_table + hco));
+    _write_gxa(drv->gxa_base, GXA_CMD_VFILTER | GXA_SRC_BMP_SEL(1) | GXA_DST_BMP_SEL(2) | GXA_PARAM_COUNT(1), (u32)(drv->coeff_table + vco));
+
+    _write_gxa(drv->gxa_base, cmd, GXA_POINT(drect->x, drect->y)); /* destination x/y */
+    _write_gxa(drv->gxa_base, cmd, GXA_POINT(drect->w, drect->h)); /* destination width/hight */
+    _write_gxa(drv->gxa_base, cmd, GXA_POINT(srect->x, srect->y)); /* source x/y */
+    _write_gxa(drv->gxa_base, cmd, GXA_POINT(srect->w, srect->h)); /* source width/hight */
+    _write_gxa(drv->gxa_base, cmd, ys);                            /* Y sclae factor */
+    _write_gxa(drv->gxa_base, cmd, xs);                            /* X sclae factor */
+    _write_gxa(drv->gxa_base, cmd, sp);                            /* destination X patch */
+
+//    _write_gxa(drv->gxa_base, GXA_CMD_QMARK | (1 << 8), 0);
+
+    return true;
+}
+
+/*******************************************************************************/
diff --git a/DirectFB-1.3.0/gfxdrivers/cx2450x/cx2450x-state.c b/DirectFB-1.3.0/gfxdrivers/cx2450x/cx2450x-state.c
new file mode 100644
index 0000000..aa4b99f
--- /dev/null
+++ b/DirectFB-1.3.0/gfxdrivers/cx2450x/cx2450x-state.c
@@ -0,0 +1,360 @@
+
+static u32 _make_cx2450x_bmp_reg(DFBSurfacePixelFormat dfbcolorformat, u32 pitch)
+{
+    u32 reg = 0;
+
+    switch (DFB_BITS_PER_PIXEL(dfbcolorformat))
+    {
+        case 32:                                /* 32 bpp */
+            reg = (3 << 16) | (pitch / 4);
+            break;
+        case 16:                                /* 16 bpp */
+            reg = (2 << 16) | (pitch / 2);
+            break;
+        case 8:                                 /* 8 bpp */
+            reg = (1 << 16) |  pitch;
+            break;
+        default:
+            D_INFO("%s() unhandled %d bpp format\n", __FUNCTION__, DFB_BITS_PER_PIXEL(dfbcolorformat));
+            reg = (1 << 16) |  pitch;
+            break;
+    }
+
+    switch (dfbcolorformat)
+    {
+	case DSPF_RGB16:        /* 16 bit   RGB (2 byte, red 5@11, green 6@5, blue 5@0) */
+	    reg |= 0x08 << 16;
+	    break;
+	case DSPF_ARGB1555:     /* 16 bit  ARGB (2 byte, alpha 1@15, red 5@10, green 5@5, blue 5@0) */
+	    reg |= 0x10 << 16;
+	    break;
+        case DSPF_AYUV:         /* 32 bit  AYUV (4 byte, alpha 8@24, Y 8@16, Cb 8@8, Cr 8@0) */
+	    reg |= 0x04 << 16;
+	    reg |= 3 << 21;	/* Y and C in range from 0 to 255 */
+	    break;
+	default:
+            break;
+    }
+																																		
+    return reg;
+}
+
+/*******************************************************************************/
+
+static u32 _make_cx3450x_color(DFBColor color, DFBSurfacePixelFormat format)
+{
+    u32 cx_color = 0;
+
+    switch (format)
+    {
+	case DSPF_RGB32:	/* 32 bit RGB without alpha channel, but DFB in case of no alpha seems to set it to 0xFF */
+	case DSPF_ARGB:		/* 32 bit RGB including alpha channel */
+	    cx_color = (color.a << 24) | (color.r << 16) | (color.g << 8) | color.b;
+	    break;
+	default:
+            D_INFO("%s() unhandled color format %.8X\n", __FUNCTION__, format);
+	    break;
+    }
+
+    return cx_color;
+}
+
+/*******************************************************************************/
+
+static void _cx2450x_check_state(void *driver_data, void *device_data, CardState *state, DFBAccelerationMask accel)
+{
+    switch (state->destination->config.format)
+    {
+        /* supported color formats - the HW knows more, but they does not fit to DFB's formats (espeically YUV) */
+	case DSPF_RGB32:	/* 24 bit   RGB (4 byte, nothing@24, red 8@16, green 8@8, blue 8@0) */
+        case DSPF_ARGB:		/* 32 bit  ARGB (4 byte, alpha 8@24, red 8@16, green 8@8, blue 8@0) */
+//	case DSPF_RGB16:	/* 16 bit   RGB (2 byte, red 5@11, green 6@5, blue 5@0) */
+//	case DSPF_ARGB4444:	/* 16 bit  ARGB (2 byte, alpha 4@12, red 4@8, green 4@4, blue 4@0) */
+//	case DSPF_ARGB1555:	/* 16 bit  ARGB (2 byte, alpha 1@15, red 5@10, green 5@5, blue 5@0) */
+//        case DSPF_AYUV:		/* 32 bit  AYUV (4 byte, alpha 8@24, Y 8@16, Cb 8@8, Cr 8@0) */
+            break;
+        default:
+    	    /* all the DFB formats, which are not handled by the HW directly  */
+	    D_INFO("%s() unhandled destination format 0x%.8X\n", __FUNCTION__, state->destination->config.format);
+            return;
+    }
+
+    if (DFB_DRAWING_FUNCTION(accel))
+    {
+        if (state->drawingflags & ~CX2450X_SUPPORTED_DRAWING_FLAGS)
+	{
+	    D_INFO("%s() [DRAW] unhandled drawing flag(s) 0x%.8X [0x%.8X]\n", __FUNCTION__, state->drawingflags & ~CX2450X_SUPPORTED_DRAWING_FLAGS, CX2450X_SUPPORTED_DRAWING_FLAGS);
+            return;
+	}
+
+        state->accel |= CX2450X_SUPPORTED_DRAWING_FUNCTIONS;
+    }
+    else
+    {
+        if (state->blittingflags & ~CX2450X_SUPPORTED_BLITTING_FLAGS)
+	{
+	    D_INFO("%s() [BLIT] unhandled blitting flag(s) 0x%.8X [0x%.8X]\n", __FUNCTION__, state->blittingflags & ~CX2450X_SUPPORTED_BLITTING_FLAGS, CX2450X_SUPPORTED_BLITTING_FLAGS);
+            return;
+	}
+	
+	if ((state->blittingflags & DSBLIT_SRC_COLORKEY) && (accel == DFXL_STRETCHBLIT))
+	{
+	    D_INFO("%s() [BLIT] GXA does not support stretch blit with source colorkeying\n", __FUNCTION__);
+	    state->accel &= ~DSBLIT_SRC_COLORKEY;
+            return;
+	}
+
+        switch (state->source->config.format)
+        {
+	    case DSPF_A8:	/* Rendered text comes in this alpha only format */
+	    case DSPF_LUT8:	/* Rendered text with blend comes in LUT8 */
+	    case DSPF_RGB16:
+            case DSPF_RGB32:    /* modify alpha to a solid value (0xFF) */
+            case DSPF_ARGB:
+//	    case DSPF_ARGB4444:	/* 16 bit  ARGB (2 byte, alpha 4@12, red 4@8, green 4@4, blue 4@0) */
+//	    case DSPF_ARGB1555:	/* 16 bit  ARGB (2 byte, alpha 1@15, red 5@10, green 5@5, blue 5@0) */
+//            case DSPF_AYUV:
+                break;
+            default:
+		D_INFO("%s() [BLIT] unhandled source format 0x%.8X\n", __FUNCTION__, state->source->config.format);
+                return;
+        }
+
+        state->accel |= CX2450X_SUPPORTED_BLITTING_FUNCTIONS;
+    }
+}
+
+/*******************************************************************************/
+
+static void _cx2450x_set_state(void *driver_data, void *device_data, GraphicsDeviceFuncs *funcs, CardState *state, DFBAccelerationMask accel)
+{
+    CX2450XDriverData *drv = (CX2450XDriverData *)driver_data;
+    CX2450XDeviceData *dev = (CX2450XDeviceData *)device_data;
+
+//    if (state->mod_hw & 0xFFFFFCF4)
+//	D_INFO("%s() state->mod_hw: 0x%.8X\n", __FUNCTION__, state->mod_hw & 0xFFFFFCF4);
+
+    if (state->mod_hw & SMF_DESTINATION)            /* 0x00000100 */
+    {
+	/* setup the destination bitmap - as supposed by the datasheet, we use bitmap context #2 */
+//	D_INFO("%s() set destination to 0x%.8lX\n", __FUNCTION__, state->dst.offset);
+        _write_gxa(drv->gxa_base, GXA_BMP2_TYPE_REG, _make_cx2450x_bmp_reg(state->destination->config.format, state->dst.pitch));
+        _write_gxa(drv->gxa_base, GXA_BMP2_ADDR_REG, drv->smem_start + state->dst.offset);
+        _write_gxa(drv->gxa_base, GXA_CONTENT_ID_REG, 0);
+    }
+
+    switch (accel)
+    {
+	case DFXL_FILLRECTANGLE:				/* 0x00000001 */
+        case DFXL_DRAWRECTANGLE:				/* 0x00000002 */
+	case DFXL_DRAWLINE:					/* 0x00000004 */
+	case DFXL_FILLTRIANGLE:					/* 0x00000008 */
+
+    	    if (state->mod_hw & SMF_COLOR)			/* 0x00000008 */
+	    {
+		/* convert the given destination color and write it to the GXA as forground color */
+		_write_gxa(drv->gxa_base, GXA_FG_COLOR_REG, _make_cx3450x_color(state->color, state->destination->config.format));
+	    }
+	    if (state->mod_hw & SMF_DRAWING_FLAGS)              /* 0x00000001 */
+	    {
+		dev->d_cmd_opts |= GXA_CMD_NOT_ALPHA;
+
+            	if (state->drawingflags & DSDRAW_BLEND)
+		{
+//		    D_INFO("%s() DSDRAW_BLEND\n", __FUNCTION__);
+		    dev->d_cmd_opts &= ~GXA_CMD_NOT_ALPHA;
+		    _write_gxa(drv->gxa_base, GXA_BLEND_CFG_REG, (0x08 << 16) | (0x09 << 12) | (0x08 << 6) | (0x00 << 2));
+		}
+		    
+		if (state->drawingflags & DSDRAW_DST_COLORKEY)
+		    D_INFO("%s() unhandled DSDRAW_DST_COLORKEY\n", __FUNCTION__);
+		if (state->drawingflags & DSDRAW_SRC_PREMULTIPLY)
+		    D_INFO("%s() unhandled DSDRAW_SRC_PREMULTIPLY\n", __FUNCTION__);
+		if (state->drawingflags & DSDRAW_DST_PREMULTIPLY)
+		    D_INFO("%s() unhandled DSDRAW_DST_PREMULTIPLY\n", __FUNCTION__);
+		if (state->drawingflags & DSDRAW_DEMULTIPLY)
+		    D_INFO("%s() unhandled DSDRAW_DEMULTIPLY\n", __FUNCTION__);
+		if (state->drawingflags & DSDRAW_XOR)
+		    D_INFO("%s() unhandled DSDRAW_XOR\n", __FUNCTION__);
+	    }
+	    if (state->source->config.format != state->destination->config.format)
+	    {
+	    
+	    }
+	    break;
+	case DFXL_STRETCHBLIT:					/* 0x00020000 */
+	case DFXL_BLIT:						/* 0x00010000 */
+            if (state->mod_hw & SMF_SOURCE)                     /* 0x00000200 */
+	    {
+		/* use content bitmap #1 as source for blitting operations */
+//		D_INFO("%s() set source to 0x%.8lX (opts: 0x%.8X, pitch: %d)\n", __FUNCTION__, state->src.offset, _make_cx2450x_bmp_reg(state->source->config.format, state->src.pitch), state->src.pitch);
+		_write_gxa(drv->gxa_base, GXA_BMP1_TYPE_REG, _make_cx2450x_bmp_reg(state->source->config.format, state->src.pitch));
+		_write_gxa(drv->gxa_base, GXA_BMP1_ADDR_REG, drv->smem_start + state->src.offset);
+    		_write_gxa(drv->gxa_base, GXA_CONTENT_ID_REG, 0);
+
+		if (accel == DFXL_STRETCHBLIT)
+		    memcpy((u8*) drv->coeff_base, scale_coeff_table, 0x0400);
+            }
+
+	    if (state->mod_hw & SMF_BLITTING_FLAGS)             /* 0x00000002 */
+	    {
+		u32 cfgreg = _read_gxa(drv->gxa_base, GXA_CFG_REG);
+		cfgreg &= 0xFF000F00;
+		dev->b_cmd_opts = GXA_CMD_NOT_ALPHA;
+		dev->b_flags = state->blittingflags;
+		dev->b_soft = false;
+
+		if (state->blittingflags & DSBLIT_BLEND_ALPHACHANNEL)
+		{
+	    	    /* use source alpha for blend */
+		    D_INFO("%s() DSBLIT_BLEND_ALPHACHANNEL\n", __FUNCTION__);
+	    	    dev->b_cmd_opts &= ~GXA_CMD_NOT_ALPHA;
+		    _write_gxa(drv->gxa_base, GXA_BLEND_CFG_REG, (0x08 << 16) | (0x09 << 12) | (0x08 << 6) | (0x00 << 2));
+		}
+
+		if (state->blittingflags & DSBLIT_BLEND_COLORALPHA)
+		{
+		    u32 color = _make_cx3450x_color(state->color, state->destination->config.format);
+		    D_INFO("%s() unsupported DSBLIT_BLEND_COLORALPHA 0x%.8X\n", __FUNCTION__, color);
+		}
+
+		if (state->blittingflags & DSBLIT_COLORIZE)
+		{
+		    /* this currently only works on colorizing monochrome/greyscale sources */
+		    u32 color = _make_cx3450x_color(state->color, state->destination->config.format);
+		    D_INFO("%s() DSBLIT_SRC_COLORIZE %.8X\n", __FUNCTION__, color);
+
+		    switch (state->source->config.format)
+		    {
+			case DSPF_A8:
+			    break;
+			default:
+			    dev->b_soft = true;
+		    }
+
+	    	    dev->b_cmd_opts &= ~GXA_CMD_NOT_ALPHA;
+
+		    _write_gxa(drv->gxa_base, GXA_CONST_COLOR_REG, color);
+		    _write_gxa(drv->gxa_base, GXA_BLEND_CFG_REG, (0x09 << 16) | (0x08 << 12) | (1 << 10) | (0x01 << 6) | (0x00 << 2));
+
+		    /* enable source transparency */
+		    dev->b_cmd_opts |= GXA_CMD_SRC_TRANSP;
+		    cfgreg |= 0x00001000;
+
+		    /* setup the "chroma" keying registers */
+		    _write_gxa(drv->gxa_base, GXA_KEY_LOWER_REG, 0);
+		    _write_gxa(drv->gxa_base, GXA_KEY_UPPER_REG, 0);
+		}							    
+
+		if (state->blittingflags & DSBLIT_SRC_COLORKEY)
+		{
+		    D_INFO("%s() DSBLIT_SRC_COLORKEY %.8X\n", __FUNCTION__, state->src_colorkey);
+
+		    /* enable source transparency */
+		    dev->b_cmd_opts |= GXA_CMD_SRC_TRANSP;
+		    cfgreg |= 0x00001000;
+
+		    /* setup the "chroma" keying registers */
+		    _write_gxa(drv->gxa_base, GXA_KEY_LOWER_REG, state->src_colorkey);
+		    _write_gxa(drv->gxa_base, GXA_KEY_UPPER_REG, state->src_colorkey);
+		}
+
+		if (state->blittingflags & DSBLIT_DST_COLORKEY)
+		    D_INFO("%s() unhandled DSBLIT_DST_COLORKEY %.8X\n", __FUNCTION__, state->dst_colorkey);
+		if (state->blittingflags & DSBLIT_SRC_PREMULTIPLY)
+		    D_INFO("%s() unhandled DSBLIT_SRC_PREMULTIPLY", __FUNCTION__);
+	        if (state->blittingflags & DSBLIT_DST_PREMULTIPLY)
+		    D_INFO("%s() unhandled DSBLIT_DST_PREMULTIPLY", __FUNCTION__);
+		if (state->blittingflags & DSBLIT_DEMULTIPLY)
+		    D_INFO("%s() unhandled DSBLIT_DEMULTIPLY", __FUNCTION__);
+		if (state->blittingflags & DSBLIT_DEINTERLACE)
+		    D_INFO("%s() unhandled DSBLIT_DEINTERLACE", __FUNCTION__);
+		if (state->blittingflags & DSBLIT_SRC_PREMULTCOLOR)
+		    D_INFO("%s() unhandled DSBLIT_SRC_PREMULTCOLOR", __FUNCTION__);
+		if (state->blittingflags & DSBLIT_XOR)
+		    D_INFO("%s() unhandled DSBLIT_XOR", __FUNCTION__);
+		if (state->blittingflags & DSBLIT_INDEX_TRANSLATION)
+		    D_INFO("%s() unhandled DSBLIT_INDEX_TRANSLATION", __FUNCTION__);
+		if (state->blittingflags & DSBLIT_ROTATE180)
+		    D_INFO("%s() unhandled DSBLIT_ROTATE180", __FUNCTION__);
+		if (state->blittingflags & DSBLIT_COLORKEY_PROTECT)
+		    D_INFO("%s() unhandled DSBLIT_COLORKEY_PROTECT", __FUNCTION__);
+		if (state->blittingflags & DSBLIT_SRC_MASK_ALPHA)
+		    D_INFO("%s() unhandled DSBLIT_SRC_MASK_ALPHA", __FUNCTION__);
+		if (state->blittingflags & DSBLIT_SRC_MASK_COLOR)
+		    D_INFO("%s() unhandled DSBLIT_SRC_MASK_COLOR", __FUNCTION__);
+
+		_write_gxa(drv->gxa_base, GXA_CFG_REG, cfgreg);
+	    }
+
+    	    if (state->mod_hw & SMF_COLOR)			/* 0x00000008 */
+	    {
+		/* for colorize DFB partly setups the hw only once and updates the color value itself */
+
+		if (state->blittingflags & DSBLIT_COLORIZE)
+		{
+		    u32 color = _make_cx3450x_color(state->color, state->destination->config.format);
+		    _write_gxa(drv->gxa_base, GXA_CONST_COLOR_REG, color);
+
+//		    _write_gxa(drv->gxa_base, GXA_KEY_LOWER_REG, color);
+//		    _write_gxa(drv->gxa_base, GXA_KEY_UPPER_REG, color);
+		}
+
+		if (state->blittingflags & DSBLIT_SRC_COLORKEY)
+		{
+		    _write_gxa(drv->gxa_base, GXA_KEY_LOWER_REG, state->src_colorkey);
+		    _write_gxa(drv->gxa_base, GXA_KEY_UPPER_REG, state->src_colorkey);
+		}
+
+		if (state->blittingflags & ~CX2450X_SUPPORTED_BLITTING_FLAGS)
+		    D_INFO("%s() unhandled color update for blitting flag(s) %.8X\n", __FUNCTION__, state->blittingflags);
+	    }
+
+	    if (state->source->config.format != state->destination->config.format)
+	    {
+		switch (state->source->config.format)
+		{
+		    case DSPF_A8:
+			memcpy((u8*) drv->A8_base, DSPF_A8_to_ARGB_table, 1024);
+			_write_gxa(drv->gxa_base, GXA_CMD_PALETTE | GXA_SRC_BMP_SEL(1) | GXA_PARAM_COUNT(1), drv->A8_table);
+			break;
+		    case DSPF_LUT8:
+		    {
+			/* we have to exchange the palette values (DFB's view: ARGB, GXA's view: BGRA) */
+			if (state->source->palette->num_entries)
+			{
+			    u32 pe = (state->source->palette->num_entries - 1) & 0xFF;
+			    u32 cnt = 0;
+			    u8 pal[256][4];
+			    for (cnt = 0; cnt <= pe; cnt++)
+			    {
+				pal[cnt][0] = state->source->palette->entries[cnt].b;
+				pal[cnt][1] = state->source->palette->entries[cnt].g;
+				pal[cnt][2] = state->source->palette->entries[cnt].r;
+				pal[cnt][3] = state->source->palette->entries[cnt].a;
+			    }
+
+			    memcpy((u8*) drv->var_base, pal, pe * 4);
+			    _write_gxa(drv->gxa_base, GXA_CMD_PALETTE | GXA_SRC_BMP_SEL(1) | GXA_PARAM_COUNT(1), drv->var_table);
+			}
+			break;
+		    }
+		    case DSPF_RGB16:
+			memcpy((u8*) drv->RGB16_base, DSPF_RGB16_to_ARGB_table, 256);
+			_write_gxa(drv->gxa_base, GXA_CMD_PALETTE | GXA_SRC_BMP_SEL(1) | GXA_PARAM_COUNT(1), drv->RGB16_table);
+			break;
+        	    case DSPF_RGB32:    /* nothing to do */
+        	    case DSPF_ARGB:
+			break;
+		    default:
+			D_INFO("%s() unhandled color space conversion (table missing)\n", __FUNCTION__);
+			break;
+		}
+	    }
+	    break;
+	default:
+	    D_INFO("%s() unhandled acceleration mask 0x%.8X\n", __FUNCTION__, accel);
+    }
+
+    state->mod_hw = 0;
+}
diff --git a/DirectFB-1.3.0/gfxdrivers/cx2450x/cx2450x-tables.h b/DirectFB-1.3.0/gfxdrivers/cx2450x/cx2450x-tables.h
new file mode 100644
index 0000000..613ae7c
--- /dev/null
+++ b/DirectFB-1.3.0/gfxdrivers/cx2450x/cx2450x-tables.h
@@ -0,0 +1,169 @@
+
+static u8 scale_coeff_table[0x0400] =
+{
+    /* 0x100 coefficients for upscaling or by pass */
+    0x00, 0x00, 0x7C, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x7F, 0x00, 0x02, 0x00, 0x00, 0x00,
+    0x00, 0xF0, 0x7B, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x7B, 0x00, 0x04, 0x00, 0x00, 0x00,
+    0x00, 0xE0, 0x77, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x73, 0x00, 0x06, 0x00, 0x00, 0x00,
+    0x00, 0xE0, 0x6F, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x6B, 0x00, 0xC9, 0x0F, 0x00, 0x00,
+    0x00, 0xE0, 0x67, 0x00, 0xCA, 0x0F, 0x00, 0x00, 0x00, 0xE0, 0x63, 0x00, 0xCB, 0x0F, 0x00, 0x00,
+    0x00, 0xE0, 0x5F, 0x00, 0xCC, 0x0F, 0x00, 0x00, 0x00, 0xE0, 0x5B, 0x00, 0xCD, 0x0F, 0x00, 0x00,
+    0x00, 0xE0, 0x57, 0x00, 0xCE, 0x0F, 0x00, 0x00, 0x00, 0xE0, 0x53, 0x00, 0xCF, 0x0F, 0x00, 0x00,
+    0x00, 0xE0, 0x4F, 0x00, 0xD0, 0x0F, 0x00, 0x00, 0x00, 0xE0, 0x4B, 0x00, 0xD1, 0x0F, 0x00, 0x00,
+    0x00, 0xF0, 0x47, 0x00, 0x92, 0x0F, 0x00, 0x00, 0x00, 0xF0, 0x43, 0x00, 0x93, 0x0F, 0x00, 0x00,
+    0x00, 0xF0, 0x3F, 0x00, 0x94, 0x0F, 0x00, 0x00, 0x00, 0xF0, 0x3B, 0x00, 0x95, 0x0F, 0x00, 0x00,
+    0x00, 0xF0, 0x37, 0x00, 0x96, 0x0F, 0x00, 0x00, 0x00, 0xF0, 0x33, 0x00, 0x97, 0x0F, 0x00, 0x00,
+    0x00, 0xF0, 0x2F, 0x00, 0x98, 0x0F, 0x00, 0x00, 0x00, 0xF0, 0x2B, 0x00, 0x99, 0x0F, 0x00, 0x00,
+    0x00, 0xF0, 0x27, 0x00, 0x9A, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x9B, 0x0F, 0x00, 0x00,
+    0x00, 0x00, 0x18, 0x00, 0x9C, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x9D, 0x0F, 0x00, 0x00,
+    0x00, 0x00, 0x10, 0x00, 0x9E, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0xDE, 0x0F, 0x00, 0x00,
+    0x00, 0x00, 0x08, 0x00, 0xDF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x1F, 0x00, 0x00, 0x00,
+    /* 0x100 coefficients for small downscaling (scale: 0 < ratio <= 2) */
+    0x00, 0x60, 0x4C, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x60, 0x4C, 0x00, 0x07, 0x00, 0x00, 0x00, 
+    0x00, 0x50, 0x4C, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x50, 0x4C, 0x00, 0x08, 0x00, 0x00, 0x00, 
+    0x00, 0x50, 0x48, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x40, 0x48, 0x00, 0x0A, 0x00, 0x00, 0x00, 
+    0x00, 0x40, 0x48, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x40, 0x48, 0x00, 0x0A, 0x00, 0x00, 0x00, 
+    0x00, 0x30, 0x48, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x30, 0x48, 0x00, 0x0B, 0x00, 0x00, 0x00, 
+    0x00, 0x20, 0x44, 0x00, 0x4C, 0x00, 0x00, 0x00, 0x00, 0x20, 0x44, 0x00, 0x4C, 0x00, 0x00, 0x00, 
+    0x00, 0x20, 0x40, 0x00, 0x4D, 0x00, 0x00, 0x00, 0x00, 0x20, 0x40, 0x00, 0x4D, 0x00, 0x00, 0x00, 
+    0x00, 0x20, 0x3C, 0x00, 0x4E, 0x00, 0x00, 0x00, 0x00, 0x20, 0x3C, 0x00, 0x4E, 0x00, 0x00, 0x00, 
+    0x00, 0x10, 0x38, 0x00, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x00, 0x8F, 0x00, 0x00, 0x00, 
+    0x00, 0x10, 0x34, 0x00, 0x90, 0x00, 0x00, 0x00, 0x00, 0x10, 0x34, 0x00, 0x90, 0x00, 0x00, 0x00, 
+    0x00, 0x10, 0x30, 0x00, 0x91, 0x00, 0x00, 0x00, 0x00, 0x10, 0x30, 0x00, 0x91, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x2C, 0x00, 0xD2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2C, 0x00, 0xD2, 0x00, 0x00, 0x00, 
+    0x00, 0x00, 0x28, 0x00, 0x12, 0x01, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x12, 0x01, 0x00, 0x00, 
+    0x00, 0x00, 0x28, 0x00, 0x12, 0x01, 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x52, 0x01, 0x00, 0x00, 
+    0x00, 0x00, 0x20, 0x00, 0x53, 0x01, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x53, 0x01, 0x00, 0x00, 
+    0x00, 0x00, 0x1C, 0x00, 0x93, 0x01, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x93, 0x01, 0x00, 0x00,
+    /* 0x100 coefficients for large downscaling (scale: 2 < ratio <= 4) */
+    0x40, 0x70, 0x40, 0x00, 0x47, 0x00, 0x00, 0x00, 0x40, 0x70, 0x40, 0x00, 0x47, 0x00, 0x00, 0x00,
+    0x40, 0x70, 0x3C, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x70, 0x3C, 0x00, 0x49, 0x00, 0x00, 0x00,
+    0x00, 0x70, 0x3C, 0x00, 0x49, 0x00, 0x00, 0x00, 0x00, 0x70, 0x3C, 0x00, 0x49, 0x00, 0x00, 0x00,
+    0x00, 0x60, 0x3C, 0x00, 0x4A, 0x00, 0x00, 0x00, 0x00, 0x60, 0x3C, 0x00, 0x4A, 0x00, 0x00, 0x00,
+    0x00, 0x50, 0x3C, 0x00, 0x8A, 0x00, 0x00, 0x00, 0x00, 0x40, 0x3C, 0x00, 0x8B, 0x00, 0x00, 0x00,
+    0x00, 0x40, 0x3C, 0x00, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x40, 0x38, 0x00, 0x8C, 0x00, 0x00, 0x00,
+    0x00, 0x40, 0x38, 0x00, 0x8C, 0x00, 0x00, 0x00, 0x00, 0x30, 0x38, 0x00, 0x8D, 0x00, 0x00, 0x00,
+    0x00, 0x30, 0x34, 0x00, 0xCD, 0x00, 0x00, 0x00, 0x00, 0x30, 0x34, 0x00, 0xCD, 0x00, 0x00, 0x00,
+    0x00, 0x30, 0x34, 0x00, 0xCD, 0x00, 0x00, 0x00, 0x00, 0x30, 0x34, 0x00, 0xCD, 0x00, 0x00, 0x00,
+    0x00, 0x20, 0x34, 0x00, 0xCE, 0x00, 0x00, 0x00, 0x00, 0x20, 0x30, 0x00, 0x0E, 0x01, 0x00, 0x00,
+    0x00, 0x20, 0x30, 0x00, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x20, 0x2C, 0x00, 0x0F, 0x01, 0x00, 0x00,
+    0x00, 0x20, 0x2C, 0x00, 0x0F, 0x01, 0x00, 0x00, 0x00, 0x20, 0x28, 0x00, 0x4F, 0x01, 0x00, 0x00,
+    0x00, 0x10, 0x28, 0x00, 0x8F, 0x01, 0x00, 0x00, 0x00, 0x10, 0x28, 0x00, 0x8F, 0x01, 0x00, 0x00,
+    0x00, 0x10, 0x24, 0x00, 0xCF, 0x01, 0x00, 0x00, 0x00, 0x10, 0x24, 0x00, 0xCF, 0x01, 0x00, 0x00,
+    0x00, 0x10, 0x24, 0x00, 0xCF, 0x01, 0x00, 0x00, 0x00, 0x10, 0x20, 0x00, 0xCF, 0x11, 0x00, 0x00,
+    0x00, 0x10, 0x1C, 0x00, 0xD0, 0x11, 0x00, 0x00, 0x00, 0x10, 0x1C, 0x00, 0xD0, 0x11, 0x00, 0x00,
+    /* 0x100 coefficients xlarge downscaling (scale: 4 < ratio <= 8) */
+    0x40, 0x80, 0x38, 0x00, 0x48, 0x00, 0x00, 0x00, 0x40, 0x80, 0x38, 0x00, 0x48, 0x00, 0x00, 0x00,
+    0x40, 0x70, 0x38, 0x00, 0x49, 0x00, 0x00, 0x00, 0x40, 0x70, 0x38, 0x00, 0x49, 0x00, 0x00, 0x00,
+    0x40, 0x60, 0x38, 0x00, 0x89, 0x00, 0x00, 0x00, 0x40, 0x60, 0x38, 0x00, 0x89, 0x00, 0x00, 0x00,
+    0x40, 0x60, 0x38, 0x00, 0x89, 0x00, 0x00, 0x00, 0x00, 0x60, 0x38, 0x00, 0x8A, 0x00, 0x00, 0x00,
+    0x00, 0x50, 0x38, 0x00, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x50, 0x38, 0x00, 0x8B, 0x00, 0x00, 0x00,
+    0x00, 0x50, 0x38, 0x00, 0x8B, 0x00, 0x00, 0x00, 0x00, 0x50, 0x34, 0x00, 0xCB, 0x00, 0x00, 0x00,
+    0x00, 0x50, 0x34, 0x00, 0xCB, 0x00, 0x00, 0x00, 0x00, 0x40, 0x34, 0x00, 0xCC, 0x00, 0x00, 0x00,
+    0x00, 0x40, 0x34, 0x00, 0xCC, 0x00, 0x00, 0x00, 0x00, 0x40, 0x34, 0x00, 0xCC, 0x00, 0x00, 0x00,
+    0x00, 0x30, 0x30, 0x00, 0x0D, 0x01, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x0D, 0x01, 0x00, 0x00,
+    0x00, 0x30, 0x30, 0x00, 0x0D, 0x01, 0x00, 0x00, 0x00, 0x30, 0x2C, 0x00, 0x4D, 0x01, 0x00, 0x00,
+    0x00, 0x30, 0x2C, 0x00, 0x4D, 0x01, 0x00, 0x00, 0x00, 0x20, 0x2C, 0x00, 0x4E, 0x01, 0x00, 0x00,
+    0x00, 0x20, 0x2C, 0x00, 0x4E, 0x01, 0x00, 0x00, 0x00, 0x20, 0x2C, 0x00, 0x4E, 0x01, 0x00, 0x00,
+    0x00, 0x20, 0x28, 0x00, 0x8E, 0x01, 0x00, 0x00, 0x00, 0x20, 0x24, 0x00, 0x8E, 0x11, 0x00, 0x00,
+    0x00, 0x20, 0x24, 0x00, 0x8E, 0x11, 0x00, 0x00, 0x00, 0x20, 0x24, 0x00, 0x8E, 0x11, 0x00, 0x00,
+    0x00, 0x10, 0x24, 0x00, 0xCE, 0x11, 0x00, 0x00, 0x00, 0x10, 0x24, 0x00, 0xCE, 0x11, 0x00, 0x00,
+    0x00, 0x10, 0x20, 0x00, 0x0E, 0x12, 0x00, 0x00, 0x00, 0x10, 0x20, 0x00, 0x0E, 0x12, 0x00, 0x00
+};
+
+/*******************************************************************************/
+/* various palettes for color format conversion. Note laette colors are BGRA   */
+
+/* a color lookup table to let the GXA convert DFB's DSPF_A8 "alphagrey" into greyscale ARGB */
+static u8 DSPF_A8_to_ARGB_table[256][4] =
+{
+    {0x00, 0x00, 0x00, 0x00}, {0x01, 0x01, 0x01, 0x01}, {0x02, 0x02, 0x02, 0x02}, {0x03, 0x03, 0x03, 0x03}, 
+    {0x04, 0x04, 0x04, 0x04}, {0x05, 0x05, 0x05, 0x05}, {0x06, 0x06, 0x06, 0x06}, {0x07, 0x07, 0x07, 0x07},
+    {0x08, 0x08, 0x08, 0x08}, {0x09, 0x09, 0x09, 0x09}, {0x0A, 0x0A, 0x0A, 0x0A}, {0x0B, 0x0B, 0x0B, 0x0B}, 
+    {0x0C, 0x0C, 0x0C, 0x0C}, {0x0D, 0x0D, 0x0D, 0x0D}, {0x0E, 0x0E, 0x0E, 0x0E}, {0x0F, 0x0F, 0x0F, 0x0F},
+    {0x10, 0x10, 0x10, 0x10}, {0x11, 0x11, 0x11, 0x11}, {0x12, 0x12, 0x12, 0x12}, {0x13, 0x13, 0x13, 0x13}, 
+    {0x14, 0x14, 0x14, 0x14}, {0x15, 0x15, 0x15, 0x15}, {0x16, 0x16, 0x16, 0x16}, {0x17, 0x17, 0x17, 0x17},
+    {0x18, 0x18, 0x18, 0x18}, {0x19, 0x19, 0x19, 0x19}, {0x1A, 0x1A, 0x1A, 0x1A}, {0x1B, 0x1B, 0x1B, 0x1B}, 
+    {0x1C, 0x1C, 0x1C, 0x1C}, {0x1D, 0x1D, 0x1D, 0x1D}, {0x1E, 0x1E, 0x1E, 0x1E}, {0x1F, 0x1F, 0x1F, 0x1F},
+    {0x20, 0x20, 0x20, 0x20}, {0x21, 0x21, 0x21, 0x21}, {0x22, 0x22, 0x22, 0x22}, {0x23, 0x23, 0x23, 0x23}, 
+    {0x24, 0x24, 0x24, 0x24}, {0x25, 0x25, 0x25, 0x25}, {0x26, 0x26, 0x26, 0x26}, {0x27, 0x27, 0x27, 0x27},
+    {0x28, 0x28, 0x28, 0x28}, {0x29, 0x29, 0x29, 0x29}, {0x2A, 0x2A, 0x2A, 0x2A}, {0x2B, 0x2B, 0x2B, 0x2B}, 
+    {0x2C, 0x2C, 0x2C, 0x2C}, {0x2D, 0x2D, 0x2D, 0x2D}, {0x2E, 0x2E, 0x2E, 0x2E}, {0x2F, 0x2F, 0x2F, 0x2F},
+    {0x30, 0x30, 0x30, 0x30}, {0x31, 0x31, 0x31, 0x31}, {0x32, 0x32, 0x32, 0x32}, {0x33, 0x33, 0x33, 0x33}, 
+    {0x34, 0x34, 0x34, 0x34}, {0x35, 0x35, 0x35, 0x35}, {0x36, 0x36, 0x36, 0x36}, {0x37, 0x37, 0x37, 0x37},
+    {0x38, 0x38, 0x38, 0x38}, {0x39, 0x39, 0x39, 0x39}, {0x3A, 0x3A, 0x3A, 0x3A}, {0x3B, 0x3B, 0x3B, 0x3B}, 
+    {0x3C, 0x3C, 0x3C, 0x3C}, {0x3D, 0x3D, 0x3D, 0x3D}, {0x3E, 0x3E, 0x3E, 0x3E}, {0x3F, 0x3F, 0x3F, 0x3F},
+    {0x40, 0x40, 0x40, 0x40}, {0x41, 0x41, 0x41, 0x41}, {0x42, 0x42, 0x42, 0x42}, {0x43, 0x43, 0x43, 0x43}, 
+    {0x44, 0x44, 0x44, 0x44}, {0x45, 0x45, 0x45, 0x45}, {0x46, 0x46, 0x46, 0x46}, {0x47, 0x47, 0x47, 0x47},
+    {0x48, 0x48, 0x48, 0x48}, {0x49, 0x49, 0x49, 0x49}, {0x4A, 0x4A, 0x4A, 0x4A}, {0x4B, 0x4B, 0x4B, 0x4B}, 
+    {0x4C, 0x4C, 0x4C, 0x4C}, {0x4D, 0x4D, 0x4D, 0x4D}, {0x4E, 0x4E, 0x4E, 0x4E}, {0x4F, 0x4F, 0x4F, 0x4F},
+    {0x50, 0x50, 0x50, 0x50}, {0x51, 0x51, 0x51, 0x51}, {0x52, 0x52, 0x52, 0x52}, {0x53, 0x53, 0x53, 0x53}, 
+    {0x54, 0x54, 0x54, 0x54}, {0x55, 0x55, 0x55, 0x55}, {0x56, 0x56, 0x56, 0x56}, {0x57, 0x57, 0x57, 0x57},
+    {0x58, 0x58, 0x58, 0x58}, {0x59, 0x59, 0x59, 0x59}, {0x5A, 0x5A, 0x5A, 0x5A}, {0x5B, 0x5B, 0x5B, 0x5B}, 
+    {0x5C, 0x5C, 0x5C, 0x5C}, {0x5D, 0x5D, 0x5D, 0x5D}, {0x5E, 0x5E, 0x5E, 0x5E}, {0x5F, 0x5F, 0x5F, 0x5F},
+    {0x60, 0x60, 0x60, 0x60}, {0x61, 0x61, 0x61, 0x61}, {0x62, 0x62, 0x62, 0x62}, {0x63, 0x63, 0x63, 0x63}, 
+    {0x64, 0x64, 0x64, 0x64}, {0x65, 0x65, 0x65, 0x65}, {0x66, 0x66, 0x66, 0x66}, {0x67, 0x67, 0x67, 0x67},
+    {0x68, 0x68, 0x68, 0x68}, {0x69, 0x69, 0x69, 0x69}, {0x6A, 0x6A, 0x6A, 0x6A}, {0x6B, 0x6B, 0x6B, 0x6B}, 
+    {0x6C, 0x6C, 0x6C, 0x6C}, {0x6D, 0x6D, 0x6D, 0x6D}, {0x6E, 0x6E, 0x6E, 0x6E}, {0x6F, 0x6F, 0x6F, 0x6F},
+    {0x70, 0x70, 0x70, 0x70}, {0x71, 0x71, 0x71, 0x71}, {0x72, 0x72, 0x72, 0x72}, {0x73, 0x73, 0x73, 0x73}, 
+    {0x74, 0x74, 0x74, 0x74}, {0x75, 0x75, 0x75, 0x75}, {0x76, 0x76, 0x76, 0x76}, {0x77, 0x77, 0x77, 0x77},
+    {0x78, 0x78, 0x78, 0x78}, {0x79, 0x79, 0x79, 0x79}, {0x7A, 0x7A, 0x7A, 0x7A}, {0x7B, 0x7B, 0x7B, 0x7B}, 
+    {0x7C, 0x7C, 0x7C, 0x7C}, {0x7D, 0x7D, 0x7D, 0x7D}, {0x7E, 0x7E, 0x7E, 0x7E}, {0x7F, 0x7F, 0x7F, 0x7F},
+    {0x80, 0x80, 0x80, 0x80}, {0x81, 0x81, 0x81, 0x81}, {0x82, 0x82, 0x82, 0x82}, {0x83, 0x83, 0x83, 0x83}, 
+    {0x84, 0x84, 0x84, 0x84}, {0x85, 0x85, 0x85, 0x85}, {0x86, 0x86, 0x86, 0x86}, {0x87, 0x87, 0x87, 0x87},
+    {0x88, 0x88, 0x88, 0x88}, {0x89, 0x89, 0x89, 0x89}, {0x8A, 0x8A, 0x8A, 0x8A}, {0x8B, 0x8B, 0x8B, 0x8B}, 
+    {0x8C, 0x8C, 0x8C, 0x8C}, {0x8D, 0x8D, 0x8D, 0x8D}, {0x8E, 0x8E, 0x8E, 0x8E}, {0x8F, 0x8F, 0x8F, 0x8F},
+    {0x90, 0x90, 0x90, 0x90}, {0x91, 0x91, 0x91, 0x91}, {0x92, 0x92, 0x92, 0x92}, {0x93, 0x93, 0x93, 0x93}, 
+    {0x94, 0x94, 0x94, 0x94}, {0x95, 0x95, 0x95, 0x95}, {0x96, 0x96, 0x96, 0x96}, {0x97, 0x97, 0x97, 0x97},
+    {0x98, 0x98, 0x98, 0x98}, {0x99, 0x99, 0x99, 0x99}, {0x9A, 0x9A, 0x9A, 0x9A}, {0x9B, 0x9B, 0x9B, 0x9B}, 
+    {0x9C, 0x9C, 0x9C, 0x9C}, {0x9D, 0x9D, 0x9D, 0x9D}, {0x9E, 0x9E, 0x9E, 0x9E}, {0x9F, 0x9F, 0x9F, 0x9F},
+    {0xA0, 0xA0, 0xA0, 0xA0}, {0xA1, 0xA1, 0xA1, 0xA1}, {0xA2, 0xA2, 0xA2, 0xA2}, {0xA3, 0xA3, 0xA3, 0xA3}, 
+    {0xA4, 0xA4, 0xA4, 0xA4}, {0xA5, 0xA5, 0xA5, 0xA5}, {0xA6, 0xA6, 0xA6, 0xA6}, {0xA7, 0xA7, 0xA7, 0xA7},
+    {0xA8, 0xA8, 0xA8, 0xA8}, {0xA9, 0xA9, 0xA9, 0xA9}, {0xAA, 0xAA, 0xAA, 0xAA}, {0xAB, 0xAB, 0xAB, 0xAB}, 
+    {0xAC, 0xAC, 0xAC, 0xAC}, {0xAD, 0xAD, 0xAD, 0xAD}, {0xAE, 0xAE, 0xAE, 0xAE}, {0xAF, 0xAF, 0xAF, 0xAF},
+    {0xB0, 0xB0, 0xB0, 0xB0}, {0xB1, 0xB1, 0xB1, 0xB1}, {0xB2, 0xB2, 0xB2, 0xB2}, {0xB3, 0xB3, 0xB3, 0xB3}, 
+    {0xB4, 0xB4, 0xB4, 0xB4}, {0xB5, 0xB5, 0xB5, 0xB5}, {0xB6, 0xB6, 0xB6, 0xB6}, {0xB7, 0xB7, 0xB7, 0xB7},
+    {0xB8, 0xB8, 0xB8, 0xB8}, {0xB9, 0xB9, 0xB9, 0xB9}, {0xBA, 0xBA, 0xBA, 0xBA}, {0xBB, 0xBB, 0xBB, 0xBB}, 
+    {0xBC, 0xBC, 0xBC, 0xBC}, {0xBD, 0xBD, 0xBD, 0xBD}, {0xBE, 0xBE, 0xBE, 0xBE}, {0xBF, 0xBF, 0xBF, 0xBF},
+    {0xC0, 0xC0, 0xC0, 0xC0}, {0xC1, 0xC1, 0xC1, 0xC1}, {0xC2, 0xC2, 0xC2, 0xC2}, {0xC3, 0xC3, 0xC3, 0xC3}, 
+    {0xC4, 0xC4, 0xC4, 0xC4}, {0xC5, 0xC5, 0xC5, 0xC5}, {0xC6, 0xC6, 0xC6, 0xC6}, {0xC7, 0xC7, 0xC7, 0xC7},
+    {0xC8, 0xC8, 0xC8, 0xC8}, {0xC9, 0xC9, 0xC9, 0xC9}, {0xCA, 0xCA, 0xCA, 0xCA}, {0xCB, 0xCB, 0xCB, 0xCB}, 
+    {0xCC, 0xCC, 0xCC, 0xCC}, {0xCD, 0xCD, 0xCD, 0xCD}, {0xCE, 0xCE, 0xCE, 0xCE}, {0xCF, 0xCF, 0xCF, 0xCF},
+    {0xD0, 0xD0, 0xD0, 0xD0}, {0xD1, 0xD1, 0xD1, 0xD1}, {0xD2, 0xD2, 0xD2, 0xD2}, {0xD3, 0xD3, 0xD3, 0xD3}, 
+    {0xD4, 0xD4, 0xD4, 0xD4}, {0xD5, 0xD5, 0xD5, 0xD5}, {0xD6, 0xD6, 0xD6, 0xD6}, {0xD7, 0xD7, 0xD7, 0xD7},
+    {0xD8, 0xD8, 0xD8, 0xD8}, {0xD9, 0xD9, 0xD9, 0xD9}, {0xDA, 0xDA, 0xDA, 0xDA}, {0xDB, 0xDB, 0xDB, 0xDB}, 
+    {0xDC, 0xDC, 0xDC, 0xDC}, {0xDD, 0xDD, 0xDD, 0xDD}, {0xDE, 0xDE, 0xDE, 0xDE}, {0xDF, 0xDF, 0xDF, 0xDF},
+    {0xE0, 0xE0, 0xE0, 0xE0}, {0xE1, 0xE1, 0xE1, 0xE1}, {0xE2, 0xE2, 0xE2, 0xE2}, {0xE3, 0xE3, 0xE3, 0xE3}, 
+    {0xE4, 0xE4, 0xE4, 0xE4}, {0xE5, 0xE5, 0xE5, 0xE5}, {0xE6, 0xE6, 0xE6, 0xE6}, {0xE7, 0xE7, 0xE7, 0xE7},
+    {0xE8, 0xE8, 0xE8, 0xE8}, {0xE9, 0xE9, 0xE9, 0xE9}, {0xEA, 0xEA, 0xEA, 0xEA}, {0xEB, 0xEB, 0xEB, 0xEB}, 
+    {0xEC, 0xEC, 0xEC, 0xEC}, {0xED, 0xED, 0xED, 0xED}, {0xEE, 0xEE, 0xEE, 0xEE}, {0xEF, 0xEF, 0xEF, 0xEF},
+    {0xF0, 0xF0, 0xF0, 0xF0}, {0xF1, 0xF1, 0xF1, 0xF1}, {0xF2, 0xF2, 0xF2, 0xF2}, {0xF3, 0xF3, 0xF3, 0xF3}, 
+    {0xF4, 0xF4, 0xF4, 0xF4}, {0xF5, 0xF5, 0xF5, 0xF5}, {0xF6, 0xF6, 0xF6, 0xF6}, {0xF7, 0xF7, 0xF7, 0xF7},
+    {0xF8, 0xF8, 0xF8, 0xF8}, {0xF9, 0xF9, 0xF9, 0xF9}, {0xFA, 0xFA, 0xFA, 0xFA}, {0xFB, 0xFB, 0xFB, 0xFB}, 
+    {0xFC, 0xFC, 0xFC, 0xFC}, {0xFD, 0xFD, 0xFD, 0xFD}, {0xFE, 0xFE, 0xFE, 0xFE}, {0xFF, 0xFF, 0xFF, 0xFF}
+};
+
+/*******************************************************************************/
+
+/* a color lookup table to let the GXA convert DFB's DSPF_RGB16 (0/5/6/5 bits ARGB) into ARGB (8/8/8/8 bits ARGB) */
+static u8 DSPF_RGB16_to_ARGB_table[64][4] =
+{
+    {0x00, 0x00, 0x00, 0xFF}, {0x08, 0x04, 0x08, 0xFF}, {0x10, 0x08, 0x10, 0xFF}, {0x19, 0x0C, 0x19, 0xFF}, 
+    {0x21, 0x10, 0x21, 0xFF}, {0x29, 0x14, 0x29, 0xFF}, {0x31, 0x18, 0x31, 0xFF}, {0x3A, 0x1C, 0x3A, 0xFF}, 
+    {0x42, 0x20, 0x42, 0xFF}, {0x4A, 0x24, 0x4A, 0xFF}, {0x52, 0x28, 0x52, 0xFF}, {0x5A, 0x2D, 0x5A, 0xFF}, 
+    {0x63, 0x31, 0x63, 0xFF}, {0x6B, 0x35, 0x6B, 0xFF}, {0x73, 0x39, 0x73, 0xFF}, {0x7B, 0x3D, 0x7B, 0xFF}, 
+    {0x84, 0x41, 0x84, 0xFF}, {0x8C, 0x45, 0x8C, 0xFF}, {0x94, 0x49, 0x94, 0xFF}, {0x9C, 0x4D, 0x9C, 0xFF}, 
+    {0xA5, 0x51, 0xA5, 0xFF}, {0xAD, 0x55, 0xAD, 0xFF}, {0xB5, 0x59, 0xB5, 0xFF}, {0xBD, 0x5D, 0xBD, 0xFF}, 
+    {0xC5, 0x61, 0xC5, 0xFF}, {0xCE, 0x65, 0xCE, 0xFF}, {0xD6, 0x69, 0xD6, 0xFF}, {0xDE, 0x6D, 0xDE, 0xFF}, 
+    {0xE6, 0x71, 0xE6, 0xFF}, {0xEF, 0x75, 0xEF, 0xFF}, {0xF7, 0x79, 0xF7, 0xFF}, {0xFF, 0x7D, 0xFF, 0xFF}, 
+    {0x00, 0x82, 0x00, 0xFF}, {0x08, 0x86, 0x08, 0xFF}, {0x10, 0x8A, 0x10, 0xFF}, {0x19, 0x8E, 0x19, 0xFF}, 
+    {0x21, 0x92, 0x21, 0xFF}, {0x29, 0x96, 0x29, 0xFF}, {0x31, 0x9A, 0x31, 0xFF}, {0x3A, 0x9E, 0x3A, 0xFF}, 
+    {0x42, 0xA2, 0x42, 0xFF}, {0x4A, 0xA6, 0x4A, 0xFF}, {0x52, 0xAA, 0x52, 0xFF}, {0x5A, 0xAE, 0x5A, 0xFF}, 
+    {0x63, 0xB2, 0x63, 0xFF}, {0x6B, 0xB6, 0x6B, 0xFF}, {0x73, 0xBA, 0x73, 0xFF}, {0x7B, 0xBE, 0x7B, 0xFF}, 
+    {0x84, 0xC2, 0x84, 0xFF}, {0x8C, 0xC6, 0x8C, 0xFF}, {0x94, 0xCA, 0x94, 0xFF}, {0x9C, 0xCE, 0x9C, 0xFF}, 
+    {0xA5, 0xD2, 0xA5, 0xFF}, {0xAD, 0xD7, 0xAD, 0xFF}, {0xB5, 0xDB, 0xB5, 0xFF}, {0xBD, 0xDF, 0xBD, 0xFF}, 
+    {0xC5, 0xE3, 0xC5, 0xFF}, {0xCE, 0xE7, 0xCE, 0xFF}, {0xD6, 0xEB, 0xD6, 0xFF}, {0xDE, 0xEF, 0xDE, 0xFF}, 
+    {0xE6, 0xF3, 0xE6, 0xFF}, {0xEF, 0xF7, 0xEF, 0xFF}, {0xF7, 0xFB, 0xF7, 0xFF}, {0xFF, 0xFF, 0xFF, 0xFF}
+};
+
+/*******************************************************************************/
diff --git a/DirectFB-1.3.0/gfxdrivers/cx2450x/cx2450x.c b/DirectFB-1.3.0/gfxdrivers/cx2450x/cx2450x.c
new file mode 100644
index 0000000..d05a9c8
--- /dev/null
+++ b/DirectFB-1.3.0/gfxdrivers/cx2450x/cx2450x.c
@@ -0,0 +1,254 @@
+/*
+ * 
+ *
+ * 
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include <config.h>
+
+#include <unistd.h>
+#include <stdio.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <string.h>
+
+#include <fbdev/fbdev.h>  /* FIXME: Needs to be included before dfb_types.h to work around a type clash with asm/types.h */
+
+#include <directfb.h>
+
+#include <direct/mem.h>
+#include <direct/messages.h>
+
+#include <core/gfxcard.h>
+#include <core/graphics_driver.h>
+#include <core/state.h>
+#include <core/surface.h>
+#include <core/palette.h>
+
+#include <fbdev/fbdev.h>
+
+#include "cx2450x.h"
+#include "cx2450x-tables.h"
+
+DFB_GRAPHICS_DRIVER(cx2450x);
+
+#define CX2450X_SUPPORTED_DRAWING_FUNCTIONS	(DFXL_DRAWLINE | DFXL_FILLRECTANGLE | DFXL_DRAWRECTANGLE) // | DFXL_FILLTRIANGLE)
+#define CX2450X_SUPPORTED_DRAWING_FLAGS		(DSDRAW_BLEND)
+
+#define CX2450X_SUPPORTED_BLITTING_FUNCTIONS	(DFXL_BLIT | DFXL_STRETCHBLIT) // | DFXL_DRAWSTRING
+#define CX2450X_SUPPORTED_BLITTING_FLAGS	(DSBLIT_BLEND_ALPHACHANNEL | DSBLIT_SRC_COLORKEY | DSBLIT_COLORIZE | DSBLIT_BLEND_COLORALPHA)
+
+static void _cx2450x_check_state(void *driver_data, void *device_data, CardState *state, DFBAccelerationMask accel);
+static void _cx2450x_set_state(void *driver_data, void *device_data, GraphicsDeviceFuncs *funcs, CardState *state, DFBAccelerationMask accel);
+
+static u32 _read_gxa(volatile u8 *base_addr, u32 offset);
+static void _write_gxa(volatile u8 *base_addr, u32 offset, u32 value);
+
+bool _cx2450x_draw_line(void *driver_data, void *device_data, DFBRegion *line);
+static bool _cx2450x_draw_rectangle(void *driver_data, void *device_data, DFBRectangle *rect);
+static bool _cx2450x_fill_rectangle(void *driver_data, void *device_data, DFBRectangle *rect);
+static bool _cx2450x_fill_triangle(void *driver_data, void *device_data, DFBTriangle *tri);
+static bool _cx2450x_blit(void *driver_data, void *device_data, DFBRectangle *rect, int dx, int dy);
+static bool _cx2450x_stretchblit( void *driver_data, void *device_data, DFBRectangle *srect, DFBRectangle *drect);
+
+
+#include "cx2450x-state.c"	/* contains set/check state functions */
+#include "cx2450x-accel.c"	/* contains the acceleration functions */
+
+/*******************************************************************************/
+
+/*
+SF_CLIP		      = 0x00000004
+SMF_SRC_BLEND         = 0x00000010,
+SMF_DST_BLEND         = 0x00000020,
+SMF_SRC_COLORKEY      = 0x00000040,
+SMF_SOURCE_MASK       = 0x00000400,
+SMF_SOURCE_MASK_VALS  = 0x00000800,
+SMF_INDEX_TRANSLATION = 0x00001000,
+SMF_COLORKEY          = 0x00002000,
+SMF_RENDER_OPTIONS    = 0x00010000,
+SMF_MATRIX            = 0x00020000,
+*/
+
+/*******************************************************************************/
+
+static int driver_probe(CoreGraphicsDevice *device)
+{
+    int x;
+
+    x = dfb_gfxcard_get_accelerator(device);
+
+    if (x == FB_ACCEL_CX2450X)
+	return 1;
+    return 0;
+}
+
+/*******************************************************************************/
+
+static void driver_get_info(CoreGraphicsDevice *device, GraphicsDriverInfo *info)
+{
+    (void)device;
+
+    snprintf(info->name,   DFB_GRAPHICS_DRIVER_INFO_NAME_LENGTH,   "CX2450X GFX Driver");
+    snprintf(info->vendor, DFB_GRAPHICS_DRIVER_INFO_VENDOR_LENGTH, "Coolstream International Limited");
+
+    info->version.major = 0;
+    info->version.minor = 1;
+
+    info->driver_data_size = sizeof(CX2450XDriverData);
+    info->device_data_size = sizeof(CX2450XDeviceData);
+}
+
+/*******************************************************************************/
+
+static DFBResult driver_init_driver(CoreGraphicsDevice *device, GraphicsDeviceFuncs *funcs, void *driver_data, void *device_data, CoreDFB *core)
+{
+
+    CX2450XDriverData *drv = (CX2450XDriverData *)driver_data;
+    FBDev *dfb_fbdev;
+
+    drv->gxa_base = (void*) -1;
+
+    dfb_fbdev = dfb_system_data();
+    if (!dfb_fbdev)
+    	return DFB_IO;
+
+    drv->smem_start  = dfb_fbdev->shared->fix.smem_start;
+    drv->smem_len    = dfb_fbdev->shared->fix.smem_len - 0x40000;	/* reserve 256 KB for private data (conversion tables) */
+    drv->priv_start  = drv->smem_start + drv->smem_len;
+    drv->priv_len    = 0x040000;
+    drv->coeff_table = drv->priv_start;
+    drv->A8_table    = drv->priv_start + 0x10000;
+    drv->RGB16_table = drv->priv_start + 0x20000;
+
+    //printf("smem_start: 0x%.8lX, smem_len: 0x%.8X, priv_start: 0x%.8lX, priv_len: 0x%.8X\n", drv->smem_start, drv->smem_len, drv->priv_start, drv->priv_len);
+
+printf("priv_start: 0x%.8X, coeff_tab: 0x%.8X, A8_tab: 0x%.8X, RGB16_table: 0x%.8X\n", drv->priv_start, drv->coeff_table, drv->A8_table, drv->RGB16_table);
+
+    drv->devmem_fd = open("/dev/mem", O_RDWR | O_SYNC);
+    if (drv->devmem_fd < 0)
+	return DFB_IO;
+
+    drv->gxa_base = mmap(NULL, 0x00040000, PROT_READ | PROT_WRITE, MAP_SHARED, drv->devmem_fd, 0xE0600000);
+    if (drv->gxa_base == (void*) -1)
+	return DFB_IO;
+
+    drv->coeff_base = mmap(NULL, 0x00010000, PROT_READ | PROT_WRITE, MAP_SHARED, dfb_fbdev->fd, drv->smem_len);
+    if (drv->coeff_base == (void*) -1)
+	return DFB_IO;
+
+    drv->A8_base = mmap(NULL, 0x00010000, PROT_READ | PROT_WRITE, MAP_SHARED, dfb_fbdev->fd, drv->smem_len + 0x10000);
+    if (drv->A8_base == (void*) -1)
+	return DFB_IO;
+
+    drv->RGB16_base = mmap(NULL, 0x00010000, PROT_READ | PROT_WRITE, MAP_SHARED, dfb_fbdev->fd, drv->smem_len + 0x20000);
+    if (drv->RGB16_base == (void*) -1)
+	return DFB_IO;
+
+    drv->var_base = mmap(NULL, 0x00010000, PROT_READ | PROT_WRITE, MAP_SHARED, dfb_fbdev->fd, drv->smem_len + 0x20000);
+    if (drv->var_base == (void*) -1)
+	return DFB_IO;
+
+
+    /* base functions */
+    funcs->EngineSync = NULL;
+    funcs->CheckState = _cx2450x_check_state;
+    funcs->SetState   = _cx2450x_set_state;
+
+    /* drawing functions */
+    funcs->DrawLine      = _cx2450x_draw_line;
+    funcs->DrawRectangle = _cx2450x_draw_rectangle;
+    funcs->FillRectangle = _cx2450x_fill_rectangle;
+    funcs->FillTriangle  = _cx2450x_fill_triangle;
+
+    /* blitting functions */
+    funcs->Blit        = _cx2450x_blit;
+    funcs->StretchBlit = _cx2450x_stretchblit;
+
+//    memcpy((u8*) drv->coeff_base, &scale_coeff_table[0],           0x0400);
+//    memcpy((u8*) drv->A8_base,    &DSPF_A8_to_ARGB_table[0][0],    0x0400);
+//    memcpy((u8*) drv->RGB16_base, &DSPF_RGB16_to_ARGB_table[0][0], 0x0100);
+
+    return DFB_OK;
+}
+
+
+static DFBResult driver_init_device(CoreGraphicsDevice *device, GraphicsDeviceInfo *device_info, void *driver_data, void *device_data)
+{
+    CX2450XDriverData *drv = (CX2450XDriverData *)driver_data;
+
+    snprintf(device_info->name,   DFB_GRAPHICS_DEVICE_INFO_NAME_LENGTH,   "CX2450X");
+    snprintf(device_info->vendor, DFB_GRAPHICS_DEVICE_INFO_VENDOR_LENGTH, "Conexant");
+
+    device_info->caps.flags    = 0;										/* CardCapabilitiesFlags */
+    device_info->caps.accel    = CX2450X_SUPPORTED_DRAWING_FUNCTIONS | CX2450X_SUPPORTED_BLITTING_FUNCTIONS;	/* DFBAccelerationMask */
+    device_info->caps.blitting = CX2450X_SUPPORTED_BLITTING_FLAGS;						/* DFBSurfaceBlittingFlags */
+    device_info->caps.drawing  = CX2450X_SUPPORTED_DRAWING_FLAGS;						/* DFBSurfaceDrawingFlags */
+    device_info->caps.clip     = DFXL_NONE;									/* DFBAccelerationMask */
+
+    device_info->limits.surface_byteoffset_alignment        = 128;	// ??? /* unsigned int */
+    device_info->limits.surface_pixelpitch_alignment        = 32;	// ??? /* unsigned int */
+
+    device_info->limits.surface_bytepitch_alignment         = 4;	/* unsigned int */
+//    device_info->limits.surface_max_power_of_two_pixelpitch = ; /* unsigned int */
+//    device_info->limits.surface_max_power_of_two_bytepitch  = ; /* unsigned int */
+//    device_info->limits.surface_max_power_of_two_height     = ; /* unsigned int */
+//    device_info->limits.dst_min                             = ;	/* DFBDimension */
+//    device_info->limits.dst_max                             = ;	/* DFBDimension */
+//    device_info->limits.src_min                             = ;	/* DFBDimension */
+//    device_info->limits.src_max                             = ;	/* DFBDimension */
+
+
+    _write_gxa(drv->gxa_base, GXA_CONTENT_ID_REG, 0);
+
+    return DFB_OK;
+}
+
+/*******************************************************************************/
+
+static void driver_close_device(CoreGraphicsDevice *device, void *driver_data,	void *device_data)
+{
+
+}
+
+/*******************************************************************************/
+
+static void driver_close_driver(CoreGraphicsDevice *device, void *driver_data)
+{
+    CX2450XDriverData *drv = (CX2450XDriverData *)driver_data;
+
+    if (drv->gxa_base != (void*) -1)
+	munmap((void*) drv->gxa_base, 0x00040000);
+
+    if (drv->coeff_base != (void*) -1)
+	munmap((void*) drv->coeff_base, 0x00010000);
+
+    if (drv->A8_base != (void*) -1)
+	munmap((void*) drv->A8_base, 0x00010000);
+
+    if (drv->RGB16_base != (void*) -1)
+	munmap((void*) drv->RGB16_base, 0x00010000);
+
+    if (drv->var_base != (void*) -1)
+	munmap((void*) drv->var_base, 0x00010000);
+
+    if (drv->devmem_fd > -1)
+	close(drv->devmem_fd);
+}
diff --git a/DirectFB-1.3.0/gfxdrivers/cx2450x/cx2450x.h b/DirectFB-1.3.0/gfxdrivers/cx2450x/cx2450x.h
new file mode 100644
index 0000000..0a0c53c
--- /dev/null
+++ b/DirectFB-1.3.0/gfxdrivers/cx2450x/cx2450x.h
@@ -0,0 +1,96 @@
+/*
+ * Conexant CX2450X accelated driver
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef __CX2450X_H__
+#define __CX2450X_H__
+
+#include <direct/types.h>
+
+/* GXA register definitions (as offset) */
+#define GXA_FG_COLOR_REG	0x0020
+#define GXA_BG_COLOR_REG	0x0024
+#define GXA_LINE_PATT_REG	0x0028
+#define	GXA_CFG_REG		0x0030
+#define GXA_BLT_CONTROL_REG	0x0034
+#define GXA_LINE_CONTROL_REG	0x0038
+#define GXA_BLEND_CFG_REG	0x003C
+#define	GXA_BMP1_TYPE_REG	0x0048
+#define	GXA_BMP1_ADDR_REG	0x004C
+#define	GXA_BMP2_TYPE_REG	0x0050
+#define	GXA_BMP2_ADDR_REG	0x0054
+#define GXA_DEPTH_REG		0x00F4
+#define	GXA_CFG2_REG		0x00FC
+#define GXA_SC_NORM_REG		0x0120
+#define GXA_CSC_SET0_REG	0x0124
+#define GXA_CSC_SET1_REG	0x0128
+#define GXA_CSC_SET2_REG	0x012C
+#define	GXA_CONST_COLOR_REG	0x0134
+#define	GXA_KEY_UPPER_REG	0x0138
+#define	GXA_KEY_LOWER_REG	0x013C
+#define GXA_CONTENT_ID_REG	0x0144
+
+/* GXA commands at bit 17:11 */
+#define GXA_CMD_QMARK		0x00001000
+#define	GXA_CMD_PALETTE		0x00001800
+#define GXA_CMD_VFILTER		0x00002000
+#define GXA_CMD_HFILTER		0x00002800
+#define GXA_CMD_BLT		0x00010800	/* perform blitting if set, or line draw if not set */
+#define GXA_CMD_NOT_ALPHA	0x00011000	/* no alpha blending if set */
+#define GXA_CMD_SRC_TRANSP	0x00012000	/* use source transparency if set */
+#define GXA_CMD_ROP		0x00014000	/* special Raster Operations if set (type of ROP must be setup manually), or simply copy if not set */
+#define GXA_CMD_NOT_TEXT	0x00018000	/* no special text blit algorythm if set (only valid for patterns) */
+#define GXA_CMD_STRETCH_BLT	0x00030000	/* stretch blit if enabled */
+
+/* various bitfield definitions for GXA addressing (if it's not a register R/W) */
+#define GXA_SRC_BMP_SEL(x)	(x << 8)	/* Source bitmap selector from 0 to 7 (for blitting cmds) */
+#define GXA_DST_BMP_SEL(x)	(x << 5)	/* destination bitmap selector from 0 to 7 (for blitting and drawing cmds) */
+#define GXA_PARAM_COUNT(x)	(x << 2)	/* command parameter from 0 to 7 */
+
+/* encode pixel data into register values */
+//#define GXA_POINT(x, y)		(((y) & 0x0FFF) << 16) | ((x) & 0x0FFF)
+#define GXA_POINT(x, y)		(((y) << 16) | (x))
+
+typedef struct 
+{
+    unsigned long	 smem_start;		/* physical start address of the framebuffer */
+    unsigned int	 smem_len;		/* length of the framebuffer */
+    int			 devmem_fd;		/* the filedescriptor for the opened /dev/mem */
+    volatile u8		*gxa_base;		/* the mmap'd GXA register address space */
+    volatile u8		*coeff_base;		/* the mmap'd view of the private used space */
+    volatile u8		*A8_base;
+    volatile u8		*RGB16_base;
+    volatile u8		*var_base;
+    u32	 		 priv_start;		/* the start address of private used framebuffer space (not seen by DFB) */
+    u32			 priv_len;		/* the size of private used space */
+    u32			 coeff_table;
+    u32			 A8_table;
+    u32			 RGB16_table;
+    u32			 var_table;
+} CX2450XDriverData;
+
+typedef struct
+{
+    u32		 		d_cmd_opts;	/* additional command options for draw */
+    u32		 		b_cmd_opts;	/* additional command options for blit */
+    DFBSurfaceBlittingFlags	b_flags;	/* local copy of blitting flags from state->mod_hw to make workarounds for DFB-bugs */
+    bool			b_soft;
+} CX2450XDeviceData;
+
+#endif /* __CX2450X_H__ */
diff --git a/DirectFB-1.3.0/gfxdrivers/davinci/davinci_2d.c b/DirectFB-1.3.0/gfxdrivers/davinci/davinci_2d.c
index 10e3344..c136006 100644
--- a/DirectFB-1.3.0/gfxdrivers/davinci/davinci_2d.c
+++ b/DirectFB-1.3.0/gfxdrivers/davinci/davinci_2d.c
@@ -445,20 +445,20 @@ davinciEmitCommands( void *drv, void *dev )
 void
 davinciFlushTextureCache( void *drv, void *dev )
 {
+/*
      DavinciDriverData *ddrv = drv;
      DavinciDeviceData *ddev = dev;
+*/
 
      D_DEBUG_AT( Davinci_2D, "%s()\n", __FUNCTION__ );
 
-     /* Bad workaround */
-     davinci_c64x_blit_32( &ddrv->c64x, dfb_config->video_phys, 1024, dfb_config->video_phys, 1024, 256, 64 );
+/* Function does not work!
+     davinci_c64x_wb_inv_range( &ddrv->c64x, dfb_config->video_phys,
+                                             dfb_config->video_length, 2 );
 
-     /* These don't work */
-//     davinci_c64x_wb_inv_range( &ddrv->c64x, dfb_config->video_phys,
-//                                             dfb_config->video_length, 2 );
-
-//     davinci_c64x_wb_inv_range( &ddrv->c64x, ddev->fix[OSD0].smem_start,
-//                                             ddev->fix[OSD0].smem_len, 2 );
+     davinci_c64x_wb_inv_range( &ddrv->c64x, ddev->fix[OSD0].smem_start,
+                                             ddev->fix[OSD0].smem_len, 2 );
+*/
 }
 
 /*
diff --git a/DirectFB-1.3.0/gfxdrivers/davinci/davinci_osd_pool.c b/DirectFB-1.3.0/gfxdrivers/davinci/davinci_osd_pool.c
index 8904461..5af398e 100644
--- a/DirectFB-1.3.0/gfxdrivers/davinci/davinci_osd_pool.c
+++ b/DirectFB-1.3.0/gfxdrivers/davinci/davinci_osd_pool.c
@@ -119,12 +119,9 @@ osdInitPool( CoreDFB                    *core,
      D_ASSERT( ret_desc != NULL );
 
      ret_desc->caps     = CSPCAPS_NONE;
+     ret_desc->access   = CSAF_CPU_READ | CSAF_CPU_WRITE | CSAF_GPU_READ | CSAF_GPU_WRITE | CSAF_SHARED;
      ret_desc->types    = CSTF_LAYER | CSTF_SHARED | CSTF_EXTERNAL;
-     ret_desc->priority = CSPP_PREFERED;
-
-     ret_desc->access[CSAID_CPU]    = CSAF_READ | CSAF_WRITE | CSAF_SHARED;
-     ret_desc->access[CSAID_GPU]    = CSAF_READ | CSAF_WRITE | CSAF_SHARED;
-     ret_desc->access[CSAID_LAYER0] = CSAF_READ | CSAF_WRITE | CSAF_SHARED;
+     ret_desc->priority = CSPP_DEFAULT;
 
      snprintf( ret_desc->name, DFB_SURFACE_POOL_DESC_NAME_LENGTH, "OSD Pool" );
 
diff --git a/DirectFB-1.3.0/gfxdrivers/davinci/davinci_screen.c b/DirectFB-1.3.0/gfxdrivers/davinci/davinci_screen.c
index fa53478..5cf1b38 100644
--- a/DirectFB-1.3.0/gfxdrivers/davinci/davinci_screen.c
+++ b/DirectFB-1.3.0/gfxdrivers/davinci/davinci_screen.c
@@ -92,7 +92,7 @@ davinciGetScreenSize( CoreScreen *screen,
 
      ret = ioctl( ddrv->fb[OSD0].fd, FBIO_GET_TIMING, &mode );
      if (ret) {
-          D_PERROR( "%s: FBIO_GET_TIMING (fb%d, OSD0) failed!\n", __func__, OSD0 );
+          D_PERROR( "%s: FBIO_GET_TIMING (fb%d) failed!\n", __func__ );
           return DFB_INIT;
      }
 
diff --git a/DirectFB-1.3.0/gfxdrivers/davinci/davinci_video_pool.c b/DirectFB-1.3.0/gfxdrivers/davinci/davinci_video_pool.c
index 1e693e1..7e5874e 100644
--- a/DirectFB-1.3.0/gfxdrivers/davinci/davinci_video_pool.c
+++ b/DirectFB-1.3.0/gfxdrivers/davinci/davinci_video_pool.c
@@ -119,13 +119,10 @@ videoInitPool( CoreDFB                    *core,
      D_ASSERT( ret_desc != NULL );
 
      ret_desc->caps     = CSPCAPS_NONE;
+     ret_desc->access   = CSAF_CPU_READ | CSAF_CPU_WRITE | CSAF_GPU_READ | CSAF_GPU_WRITE | CSAF_SHARED;
      ret_desc->types    = CSTF_LAYER | CSTF_SHARED | CSTF_EXTERNAL;
      ret_desc->priority = CSPP_DEFAULT;
 
-     ret_desc->access[CSAID_CPU]    = CSAF_READ | CSAF_WRITE | CSAF_SHARED;
-     ret_desc->access[CSAID_GPU]    = CSAF_READ | CSAF_WRITE | CSAF_SHARED;
-     ret_desc->access[CSAID_LAYER1] = CSAF_READ | CSAF_WRITE | CSAF_SHARED;
-
      snprintf( ret_desc->name, DFB_SURFACE_POOL_DESC_NAME_LENGTH, "Video Pool" );
 
      local->core = core;
diff --git a/DirectFB-1.3.0/gfxdrivers/omap/omapfb.h b/DirectFB-1.3.0/gfxdrivers/omap/omapfb.h
new file mode 100644
index 0000000..5d511b9
--- /dev/null
+++ b/DirectFB-1.3.0/gfxdrivers/omap/omapfb.h
@@ -0,0 +1,163 @@
+/*
+ * File: include/asm-arm/arch-omap/omapfb.h
+ *
+ * Framebuffer driver for TI OMAP boards
+ *
+ * Copyright (C) 2004 Nokia Corporation
+ * Author: Imre Deak <imre.deak@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#ifndef __OMAPFB_H
+#define __OMAPFB_H
+
+#include <asm/ioctl.h>
+#include <asm/types.h>
+
+/* IOCTL commands. */
+
+#define OMAP_IOW(num, dtype)	_IOW('O', num, dtype)
+#define OMAP_IOR(num, dtype)	_IOR('O', num, dtype)
+#define OMAP_IOWR(num, dtype)	_IOWR('O', num, dtype)
+#define OMAP_IO(num)		_IO('O', num)
+
+#define OMAPFB_MIRROR		OMAP_IOW(31, int)
+#define OMAPFB_SYNC_GFX		OMAP_IO(37)
+#define OMAPFB_VSYNC		OMAP_IO(38)
+#define OMAPFB_SET_UPDATE_MODE	OMAP_IOW(40, int)
+#define OMAPFB_GET_CAPS		OMAP_IOR(42, struct omapfb_caps)
+#define OMAPFB_GET_UPDATE_MODE	OMAP_IOW(43, int)
+#define OMAPFB_LCD_TEST		OMAP_IOW(45, int)
+#define OMAPFB_CTRL_TEST	OMAP_IOW(46, int)
+#define OMAPFB_UPDATE_WINDOW_OLD OMAP_IOW(47, struct omapfb_update_window_old)
+#define OMAPFB_SET_COLOR_KEY	OMAP_IOW(50, struct omapfb_color_key)
+#define OMAPFB_GET_COLOR_KEY	OMAP_IOW(51, struct omapfb_color_key)
+#define OMAPFB_SETUP_PLANE	OMAP_IOW(52, struct omapfb_plane_info)
+#define OMAPFB_QUERY_PLANE	OMAP_IOW(53, struct omapfb_plane_info)
+#define OMAPFB_UPDATE_WINDOW	OMAP_IOW(54, struct omapfb_update_window)
+#define OMAPFB_SETUP_MEM	OMAP_IOW(55, struct omapfb_mem_info)
+#define OMAPFB_QUERY_MEM	OMAP_IOW(56, struct omapfb_mem_info)
+
+#define OMAPFB_CAPS_GENERIC_MASK	0x00000fff
+#define OMAPFB_CAPS_LCDC_MASK		0x00fff000
+#define OMAPFB_CAPS_PANEL_MASK		0xff000000
+
+#define OMAPFB_CAPS_MANUAL_UPDATE	0x00001000
+#define OMAPFB_CAPS_TEARSYNC		0x00002000
+#define OMAPFB_CAPS_PLANE_RELOCATE_MEM	0x00004000
+#define OMAPFB_CAPS_PLANE_SCALE		0x00008000
+#define OMAPFB_CAPS_WINDOW_PIXEL_DOUBLE	0x00010000
+#define OMAPFB_CAPS_WINDOW_SCALE	0x00020000
+#define OMAPFB_CAPS_WINDOW_OVERLAY	0x00040000
+#define OMAPFB_CAPS_SET_BACKLIGHT	0x01000000
+
+/* Values from DSP must map to lower 16-bits */
+#define OMAPFB_FORMAT_MASK		0x00ff
+#define OMAPFB_FORMAT_FLAG_DOUBLE	0x0100
+#define OMAPFB_FORMAT_FLAG_TEARSYNC	0x0200
+#define OMAPFB_FORMAT_FLAG_FORCE_VSYNC	0x0400
+#define OMAPFB_FORMAT_FLAG_ENABLE_OVERLAY	0x0800
+#define OMAPFB_FORMAT_FLAG_DISABLE_OVERLAY	0x1000
+
+#define OMAPFB_EVENT_READY	1
+#define OMAPFB_EVENT_DISABLED	2
+
+#define OMAPFB_MEMTYPE_SDRAM		0
+#define OMAPFB_MEMTYPE_SRAM		1
+#define OMAPFB_MEMTYPE_MAX		1
+
+enum omapfb_color_format {
+	OMAPFB_COLOR_RGB565 = 0,
+	OMAPFB_COLOR_YUV422,
+	OMAPFB_COLOR_YUV420,
+	OMAPFB_COLOR_CLUT_8BPP,
+	OMAPFB_COLOR_CLUT_4BPP,
+	OMAPFB_COLOR_CLUT_2BPP,
+	OMAPFB_COLOR_CLUT_1BPP,
+	OMAPFB_COLOR_RGB444,
+	OMAPFB_COLOR_YUY422,
+};
+
+struct omapfb_update_window {
+	u32 x, y;
+	u32 width, height;
+	u32 format;
+	u32 out_x, out_y;
+	u32 out_width, out_height;
+	u32 reserved[8];
+};
+
+struct omapfb_update_window_old {
+	u32 x, y;
+	u32 width, height;
+	u32 format;
+};
+
+enum omapfb_plane {
+	OMAPFB_PLANE_GFX = 0,
+	OMAPFB_PLANE_VID1,
+	OMAPFB_PLANE_VID2,
+};
+
+enum omapfb_channel_out {
+	OMAPFB_CHANNEL_OUT_LCD = 0,
+	OMAPFB_CHANNEL_OUT_DIGIT,
+};
+
+struct omapfb_plane_info {
+	u32 pos_x;
+	u32 pos_y;
+	u8  enabled;
+	u8  channel_out;
+	u8  mirror;
+	u8  reserved1;
+	u32 out_width;
+	u32 out_height;
+	u32 reserved2[12];
+};
+
+struct omapfb_mem_info {
+	u32 size;
+	u8  type;
+	u8  reserved[3];
+};
+
+struct omapfb_caps {
+	u32 ctrl;
+	u32 plane_color;
+	u32 wnd_color;
+};
+
+enum omapfb_color_key_type {
+	OMAPFB_COLOR_KEY_DISABLED = 0,
+	OMAPFB_COLOR_KEY_GFX_DST,
+	OMAPFB_COLOR_KEY_VID_SRC,
+};
+
+struct omapfb_color_key {
+	u8  channel_out;
+	u32 background;
+	u32 trans_key;
+	u8  key_type;
+};
+
+enum omapfb_update_mode {
+	OMAPFB_UPDATE_DISABLED = 0,
+	OMAPFB_AUTO_UPDATE,
+	OMAPFB_MANUAL_UPDATE
+};
+
+#endif /* __OMAPFB_H */
diff --git a/DirectFB-1.3.0/gfxdrivers/savage/savage_streams_old.c b/DirectFB-1.3.0/gfxdrivers/savage/savage_streams_old.c
new file mode 100644
index 0000000..0dc8554
--- /dev/null
+++ b/DirectFB-1.3.0/gfxdrivers/savage/savage_streams_old.c
@@ -0,0 +1,1033 @@
+/*
+   (c) Copyright 2001-2008  The world wide DirectFB Open Source Community (directfb.org)
+   (c) Copyright 2000-2004  Convergence (integrated media) GmbH
+
+   All rights reserved.
+
+   Written by Denis Oliver Kropp <dok@directfb.org>,
+              Andreas Hundt <andi@fischlustig.de>,
+              Sven Neumann <neo@directfb.org>,
+              Ville Syrjl <syrjala@sci.fi> and
+              Claudio Ciccani <klan@users.sf.net>.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <dfb_types.h>
+
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+
+#include <sys/mman.h>
+#include <sys/io.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <math.h>
+
+#include <directfb.h>
+
+#include <fusion/shmalloc.h>
+
+#include <core/coredefs.h>
+#include <core/coretypes.h>
+
+#include <core/state.h>
+#include <core/surface.h>
+#include <core/gfxcard.h>
+#include <core/layers.h>
+#include <core/windows.h>
+#include <core/system.h>
+
+#include <gfx/convert.h>
+#include <gfx/util.h>
+#include <misc/conf.h>
+#include <direct/mem.h>
+
+#include "savage.h"
+#include "savage_streams_old.h"
+#include "mmio.h"
+#include "savage_bci.h"
+
+/* #define SAVAGE_DEBUG */
+#ifdef SAVAGE_DEBUG
+     #define SVGDBG(x...) fprintf(stderr, "savage_streams_old:" x)
+#else
+     #define SVGDBG(x...)
+#endif
+
+typedef struct {
+     DFBRectangle          dest;
+     DFBDisplayLayerConfig config;
+     int video_pitch;
+
+     struct {
+          /* secondary stream registers */
+          u32 SSTREAM_CTRL;
+          u32 SSTREAM_H_SCALE;
+          u32 BLEND_CTRL;
+          u32 SSTREAM_MULTIBUF;
+          u32 SSTREAM_FB_ADDR0;
+          u32 SSTREAM_FB_ADDR1;
+          u32 SSTREAM_STRIDE;
+          u32 SSTREAM_V_SCALE;
+          u32 SSTREAM_V_INIT_VALUE;
+          u32 SSTREAM_SRC_LINE_COUNT;
+          u32 SSTREAM_WIN_START;
+          u32 SSTREAM_WIN_SIZE;
+          u32 SSTREAM_FB_CB_ADDR;
+          u32 SSTREAM_FB_CR_ADDR;
+          u32 SSTREAM_CBCR_STRIDE;
+          u32 SSTREAM_FB_SIZE;
+          u32 SSTREAM_FB_ADDR2;
+     } regs;
+} SavageSecondaryLayerData;
+
+typedef struct {
+     DFBDisplayLayerConfig config;
+     int dx;
+     int dy;
+     int init;
+
+     struct {
+          /* primary stream registers */
+          u32 PSTREAM_CTRL;
+          u32 PSTREAM_FB_ADDR0;
+          u32 PSTREAM_FB_ADDR1;
+          u32 PSTREAM_STRIDE;
+          u32 PSTREAM_WIN_START;
+          u32 PSTREAM_WIN_SIZE;
+          u32 PSTREAM_FB_SIZE;
+     } regs;
+} SavagePrimaryLayerData;
+
+DisplayLayerFuncs savage_pfuncs;
+void *savage_pdriver_data;
+
+/* function prototypes */
+static void
+secondary_set_regs (SavageDriverData         *sdrv,
+                    SavageSecondaryLayerData *slay);
+static void
+secondary_calc_regs(SavageDriverData         *sdrv,
+                    SavageSecondaryLayerData *slay,
+                    CoreLayer                *layer,
+                    DFBDisplayLayerConfig    *config);
+static void
+primary_set_regs   (SavageDriverData         *sdrv,
+                    SavagePrimaryLayerData   *play);
+static void
+primary_calc_regs  (SavageDriverData         *sdrv,
+                    SavagePrimaryLayerData   *play,
+                    CoreLayer                *layer,
+                    DFBDisplayLayerConfig    *config);
+
+static inline
+void waitretrace (void)
+{
+     iopl(3);
+     while ((inb (0x3da) & 0x8))
+          ;
+
+     while (!(inb (0x3da) & 0x8))
+          ;
+}
+
+static void
+streamOnOff(SavageDriverData * sdrv, int on)
+{
+     volatile u8 *mmio = sdrv->mmio_base;
+
+     waitretrace();
+
+     if (on) {
+          vga_out8( mmio, 0x3d4, 0x23 );
+          vga_out8( mmio, 0x3d5, 0x00 );
+
+          vga_out8( mmio, 0x3d4, 0x26 );
+          vga_out8( mmio, 0x3d5, 0x00 );
+
+          /* turn on stream operation */
+          vga_out8( mmio, 0x3d4, 0x67 );
+          vga_out8( mmio, 0x3d5, 0x0c );
+     }
+     else {
+          /* turn off stream operation */
+          vga_out8( mmio, 0x3d4, 0x67 );
+          vga_out8( mmio, 0x3d5, vga_in8( mmio, 0x3d5 ) & ~0x0c );
+     }
+}
+
+/* secondary layer functions */
+static int
+savageSecondaryLayerDataSize()
+{
+     SVGDBG("savageSecondaryLayerDataSize\n");
+     return sizeof(SavageSecondaryLayerData);
+}
+
+static DFBResult
+savageSecondaryInitLayer( GraphicsDevice        *device,
+                          CoreLayer             *layer,
+                          DisplayLayerInfo      *layer_info,
+                          DFBDisplayLayerConfig *default_config,
+                          DFBColorAdjustment    *default_adj,
+                          void                  *driver_data,
+                          void                  *layer_data )
+{
+     SavageSecondaryLayerData *slay = (SavageSecondaryLayerData*) layer_data;
+
+     SVGDBG("savageSecondaryInitLayer\n");
+
+     /* set capabilities and type */
+     layer_info->desc.caps = DLCAPS_SURFACE | DLCAPS_SCREEN_LOCATION |
+                             DLCAPS_BRIGHTNESS | DLCAPS_CONTRAST |
+                             DLCAPS_OPACITY | DLCAPS_HUE | DLCAPS_SATURATION |
+                             DLCAPS_ALPHACHANNEL | DLCAPS_SRC_COLORKEY |
+                             DLCAPS_DST_COLORKEY;
+     layer_info->desc.type = DLTF_GRAPHICS | DLTF_VIDEO | DLTF_STILL_PICTURE;
+
+     /* set name */
+     snprintf(layer_info->desc.name, DFB_DISPLAY_LAYER_DESC_NAME_LENGTH,
+              "Savage Secondary Stream");
+
+     /* fill out the default configuration */
+     default_config->flags       = DLCONF_WIDTH | DLCONF_HEIGHT |
+                                   DLCONF_PIXELFORMAT | DLCONF_BUFFERMODE |
+                                   DLCONF_OPTIONS;
+     default_config->width       = 640;
+     default_config->height      = 480;
+     default_config->pixelformat = DSPF_YUY2;
+     default_config->buffermode  = DLBM_FRONTONLY;
+     default_config->options     = DLOP_NONE;
+
+     /* fill out default color adjustment,
+        only fields set in flags will be accepted from applications */
+     default_adj->flags      = DCAF_BRIGHTNESS | DCAF_CONTRAST |
+                               DCAF_HUE | DCAF_SATURATION;
+     default_adj->brightness = 0x8000;
+     default_adj->contrast   = 0x8000;
+     default_adj->hue        = 0x8000;
+     default_adj->saturation = 0x8000;
+
+     /* initialize destination rectangle */
+     dfb_primary_layer_rectangle(0.0f, 0.0f, 1.0f, 1.0f, &slay->dest);
+
+     return DFB_OK;
+}
+
+static DFBResult savageSecondaryEnable( CoreLayer *layer,
+                                        void      *driver_data,
+                                        void      *layer_data )
+{
+     SavageDriverData *sdrv = (SavageDriverData*) driver_data;
+     volatile u8 *mmio = sdrv->mmio_base;
+
+     SVGDBG("savageSecondaryEnable\n");
+
+     /* put secondary stream on top of primary stream */
+     savage_out32(mmio, SAVAGE_BLEND_CONTROL,
+                  SAVAGE_BLEND_CONTROL_COMP_SSTREAM);
+
+     return DFB_OK;
+}
+
+static DFBResult savageSecondaryDisable( CoreLayer *layer,
+                                         void      *driver_data,
+                                         void      *layer_data )
+{
+     SavageDriverData *sdrv = (SavageDriverData*) driver_data;
+     volatile u8 *mmio = sdrv->mmio_base;
+
+     SVGDBG("savageSecondaryDisable\n");
+
+     /* put primary stream on top of secondary stream */
+     savage_out32(mmio, SAVAGE_BLEND_CONTROL,
+                  SAVAGE_BLEND_CONTROL_COMP_PSTREAM);
+
+     return DFB_OK;
+}
+
+static DFBResult
+savageSecondaryTestConfiguration( CoreLayer                  *layer,
+                                  void                       *driver_data,
+                                  void                       *layer_data,
+                                  DFBDisplayLayerConfig      *config,
+                                  DFBDisplayLayerConfigFlags *failed )
+{
+     DFBDisplayLayerConfigFlags fail = 0;
+
+     SVGDBG("savageSecondaryTestConfig\n");
+
+     /* check for unsupported options */
+     /* savage only supports one option at a time */
+     switch (config->options) {
+          case DLOP_NONE:
+          case DLOP_ALPHACHANNEL:
+          case DLOP_SRC_COLORKEY:
+          case DLOP_DST_COLORKEY:
+          case DLOP_OPACITY:
+               break;
+          default:
+               fail |= DLCONF_OPTIONS;
+               break;
+     }
+
+     /* check pixel format */
+     switch (config->pixelformat) {
+          case DSPF_ARGB1555:
+          case DSPF_RGB16:
+          case DSPF_RGB24:
+          case DSPF_RGB32:
+          case DSPF_YUY2:
+          case DSPF_UYVY:
+          case DSPF_I420:
+          case DSPF_YV12:
+               break;
+          default:
+               fail |= DLCONF_PIXELFORMAT;
+     }
+
+     /* check width */
+     if (config->width > 2048 || config->width < 1)
+          fail |= DLCONF_WIDTH;
+
+     /* check height */
+     if (config->height > 2048 || config->height < 1)
+          fail |= DLCONF_HEIGHT;
+
+     /* write back failing fields */
+     if (failed)
+          *failed = fail;
+
+     /* return failure if any field failed */
+     if (fail)
+          return DFB_UNSUPPORTED;
+
+     return DFB_OK;
+}
+
+static DFBResult
+savageSecondarySetConfiguration( CoreLayer             *layer,
+                                 void                  *driver_data,
+                                 void                  *layer_data,
+                                 DFBDisplayLayerConfig *config)
+{
+     SavageDriverData *sdrv = (SavageDriverData*) driver_data;
+     SavageSecondaryLayerData *slay = (SavageSecondaryLayerData*) layer_data;
+
+     SVGDBG("savageSecondarySetConfiguration w:%i h:%i bpp:%i\n",
+            config->width, config->height,
+            DFB_BYTES_PER_PIXEL(config->pixelformat) * 8);
+
+     /* remember configuration */
+     slay->config = *config;
+
+     secondary_calc_regs(sdrv, slay, layer, config);
+     secondary_set_regs(sdrv, slay);
+
+     return DFB_OK;
+}
+
+static DFBResult
+savageSecondarySetOpacity( CoreLayer *layer,
+                           void      *driver_data,
+                           void      *layer_data,
+                           u8         opacity )
+{
+     SavageDriverData *sdrv = (SavageDriverData*) driver_data;
+     SavageSecondaryLayerData *slay = (SavageSecondaryLayerData*) layer_data;
+     volatile u8 *mmio = sdrv->mmio_base;
+
+     SVGDBG("savageSecondarySetOpacity\n");
+     switch (opacity) {
+          case 0:
+               /* put primary stream on top of secondary stream */
+               savage_out32(mmio, SAVAGE_BLEND_CONTROL,
+                            SAVAGE_BLEND_CONTROL_COMP_PSTREAM);
+               break;
+          case 0xFF:
+               /* put secondary stream on top of primary stream */
+               savage_out32(mmio, SAVAGE_BLEND_CONTROL,
+                            SAVAGE_BLEND_CONTROL_COMP_SSTREAM);
+               break;
+          default:
+               if (slay->config.options == DLOP_OPACITY) {
+                    /* reverse opacity */
+                    opacity = 7 - (opacity >> 5);
+
+                    /* for some reason opacity can not be zero */
+                    if (opacity == 0)
+                         opacity = 1;
+
+                    /* dissolve primary and secondary stream */
+                    savage_out32(mmio, SAVAGE_BLEND_CONTROL,
+                                 SAVAGE_BLEND_CONTROL_COMP_DISSOLVE |
+                                 KP_KS(opacity,0));
+               }
+               else {
+                    return DFB_UNSUPPORTED;
+               }
+               break;
+     }
+     return DFB_OK;
+}
+
+static DFBResult
+savageSecondarySetScreenLocation( CoreLayer *layer,
+                                  void      *driver_data,
+                                  void      *layer_data,
+                                  float      x,
+                                  float      y,
+                                  float      width,
+                                  float      height )
+{
+     SavageDriverData *sdrv = (SavageDriverData*) driver_data;
+     SavageSecondaryLayerData *slay = (SavageSecondaryLayerData*) layer_data;
+     volatile u8      *mmio = sdrv->mmio_base;
+
+     SVGDBG("savageSecondarySetScreenLocation x:%f y:%f w:%f h:%f\n",
+            x, y, width, height);
+
+     /* get new destination rectangle */
+     dfb_primary_layer_rectangle(x, y, width, height, &slay->dest);
+
+     if ((slay->regs.SSTREAM_FB_SIZE & 0x00400000) == 0) {
+          /* secondary is yuv format */
+          if (slay->dest.w < (slay->config.width / 2) ||
+              slay->dest.h < (slay->config.height / 32)) {
+               return DFB_UNSUPPORTED;
+          }
+     }
+     else {
+          /* secondary is rgb format */
+          if (slay->dest.w < slay->config.width ||
+              slay->dest.h < slay->config.height) {
+               return DFB_UNSUPPORTED;
+          }
+     }
+
+     savage_out32(mmio, SAVAGE_SECONDARY_STREAM_HORIZONTAL_SCALING,
+                  ((32768 * slay->config.width) / slay->dest.w) & 0x0000FFFF);
+     savage_out32(mmio, SAVAGE_SECONDARY_STREAM_VERTICAL_SCALING,
+                  ((32768 * slay->config.height) / slay->dest.h) & 0x000FFFFF);
+     savage_out32(mmio, SAVAGE_SECONDARY_STREAM_WINDOW_START,
+                  OS_XY(slay->dest.x, slay->dest.y));
+     savage_out32(mmio, SAVAGE_SECONDARY_STREAM_WINDOW_SIZE,
+                  OS_WH(slay->dest.w, slay->dest.h));
+     return DFB_OK;
+}
+
+static DFBResult
+savageSecondarySetSrcColorKey( CoreLayer *layer,
+                               void      *driver_data,
+                               void      *layer_data,
+                               u8         r,
+                               u8         g,
+                               u8         b )
+{
+     SavageDriverData *sdrv = (SavageDriverData*) driver_data;
+     SavageSecondaryLayerData *slay = (SavageSecondaryLayerData*) layer_data;
+     volatile u8      *mmio = sdrv->mmio_base;
+
+     SVGDBG("savageSecondarySetSrcColorKey\n");
+
+     if (slay->config.options == DLOP_SRC_COLORKEY) {
+          u32 reg;
+
+          switch (slay->config.pixelformat) {
+               case DSPF_ARGB1555:
+               case DSPF_RGB16:
+                    reg = 0x14000000;
+                    break;
+               case DSPF_RGB24:
+               case DSPF_RGB32:
+                    reg = 0x17000000;
+                    break;
+               default:
+                    return DFB_UNSUPPORTED;
+          }
+
+          savage_out32(mmio, SAVAGE_CHROMA_KEY_CONTROL,
+                       reg | (r << 16) | (g << 8) | (b));
+          savage_out32(mmio, SAVAGE_CHROMA_KEY_UPPER_BOUND,
+                       0x00000000 | (r << 16) | (g << 8) | (b));
+
+          return DFB_OK;
+     }
+     else {
+          return DFB_UNSUPPORTED;
+     }
+}
+
+static DFBResult
+savageSecondarySetDstColorKey( CoreLayer *layer,
+                               void      *driver_data,
+                               void      *layer_data,
+                               u8         r,
+                               u8         g,
+                               u8         b )
+{
+     SavageDriverData *sdrv = (SavageDriverData*) driver_data;
+     SavageSecondaryLayerData *slay = (SavageSecondaryLayerData*) layer_data;
+     volatile u8      *mmio = sdrv->mmio_base;
+
+     SVGDBG("savageSecondarySetDstColorKey\n");
+
+     if (slay->config.options == DLOP_DST_COLORKEY) {
+          u32 reg;
+
+          switch (dfb_primary_layer_pixelformat()) {
+               case DSPF_RGB16:
+                    reg = 0x14000000;
+                    break;
+               case DSPF_RGB24:
+               case DSPF_RGB32:
+                    reg = 0x17000000;
+                    break;
+               default:
+                    return DFB_UNSUPPORTED;
+          }
+
+          savage_out32(mmio, SAVAGE_CHROMA_KEY_CONTROL,
+                       reg | (r << 16) | (g << 8) | (b));
+          savage_out32(mmio, SAVAGE_CHROMA_KEY_UPPER_BOUND,
+                       0x00000000 | (r << 16) | (g << 8) | (b));
+
+          return DFB_OK;
+     }
+     else {
+          return DFB_UNSUPPORTED;
+     }
+}
+
+static DFBResult
+savageSecondaryFlipBuffers( CoreLayer           *layer,
+                            void                *driver_data,
+                            void                *layer_data,
+                            DFBSurfaceFlipFlags flags )
+{
+     SavageDriverData *sdrv = (SavageDriverData*) driver_data;
+     SavageSecondaryLayerData *slay = (SavageSecondaryLayerData*) layer_data;
+     CoreSurface        *surface = dfb_layer_surface( layer );
+
+     SVGDBG("savageSecondaryFlipBuffers\n");
+
+     dfb_surface_flip_buffers( surface, false );
+
+     secondary_calc_regs(sdrv, slay, layer, &slay->config);
+     secondary_set_regs(sdrv, slay);
+
+     if (flags & DSFLIP_WAIT)
+          dfb_layer_wait_vsync( dfb_layer_at( DLID_PRIMARY ) );
+
+     return DFB_OK;
+}
+
+
+static DFBResult
+savageSecondarySetColorAdjustment( CoreLayer          *layer,
+                                   void               *driver_data,
+                                   void               *layer_data,
+                                   DFBColorAdjustment *adj )
+{
+     SavageDriverData *sdrv = (SavageDriverData*) driver_data;
+     SavageSecondaryLayerData *slay = (SavageSecondaryLayerData*) layer_data;
+     volatile u8      *mmio = sdrv->mmio_base;
+
+     SVGDBG("savageSecondaryColorAdjustment b:%i c:%i h:%i s:%i\n",
+            adj->brightness, adj->contrast, adj->hue, adj->saturation);
+
+     if ((slay->regs.SSTREAM_FB_SIZE & 0x00400000) == 0) {
+          /* secondary is yuv format */
+          u32 reg;
+          long sat = adj->saturation * 16 / 65536;
+          double hue = (adj->hue - 0x8000) * 3.141592654 / 32768.0;
+          unsigned char hs1 = ((char)(sat * cos(hue))) & 0x1f;
+          unsigned char hs2 = ((char)(sat * sin(hue))) & 0x1f;
+
+          reg = 0x80008000 | (adj->brightness >> 8) |
+                ((adj->contrast & 0xf800) >> 3) | (hs1 << 16) | (hs2 << 24);
+
+          savage_out32(mmio, SAVAGE_COLOR_ADJUSTMENT, reg);
+
+          return DFB_OK;
+     }
+     else {
+          /* secondary is rgb format */
+          return DFB_UNSUPPORTED;
+     }
+}
+
+DisplayLayerFuncs savageSecondaryFuncs = {
+     LayerDataSize:      savageSecondaryLayerDataSize,
+     InitLayer:          savageSecondaryInitLayer,
+     Enable:             savageSecondaryEnable,
+     Disable:            savageSecondaryDisable,
+     TestConfiguration:  savageSecondaryTestConfiguration,
+     SetConfiguration:   savageSecondarySetConfiguration,
+     SetOpacity:         savageSecondarySetOpacity,
+     SetScreenLocation:  savageSecondarySetScreenLocation,
+     SetSrcColorKey:     savageSecondarySetSrcColorKey,
+     SetDstColorKey:     savageSecondarySetDstColorKey,
+     /*GetLevel:*/
+     /*SetLevel:*/
+     FlipBuffers:        savageSecondaryFlipBuffers,
+     SetColorAdjustment: savageSecondarySetColorAdjustment,
+     /*SetPalette:*/
+     /*AllocateSurface:*/
+     /*ReallocateSurface:*/
+     /*DeallocateSurface:*/
+};
+
+/* secondary internal */
+static void
+secondary_set_regs(SavageDriverData *sdrv, SavageSecondaryLayerData *slay)
+{
+     volatile u8 *mmio = sdrv->mmio_base;
+
+     SVGDBG("secondary_set_regs\n");
+
+     savage_out32(mmio, SAVAGE_SECONDARY_STREAM_CONTROL,
+                  slay->regs.SSTREAM_CTRL);
+     savage_out32(mmio, SAVAGE_SECONDARY_STREAM_HORIZONTAL_SCALING,
+                  slay->regs.SSTREAM_H_SCALE);
+     savage_out32(mmio, SAVAGE_BLEND_CONTROL,
+                  slay->regs.BLEND_CTRL);
+     savage_out32(mmio, SAVAGE_SECONDARY_STREAM_MULTIPLE_BUFFER_SUPPORT,
+                  slay->regs.SSTREAM_MULTIBUF);
+     savage_out32(mmio, SAVAGE_SECONDARY_STREAM_FRAME_BUFFER_ADDRESS0,
+                  slay->regs.SSTREAM_FB_ADDR0);
+     savage_out32(mmio, SAVAGE_SECONDARY_STREAM_FRAME_BUFFER_ADDRESS1,
+                  slay->regs.SSTREAM_FB_ADDR1);
+     savage_out32(mmio, SAVAGE_SECONDARY_STREAM_FRAME_BUFFER_ADDRESS2,
+                  slay->regs.SSTREAM_FB_ADDR2);
+     savage_out32(mmio, SAVAGE_SECONDARY_STREAM_FRAME_BUFFER_SIZE,
+                  slay->regs.SSTREAM_FB_SIZE);
+     savage_out32(mmio, SAVAGE_SECONDARY_STREAM_STRIDE,
+                  slay->regs.SSTREAM_STRIDE);
+     savage_out32(mmio, SAVAGE_SECONDARY_STREAM_VERTICAL_SCALING,
+                  slay->regs.SSTREAM_V_SCALE);
+     savage_out32(mmio, SAVAGE_SECONDARY_STREAM_SOURCE_LINE_COUNT,
+                  slay->regs.SSTREAM_SRC_LINE_COUNT);
+     savage_out32(mmio, SAVAGE_SECONDARY_STREAM_VERTICAL_INITIAL_VALUE,
+                  slay->regs.SSTREAM_V_INIT_VALUE);
+     savage_out32(mmio, SAVAGE_SECONDARY_STREAM_WINDOW_START,
+                  slay->regs.SSTREAM_WIN_START);
+     savage_out32(mmio, SAVAGE_SECONDARY_STREAM_WINDOW_SIZE,
+                  slay->regs.SSTREAM_WIN_SIZE);
+     savage_out32(mmio, SAVAGE_SECONDARY_STREAM_FB_CB_ADDRESS,
+                  slay->regs.SSTREAM_FB_CB_ADDR);
+     savage_out32(mmio, SAVAGE_SECONDARY_STREAM_FB_CR_ADDRESS,
+                  slay->regs.SSTREAM_FB_CR_ADDR);
+     savage_out32(mmio, SAVAGE_SECONDARY_STREAM_CBCR_STRIDE,
+                  slay->regs.SSTREAM_CBCR_STRIDE);
+
+     /* Set FIFO L2 on second stream. */
+     {
+          int pitch = slay->video_pitch;
+          unsigned char cr92;
+
+          SVGDBG("FIFO L2 pitch:%i\n", pitch);
+          pitch = (pitch + 7) / 8;
+          vga_out8(mmio, 0x3d4, 0x92);
+          cr92 = vga_in8( mmio, 0x3d5);
+          vga_out8(mmio, 0x3d5, (cr92 & 0x40) | (pitch >> 8) | 0x80);
+          vga_out8(mmio, 0x3d4, 0x93);
+          vga_out8(mmio, 0x3d5, pitch);
+     }
+}
+
+static void
+secondary_calc_regs(SavageDriverData         *sdrv,
+                    SavageSecondaryLayerData *slay,
+                    CoreLayer                *layer,
+                    DFBDisplayLayerConfig    *config)
+{
+     CoreSurface * surface = dfb_layer_surface(layer);
+     SurfaceBuffer * front_buffer = surface->front_buffer;
+     /* source size */
+     const int src_w = surface->config.size.w;
+     const int src_h = surface->config.size.h;
+     /* destination size */
+     const int drw_w = slay->dest.w;
+     const int drw_h = slay->dest.h;
+
+     SVGDBG("secondary_calc_regs x:%i y:%i w:%i h:%i\n",
+            slay->dest.x, slay->dest.y, slay->dest.w, slay->dest.h);
+     SVGDBG("w:%i h:%i pitch:%i video.offset:%x\n", surface->config.size.w,
+            surface->config.size.h, front_buffer->video.pitch,
+            front_buffer->video.offset);
+
+     slay->video_pitch = 1;
+     slay->regs.SSTREAM_FB_SIZE = (((front_buffer->video.pitch *
+                                     surface->config.size.h) / 8) - 1) & 0x003fffff;
+
+     switch (surface->config.format) {
+          case DSPF_ARGB1555:
+               SVGDBG("secondary set to DSPF_ARGB1555\n");
+               slay->regs.SSTREAM_FB_SIZE |= 0x00400000;
+               slay->regs.SSTREAM_CTRL = SAVAGE_SECONDARY_STREAM_CONTROL_SSIDF_KRGB16;
+               break;
+          case DSPF_RGB16:
+               SVGDBG("secondary set to DSPF_RGB16\n");
+               slay->regs.SSTREAM_FB_SIZE |= 0x00400000;
+               slay->regs.SSTREAM_CTRL = SAVAGE_SECONDARY_STREAM_CONTROL_SSIDF_RGB16;
+               break;
+          case DSPF_RGB24:
+               SVGDBG("secondary set to DSPF_RGB24\n");
+               slay->regs.SSTREAM_FB_SIZE |= 0x00400000;
+               slay->regs.SSTREAM_CTRL = SAVAGE_SECONDARY_STREAM_CONTROL_SSIDF_RGB24;
+               break;
+          case DSPF_RGB32:
+               SVGDBG("secondary set to DSPF_RGB32\n");
+               slay->regs.SSTREAM_FB_SIZE |= 0x00400000;
+               slay->regs.SSTREAM_CTRL = SAVAGE_SECONDARY_STREAM_CONTROL_SSIDF_RGB32;
+               break;
+          case DSPF_YUY2:
+               SVGDBG("secondary set to DSPF_YUY2\n");
+               slay->regs.SSTREAM_CTRL = SAVAGE_SECONDARY_STREAM_CONTROL_SSIDF_YCbCr422;
+               break;
+          case DSPF_UYVY:
+               SVGDBG("secondary set to DSPF_UYVY\n");
+               slay->regs.SSTREAM_CTRL = SAVAGE_SECONDARY_STREAM_CONTROL_SSIDF_CbYCrY422;
+               break;
+          case DSPF_I420:
+               SVGDBG("secondary set to DSPF_I420\n");
+               slay->video_pitch = 2;
+               slay->regs.SSTREAM_CTRL = SAVAGE_SECONDARY_STREAM_CONTROL_SSIDF_YCbCr420;
+               slay->regs.SSTREAM_FB_CB_ADDR = front_buffer->video.offset +
+                                               (surface->config.size.h * front_buffer->video.pitch);
+               slay->regs.SSTREAM_FB_CR_ADDR = slay->regs.SSTREAM_FB_CB_ADDR +
+                                               ((surface->config.size.h * front_buffer->video.pitch)/4);
+               slay->regs.SSTREAM_CBCR_STRIDE = ((front_buffer->video.pitch/2)
+                                                 & 0x00001fff);
+               break;
+          case DSPF_YV12:
+               SVGDBG("secondary set to DSPF_YV12\n");
+               slay->video_pitch = 2;
+               slay->regs.SSTREAM_CTRL = SAVAGE_SECONDARY_STREAM_CONTROL_SSIDF_YCbCr420;
+               slay->regs.SSTREAM_FB_CR_ADDR = front_buffer->video.offset +
+                                               surface->config.size.h * front_buffer->video.pitch;
+               slay->regs.SSTREAM_FB_CB_ADDR = slay->regs.SSTREAM_FB_CR_ADDR +
+                                               (surface->config.size.h * front_buffer->video.pitch)/4;
+               slay->regs.SSTREAM_CBCR_STRIDE = ((front_buffer->video.pitch/2)
+                                                 & 0x00001fff);
+               break;
+          default:
+               D_BUG("unexpected secondary pixelformat");
+               return;
+     }
+
+     slay->regs.SSTREAM_CTRL |= src_w;
+
+     switch (config->options) {
+          case DLOP_ALPHACHANNEL:
+               SVGDBG("secondary option DLOP_ALPHACHANNEL\n");
+               slay->regs.BLEND_CTRL = SAVAGE_BLEND_CONTROL_COMP_ALPHA;
+               break;
+          case DLOP_SRC_COLORKEY:
+               SVGDBG("secondary option DLOP_SRC_COLORKEY\n");
+               slay->regs.BLEND_CTRL = SAVAGE_BLEND_CONTROL_COMP_SCOLORKEY;
+               break;
+          case DLOP_DST_COLORKEY:
+               SVGDBG("secondary option DLOP_DST_COLORKEY\n");
+               slay->regs.BLEND_CTRL = SAVAGE_BLEND_CONTROL_COMP_PCOLORKEY;
+               break;
+          case DLOP_OPACITY:
+               SVGDBG("secondary option DLOP_OPACITY\n");
+               /* fall through */
+          default:
+               SVGDBG("secondary option default\n");
+               slay->regs.BLEND_CTRL = SAVAGE_BLEND_CONTROL_COMP_SSTREAM;
+               break;
+     }
+
+     slay->regs.SSTREAM_H_SCALE = ((32768 * src_w) / drw_w) & 0x0000FFFF;
+     slay->regs.SSTREAM_V_SCALE = ((32768 * src_h) / drw_h) & 0x000FFFFF;
+     slay->regs.SSTREAM_V_INIT_VALUE = 0;
+     slay->regs.SSTREAM_SRC_LINE_COUNT = src_h & 0x7ff;
+     slay->regs.SSTREAM_MULTIBUF = 0;
+     slay->regs.SSTREAM_FB_ADDR0 = front_buffer->video.offset & 0x01ffffff;
+     slay->regs.SSTREAM_FB_ADDR1 = 0;
+     slay->regs.SSTREAM_FB_ADDR2 = 0;
+     slay->regs.SSTREAM_STRIDE = front_buffer->video.pitch & 0x00001fff;
+     slay->regs.SSTREAM_WIN_START = OS_XY(slay->dest.x, slay->dest.y);
+     slay->regs.SSTREAM_WIN_SIZE = OS_WH(drw_w, drw_h);
+
+     /* remember pitch */
+     slay->video_pitch *= front_buffer->video.pitch;
+}
+
+/* primary layer functions */
+static int
+savagePrimaryLayerDataSize()
+{
+     SVGDBG("savagePrimaryLayerDataSize\n");
+     return sizeof(SavagePrimaryLayerData);
+}
+
+static DFBResult
+savagePrimaryInitLayer( GraphicsDevice        *device,
+                        CoreLayer             *layer,
+                        DisplayLayerInfo      *layer_info,
+                        DFBDisplayLayerConfig *default_config,
+                        DFBColorAdjustment    *default_adj,
+                        void                  *driver_data,
+                        void                  *layer_data )
+{
+     SavagePrimaryLayerData *play = (SavagePrimaryLayerData*) layer_data;
+     DFBResult ret;
+
+     SVGDBG("savagePrimaryInitLayer w:%i h:%i bpp:%i\n",
+            dfb_config->mode.width, dfb_config->mode.height,
+            dfb_config->mode.depth);
+
+     /* call the original initialization function first */
+     ret = savage_pfuncs.InitLayer (device, layer, layer_info,
+                                    default_config, default_adj,
+                                    savage_pdriver_data, layer_data);
+     if (ret)
+          return ret;
+
+     /* set name */
+     snprintf(layer_info->desc.name, DFB_DISPLAY_LAYER_DESC_NAME_LENGTH,
+              "Savage Primary Stream");
+
+     /* add support for options */
+     default_config->flags |= DLCONF_OPTIONS;
+     default_config->options = DLOP_NONE;
+
+     /* add capabilities */
+     layer_info->desc.caps |= DLCAPS_SCREEN_LOCATION;
+
+     play->dx = 0;
+     play->dy = 0;
+     play->init = 0;
+
+     return DFB_OK;
+}
+
+static DFBResult
+savagePrimarySetConfiguration( CoreLayer             *layer,
+                               void                  *driver_data,
+                               void                  *layer_data,
+                               DFBDisplayLayerConfig *config )
+{
+     SavageDriverData *sdrv = (SavageDriverData*) driver_data;
+     SavagePrimaryLayerData *play = (SavagePrimaryLayerData*) layer_data;
+     DFBResult ret;
+
+     SVGDBG("savagePrimarySetConfiguration w:%i h:%i bpp:%i\n",
+            config->width, config->height,
+            DFB_BYTES_PER_PIXEL(config->pixelformat) * 8);
+
+     ret = savage_pfuncs.SetConfiguration(layer, driver_data,
+                                          layer_data, config);
+     if (ret != DFB_OK)
+          return ret;
+
+     /* remember configuration */
+     play->config = *config;
+
+     primary_calc_regs(sdrv, play, layer, config);
+     primary_set_regs(sdrv, play);
+
+     return DFB_OK;
+}
+
+static DFBResult
+savagePrimarySetScreenLocation( CoreLayer *layer,
+                                void      *driver_data,
+                                void      *layer_data,
+                                float      x,
+                                float      y,
+                                float      width,
+                                float      height )
+{
+     SavageDriverData *sdrv = (SavageDriverData*) driver_data;
+     SavagePrimaryLayerData *play = (SavagePrimaryLayerData*) layer_data;
+
+     SVGDBG("savagePrimarySetScreenLocation x:%f y:%f w:%f h:%f\n",
+            x, y, width, height);
+
+     if (width != 1  ||  height != 1)
+          return DFB_UNSUPPORTED;
+
+     play->dx = (int)(x * (float)play->config.width + 0.5f);
+     play->dy = (int)(y * (float)play->config.height + 0.5f);
+
+     primary_calc_regs(sdrv, play, layer, &play->config);
+     primary_set_regs(sdrv, play);
+
+     return DFB_OK;
+}
+
+DisplayLayerFuncs savagePrimaryFuncs = {
+     LayerDataSize:      savagePrimaryLayerDataSize,
+     InitLayer:          savagePrimaryInitLayer,
+     /*Enable:             savagePrimaryEnable,*/
+     /*Disable:            savagePrimaryDisable,*/
+     /*TestConfiguration:  savagePrimaryTestConfiguration,*/
+     SetConfiguration:   savagePrimarySetConfiguration,
+     /*SetOpacity:         savagePrimarySetOpacity,*/
+     SetScreenLocation:  savagePrimarySetScreenLocation,
+     /*SetSrcColorKey:     savagePrimarySetSrcColorKey,*/
+     /*SetDstColorKey:     savagePrimarySetDstColorKey,*/
+     /*GetLevel:*/
+     /*SetLevel:*/
+     /*FlipBuffers:        savagePrimaryFlipBuffers,*/
+     /*SetColorAdjustment: savagePrimarySetColorAdjustment,*/
+     /*SetPalette:*/
+     /*AllocateSurface:    savagePrimaryAllocateSurface,*/
+     /*ReallocateSurface:*/
+     /*DeallocateSurface:*/
+};
+
+/* primary internal */
+static void
+primary_set_regs(SavageDriverData *sdrv, SavagePrimaryLayerData *play)
+{
+     volatile u8 *mmio = sdrv->mmio_base;
+
+     SVGDBG("primary_set_regs\n");
+
+     /* turn streams on */
+     streamOnOff(sdrv, 1);
+
+     /* setup primary stream */
+     savage_out32(mmio, SAVAGE_PRIMARY_STREAM_WINDOW_START,
+                  play->regs.PSTREAM_WIN_START);
+     savage_out32(mmio, SAVAGE_PRIMARY_STREAM_WINDOW_SIZE,
+                  play->regs.PSTREAM_WIN_SIZE);
+     savage_out32(mmio, SAVAGE_PRIMARY_STREAM_FRAME_BUFFER_ADDRESS0,
+                  play->regs.PSTREAM_FB_ADDR0);
+     savage_out32(mmio, SAVAGE_PRIMARY_STREAM_FRAME_BUFFER_ADDRESS1,
+                  play->regs.PSTREAM_FB_ADDR1);
+     savage_out32(mmio, SAVAGE_PRIMARY_STREAM_STRIDE,
+                  play->regs.PSTREAM_STRIDE);
+     savage_out32(mmio, SAVAGE_PRIMARY_STREAM_CONTROL,
+                  play->regs.PSTREAM_CTRL);
+     savage_out32(mmio, SAVAGE_PRIMARY_STREAM_FRAME_BUFFER_SIZE,
+                  play->regs.PSTREAM_FB_SIZE);
+
+     if (play->init == 0) {
+          /* tweak */
+          /* fifo fetch delay register */
+          vga_out8( mmio, 0x3d4, 0x85 );
+          SVGDBG( "cr85: 0x%02x\n", vga_in8( mmio, 0x3d5 ) );
+          vga_out8( mmio, 0x3d5, 0x00 );
+
+          /* force high priority for display channel memory */
+          vga_out8( mmio, 0x3d4, 0x88 );
+          SVGDBG( "cr88: 0x%02x\n", vga_in8( mmio, 0x3d5 ) );
+          vga_out8( mmio, 0x3d5, vga_in8( mmio, 0x3d5 ) & ~0x01 );
+
+          /* primary stream timeout register */
+          vga_out8( mmio, 0x3d4, 0x71 );
+          SVGDBG( "cr71: 0x%02x\n", vga_in8( mmio, 0x3d5 ) );
+
+          /* secondary stream timeout register */
+          vga_out8( mmio, 0x3d4, 0x73 );
+          SVGDBG( "cr73: 0x%02x\n", vga_in8( mmio, 0x3d5 ) );
+
+          /* set primary stream to use memory mapped io */
+          vga_out8( mmio, 0x3d4, 0x69 );
+          SVGDBG( "cr69: 0x%02x\n", vga_in8( mmio, 0x3d5 ) );
+          vga_out8( mmio, 0x3d5, vga_in8( mmio, 0x3d5 ) | 0x80 );
+
+          /* enable certain registers to be loaded on vsync */
+          vga_out8( mmio, 0x3d4, 0x51 );
+          SVGDBG( "cr51: 0x%02x\n", vga_in8( mmio, 0x3d5 ) );
+          vga_out8( mmio, 0x3d5, vga_in8( mmio, 0x3d5 ) | 0x80 );
+
+          /* setup secondary stream */
+          savage_out32(mmio, SAVAGE_CHROMA_KEY_CONTROL, 0);
+          savage_out32(mmio, SAVAGE_SECONDARY_STREAM_CONTROL, 0);
+          savage_out32(mmio, SAVAGE_CHROMA_KEY_UPPER_BOUND, 0);
+          savage_out32(mmio, SAVAGE_SECONDARY_STREAM_HORIZONTAL_SCALING, 0);
+          savage_out32(mmio, SAVAGE_COLOR_ADJUSTMENT, 0);
+          savage_out32(mmio, SAVAGE_BLEND_CONTROL, 1 << 24);
+          savage_out32(mmio, SAVAGE_SECONDARY_STREAM_MULTIPLE_BUFFER_SUPPORT, 0);
+          savage_out32(mmio, SAVAGE_SECONDARY_STREAM_FRAME_BUFFER_ADDRESS0, 0);
+          savage_out32(mmio, SAVAGE_SECONDARY_STREAM_FRAME_BUFFER_ADDRESS1, 0);
+          savage_out32(mmio, SAVAGE_SECONDARY_STREAM_FRAME_BUFFER_ADDRESS2, 0);
+          savage_out32(mmio, SAVAGE_SECONDARY_STREAM_FRAME_BUFFER_SIZE, 0);
+          savage_out32(mmio, SAVAGE_SECONDARY_STREAM_STRIDE, 0);
+          savage_out32(mmio, SAVAGE_SECONDARY_STREAM_VERTICAL_SCALING, 0);
+          savage_out32(mmio, SAVAGE_SECONDARY_STREAM_SOURCE_LINE_COUNT, 0);
+          savage_out32(mmio, SAVAGE_SECONDARY_STREAM_VERTICAL_INITIAL_VALUE, 0);
+          savage_out32(mmio, SAVAGE_SECONDARY_STREAM_WINDOW_START,
+                       OS_XY(0xfffe, 0xfffe));
+          savage_out32(mmio, SAVAGE_SECONDARY_STREAM_WINDOW_SIZE,
+                       OS_WH(10,2));
+
+          play->init = 1;
+     }
+}
+
+static void
+primary_calc_regs(SavageDriverData       *sdrv,
+                  SavagePrimaryLayerData *play,
+                  CoreLayer              *layer,
+                  DFBDisplayLayerConfig  *config)
+{
+     CoreSurface * surface = dfb_layer_surface(layer);
+     SurfaceBuffer * front_buffer = surface->front_buffer;
+
+     SVGDBG("primary_calc_regs w:%i h:%i pitch:%i video.offset:%x\n",
+            surface->config.size.w, surface->config.size.h, front_buffer->video.pitch,
+            front_buffer->video.offset);
+
+     switch (surface->config.format) {
+          case DSPF_ARGB1555:
+               SVGDBG("primary set to DSPF_ARGB1555\n");
+               play->regs.PSTREAM_CTRL = SAVAGE_PRIMARY_STREAM_CONTROL_PSIDF_KRGB16;
+               break;
+          case DSPF_RGB16:
+               SVGDBG("primary set to DSPF_RGB16\n");
+               play->regs.PSTREAM_CTRL = SAVAGE_PRIMARY_STREAM_CONTROL_PSIDF_RGB16;
+               break;
+          case DSPF_RGB24:
+               SVGDBG("primary set to DSPF_RGB24 (unaccelerated)\n");
+               play->regs.PSTREAM_CTRL = SAVAGE_PRIMARY_STREAM_CONTROL_PSIDF_RGB24;
+               break;
+          case DSPF_RGB32:
+               SVGDBG("primary set to DSPF_RGB32\n");
+               play->regs.PSTREAM_CTRL = SAVAGE_PRIMARY_STREAM_CONTROL_PSIDF_RGB32;
+               break;
+          case DSPF_ARGB:
+               SVGDBG("primary set to DSPF_ARGB\n");
+               play->regs.PSTREAM_CTRL = SAVAGE_PRIMARY_STREAM_CONTROL_PSIDF_ARGB;
+               break;
+          case DSPF_RGB332:
+               SVGDBG("primary set to DSPF_RGB332\n");
+               play->regs.PSTREAM_CTRL = SAVAGE_PRIMARY_STREAM_CONTROL_PSIDF_CLUT;
+               break;
+          default:
+               D_BUG("unexpected primary pixelformat");
+               return;
+     }
+
+     play->regs.PSTREAM_FB_ADDR0 = front_buffer->video.offset & 0x01ffffff;
+     play->regs.PSTREAM_FB_ADDR1 = 0;
+     play->regs.PSTREAM_STRIDE = front_buffer->video.pitch & 0x00001fff;
+     play->regs.PSTREAM_WIN_START = OS_XY(play->dx, play->dy);
+     play->regs.PSTREAM_WIN_SIZE = OS_WH(surface->config.size.w, surface->config.size.h);
+     play->regs.PSTREAM_FB_SIZE = (((front_buffer->video.pitch *
+                                     surface->config.size.h) / 8) - 1) & 0x003fffff;
+}
+/* end of code */
diff --git a/DirectFB-1.3.0/gfxdrivers/sh7722/Makefile.am b/DirectFB-1.3.0/gfxdrivers/sh7722/Makefile.am
index 08fe178..65b9304 100644
--- a/DirectFB-1.3.0/gfxdrivers/sh7722/Makefile.am
+++ b/DirectFB-1.3.0/gfxdrivers/sh7722/Makefile.am
@@ -2,16 +2,11 @@
 
 EXTRA_DIST = \
 	directfbrc.sh7722		\
-	directfbrc.sh7723		\
 	Makefile.kernel			\
 	README.sh7722			\
-	kernel-module/sh772x_driver.c	\
-	kernel-module/sh772x_gfx.h	\
-	kernel-module/sh7722.c		\
-	kernel-module/sh7722.h		\
-	kernel-module/sh7723.c		\
-	kernel-module/sh7723.h		\
-	kernel-module/Makefile
+	kernel-module/Makefile		\
+	kernel-module/sh7722gfx.c	\
+	kernel-module/sh7722gfx.h
 
 INCLUDES = \
 	-I$(top_srcdir)/include		\
@@ -56,8 +51,6 @@ libdirectfb_sh7722_la_SOURCES =	\
 	sh7722.h		\
 	sh7722_blt.c		\
 	sh7722_blt.h		\
-	sh7723_blt.c		\
-	sh7723_blt.h		\
 	sh7722_jpeg.c		\
 	sh7722_layer.c		\
 	sh7722_layer.h		\
diff --git a/DirectFB-1.3.0/gfxdrivers/sh7722/Makefile.kernel b/DirectFB-1.3.0/gfxdrivers/sh7722/Makefile.kernel
index 8b6be07..91d0fcc 100644
--- a/DirectFB-1.3.0/gfxdrivers/sh7722/Makefile.kernel
+++ b/DirectFB-1.3.0/gfxdrivers/sh7722/Makefile.kernel
@@ -1,23 +1,8 @@
-KERNEL_VERSION  ?= $(shell uname -r)
-KERNEL_MODLIB   ?= /lib/modules/$(KERNEL_VERSION)
-KERNEL_BUILD    ?= $(SYSROOT)$(KERNEL_MODLIB)/build
-KERNEL_SOURCE   ?= $(SYSROOT)$(KERNEL_MODLIB)/source
-
-ifeq ($(shell test -L $(KERNEL_BUILD) && echo yes),yes)
-  KERNEL_BUILD := $(SYSROOT)$(shell readlink $(KERNEL_BUILD))
-endif
-
-ifeq ($(shell test -L $(KERNEL_SOURCE) && echo yes),yes)
-  KERNEL_SOURCE := $(SYSROOT)$(shell readlink $(KERNEL_SOURCE))
-endif
-
-K_VERSION    := $(shell echo $(KERNEL_VERSION) | cut -d . -f 1)
-K_PATCHLEVEL := $(shell echo $(KERNEL_VERSION) | cut -d . -f 2)
-K_SUBLEVEL   := $(shell echo $(KERNEL_VERSION) | cut -d . -f 3 | cut -d '-' -f 1)
-
-
-DESTDIR ?= $(SYSROOT)
+KERNEL_SOURCE  = /home/taki/AP325/linux-2.6.21.1
+KERNEL_BUILD   = $(KERNEL_SOURCE)
+KERNEL_VERSION = 2.6.21.1
 
+DESTDIR = /export/nfs/ap325/rootfs
 
 ifeq ($(DEBUG_2DG),yes)
   CPPFLAGS += -DSH7722GFX_DEBUG_2DG
@@ -35,27 +20,18 @@ ifeq ($(shell test -e $(KERNEL_BUILD)/include/linux/config.h && echo yes),yes)
   CPPFLAGS += -DHAVE_LINUX_CONFIG_H
 endif
     
-check-version = $(shell expr \( $(K_VERSION) \* 65536 + $(K_PATCHLEVEL) \* 256 + $(K_SUBLEVEL) \) \>= \( $(1) \* 65536 + $(2) \* 256 + $(3) \))
-
-.PHONY: all install clean
 
 all:
-ifeq ($(call check-version,2,6,24),1)
-	$(MAKE) -C $(KERNEL_BUILD) \
-		KCPPFLAGS="$(CPPFLAGS) -I`pwd`/kernel-module" \
-		SUBDIRS="`pwd`/kernel-module" modules
-else
-	$(MAKE) -C $(KERNEL_BUILD) \
+	make -C $(KERNEL_SOURCE) \
 		CPPFLAGS="$(CPPFLAGS) -D__KERNEL__ -I`pwd`/kernel-module -I$(KERNEL_BUILD)/include -I$(KERNEL_SOURCE)/include $(AUTOCONF_H)" \
 		SUBDIRS="`pwd`/kernel-module" modules
-endif
 
 clean:
 	rm -rf kernel-module/*.*o kernel-module/.*.*o* kernel-module/*.mod.c kernel-module/.tmp_versions
 
 install: all
 	install -v -m 0755 -d $(DESTDIR)/lib/modules/$(KERNEL_VERSION)/renesas
-	install -v -m 0644 kernel-module/sh772x_gfx.ko $(DESTDIR)/lib/modules/$(KERNEL_VERSION)/renesas/
+	install -v -m 0644 kernel-module/sh7722gfx.ko $(DESTDIR)/lib/modules/$(KERNEL_VERSION)/renesas/
 
 
 .PHONY: all clean
diff --git a/DirectFB-1.3.0/gfxdrivers/sh7722/directfbrc.sh7722 b/DirectFB-1.3.0/gfxdrivers/sh7722/directfbrc.sh7722
index 7417294..7bba321 100644
--- a/DirectFB-1.3.0/gfxdrivers/sh7722/directfbrc.sh7722
+++ b/DirectFB-1.3.0/gfxdrivers/sh7722/directfbrc.sh7722
@@ -1,10 +1,9 @@
-
 system = devmem
 
-video-phys   = f800000	# Requires 'mem=120M' kernel option!!!!!
-video-length = 8388608	# 8MB of physically contiguous memory for acceleration
+video-phys   = f800000
+video-length = 8388608
 
-mmio-phys    = fd000000	# Start of 2DG register space
-mmio-length  = 65536	# Size of register space
+mmio-phys    = fd000000
+mmio-length  = 33554432
 
-accelerator  = 11591	# 0x2D47 (2DG)
+accelerator  = 11591
diff --git a/DirectFB-1.3.0/gfxdrivers/sh7722/kernel-module/Makefile b/DirectFB-1.3.0/gfxdrivers/sh7722/kernel-module/Makefile
index d054dd5..06ae468 100644
--- a/DirectFB-1.3.0/gfxdrivers/sh7722/kernel-module/Makefile
+++ b/DirectFB-1.3.0/gfxdrivers/sh7722/kernel-module/Makefile
@@ -1,3 +1 @@
-obj-m += sh772x_gfx.o
-
-sh772x_gfx-y += sh772x_driver.o sh7722.o sh7723.o
+obj-m += sh7722gfx.o
diff --git a/DirectFB-1.3.0/gfxdrivers/sh7722/kernel-module/sh7722gfx.c b/DirectFB-1.3.0/gfxdrivers/sh7722/kernel-module/sh7722gfx.c
new file mode 100644
index 0000000..674035f
--- /dev/null
+++ b/DirectFB-1.3.0/gfxdrivers/sh7722/kernel-module/sh7722gfx.c
@@ -0,0 +1,1104 @@
+/*
+ * SH7722/SH7723 Graphics Device
+ *
+ * Copyright (C) 2006-2008  IGEL Co.,Ltd
+ *
+ * Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License v2
+ * as published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/version.h>
+
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/miscdevice.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#include <sh7722gfx.h>
+
+//#define SH7722GFX_DEBUG_2DG
+#define SH7722GFX_DEBUG_JPU
+//#define SH7722GFX_IRQ_POLLER
+
+/**********************************************************************************************************************/
+
+#define ENGINE_REG_TOP   0xFD000000
+#define SH7722_VEU_BASE  0xFE920000
+#define SH7722_BEU_BASE  0xFE930000
+#define SH7722_JPU_BASE  0xFEA00000
+
+#define BEM_REG(x)       (*(volatile u32*)((x)+ENGINE_REG_TOP))
+#define VEU_REG(x)       (*(volatile u32*)((x)+SH7722_VEU_BASE))
+#define BEU_REG(x)       (*(volatile u32*)((x)+SH7722_BEU_BASE))
+#define JPU_REG(x)       (*(volatile u32*)((x)+SH7722_JPU_BASE))
+
+#define BEM_HC_STATUS              BEM_REG(0x00000)
+#define BEM_HC_RESET               BEM_REG(0x00004)
+#define BEM_HC_CLOCK               BEM_REG(0x00008)
+#define BEM_HC_INT_STATUS          BEM_REG(0x00020)
+#define BEM_HC_INT_MASK            BEM_REG(0x00024)
+#define BEM_HC_INT_CLEAR           BEM_REG(0x00028)
+#define BEM_HC_CACHE_FLUSH         BEM_REG(0x0002C)
+#define BEM_HC_DMA_ADR             BEM_REG(0x00040)
+#define BEM_HC_DMA_START           BEM_REG(0x00044)
+#define BEM_HC_DMA_STOP            BEM_REG(0x00048)
+#define BEM_PE_CACHE               BEM_REG(0x010B0)
+
+#define BEVTR                      BEU_REG(0x0018C)
+
+#define JPU_JCCMD                  JPU_REG(0x00004)
+#define JPU_JCSTS                  JPU_REG(0x00008)
+#define JPU_JINTE                  JPU_REG(0x00038)
+#define JPU_JINTS                  JPU_REG(0x0003C)
+#define JPU_JCDERR                 JPU_REG(0x00040)
+#define JPU_JCRST                  JPU_REG(0x00044)
+#define JPU_JIFDDVSZ               JPU_REG(0x000B4)
+#define JPU_JIFDDHSZ               JPU_REG(0x000B8)
+#define JPU_JIFDDYA1               JPU_REG(0x000BC)
+#define JPU_JIFDDCA1               JPU_REG(0x000C0)
+#define JPU_JIFDDYA2               JPU_REG(0x000C4)
+#define JPU_JIFDDCA2               JPU_REG(0x000C8)
+#define JPU_JIFESYA1               JPU_REG(0x00074)
+#define JPU_JIFESCA1               JPU_REG(0x00078)
+#define JPU_JIFESYA2               JPU_REG(0x0007C)
+#define JPU_JIFESCA2               JPU_REG(0x00080)
+                                              
+#define VEU_VESTR                  VEU_REG(0x00000)
+#define VEU_VSAYR                  VEU_REG(0x00018)
+#define VEU_VSACR                  VEU_REG(0x0001c)
+#define VEU_VDAYR                  VEU_REG(0x00034)
+#define VEU_VDACR                  VEU_REG(0x00038)
+#define VEU_VEVTR                  VEU_REG(0x000A4)
+
+#define JINTS_MASK                 0x00007CE8
+#define JINTS_INS3_HEADER          0x00000008
+#define JINTS_INS5_ERROR           0x00000020
+#define JINTS_INS6_DONE            0x00000040
+#define JINTS_INS10_XFER_DONE      0x00000400
+#define JINTS_INS11_LINEBUF0       0x00000800
+#define JINTS_INS12_LINEBUF1       0x00001000
+#define JINTS_INS13_LOADED         0x00002000
+#define JINTS_INS14_RELOAD         0x00004000
+
+#define JCCMD_START                0x00000001
+#define JCCMD_RESTART              0x00000002
+#define JCCMD_END                  0x00000004
+#define JCCMD_RESET                0x00000080
+#define JCCMD_LCMD2                0x00000100
+#define JCCMD_LCMD1                0x00000200
+#define JCCMD_READ_RESTART         0x00000400
+#define JCCMD_WRITE_RESTART        0x00000800
+
+/**********************************************************************************************************************/
+
+#ifdef SH7722GFX_DEBUG_2DG
+#define QPRINT(x...)     do {                                                        \
+     char buf[128];                                                                  \
+     struct timeval tv;                                                              \
+     do_gettimeofday( &tv );                                                         \
+     snprintf( buf, sizeof(buf), x );                                                \
+     printk( KERN_DEBUG "%ld.%03ld.%03ld - %-17s: %s\n",                             \
+             tv.tv_sec - base_time.tv_sec,                                           \
+             tv.tv_usec / 1000, tv.tv_usec % 1000, __FUNCTION__, buf );              \
+} while (0)
+#else
+#define QPRINT(x...)     do {} while (0)
+#endif
+
+#define QDUMP(msg)       QPRINT( "%-12s (%s, hw %5d-%5d, next %5d-%5d, %svalid, "    \
+                                 "HC %07x, INT %06x)", msg,                          \
+                                 shared->hw_running ? "running" : "   idle",         \
+                                 shared->hw_start,                                   \
+                                 shared->hw_end,                                     \
+                                 shared->next_start,                                 \
+                                 shared->next_end,                                   \
+                                 shared->next_valid ? "  " : "in",                   \
+                                 BEM_HC_STATUS, BEM_HC_INT_STATUS );
+
+/**********************************************************************************************************************/
+
+#ifdef SH7722GFX_DEBUG_JPU
+#define JPRINT(x...)     do {                                                        \
+     char buf[128];                                                                  \
+     struct timeval tv;                                                              \
+     do_gettimeofday( &tv );                                                         \
+     snprintf( buf, sizeof(buf), x );                                                \
+     printk( KERN_DEBUG "%ld.%03ld.%03ld - %-17s: %s\n",                             \
+             tv.tv_sec - base_time.tv_sec,                                           \
+             tv.tv_usec / 1000, tv.tv_usec % 1000, __FUNCTION__, buf );              \
+} while (0)
+#else
+#define JPRINT(x...)     do {} while (0)
+#endif
+
+/**********************************************************************************************************************/
+
+static DECLARE_WAIT_QUEUE_HEAD( wait_idle );
+static DECLARE_WAIT_QUEUE_HEAD( wait_next );
+
+static SH7722GfxSharedArea *shared;
+
+static struct timeval       base_time;
+
+static struct page         *shared_page;
+static unsigned int         shared_order;
+
+#ifdef SH7722GFX_IRQ_POLLER
+static int                  stop_poller;
+#endif
+
+/**********************************************************************************************************************/
+
+static DECLARE_WAIT_QUEUE_HEAD( wait_jpeg_irq );
+static DECLARE_WAIT_QUEUE_HEAD( wait_jpeg_run );
+static DECLARE_WAIT_QUEUE_HEAD( wait_jpeg_lock );
+
+static struct page         *jpeg_page;
+static unsigned int         jpeg_order;
+static volatile void       *jpeg_area;
+static u32                  jpeg_buffers;
+static int                  jpeg_buffer;
+static u32                  jpeg_error;
+static int                  jpeg_encode;
+static int                  jpeg_reading;
+static int                  jpeg_writing;
+static int                  jpeg_reading_line;
+static int                  jpeg_writing_line;
+static int                  jpeg_height;
+static int                  jpeg_end;
+static u32                  jpeg_linebufs;
+static int                  jpeg_linebuf;
+static int                  jpeg_line;
+static int                  veu_linebuf;
+static int                  veu_running;
+
+static pid_t                jpeg_locked;
+
+/**********************************************************************************************************************/
+
+static int
+sh7722_reset( SH7722GfxSharedArea *shared )
+{
+     int i;
+
+     do_gettimeofday( &base_time );
+
+     QPRINT( "Resetting hardware..." );
+
+     BEM_HC_CLOCK = 0;
+     for (i=0; i<30000; i++);
+     BEM_HC_CLOCK = 0x1111;
+
+     BEM_HC_RESET = 0x1111;
+     for (i=0; i<30000; i++);
+     BEM_HC_RESET = 0;
+
+
+     QPRINT( "Initializing shared area..." );
+
+     memset( (void*) shared, 0, sizeof(SH7722GfxSharedArea) );
+
+     shared->buffer_phys = virt_to_phys(&shared->buffer[0]);
+     shared->jpeg_phys   = virt_to_phys(jpeg_area);
+     shared->magic       = SH7722GFX_SHARED_MAGIC;
+
+
+     QPRINT( "Clearing interrupts..." );
+
+     BEM_HC_INT_CLEAR = 0x111111;
+     BEM_HC_INT_MASK  = 0x110011;
+
+     BEM_HC_CACHE_FLUSH = 0;
+
+     QDUMP( "Ready" );
+
+     return 0;
+}
+
+static int
+sh7722_wait_idle( SH7722GfxSharedArea *shared )
+{
+     int ret;
+
+     QDUMP( "Waiting....." );
+
+     /* Does not need to be atomic. There's a lock in user space,
+      * but anyhow, this is just for statistics. */
+     shared->num_wait_idle++;
+
+     ret = wait_event_interruptible_timeout( wait_idle, !shared->hw_running, 42*HZ );
+     if (!ret) {
+          printk( KERN_ERR "%s: TIMEOUT! (%srunning, hw %d-%d, next %d-%d - %svalid, "
+                           "STATUS 0x%08x, INT_STATUS 0x%08x)\n",
+                  __FUNCTION__,
+                  shared->hw_running ? "" : "not ",
+                  shared->hw_start,
+                  shared->hw_end,
+                  shared->next_start,
+                  shared->next_end,
+                  shared->next_valid ? "" : "not ",
+                  BEM_HC_STATUS, BEM_HC_INT_STATUS );
+     }
+
+     QDUMP( "........done" );
+
+     return (ret > 0) ? 0 : (ret < 0) ? ret : -ETIMEDOUT;
+}
+
+static int
+sh7722_wait_next( SH7722GfxSharedArea *shared )
+{
+     int ret;
+
+     QDUMP( "Waiting....." );
+
+     /* Does not need to be atomic. There's a lock in user space,
+      * but anyhow, this is just for statistics. */
+     shared->num_wait_next++;
+
+     ret = wait_event_interruptible_timeout( wait_next, !shared->hw_running ||
+                                             shared->next_start == shared->next_end, 42*HZ );
+     if (!ret) {
+          printk( KERN_ERR "%s: TIMEOUT! (%srunning, hw %d-%d, next %d-%d - %svalid, "
+                           "STATUS 0x%08x, INT_STATUS 0x%08x)\n",
+                  __FUNCTION__,
+                  shared->hw_running ? "" : "not ",
+                  shared->hw_start,
+                  shared->hw_end,
+                  shared->next_start,
+                  shared->next_end,
+                  shared->next_valid ? "" : "not ",
+                  BEM_HC_STATUS, BEM_HC_INT_STATUS );
+     }
+
+     QDUMP( "........done" );
+
+     return (ret > 0) ? 0 : (ret < 0) ? ret : -ETIMEDOUT;
+}
+
+/**********************************************************************************************************************/
+
+static int
+sh7722_wait_jpeg( SH7722GfxSharedArea *shared )
+{
+     int ret;
+
+     ret = wait_event_interruptible_timeout( wait_jpeg_irq, shared->jpeg_ints, HZ );
+     if (!ret) {
+          printk( KERN_ERR "%s: TIMEOUT! (status 0x%08x, ints 0x%08x)\n", __FUNCTION__, JPU_JCSTS, JPU_JINTS );
+     }
+
+     return (ret > 0) ? 0 : (ret < 0) ? ret : -ETIMEDOUT;
+}
+
+static int
+sh7722_run_jpeg( SH7722GfxSharedArea *shared,
+                 SH7722JPEG          *jpeg )
+{
+     int ret;
+     int encode  = (jpeg->flags & SH7722_JPEG_FLAG_ENCODE) ? 1 : 0;
+     int convert = (jpeg->flags & SH7722_JPEG_FLAG_CONVERT) ? 1 : 0;
+
+     switch (jpeg->state) {
+          case SH7722_JPEG_START:
+               JPRINT( "START (buffers: %d, flags: 0x%x)", jpeg->buffers, jpeg->flags );
+
+               jpeg_line         = 0;
+               jpeg_end          = 0;
+               jpeg_error        = 0;
+               jpeg_encode       = encode;
+               jpeg_reading      = 0;
+               jpeg_writing      = encode ? 2 : 0;
+               jpeg_reading_line = encode && !convert;
+               jpeg_writing_line = !encode;
+               jpeg_height       = jpeg->height;
+               jpeg_linebuf      = 0;
+               jpeg_linebufs     = 0;
+               jpeg_buffer       = 0;
+               jpeg_buffers      = jpeg->buffers;
+               veu_linebuf       = 0;
+               veu_running       = 0;
+
+               jpeg->state       = SH7722_JPEG_RUN;
+               jpeg->error       = 0;
+
+//               if (!encode || !convert)
+                    JPU_JCCMD = JCCMD_START;
+               break;
+
+          case SH7722_JPEG_RUN:
+               JPRINT( "RUN (buffers: %d)", jpeg->buffers );
+
+               /* Validate loaded buffers. */
+               jpeg_buffers |= jpeg->buffers;
+               break;
+
+          default:
+               printk( KERN_ERR "%s: INVALID STATE %d! (status 0x%08x, ints 0x%08x)\n",
+                       __FUNCTION__, jpeg->state, JPU_JCSTS, JPU_JINTS );
+               return -EINVAL;
+     }
+
+     if (encode) {
+          if (convert) {
+               if (jpeg_linebufs != 3 && !veu_running) {
+                    JPRINT( " '-> convert start (buffers: %d, veu linebuf: %d)", jpeg_buffers, veu_linebuf );
+
+                    veu_running = 1;
+
+                    VEU_VDAYR = veu_linebuf ? JPU_JIFESYA2 : JPU_JIFESYA1;
+                    VEU_VDACR = veu_linebuf ? JPU_JIFESCA2 : JPU_JIFESCA1;
+                    VEU_VESTR = 0x101;
+               }
+          }
+          if (jpeg_buffers && !jpeg_writing) {
+               JPRINT( " '-> write start (buffers: %d)", jpeg_buffers );
+
+               jpeg_writing = 1;
+               JPU_JCCMD = JCCMD_WRITE_RESTART;
+          }
+     }
+     else if (jpeg_buffers && !jpeg_reading) {
+          JPRINT( " '-> read start (buffers: %d)", jpeg_buffers );
+
+          jpeg_reading = 1;
+          JPU_JCCMD = JCCMD_READ_RESTART;
+     }
+
+     ret = wait_event_interruptible_timeout( wait_jpeg_run,
+                                             jpeg_end || jpeg_error ||
+                                             (jpeg_buffers != 3 && (jpeg->flags & SH7722_JPEG_FLAG_RELOAD)), 5 * HZ );
+     if (ret < 0)
+          return ret;
+          
+     if (!ret) {
+          printk( KERN_ERR "%s: TIMEOUT! (JCSTS 0x%08x, JINTS 0x%08x, JCRST 0x%08x)\n", __FUNCTION__,
+                  JPU_JCSTS, JPU_JINTS, JPU_JCRST );
+          return -ETIMEDOUT;
+     }
+
+     if (jpeg_error) {
+          /* Return error. */
+          jpeg->state = SH7722_JPEG_END;
+          jpeg->error = jpeg_error;
+
+          JPRINT( " '-> ERROR (0x%x)", jpeg->error );
+     }
+     else {
+          /* Return buffers to reload or to empty. */
+          jpeg->buffers = jpeg_buffers ^ 3;
+
+          if (jpeg_end) {
+               JPRINT( " '-> END" );
+
+               /* Return end. */
+               jpeg->state    = SH7722_JPEG_END;
+               jpeg->buffers |= 1 << jpeg_buffer;
+          }
+          else if (encode)
+               JPRINT( " '-> LOADED (%d)", jpeg->buffers );
+          else
+               JPRINT( " '-> RELOAD (%d)", jpeg->buffers );
+     }
+
+     return 0;
+}
+
+static int
+sh7722_lock_jpeg( SH7722GfxSharedArea *shared )
+{
+     int ret;
+
+     if (jpeg_locked) {
+          ret = wait_event_interruptible_timeout( wait_jpeg_lock, !jpeg_locked, 5 * HZ );
+          if (ret < 0)
+               return ret;
+               
+          if (!ret) {
+               printk( KERN_ERR "%s: TIMEOUT! (status 0x%08x, ints 0x%08x)\n", __FUNCTION__, JPU_JCSTS, JPU_JINTS );
+               return -ETIMEDOUT;
+          }
+     }
+
+     jpeg_locked = current->pid;
+
+     return 0;
+}
+
+static int
+sh7722_unlock_jpeg( SH7722GfxSharedArea *shared )
+{
+     if (jpeg_locked != current->pid)
+          return -EIO;
+
+     jpeg_locked = 0;
+
+     wake_up_all( &wait_jpeg_lock );
+
+     return 0;
+}
+
+/**********************************************************************************************************************/
+
+static irqreturn_t
+sh7722_jpu_irq( int irq, void *ctx )
+{
+     u32                  ints;
+     SH7722GfxSharedArea *shared = ctx;
+
+     ints = JPU_JINTS;
+
+     JPU_JINTS = ~ints & JINTS_MASK;
+
+     if (ints & (JINTS_INS3_HEADER | JINTS_INS5_ERROR | JINTS_INS6_DONE))
+          JPU_JCCMD = JCCMD_END;
+
+     JPRINT( " ... JPU interrupt 0x%08x (veu_linebuf: %d, jpeg_linebuf: %d, jpeg_linebufs: %d, jpeg_line: %d, jpeg_buffers: %d)",
+             ints, veu_linebuf, jpeg_linebuf, jpeg_linebufs, jpeg_line, jpeg_buffers );
+
+     if (ints) {
+          shared->jpeg_ints |= ints;
+
+          wake_up_all( &wait_jpeg_irq );
+
+          /* Header */
+          if (ints & JINTS_INS3_HEADER) {
+               JPRINT( "         -> HEADER (%dx%d)", JPU_JIFDDHSZ, JPU_JIFDDVSZ );
+          }
+
+          /* Error */
+          if (ints & JINTS_INS5_ERROR) {
+               jpeg_error = JPU_JCDERR;
+
+               JPRINT( "         -> ERROR 0x%08x!", jpeg_error );
+
+               wake_up_all( &wait_jpeg_run );
+          }
+
+          /* Done */
+          if (ints & JINTS_INS6_DONE) {
+               jpeg_end = 1;
+
+               JPRINT( "         -> DONE" );
+
+               wake_up_all( &wait_jpeg_run );
+          }
+
+          /* Done */
+          if (ints & JINTS_INS10_XFER_DONE) {
+               jpeg_end = 1;
+
+               JPRINT( "         -> XFER DONE" );
+
+               wake_up_all( &wait_jpeg_run );
+          }
+
+          /* Line buffer ready? FIXME: encoding */
+          if (ints & (JINTS_INS11_LINEBUF0 | JINTS_INS12_LINEBUF1)) {
+               JPRINT( "         -> LINEBUF %d", jpeg_linebuf );
+
+               if (jpeg_encode) {
+                    jpeg_linebufs &= ~(1 << jpeg_linebuf);
+
+                    jpeg_linebuf = jpeg_linebuf ? 0 : 1;
+
+                    if (jpeg_linebufs) {
+                         jpeg_reading_line = 1;   /* should still be one */
+
+                         if (!jpeg_end)
+                              JPU_JCCMD = JCCMD_LCMD2 | JCCMD_LCMD1;
+                    }
+                    else {
+                         jpeg_reading_line = 0;
+                    }
+
+                    jpeg_line += 16;
+
+                    if (!veu_running && !jpeg_end) {
+                         JPRINT( "         -> CONVERT %d", veu_linebuf );
+
+                         veu_running = 1;
+
+                         VEU_VDAYR = veu_linebuf ? JPU_JIFESYA2 : JPU_JIFESYA1;
+                         VEU_VDACR = veu_linebuf ? JPU_JIFESCA2 : JPU_JIFESCA1;
+                         VEU_VESTR = 0x101;
+                    }
+               }
+               else {
+                    jpeg_linebufs |= (1 << jpeg_linebuf);
+
+                    jpeg_linebuf = jpeg_linebuf ? 0 : 1;
+
+                    if (jpeg_linebufs != 3) {
+                         jpeg_writing_line = 1;   /* should still be one */
+
+                         if (jpeg_line > 0 && !jpeg_end)
+                              JPU_JCCMD = JCCMD_LCMD1 | JCCMD_LCMD2;
+                    }
+                    else {
+                         jpeg_writing_line = 0;
+                    }
+
+                    jpeg_line += 16;
+
+                    if (!veu_running && !jpeg_end && !jpeg_error) {
+                         JPRINT( "         -> CONVERT %d", veu_linebuf );
+
+                         veu_running = 1;
+
+                         VEU_VSAYR = veu_linebuf ? JPU_JIFDDYA2 : JPU_JIFDDYA1;
+                         VEU_VSACR = veu_linebuf ? JPU_JIFDDCA2 : JPU_JIFDDCA1;
+                         VEU_VESTR = 0x101;
+                    }
+               }
+          }
+
+          /* Loaded */
+          if (ints & JINTS_INS13_LOADED) {
+               JPRINT( "         -> LOADED %d (writing: %d)", jpeg_buffer, jpeg_writing );
+
+               jpeg_buffers &= ~(1 << jpeg_buffer);
+
+               jpeg_buffer = jpeg_buffer ? 0 : 1;
+
+               jpeg_writing--;
+
+               wake_up_all( &wait_jpeg_run );
+          }
+
+          /* Reload */
+          if (ints & JINTS_INS14_RELOAD) {
+               JPRINT( "         -> RELOAD %d", jpeg_buffer );
+
+               jpeg_buffers &= ~(1 << jpeg_buffer);
+
+               jpeg_buffer = jpeg_buffer ? 0 : 1;
+
+               if (jpeg_buffers) {
+                    jpeg_reading = 1;   /* should still be one */
+
+                    JPU_JCCMD = JCCMD_READ_RESTART;
+               }
+               else
+                    jpeg_reading = 0;
+
+               wake_up_all( &wait_jpeg_run );
+          }
+     }
+
+     return IRQ_HANDLED;
+}
+
+/**********************************************************************************************************************/
+
+static irqreturn_t
+sh7722_veu_irq( int irq, void *ctx )
+{
+     u32 events = VEU_VEVTR;
+
+     VEU_VEVTR = ~events & 0x101;
+
+     JPRINT( " ... VEU interrupt 0x%08x (veu_linebuf: %d, jpeg_linebuf: %d, jpeg_linebufs: %d, jpeg_line: %d)",
+             events, veu_linebuf, jpeg_linebuf, jpeg_linebufs, jpeg_line );
+
+     if (events & 1)
+          return IRQ_HANDLED;
+
+     if (jpeg_encode) {
+          /* Fill line buffers. */
+          jpeg_linebufs |= 1 << veu_linebuf;
+
+          /* Resume encoding if it was blocked. */
+          if (!jpeg_reading_line && !jpeg_end && !jpeg_error && jpeg_linebufs) {
+               if (jpeg_writing == 2) {
+                    if (jpeg_linebufs == 3) {
+                         JPRINT( "         -> ENCODE START!" );
+
+                         jpeg_reading_line = 1;
+
+                         JPU_JCCMD = JCCMD_LCMD2 | JCCMD_LCMD1;
+                    }
+               }
+               else {
+                    JPRINT( "         -> ENCODE %d", veu_linebuf );
+
+                    jpeg_reading_line = 1;
+
+                    JPU_JCCMD = JCCMD_LCMD2 | JCCMD_LCMD1;
+               }
+          }
+
+          veu_linebuf = veu_linebuf ? 0 : 1;
+
+          if (jpeg_linebufs != 3 && !jpeg_end && !jpeg_error) {
+               JPRINT( "         -> CONVERT %d", veu_linebuf );
+
+               veu_running = 1;   /* should still be one */
+
+               VEU_VDAYR = veu_linebuf ? JPU_JIFESYA2 : JPU_JIFESYA1;
+               VEU_VDACR = veu_linebuf ? JPU_JIFESCA2 : JPU_JIFESCA1;
+               VEU_VESTR = 0x101;
+          }
+          else {
+               veu_running = 0;
+          }
+     }
+     else {
+          /* Release line buffer. */
+          jpeg_linebufs &= ~(1 << veu_linebuf);
+
+          /* Resume decoding if it was blocked. */
+          if (!jpeg_writing_line && !jpeg_end && !jpeg_error && jpeg_linebufs != 3) {
+               JPRINT( "         -> RESUME %d", jpeg_linebuf );
+
+               jpeg_writing_line = 1;
+
+               JPU_JCCMD = JCCMD_LCMD1 | JCCMD_LCMD2;
+          }
+
+          veu_linebuf = veu_linebuf ? 0 : 1;
+
+          if (jpeg_linebufs) {
+               JPRINT( "         -> CONVERT %d", veu_linebuf );
+
+               veu_running = 1;   /* should still be one */
+
+               VEU_VSAYR = veu_linebuf ? JPU_JIFDDYA2 : JPU_JIFDDYA1;
+               VEU_VSACR = veu_linebuf ? JPU_JIFDDCA2 : JPU_JIFDDCA1;
+               VEU_VESTR = 0x101;
+          }
+          else {
+               if (jpeg_end)
+                    wake_up_all( &wait_jpeg_run );
+
+               veu_running = 0;
+          }
+     }
+
+     return IRQ_HANDLED;
+}
+
+/**********************************************************************************************************************/
+
+static irqreturn_t
+sh7722_beu_irq( int irq, void *ctx )
+{
+     BEVTR = 0;
+
+     /* Nothing here so far. But Vsync could be added. */
+
+     return IRQ_HANDLED;
+}
+
+/**********************************************************************************************************************/
+
+static irqreturn_t
+sh7722_tdg_irq( int irq, void *ctx )
+{
+     SH7722GfxSharedArea *shared = ctx;
+     u32                  status = BEM_HC_INT_STATUS;
+
+     if (! (status & 0x111111)) {
+#ifndef SH7722GFX_IRQ_POLLER
+          printk( KERN_WARNING "%s: bogus interrupt, INT_STATUS 0x%08x!\n", __FUNCTION__, status );
+#endif
+          return IRQ_NONE;
+     }
+
+     if (status & ~0x100)
+          QDUMP( "-Interrupt" );
+
+     if (status & ~0x101100)
+          printk( KERN_ERR "%s: error! INT_STATUS 0x%08x!\n", __FUNCTION__, status );
+
+     shared->num_interrupts++;
+
+     /* Clear the interrupt. */
+     BEM_HC_INT_CLEAR = status;
+
+     if (status & 0x100010) {
+          if (!shared->hw_running)
+               printk( KERN_WARNING "%s: hw not running? INT_STATUS 0x%08x!\n", __FUNCTION__, status );
+
+          if (status & 0x10) {
+               printk( KERN_ERR "%s: RUNAWAY! (%srunning, hw %d-%d, next %d-%d - %svalid, "
+                                "STATUS 0x%08x, INT_STATUS 0x%08x)\n",
+                       __FUNCTION__,
+                       shared->hw_running ? "" : "not ",
+                       shared->hw_start,
+                       shared->hw_end,
+                       shared->next_start,
+                       shared->next_end,
+                       shared->next_valid ? "" : "not ",
+                       BEM_HC_STATUS, status );
+
+               BEM_HC_RESET = 0x1111;
+          }
+
+          /* Next valid means user space is not in the process of extending the buffer. */
+          if (shared->next_valid && shared->next_start != shared->next_end) {
+               shared->hw_start = shared->next_start;
+               shared->hw_end   = shared->next_end;
+
+               shared->next_start = shared->next_end = (shared->hw_end + 1 + 3) & ~3;
+               shared->next_valid = 0;
+
+               shared->num_words += shared->hw_end - shared->hw_start;
+
+               shared->num_starts++;
+
+               QDUMP( " '-> Start!" );
+
+               BEM_HC_DMA_ADR   = shared->buffer_phys + shared->hw_start*4;
+               BEM_HC_DMA_START = 1;
+
+               wake_up_all( &wait_next );
+          }
+          else {
+               shared->num_idle++;
+
+               QDUMP( " '-> Idle." );
+
+               BEM_PE_CACHE = 1;
+
+               shared->hw_running = 0;
+
+               wake_up_all( &wait_next );
+               wake_up_all( &wait_idle );
+          }
+
+          shared->num_done++;
+     }
+
+     return IRQ_HANDLED;
+}
+
+#ifdef SH7722GFX_IRQ_POLLER
+static int
+sh7722_tdg_irq_poller( void *arg )
+{
+     daemonize( "%s", __FUNCTION__ );
+
+     sigfillset( &current->blocked );
+
+     while (!stop_poller) {
+          set_current_state( TASK_UNINTERRUPTIBLE );
+          schedule_timeout( 1 );
+
+          sh7722_tdg_irq( TDG_IRQ, (void*) arg );
+     }
+
+     stop_poller = 0;
+
+     return 0;
+}
+#endif
+
+/**********************************************************************************************************************/
+/**********************************************************************************************************************/
+
+static int
+sh7722gfx_flush( struct file *filp,
+                 fl_owner_t   id )
+{
+     if (jpeg_locked == current->pid) {
+          jpeg_locked = 0;
+
+          wake_up_all( &wait_jpeg_lock );
+     }
+          
+     return 0;
+}
+
+static int
+sh7722gfx_ioctl( struct inode  *inode,
+                 struct file   *filp,
+                 unsigned int   cmd,
+                 unsigned long  arg )
+{
+     int            ret;
+     SH7722Register reg;
+     SH7722JPEG     jpeg;
+
+     switch (cmd) {
+          case SH7722GFX_IOCTL_RESET:
+               return sh7722_reset( shared );
+
+          case SH7722GFX_IOCTL_WAIT_IDLE:
+               return sh7722_wait_idle( shared );
+
+          case SH7722GFX_IOCTL_WAIT_NEXT:
+               return sh7722_wait_next( shared );
+
+          case SH7722GFX_IOCTL_SETREG32:
+               if (copy_from_user( &reg, arg, sizeof(SH7722Register) ))
+                    return -EFAULT;
+
+               /* VEU, BEU, LCDC, VOU, JPEG */
+               if (reg.address < 0xFE920000 || reg.address > 0xFEA102D0)
+                    return -EACCES;
+
+               *(volatile __u32 *) reg.address = reg.value;
+
+               return 0;
+
+          case SH7722GFX_IOCTL_GETREG32:
+               if (copy_from_user( &reg, arg, sizeof(SH7722Register) ))
+                    return -EFAULT;
+
+               /* VEU, BEU, LCDC, VOU, JPEG */
+               if (reg.address < 0xFE920000 || reg.address > 0xFEA102D0)
+                    return -EACCES;
+
+               reg.value = *(volatile __u32 *) reg.address;
+
+               if (copy_to_user( arg, &reg, sizeof(SH7722Register) ))
+                    return -EFAULT;
+
+               return 0;
+
+          case SH7722GFX_IOCTL_WAIT_JPEG:
+               return sh7722_wait_jpeg( shared );
+
+          case SH7722GFX_IOCTL_RUN_JPEG:
+               if (copy_from_user( &jpeg, arg, sizeof(SH7722JPEG) ))
+                    return -EFAULT;
+
+               ret = sh7722_run_jpeg( shared, &jpeg );
+               if (ret)
+                    return ret;
+
+               if (copy_to_user( arg, &jpeg, sizeof(SH7722JPEG) ))
+                    return -EFAULT;
+
+               return 0;
+
+          case SH7722GFX_IOCTL_LOCK_JPEG:
+               return sh7722_lock_jpeg( shared );
+
+          case SH7722GFX_IOCTL_UNLOCK_JPEG:
+               return sh7722_unlock_jpeg( shared );
+     }
+
+     return -ENOSYS;
+}
+
+static int
+sh7722gfx_mmap( struct file           *file,
+                struct vm_area_struct *vma )
+{
+     unsigned int size;
+
+     /* Just allow mapping at offset 0. */
+     if (vma->vm_pgoff)
+          return -EINVAL;
+
+     /* Check size of requested mapping. */
+     size = vma->vm_end - vma->vm_start;
+     if (size != PAGE_ALIGN(sizeof(SH7722GfxSharedArea)))
+          return -EINVAL;
+
+     /* Set reserved and I/O flag for the area. */
+     vma->vm_flags |= VM_RESERVED | VM_IO;
+
+     /* Select uncached access. */
+     vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 9)
+     return remap_pfn_range( vma, vma->vm_start,
+                             virt_to_phys((void*)shared) >> PAGE_SHIFT,
+                             size, vma->vm_page_prot );
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+     return remap_page_range( vma, vma->vm_start,
+                              virt_to_phys((void*)shared),
+                              size, vma->vm_page_prot );
+#else
+     return io_remap_page_range( vma->vm_start,
+                                 virt_to_phys((void*)shared),
+                                 size, vma->vm_page_prot );
+#endif
+}
+
+/**********************************************************************************************************************/
+
+static struct file_operations sh7722gfx_fops = {
+     flush:    sh7722gfx_flush,
+     ioctl:    sh7722gfx_ioctl,
+     mmap:     sh7722gfx_mmap
+};
+
+static struct miscdevice sh7722gfx_miscdev = {
+     minor:    196,           // 7*7*2*2
+     name:     "sh7722gfx",
+     fops:     &sh7722gfx_fops
+};
+
+/**********************************************************************************************************************/
+
+static int __init
+sh7722gfx_module_init( void )
+{
+     int i;
+     int ret;
+
+     /* Register the SH7722 graphics device. */
+     ret = misc_register( &sh7722gfx_miscdev );
+     if (ret < 0) {
+          printk( KERN_ERR "%s: misc_register() for minor %d failed! (error %d)\n",
+                  __FUNCTION__, sh7722gfx_miscdev.minor, ret );
+          return ret;
+     }
+
+     /* Allocate and initialize the shared area. */
+     shared_order = get_order(sizeof(SH7722GfxSharedArea));
+     shared_page  = alloc_pages( GFP_DMA | GFP_KERNEL, shared_order );
+     shared       = ioremap( virt_to_phys( page_address(shared_page) ),
+                             PAGE_ALIGN(sizeof(SH7722GfxSharedArea)) );
+
+     for (i=0; i<1<<shared_order; i++)
+          SetPageReserved( shared_page + i );
+
+     printk( KERN_INFO "sh7722gfx: shared area (order %d) at %p [%lx] using %d bytes\n",
+             shared_order, shared, virt_to_phys(shared), sizeof(SH7722GfxSharedArea) );
+
+
+     /* Allocate and initialize the JPEG area. */
+     jpeg_order = get_order(SH7722GFX_JPEG_SIZE);
+     jpeg_page  = alloc_pages( GFP_DMA | GFP_KERNEL, jpeg_order );
+     jpeg_area  = ioremap( virt_to_phys( page_address(jpeg_page) ),
+                           PAGE_ALIGN(SH7722GFX_JPEG_SIZE) );
+
+     for (i=0; i<1<<jpeg_order; i++)
+          SetPageReserved( jpeg_page + i );
+
+     printk( KERN_INFO "sh7722gfx: jpeg area (order %d) at %p [%lx] using %d bytes\n",
+             jpeg_order, jpeg_area, virt_to_phys(jpeg_area), SH7722GFX_JPEG_SIZE );
+
+
+     /* Register the BEU interrupt handler. */
+     ret = request_irq( BEU_IRQ, sh7722_beu_irq, IRQF_DISABLED, "BEU", (void*) shared );
+     if (ret) {
+          printk( KERN_ERR "%s: request_irq() for interrupt %d failed! (error %d)\n",
+                  __FUNCTION__, BEU_IRQ, ret );
+          goto error_beu;
+     }
+
+#ifdef SH7722GFX_IRQ_POLLER
+     kernel_thread( sh7722_tdg_irq_poller, (void*) shared, CLONE_KERNEL );
+#else
+     /* Register the TDG interrupt handler. */
+     ret = request_irq( TDG_IRQ, sh7722_tdg_irq, IRQF_DISABLED, "TDG", (void*) shared );
+     if (ret) {
+          printk( KERN_ERR "%s: request_irq() for interrupt %d failed! (error %d)\n",
+                  __FUNCTION__, TDG_IRQ, ret );
+          goto error_tdg;
+     }
+#endif
+
+     /* Register the JPU interrupt handler. */
+     ret = request_irq( JPU_IRQ, sh7722_jpu_irq, IRQF_DISABLED, "JPU", (void*) shared );
+     if (ret) {
+          printk( KERN_ERR "%s: request_irq() for interrupt %d failed! (error %d)\n",
+                  __FUNCTION__, JPU_IRQ, ret );
+          goto error_jpu;
+     }
+
+     /* Register the VEU interrupt handler. */
+     ret = request_irq( VEU_IRQ, sh7722_veu_irq, IRQF_DISABLED, "VEU", (void*) shared );
+     if (ret) {
+          printk( KERN_ERR "%s: request_irq() for interrupt %d failed! (error %d)\n",
+                  __FUNCTION__, VEU_IRQ, ret );
+          goto error_veu;
+     }
+
+     sh7722_reset( shared );
+
+     return 0;
+
+
+error_veu:
+     free_irq( JPU_IRQ, (void*) shared );
+
+error_jpu:
+#ifndef SH7722GFX_IRQ_POLLER
+     free_irq( TDG_IRQ, (void*) shared );
+
+error_tdg:
+#endif
+     free_irq( BEU_IRQ, (void*) shared );
+
+error_beu:
+     for (i=0; i<1<<jpeg_order; i++)
+          ClearPageReserved( jpeg_page + i );
+
+     __free_pages( jpeg_page, jpeg_order );
+
+
+     for (i=0; i<1<<shared_order; i++)
+          ClearPageReserved( shared_page + i );
+
+     __free_pages( shared_page, shared_order );
+
+
+     misc_deregister( &sh7722gfx_miscdev );
+
+     return ret;
+}
+
+module_init( sh7722gfx_module_init );
+
+/**********************************************************************************************************************/
+
+static void __exit
+sh7722gfx_module_exit( void )
+{
+     int i;
+
+
+     free_irq( VEU_IRQ, (void*) shared );
+     free_irq( JPU_IRQ, (void*) shared );
+
+#ifdef SH7722GFX_IRQ_POLLER
+     stop_poller = 1;
+
+     while (stop_poller) {
+          set_current_state( TASK_UNINTERRUPTIBLE );
+          schedule_timeout( 1 );
+     }
+#else
+     free_irq( TDG_IRQ, (void*) shared );
+#endif
+
+     free_irq( BEU_IRQ, (void*) shared );
+
+     misc_deregister( &sh7722gfx_miscdev );
+
+
+     for (i=0; i<1<<jpeg_order; i++)
+          ClearPageReserved( jpeg_page + i );
+
+     __free_pages( jpeg_page, jpeg_order );
+
+
+     for (i=0; i<1<<shared_order; i++)
+          ClearPageReserved( shared_page + i );
+
+     __free_pages( shared_page, shared_order );
+}
+
+module_exit( sh7722gfx_module_exit );
+
+/**********************************************************************************************************************/
+
+MODULE_AUTHOR( "Denis Oliver Kropp <dok@directfb.org>" );
+MODULE_LICENSE( "GPL v2" );
+
diff --git a/DirectFB-1.3.0/gfxdrivers/sh7722/kernel-module/sh7722gfx.h b/DirectFB-1.3.0/gfxdrivers/sh7722/kernel-module/sh7722gfx.h
new file mode 100644
index 0000000..cedc87a
--- /dev/null
+++ b/DirectFB-1.3.0/gfxdrivers/sh7722/kernel-module/sh7722gfx.h
@@ -0,0 +1,99 @@
+#ifndef __SH7722GFX_H__
+#define __SH7722GFX_H__
+
+#include <asm/types.h>
+
+
+#define SH7722GFX_BUFFER_WORDS  0x1f000      /* Number of 32bit words in display list (ring buffer). */
+#define SH7722GFX_SHARED_MAGIC  0x77220001   /* Increase if binary compatibility is broken. */
+
+#define SH7722GFX_JPEG_RELOAD_SIZE       (64 * 1024)
+#define SH7722GFX_JPEG_LINEBUFFER_PITCH  (2560)
+#define SH7722GFX_JPEG_LINEBUFFER_HEIGHT (16)
+#define SH7722GFX_JPEG_LINEBUFFER_SIZE   (SH7722GFX_JPEG_LINEBUFFER_PITCH * SH7722GFX_JPEG_LINEBUFFER_HEIGHT * 2)
+#define SH7722GFX_JPEG_LINEBUFFER_SIZE_Y (SH7722GFX_JPEG_LINEBUFFER_PITCH * SH7722GFX_JPEG_LINEBUFFER_HEIGHT)
+#define SH7722GFX_JPEG_SIZE              (SH7722GFX_JPEG_LINEBUFFER_SIZE * 2 + SH7722GFX_JPEG_RELOAD_SIZE * 2)
+
+
+typedef volatile struct {
+     u32            buffer[SH7722GFX_BUFFER_WORDS];
+
+
+     int            hw_start;
+     int            hw_end;
+
+     int            hw_running;
+
+
+     int            next_start;
+     int            next_end;
+
+     int            next_valid;
+
+
+     unsigned long  buffer_phys;
+
+     unsigned int   num_words;
+     unsigned int   num_starts;
+     unsigned int   num_done;
+     unsigned int   num_interrupts;
+     unsigned int   num_wait_idle;
+     unsigned int   num_wait_next;
+     unsigned int   num_idle;
+
+     u32            jpeg_ints;
+     unsigned long  jpeg_phys;
+
+     u32            magic;
+} SH7722GfxSharedArea;
+
+
+typedef struct {
+     u32            address;  /* in */
+     u32            value;    /* in/out */
+} SH7722Register;
+
+
+typedef enum {
+     SH7722_JPEG_START,
+     SH7722_JPEG_RUN,
+     SH7722_JPEG_END
+} SH7722JPEGState;
+
+typedef enum {
+     SH7722_JPEG_FLAG_RELOAD  = 0x00000001,  /* enable reload mode */
+     SH7722_JPEG_FLAG_CONVERT = 0x00000002,  /* enable conversion through VEU */
+     SH7722_JPEG_FLAG_ENCODE  = 0x00000004   /* set encoding mode */
+} SH7722JPEGFlags;
+
+typedef struct {
+     SH7722JPEGState state;   /* starting, running or ended (done/error) */
+     SH7722JPEGFlags flags;   /* control decoding options */
+
+     u32             buffers; /* input = loaded buffers, output = buffers to reload */
+     u32             error;   /* valid in END state, non-zero means error */
+
+     int             height;
+} SH7722JPEG;
+
+
+/* Just initialization and synchronization.
+ * Hardware is started from user space via MMIO to DMA registers. */
+#define SH7722GFX_IOCTL_RESET      _IO( 'G', 0 )
+#define SH7722GFX_IOCTL_WAIT_IDLE  _IO( 'G', 1 )
+#define SH7722GFX_IOCTL_WAIT_NEXT  _IO( 'G', 2 )
+
+/* JPEG processing, requires programming from user space. */
+#define SH7722GFX_IOCTL_WAIT_JPEG   _IO  ( 'J', 0 )
+#define SH7722GFX_IOCTL_RUN_JPEG    _IOWR( 'J', 1, SH7722JPEG )
+#define SH7722GFX_IOCTL_LOCK_JPEG   _IO  ( 'J', 2 )
+#define SH7722GFX_IOCTL_UNLOCK_JPEG _IO  ( 'J', 3 )
+
+
+/* Register access limited to BEU, LCDC, VOU and JPU. */
+#define SH7722GFX_IOCTL_SETREG32   _IOW( 'g', 0, SH7722Register )
+#define SH7722GFX_IOCTL_GETREG32   _IOR( 'g', 1, SH7722Register )
+
+
+#endif
+
diff --git a/DirectFB-1.3.0/gfxdrivers/sh7722/sh7722.c b/DirectFB-1.3.0/gfxdrivers/sh7722/sh7722.c
index 21166dd..9773d66 100644
--- a/DirectFB-1.3.0/gfxdrivers/sh7722/sh7722.c
+++ b/DirectFB-1.3.0/gfxdrivers/sh7722/sh7722.c
@@ -2,10 +2,6 @@
 #define DIRECT_ENABLE_DEBUG
 #endif
 
-#include <stdio.h>
-#include <jpeglib.h>
-
-#undef HAVE_STDLIB_H
 
 #include <config.h>
 #include <stdio.h>
@@ -47,8 +43,6 @@ DFB_GRAPHICS_DRIVER( sh7722 )
 #include "sh7722_multi.h"
 #include "sh7722_screen.h"
 
-#include "sh7723_blt.h"
-
 
 D_DEBUG_DOMAIN( SH7722_Driver, "SH7722/Driver", "Renesas SH7722 Driver" );
 
@@ -71,14 +65,14 @@ driver_get_info( CoreGraphicsDevice *device,
      /* fill driver info structure */
      snprintf( info->name,
                DFB_GRAPHICS_DRIVER_INFO_NAME_LENGTH,
-               "Renesas SH772x Driver" );
+               "Renesas SH7722 Driver" );
 
      snprintf( info->vendor,
                DFB_GRAPHICS_DRIVER_INFO_VENDOR_LENGTH,
-               "Denis & Janine Kropp" );
+               "Denis Oliver Kropp" );
 
      info->version.major = 0;
-     info->version.minor = 9;
+     info->version.minor = 8;
 
      info->driver_data_size = sizeof(SH7722DriverData);
      info->device_data_size = sizeof(SH7722DeviceData);
@@ -105,12 +99,12 @@ driver_init_driver( CoreGraphicsDevice  *device,
      sdrv->device = device;
 
      /* Open the drawing engine device. */
-     sdrv->gfx_fd = direct_try_open( "/dev/sh772x_gfx", "/dev/misc/sh772x_gfx", O_RDWR, true );
+     sdrv->gfx_fd = direct_try_open( "/dev/sh7722gfx", "/dev/misc/sh7722gfx", O_RDWR, true );
      if (sdrv->gfx_fd < 0)
           return DFB_INIT;
 
      /* Map its shared data. */
-     sdrv->gfx_shared = mmap( NULL, direct_page_align( sizeof(SH772xGfxSharedArea) ),
+     sdrv->gfx_shared = mmap( NULL, direct_page_align( sizeof(SH7722GfxSharedArea) ),
                               PROT_READ | PROT_WRITE,
                               MAP_SHARED, sdrv->gfx_fd, 0 );
      if (sdrv->gfx_shared == MAP_FAILED) {
@@ -122,69 +116,46 @@ driver_init_driver( CoreGraphicsDevice  *device,
      sdrv->mmio_base = dfb_gfxcard_map_mmio( device, 0, -1 );
      if (!sdrv->mmio_base) {
           D_PERROR( "SH7722/Driver: Could not map MMIO area!\n" );
-          munmap( (void*) sdrv->gfx_shared, direct_page_align( sizeof(SH772xGfxSharedArea) ) );
+          munmap( (void*) sdrv->gfx_shared, direct_page_align( sizeof(SH7722GfxSharedArea) ) );
           close( sdrv->gfx_fd );
           return DFB_INIT;
      }
 
      /* Check the magic value. */
-     switch (sdrv->gfx_shared->magic) {
-          case SH7722GFX_SHARED_MAGIC:
-               sdev->sh772x = 7722;
-
-               /* Initialize function table. */
-               funcs->EngineReset       = sh7722EngineReset;
-               funcs->EngineSync        = sh7722EngineSync;
-               funcs->EmitCommands      = sh7722EmitCommands;
-               funcs->CheckState        = sh7722CheckState;
-               funcs->SetState          = sh7722SetState;
-               funcs->FillTriangle      = sh7722FillTriangle;
-               funcs->Blit              = sh7722Blit;
-               funcs->StretchBlit       = sh7722StretchBlit;
-               funcs->FlushTextureCache = sh7722FlushTextureCache;
-
-               /* Initialize JPEG library. */
-               ret = SH7722_JPEG_Initialize();
-               if (ret) {
-                    D_DERROR( ret, "SH7722/Driver: JPEG initialization failed!\n" );
-                    dfb_gfxcard_unmap_mmio( device, sdrv->mmio_base, -1 );
-                    munmap( (void*) sdrv->gfx_shared, direct_page_align( sizeof(SH772xGfxSharedArea) ) );
-                    close( sdrv->gfx_fd );
-                    return DFB_INIT;
-               }
-               break;
-
-          case SH7723GFX_SHARED_MAGIC:
-               sdev->sh772x = 7723;
-
-               /* Initialize function table. */
-               funcs->EngineReset       = sh7723EngineReset;
-               funcs->EngineSync        = sh7723EngineSync;
-               funcs->EmitCommands      = sh7723EmitCommands;
-               funcs->CheckState        = sh7723CheckState;
-               funcs->SetState          = sh7723SetState;
-               funcs->FillRectangle     = sh7723FillRectangle;
-               funcs->FillTriangle      = sh7723FillTriangle;
-               funcs->DrawRectangle     = sh7723DrawRectangle;
-               funcs->DrawLine          = sh7723DrawLine;
-               funcs->Blit              = sh7723Blit;
-               break;
-
-          default:
-               D_ERROR( "SH772x/Driver: Magic value 0x%08x doesn't match 0x%08x or 0x%08x!\n",
-                        sdrv->gfx_shared->magic, SH7722GFX_SHARED_MAGIC, SH7723GFX_SHARED_MAGIC );
-               dfb_gfxcard_unmap_mmio( device, sdrv->mmio_base, -1 );
-               munmap( (void*) sdrv->gfx_shared, direct_page_align( sizeof(SH772xGfxSharedArea) ) );
-               close( sdrv->gfx_fd );
-               return DFB_INIT;
+     if (sdrv->gfx_shared->magic != SH7722GFX_SHARED_MAGIC) {
+          D_ERROR( "SH7722/Driver: Magic value 0x%08x doesn't match 0x%08x!\n",
+                   sdrv->gfx_shared->magic, SH7722GFX_SHARED_MAGIC );
+          dfb_gfxcard_unmap_mmio( device, sdrv->mmio_base, -1 );
+          munmap( (void*) sdrv->gfx_shared, direct_page_align( sizeof(SH7722GfxSharedArea) ) );
+          close( sdrv->gfx_fd );
+          return DFB_INIT;
      }
 
+     /* Initialize JPEG library. */
+     ret = SH7722_JPEG_Initialize();
+     if (ret) {
+          D_DERROR( ret, "SH7722/Driver: JPEG initialization failed!\n" );
+          dfb_gfxcard_unmap_mmio( device, sdrv->mmio_base, -1 );
+          munmap( (void*) sdrv->gfx_shared, direct_page_align( sizeof(SH7722GfxSharedArea) ) );
+          close( sdrv->gfx_fd );
+          return DFB_INIT;
+     }
 
      /* Get virtual address for the LCD buffer in slaves here,
         master does it in driver_init_device(). */
      if (!dfb_core_is_master( core ))
           sdrv->lcd_virt = dfb_gfxcard_memory_virtual( device, sdev->lcd_offset );
 
+     /* Initialize function table. */
+     funcs->EngineReset       = sh7722EngineReset;
+     funcs->EngineSync        = sh7722EngineSync;
+     funcs->EmitCommands      = sh7722EmitCommands;
+     funcs->CheckState        = sh7722CheckState;
+     funcs->SetState          = sh7722SetState;
+     funcs->FillTriangle      = sh7722FillTriangle;
+     funcs->Blit              = sh7722Blit;
+     funcs->StretchBlit       = sh7722StretchBlit;
+     funcs->FlushTextureCache = sh7722FlushTextureCache;
 
      /* Register primary screen. */
      sdrv->screen = dfb_screens_register( device, driver_data, &sh7722ScreenFuncs );
@@ -224,15 +195,12 @@ driver_init_device( CoreGraphicsDevice *device,
                return DFB_UNSUPPORTED;
      }
 
-     if (sdev->sh772x == 7723)
-          memset( dfb_gfxcard_memory_virtual(device,0), 0, dfb_gfxcard_memory_length() );
-
      /*
       * Setup LCD buffer.
       */
      sdev->lcd_width  = SH7722_LCD_WIDTH;
      sdev->lcd_height = SH7722_LCD_HEIGHT;
-     sdev->lcd_pitch  = (DFB_BYTES_PER_LINE( sdev->lcd_format, sdev->lcd_width ) + 0x1ff) & ~0x1ff;
+     sdev->lcd_pitch  = (DFB_BYTES_PER_LINE( sdev->lcd_format, sdev->lcd_width ) + 0xf) & ~0xf;
      sdev->lcd_size   = DFB_PLANE_MULTIPLY( sdev->lcd_format, sdev->lcd_height ) * sdev->lcd_pitch;
      sdev->lcd_offset = dfb_gfxcard_reserve_memory( device, sdev->lcd_size );
 
@@ -254,63 +222,35 @@ driver_init_device( CoreGraphicsDevice *device,
      D_ASSERT( ! (sdev->lcd_pitch & 0xf) );
      D_ASSERT( ! (sdev->lcd_phys & 0xf) );
 
-     /*
-      * Initialize hardware.
-      */
 
-     switch (sdev->sh772x) {
-          case 7722:
-               /* Reset the drawing engine. */
-               sh7722EngineReset( sdrv, sdev );
-
-               /* Fill in the device info. */
-               snprintf( device_info->name,   DFB_GRAPHICS_DEVICE_INFO_NAME_LENGTH,   "SH7722" );
-               snprintf( device_info->vendor, DFB_GRAPHICS_DEVICE_INFO_VENDOR_LENGTH, "Renesas" );
-
-               /* Set device limitations. */
-               device_info->limits.surface_byteoffset_alignment = 16;
-               device_info->limits.surface_bytepitch_alignment  = 8;
-
-               /* Set device capabilities. */
-               device_info->caps.flags    = CCF_CLIPPING | CCF_RENDEROPTS;
-               device_info->caps.accel    = SH7722_SUPPORTED_DRAWINGFUNCTIONS |
-                                            SH7722_SUPPORTED_BLITTINGFUNCTIONS;
-               device_info->caps.drawing  = SH7722_SUPPORTED_DRAWINGFLAGS;
-               device_info->caps.blitting = SH7722_SUPPORTED_BLITTINGFLAGS;
-
-               /* Change font format for acceleration. */
-               if (!dfb_config->software_only) {
-                    dfb_config->font_format  = DSPF_ARGB;
-                    dfb_config->font_premult = false;
-               }
-               break;
+     /* Fill in the device info. */
+     snprintf( device_info->name,   DFB_GRAPHICS_DEVICE_INFO_NAME_LENGTH,   "SH7722" );
+     snprintf( device_info->vendor, DFB_GRAPHICS_DEVICE_INFO_VENDOR_LENGTH, "Renesas" );
 
-          case 7723:
-               /* Reset the drawing engine. */
-               sh7723EngineReset( sdrv, sdev );
+     /* Set device limitations. */
+     device_info->limits.surface_byteoffset_alignment = 16;
+     device_info->limits.surface_bytepitch_alignment  = 8;
 
-               /* Fill in the device info. */
-               snprintf( device_info->name,   DFB_GRAPHICS_DEVICE_INFO_NAME_LENGTH,   "SH7723" );
-               snprintf( device_info->vendor, DFB_GRAPHICS_DEVICE_INFO_VENDOR_LENGTH, "Renesas" );
+     /* Set device capabilities. */
+     device_info->caps.flags    = CCF_CLIPPING | CCF_RENDEROPTS;
+     device_info->caps.accel    = SH7722_SUPPORTED_DRAWINGFUNCTIONS |
+                                  SH7722_SUPPORTED_BLITTINGFUNCTIONS;
+     device_info->caps.drawing  = SH7722_SUPPORTED_DRAWINGFLAGS;
+     device_info->caps.blitting = SH7722_SUPPORTED_BLITTINGFLAGS;
 
-               /* Set device limitations. */
-               device_info->limits.surface_byteoffset_alignment = 512;
-               device_info->limits.surface_bytepitch_alignment  = 64;
-
-               /* Set device capabilities. */
-               device_info->caps.flags    = CCF_CLIPPING | CCF_RENDEROPTS;
-               device_info->caps.accel    = SH7723_SUPPORTED_DRAWINGFUNCTIONS | \
-                                            SH7723_SUPPORTED_BLITTINGFUNCTIONS;
-               device_info->caps.drawing  = SH7723_SUPPORTED_DRAWINGFLAGS;
-               device_info->caps.blitting = SH7723_SUPPORTED_BLITTINGFLAGS;
+     /* Change font format for acceleration. */
+     if (!dfb_config->software_only) {
+          dfb_config->font_format  = DSPF_ARGB;
+          dfb_config->font_premult = false;
+     }
 
-               break;
 
-          default:
-               D_BUG( "unexpected device" );
-               return DFB_BUG;
-     }
+     /*
+      * Initialize hardware.
+      */
 
+     /* Reset the drawing engine. */
+     sh7722EngineReset( sdrv, sdev );
 
      /* Wait for idle BEU. */
      while (SH7722_GETREG32( sdrv, BSTAR ) & 1);
@@ -392,7 +332,7 @@ driver_close_driver( CoreGraphicsDevice *device,
                      void               *driver_data )
 {
      SH7722DriverData    *sdrv   = driver_data;
-     SH772xGfxSharedArea *shared = sdrv->gfx_shared;
+     SH7722GfxSharedArea *shared = sdrv->gfx_shared;
 
      (void) shared;
 
@@ -412,7 +352,7 @@ driver_close_driver( CoreGraphicsDevice *device,
      SH7722_JPEG_Shutdown();
 
      /* Unmap shared area. */
-     munmap( (void*) sdrv->gfx_shared, direct_page_align( sizeof(SH772xGfxSharedArea) ) );
+     munmap( (void*) sdrv->gfx_shared, direct_page_align( sizeof(SH7722GfxSharedArea) ) );
 
      /* Close Drawing Engine device. */
      close( sdrv->gfx_fd );
diff --git a/DirectFB-1.3.0/gfxdrivers/sh7722/sh7722.h b/DirectFB-1.3.0/gfxdrivers/sh7722/sh7722.h
index 4b0dea7..a861d4a 100644
--- a/DirectFB-1.3.0/gfxdrivers/sh7722/sh7722.h
+++ b/DirectFB-1.3.0/gfxdrivers/sh7722/sh7722.h
@@ -3,11 +3,13 @@
 
 #include <sys/ioctl.h>
 
-#include <sh772x_gfx.h>
+#include <sh7722gfx.h>
 
 #include "sh7722_regs.h"
 #include "sh7722_types.h"
 
+extern SH7722GfxSharedArea *sh7722gfx_shared;
+
 
 /******************************************************************************
  * Platform specific values (FIXME: add runtime config)
@@ -33,35 +35,33 @@
  * Register access
  */
 
-//#define SH7722_TDG_REG_USE_IOCTLS
-
-#ifdef SH7722_TDG_REG_USE_IOCTLS
+#ifdef SH7722_REG_USE_IOCTLS
 static inline u32
-SH7722_TDG_GETREG32( SH7722DriverData *sdrv,
-                     u32               address )
+SH7722_GETREG32( SH7722DriverData *sdrv,
+                 u32               address )
 {
-     SH772xRegister reg = { address, 0 };
+     SH7722Register reg = { address, 0 };
 
-     if (ioctl( sdrv->gfx_fd, SH772xGFX_IOCTL_GETREG32, &reg ) < 0)
-          D_PERROR( "SH772xGFX_IOCTL_GETREG32( 0x%08x )\n", reg.address );
+     if (ioctl( sdrv->gfx_fd, SH7722GFX_IOCTL_GETREG32, &reg ) < 0)
+          D_PERROR( "SH7722GFX_IOCTL_GETREG32( 0x%08x )\n", reg.address );
 
      return reg.value;
 }
 
 static inline void
-SH7722_TDG_SETREG32( SH7722DriverData *sdrv,
-                     u32               address,
-                     u32               value )
+SH7722_SETREG32( SH7722DriverData *sdrv,
+                 u32               address,
+                 u32               value )
 {
-     SH772xRegister reg = { address, value };
+     SH7722Register reg = { address, value };
 
-     if (ioctl( sdrv->gfx_fd, SH772xGFX_IOCTL_SETREG32, &reg ) < 0)
-          D_PERROR( "SH772xGFX_IOCTL_SETREG32( 0x%08x, 0x%08x )\n", reg.address, reg.value );
+     if (ioctl( sdrv->gfx_fd, SH7722GFX_IOCTL_SETREG32, &reg ) < 0)
+          D_PERROR( "SH7722GFX_IOCTL_SETREG32( 0x%08x, 0x%08x )\n", reg.address, reg.value );
 }
 #else
 static inline u32
-SH7722_TDG_GETREG32( SH7722DriverData *sdrv,
-                     u32               address )
+SH7722_GETREG32( SH7722DriverData *sdrv,
+                 u32               address )
 {
      D_ASSERT( address >= dfb_config->mmio_phys );
      D_ASSERT( address < (dfb_config->mmio_phys + dfb_config->mmio_length) );
@@ -70,9 +70,9 @@ SH7722_TDG_GETREG32( SH7722DriverData *sdrv,
 }
 
 static inline void
-SH7722_TDG_SETREG32( SH7722DriverData *sdrv,
-                     u32               address,
-                     u32               value )
+SH7722_SETREG32( SH7722DriverData *sdrv,
+                 u32               address,
+                 u32               value )
 {
      D_ASSERT( address >= dfb_config->mmio_phys );
      D_ASSERT( address < (dfb_config->mmio_phys + dfb_config->mmio_length) );
@@ -82,30 +82,6 @@ SH7722_TDG_SETREG32( SH7722DriverData *sdrv,
 #endif
 
 
-static inline u32
-SH7722_GETREG32( SH7722DriverData *sdrv,
-                 u32               address )
-{
-     SH772xRegister reg = { address, 0 };
-
-     if (ioctl( sdrv->gfx_fd, SH772xGFX_IOCTL_GETREG32, &reg ) < 0)
-          D_PERROR( "SH772xGFX_IOCTL_GETREG32( 0x%08x )\n", reg.address );
-
-     return reg.value;
-}
-
-static inline void
-SH7722_SETREG32( SH7722DriverData *sdrv,
-                 u32               address,
-                 u32               value )
-{
-     SH772xRegister reg = { address, value };
-
-     if (ioctl( sdrv->gfx_fd, SH772xGFX_IOCTL_SETREG32, &reg ) < 0)
-          D_PERROR( "SH772xGFX_IOCTL_SETREG32( 0x%08x, 0x%08x )\n", reg.address, reg.value );
-}
-
-
 static inline void
 BEU_Start( SH7722DriverData *sdrv,
            SH7722DeviceData *sdev )
diff --git a/DirectFB-1.3.0/gfxdrivers/sh7722/sh7722_blt.c b/DirectFB-1.3.0/gfxdrivers/sh7722/sh7722_blt.c
index 21b016d..2a0eafd 100644
--- a/DirectFB-1.3.0/gfxdrivers/sh7722/sh7722_blt.c
+++ b/DirectFB-1.3.0/gfxdrivers/sh7722/sh7722_blt.c
@@ -111,7 +111,7 @@ static const int pixel_formats[DFB_NUM_PIXELFORMATS] = {
 #define SH7722_INVALIDATE(flags)        do { sdev->v_flags &= ~(flags); } while (0)
 
 #define SH7722_CHECK_VALIDATE(flag)     do {                                                        \
-                                             if ((sdev->v_flags & flag) != flag)                    \
+                                             if (! (sdev->v_flags & flag))                          \
                                                   sh7722_validate_##flag( sdrv, sdev, state );      \
                                         } while (0)
 
@@ -179,7 +179,7 @@ check_blend_functions( const CardState *state )
 static inline bool
 start_hardware( SH7722DriverData *sdrv )
 {
-     SH772xGfxSharedArea *shared = sdrv->gfx_shared;
+     SH7722GfxSharedArea *shared = sdrv->gfx_shared;
 
      D_DEBUG_AT( SH7722_BLT, "%s()\n", __FUNCTION__ );
 
@@ -203,8 +203,8 @@ start_hardware( SH7722DriverData *sdrv )
 
      D_ASSERT( shared->buffer[shared->hw_end] == 0xF0000000 );
 
-     SH7722_TDG_SETREG32( sdrv, BEM_HC_DMA_ADR,   shared->buffer_phys + shared->hw_start*4 );
-     SH7722_TDG_SETREG32( sdrv, BEM_HC_DMA_START, 1 );
+     SH7722_SETREG32( sdrv, BEM_HC_DMA_ADR,   shared->buffer_phys + shared->hw_start*4 );
+     SH7722_SETREG32( sdrv, BEM_HC_DMA_START, 1 );
 
      return true;
 }
@@ -213,14 +213,14 @@ __attribute__((noinline))
 static void
 flush_prepared( SH7722DriverData *sdrv )
 {
-     SH772xGfxSharedArea *shared  = sdrv->gfx_shared;
+     SH7722GfxSharedArea *shared  = sdrv->gfx_shared;
      unsigned int         timeout = 2;
 
      D_DEBUG_AT( SH7722_BLT, "%s()\n", __FUNCTION__ );
 
      DUMP_INFO();
 
-     D_ASSERT( sdrv->prep_num < SH772xGFX_BUFFER_WORDS );
+     D_ASSERT( sdrv->prep_num < SH7722GFX_BUFFER_WORDS );
      D_ASSERT( sdrv->prep_num <= D_ARRAY_SIZE(sdrv->prep_buf) );
 
      /* Something prepared? */
@@ -233,8 +233,8 @@ flush_prepared( SH7722DriverData *sdrv )
 
           /* Check if there's enough space at the end.
            * Wait until hardware has started next block before it gets too big. */
-          if (shared->next_end + sdrv->prep_num >= SH772xGFX_BUFFER_WORDS ||
-              shared->next_end - shared->next_start >= SH772xGFX_BUFFER_WORDS/4)
+          if (shared->next_end + sdrv->prep_num >= SH7722GFX_BUFFER_WORDS ||
+              shared->next_end - shared->next_start >= SH7722GFX_BUFFER_WORDS/4)
           {
                /* If there's no next block waiting, start at the beginning. */
                if (shared->next_start == shared->next_end)
@@ -264,7 +264,7 @@ flush_prepared( SH7722DriverData *sdrv )
                          }
 
                          /* Wait til next block is started. */
-                         ioctl( sdrv->gfx_fd, SH772xGFX_IOCTL_WAIT_NEXT );
+                         ioctl( sdrv->gfx_fd, SH7722GFX_IOCTL_WAIT_NEXT );
                     }
 
                     /* Start over with the checks. */
@@ -301,7 +301,7 @@ flush_prepared( SH7722DriverData *sdrv )
                }
 
                /* Wait til next block is started. */
-               ioctl( sdrv->gfx_fd, SH772xGFX_IOCTL_WAIT_NEXT );
+               ioctl( sdrv->gfx_fd, SH7722GFX_IOCTL_WAIT_NEXT );
           }
 
           /* Copy from local to shared buffer. */
@@ -357,9 +357,6 @@ sh7722_validate_DEST_CLIP( SH7722DriverData *sdrv,
 {
      __u32 *prep = start_buffer( sdrv, 10 );
 
-     D_DEBUG_AT( SH7722_BLT, "%s( 0x%08lx [%d] - %4d,%4d-%4dx%4d )\n", __FUNCTION__,
-                 state->dst.phys, state->dst.pitch, DFB_RECTANGLE_VALS_FROM_REGION( &state->clip ) );
-
      /* Set clip. */
      prep[0] = BEM_PE_SC0_MIN;
      prep[1] = SH7722_XY( state->clip.x1, state->clip.y1 );
@@ -715,13 +712,13 @@ sh7722EngineSync( void *drv, void *dev )
 {
      DFBResult            ret    = DFB_OK;
      SH7722DriverData    *sdrv   = drv;
-     SH772xGfxSharedArea *shared = sdrv->gfx_shared;
+     SH7722GfxSharedArea *shared = sdrv->gfx_shared;
 
      D_DEBUG_AT( SH7722_BLT, "%s()\n", __FUNCTION__ );
 
      DUMP_INFO();
 
-     while (shared->hw_running && ioctl( sdrv->gfx_fd, SH772xGFX_IOCTL_WAIT_IDLE ) < 0) {
+     while (shared->hw_running && ioctl( sdrv->gfx_fd, SH7722GFX_IOCTL_WAIT_IDLE ) < 0) {
           if (errno == EINTR)
                continue;
 
@@ -758,7 +755,7 @@ sh7722EngineReset( void *drv, void *dev )
 
      DUMP_INFO();
 
-     ioctl( sdrv->gfx_fd, SH772xGFX_IOCTL_RESET );
+     ioctl( sdrv->gfx_fd, SH7722GFX_IOCTL_RESET );
 
      prep = start_buffer( sdrv, 20 );
 
diff --git a/DirectFB-1.3.0/gfxdrivers/sh7722/sh7722_jpeg.c b/DirectFB-1.3.0/gfxdrivers/sh7722/sh7722_jpeg.c
index 28b60c9..7174a98 100644
--- a/DirectFB-1.3.0/gfxdrivers/sh7722/sh7722_jpeg.c
+++ b/DirectFB-1.3.0/gfxdrivers/sh7722/sh7722_jpeg.c
@@ -2,11 +2,6 @@
 #define DIRECT_ENABLE_DEBUG
 #endif
 
-#include <stdio.h>
-#include <jpeglib.h>
-
-#undef HAVE_STDLIB_H
-
 #include <config.h>
 
 #include <stdio.h>
@@ -17,8 +12,6 @@
 #include <stdarg.h>
 #include <fcntl.h>
 
-#include <asm/types.h>
-
 #include <direct/debug.h>
 #include <direct/interface.h>
 #include <direct/mem.h>
@@ -126,6 +119,20 @@ IDirectFBImageProvider_SH7722_JPEG_RenderTo( IDirectFBImageProvider *thiz,
      if (!dst_surface)
           return DFB_DESTROYED;
 
+     switch (dst_surface->config.format) {
+          case DSPF_NV12:
+          case DSPF_NV16:
+          case DSPF_RGB16:
+          case DSPF_RGB32:
+          case DSPF_RGB24:
+               break;
+
+          default:
+               /* FIXME: implement fallback */
+               D_UNIMPLEMENTED();
+               return DFB_UNIMPLEMENTED;
+     }
+
      dfb_region_from_rectangle( &clip, &dst_data->area.current );
 
      if (dest_rect) {
@@ -143,7 +150,7 @@ IDirectFBImageProvider_SH7722_JPEG_RenderTo( IDirectFBImageProvider *thiz,
      if (!dfb_rectangle_region_intersects( &rect, &clip ))
           return DFB_OK;
 
-     ret = dfb_surface_lock_buffer( dst_surface, CSBR_BACK, CSAID_GPU, CSAF_WRITE, &lock );
+     ret = dfb_surface_lock_buffer( dst_surface, CSBR_BACK, CSAF_GPU_WRITE, &lock );
      if (ret)
           return ret;
 
@@ -257,11 +264,11 @@ IDirectFBImageProvider_SH7722_JPEG_WriteBack( IDirectFBImageProvider *thiz,
      if (!dfb_rectangle_region_intersects( &rect, &clip ))
           return DFB_INVAREA;
 
-     ret = dfb_surface_lock_buffer( src_surface, CSBR_FRONT, CSAID_GPU, CSAF_READ, &lock );
+     ret = dfb_surface_lock_buffer( src_surface, CSBR_FRONT, CSAF_GPU_READ, &lock );
      if (ret)
           return ret;
 
-     ret = SH7722_JPEG_Encode( filename, &rect, src_surface->config.format, lock.phys, lock.pitch,
+     ret = SH7722_JPEG_Encode( filename, &rect, &clip, src_surface->config.format, lock.phys, lock.pitch,
                                src_surface->config.size.w, src_surface->config.size.h );
 
      dfb_surface_unlock_buffer( src_surface, &lock );
@@ -274,11 +281,6 @@ IDirectFBImageProvider_SH7722_JPEG_WriteBack( IDirectFBImageProvider *thiz,
 static DFBResult
 Probe( IDirectFBImageProvider_ProbeContext *ctx )
 {
-     SH7722DeviceData *sdev = dfb_gfxcard_get_device_data();
-
-     if (sdev->sh772x != 7722)
-          return DFB_UNSUPPORTED;
-
      /* Called with NULL when used for encoding. */
      if (!ctx)
           return DFB_OK;
diff --git a/DirectFB-1.3.0/gfxdrivers/sh7722/sh7722_jpeglib.c b/DirectFB-1.3.0/gfxdrivers/sh7722/sh7722_jpeglib.c
index 2fb6405..62b6f85 100644
--- a/DirectFB-1.3.0/gfxdrivers/sh7722/sh7722_jpeglib.c
+++ b/DirectFB-1.3.0/gfxdrivers/sh7722/sh7722_jpeglib.c
@@ -1,9 +1,6 @@
-#ifdef SH7722_DEBUG_JPEG
+//#ifdef SH7722_DEBUG_JPEG
 #define DIRECT_ENABLE_DEBUG
-#endif
-
-#include <stdio.h>
-#include <jpeglib.h>
+//#endif
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -15,12 +12,10 @@
 #include <sys/ioctl.h>
 #include <sys/mman.h>
 
-#include <asm/types.h>
 
 #ifdef STANDALONE
 #include "sh7722_jpeglib_standalone.h"
 #else
-#undef HAVE_STDLIB_H
 #include <config.h>
 
 #include <direct/conf.h>
@@ -40,7 +35,7 @@
 #include <jpeglib.h>
 #include <setjmp.h>
 
-#include <sh772x_gfx.h>
+#include <sh7722gfx.h>
 
 #include "sh7722_jpeglib.h"
 #include "sh7722_regs.h"
@@ -57,7 +52,7 @@ typedef struct {
      int                            ref_count;
 
      int                            gfx_fd;
-     SH772xGfxSharedArea           *gfx_shared;
+     SH7722GfxSharedArea           *gfx_shared;
 
      unsigned long                  jpeg_phys;
      unsigned long                  jpeg_lb1;
@@ -76,10 +71,10 @@ static inline u32
 SH7722_GETREG32( SH7722_JPEG_data *data,
                  u32               address )
 {
-     SH772xRegister reg = { address, 0 };
+     SH7722Register reg = { address, 0 };
 
-     if (ioctl( data->gfx_fd, SH772xGFX_IOCTL_GETREG32, &reg ) < 0)
-          D_PERROR( "SH772xGFX_IOCTL_GETREG32( 0x%08x )\n", reg.address );
+     if (ioctl( data->gfx_fd, SH7722GFX_IOCTL_GETREG32, &reg ) < 0)
+          D_PERROR( "SH7722GFX_IOCTL_GETREG32( 0x%08x )\n", reg.address );
 
      return reg.value;
 }
@@ -89,10 +84,10 @@ SH7722_SETREG32( SH7722_JPEG_data *data,
                  u32               address,
                  u32               value )
 {
-     SH772xRegister reg = { address, value };
+     SH7722Register reg = { address, value };
 
-     if (ioctl( data->gfx_fd, SH772xGFX_IOCTL_SETREG32, &reg ) < 0)
-          D_PERROR( "SH772xGFX_IOCTL_SETREG32( 0x%08x, 0x%08x )\n", reg.address, reg.value );
+     if (ioctl( data->gfx_fd, SH7722GFX_IOCTL_SETREG32, &reg ) < 0)
+          D_PERROR( "SH7722GFX_IOCTL_SETREG32( 0x%08x, 0x%08x )\n", reg.address, reg.value );
 }
 #else
 static inline u32
@@ -141,7 +136,7 @@ DecodeHW( SH7722_JPEG_data      *data,
      int                    i;
      int                    cw, ch;
      bool                   reload = false;
-     SH772xGfxSharedArea   *shared = data->gfx_shared;
+     SH7722GfxSharedArea   *shared = data->gfx_shared;
      SH7722JPEG             jpeg;
      u32                    vtrcr   = 0;
      u32                    vswpout = 0;
@@ -219,8 +214,7 @@ DecodeHW( SH7722_JPEG_data      *data,
      }
 
      /* Calculate destination base address. */
-     phys += DFB_BYTES_PER_LINE(format, rect->x) + rect->y * pitch;
-     jpeg.phys = phys;
+     phys += rect->x + rect->y * pitch;
 
      D_DEBUG_AT( SH7722_JPEG, "  -> locking JPU...\n" );
 
@@ -370,57 +364,11 @@ DecodeHW( SH7722_JPEG_data      *data,
      return ret;
 }
 
-static int calculate_scaling( int input, int output )
-{
-     int frac = 0;
-     int mant = 0;
-     
-     if( input == output ) { /* no scaling, done */
-          return 0;
-     }
-
-     mant = input / output;     
-     frac = ((input * 4096 / output) & ~7) - mant * 4096;
-     
-     if( input < output ) { /* upscaling */
-          if( input*8 < output ) /* out-of-range */
-               return -1;
-
-          while( output > 1 + (int)((input-1)*4096/frac) ) {
-               frac -= 8;
-          }
-     }
-     else { /* downscaling */
-          int a,size,pmant;
-          
-          if( output*16 < input ) /* out-of-range */
-               return -1;
-
-          while(1) {
-               pmant = "1122333344444444"[mant] - '0';
-               a     = mant * 4096 + frac;
-               size  = (2*(input-1)*pmant)/(2*pmant);
-               size  = (((size-1) * 4096 * pmant) + a) / a;
-               
-               if( output <= size )
-                    break;
-                    
-               if( frac )
-                    frac -= 8;
-               else {
-                    mant--;
-                    frac = 0xff8;
-               }
-          }
-     }
-     
-     return (mant << 12) + frac;
-}
-
 static DirectResult
 EncodeHW( SH7722_JPEG_data      *data,
           const char            *filename,
           const DFBRectangle    *rect,
+          const DFBRegion       *clip,
           DFBSurfacePixelFormat  format,
           unsigned long          phys,
           int                    pitch,
@@ -429,39 +377,30 @@ EncodeHW( SH7722_JPEG_data      *data,
 {
      DirectResult           ret;
      int                    i, fd;
+     int                    cw, ch;
      int                    written = 0;
-     SH772xGfxSharedArea   *shared  = data->gfx_shared;
+     SH7722GfxSharedArea   *shared  = data->gfx_shared;
      u32                    vtrcr   = 0;
      u32                    vswpin  = 0;
      bool                   mode420 = false;
      SH7722JPEG             jpeg;
-         
-     int                    horizontalscaling = 0;
-     int                    verticalscaling   = 0;
 
      D_ASSERT( data != NULL );
      DFB_RECTANGLE_ASSERT( rect );
+     DFB_REGION_ASSERT( clip );
 
-     D_DEBUG_AT( SH7722_JPEG, "%s( %p, 0x%08lx|%d [%dx%d] %s )\n", __FUNCTION__,
-                 data, phys, pitch, width, height,
-                 dfb_pixelformat_name(format) );
-
-     D_DEBUG_AT( SH7722_JPEG, "  -> %d,%d - %4dx%4d\n",
-                 DFB_RECTANGLE_VALS( rect ) );
-
-     /* JPU input is 16x16 to 2560x1920 */
-     if (width < 16 || width > 2560 || height < 16 || height > 1920)
-          return DR_INVAREA;
+     cw = clip->x2 - clip->x1 + 1;
+     ch = clip->y2 - clip->y1 + 1;
 
-     if (rect->w < 1 || rect->h < 1)
+     if (cw < 1 || ch < 1)
           return DR_INVAREA;
 
-     horizontalscaling = calculate_scaling( rect->w, width  );
-     verticalscaling   = calculate_scaling( rect->h * SH7722GFX_JPEG_LINEBUFFER_HEIGHT / height, SH7722GFX_JPEG_LINEBUFFER_HEIGHT );
+     D_DEBUG_AT( SH7722_JPEG, "%s( %p, 0x%08lx|%d [%dx%d] %s )\n", __FUNCTION__,
+                 data, phys, pitch, width, height,
+                 dfb_pixelformat_name(format) );
 
-     /* scaling out-of-range? */
-     if( horizontalscaling == -1 || verticalscaling == -1 )
-          return DR_INVAREA;
+     D_DEBUG_AT( SH7722_JPEG, "  -> %d,%d - %4dx%4d  [clip %d,%d - %4dx%4d]\n",
+                 DFB_RECTANGLE_VALS( rect ), DFB_RECTANGLE_VALS_FROM_REGION( clip ) );
 
      /*
       * Kernel based state machine
@@ -475,6 +414,12 @@ EncodeHW( SH7722_JPEG_data      *data,
       * - finish clipping (maybe not all is possible without tricky code)
       */
 
+     /* No cropping of top or left edge :( */
+     if (clip->x1 > rect->x || clip->y1 > rect->y) {
+          D_UNIMPLEMENTED();
+          return DR_UNIMPLEMENTED;
+     }
+
      /* Init VEU transformation control (format conversion). */
      if (format == DSPF_NV12)
           mode420 = true;
@@ -512,8 +457,7 @@ EncodeHW( SH7722_JPEG_data      *data,
      }
 
      /* Calculate source base address. */
-     phys += DFB_BYTES_PER_LINE(format, rect->x) + rect->y * pitch;
-     jpeg.phys = phys;
+     phys += rect->x + rect->y * pitch;
 
      D_DEBUG_AT( SH7722_JPEG, "  -> locking JPU...\n" );
 
@@ -563,9 +507,9 @@ EncodeHW( SH7722_JPEG_data      *data,
      SH7722_SETREG32( data, JIFESHSZ, width );
      SH7722_SETREG32( data, JIFESVSZ, height );
 
-     if (width == rect->w && height == rect->h && (format == DSPF_NV12 || format == DSPF_NV16))
+     if (width == cw && height == ch && rect->w == cw && rect->h == ch &&
+         (format == DSPF_NV12 || format == DSPF_NV16))
      {
-          /* no scaling, and supported format - so no VEU needed */
           /* Setup JPU for encoding in frame mode (directly from surface). */
           SH7722_SETREG32( data, JINTE,    JINTS_INS10_XFER_DONE | JINTS_INS13_LOADED );
           SH7722_SETREG32( data, JIFECNT,  JIFECNT_SWAP_4321 | JIFECNT_RELOAD_ENABLE | (mode420 ? 1 : 0) );
@@ -575,12 +519,10 @@ EncodeHW( SH7722_JPEG_data      *data,
           SH7722_SETREG32( data, JIFESMW,  pitch );
      }
      else {
-          /* Setup JPU for encoding in line buffer mode. */
-          
-          jpeg.flags       |= SH7722_JPEG_FLAG_CONVERT;
-          jpeg.height       = height;
-          jpeg.inputheight  = rect->h;
+          jpeg.flags |= SH7722_JPEG_FLAG_CONVERT;
+          jpeg.height = height;
 
+          /* Setup JPU for encoding in line buffer mode. */
           SH7722_SETREG32( data, JINTE,    JINTS_INS11_LINEBUF0 | JINTS_INS12_LINEBUF1 |
                                            JINTS_INS10_XFER_DONE | JINTS_INS13_LOADED );
           SH7722_SETREG32( data, JIFECNT,  JIFECNT_LINEBUF_MODE | (SH7722GFX_JPEG_LINEBUFFER_HEIGHT << 16) |
@@ -593,24 +535,22 @@ EncodeHW( SH7722_JPEG_data      *data,
           SH7722_SETREG32( data, JIFESMW,  SH7722GFX_JPEG_LINEBUFFER_PITCH );
 
           /* FIXME: Setup VEU for conversion/scaling (from surface to line buffer). */
-          /* we will not use the VEU in burst mode since we cannot program the 
-           * destination addresses intermediately. */
           SH7722_SETREG32( data, VEU_VBSRR, 0x00000100 );
           SH7722_SETREG32( data, VEU_VESTR, 0x00000000 );
           SH7722_SETREG32( data, VEU_VESWR, pitch );
-          //SH7722_SETREG32( data, VEU_VESSR, (224 << 16) | cw );
-          SH7722_SETREG32( data, VEU_VESSR, (rect->h * SH7722GFX_JPEG_LINEBUFFER_HEIGHT / height)<<16 | rect->w );
-          //SH7722_SETREG32( data, VEU_VBSSR, 16 );
-           
+          SH7722_SETREG32( data, VEU_VESSR, (ch << 16) | cw );
+          SH7722_SETREG32( data, VEU_VBSSR, 16 );
           SH7722_SETREG32( data, VEU_VEDWR, SH7722GFX_JPEG_LINEBUFFER_PITCH );
           SH7722_SETREG32( data, VEU_VDAYR, data->jpeg_lb1 );
           SH7722_SETREG32( data, VEU_VDACR, data->jpeg_lb1 + SH7722GFX_JPEG_LINEBUFFER_SIZE_Y );
           SH7722_SETREG32( data, VEU_VSAYR, phys );
           SH7722_SETREG32( data, VEU_VSACR, phys + pitch * height );
           SH7722_SETREG32( data, VEU_VTRCR, vtrcr );
-          SH7722_SETREG32( data, VEU_VRFCR, (verticalscaling << 16) | horizontalscaling );
-          /* SH7722GFX_JPEG_LINEBUFFER_HEIGHT should be 16 for this to work */
-          SH7722_SETREG32( data, VEU_VRFSR, (SH7722GFX_JPEG_LINEBUFFER_HEIGHT << 16) | width );
+
+          SH7722_SETREG32( data, VEU_VRFCR, (((ch << 12) / height) << 16) |
+                                            ((cw << 12) / width) );
+          SH7722_SETREG32( data, VEU_VRFSR, (ch << 16) | cw );
+
           SH7722_SETREG32( data, VEU_VENHR, 0x00000000 );
           SH7722_SETREG32( data, VEU_VFMCR, 0x00000000 );
           SH7722_SETREG32( data, VEU_VAPCR, 0x00000000 );
@@ -822,7 +762,7 @@ DecodeHeader( SH7722_JPEG_data    *data,
 {
      DirectResult         ret;
      unsigned int         len;
-     SH772xGfxSharedArea *shared;
+     SH7722GfxSharedArea *shared;
 
      D_DEBUG_AT( SH7722_JPEG, "%s( %p )\n", __FUNCTION__, data );
 
@@ -1173,12 +1113,12 @@ Initialize_GFX( SH7722_JPEG_data *data )
      D_DEBUG_AT( SH7722_JPEG, "%s( %p )\n", __FUNCTION__, data );
 
      /* Open the drawing engine device. */
-     data->gfx_fd = direct_try_open( "/dev/sh772x_gfx", "/dev/misc/sh772x_gfx", O_RDWR, true );
+     data->gfx_fd = direct_try_open( "/dev/sh7722gfx", "/dev/misc/sh7722gfx", O_RDWR, true );
      if (data->gfx_fd < 0)
           return DR_INIT;
 
      /* Map its shared data. */
-     data->gfx_shared = mmap( NULL, direct_page_align( sizeof(SH772xGfxSharedArea) ),
+     data->gfx_shared = mmap( NULL, direct_page_align( sizeof(SH7722GfxSharedArea) ),
                               PROT_READ | PROT_WRITE,
                               MAP_SHARED, data->gfx_fd, 0 );
      if (data->gfx_shared == MAP_FAILED) {
@@ -1195,7 +1135,7 @@ Initialize_GFX( SH7722_JPEG_data *data )
      if (data->gfx_shared->magic != SH7722GFX_SHARED_MAGIC) {
           D_ERROR( "SH7722/GFX: Magic value 0x%08x doesn't match 0x%08x!\n",
                    data->gfx_shared->magic, SH7722GFX_SHARED_MAGIC );
-          munmap( (void*) data->gfx_shared, direct_page_align( sizeof(SH772xGfxSharedArea) ) );
+          munmap( (void*) data->gfx_shared, direct_page_align( sizeof(SH7722GfxSharedArea) ) );
           close( data->gfx_fd );
           return DR_INIT;
      }
@@ -1206,7 +1146,7 @@ Initialize_GFX( SH7722_JPEG_data *data )
 static DirectResult
 Shutdown_GFX( SH7722_JPEG_data *data )
 {
-     munmap( (void*) data->gfx_shared, direct_page_align( sizeof(SH772xGfxSharedArea) ) );
+     munmap( (void*) data->gfx_shared, direct_page_align( sizeof(SH7722GfxSharedArea) ) );
 
      close( data->gfx_fd );
 
@@ -1481,7 +1421,6 @@ SH7722_JPEG_Decode( SH7722_JPEG_context   *context,
      DFBRectangle        _rect;
      DFBRegion           _clip;
      struct my_error_mgr jerr;
-     bool                sw_only = false;
 
      if (!data.ref_count)
           return DR_DEAD;
@@ -1502,18 +1441,6 @@ SH7722_JPEG_Decode( SH7722_JPEG_context   *context,
           case DSPF_RGB24:
                break;
 
-          case DSPF_RGB332:
-          case DSPF_ARGB1555:
-          case DSPF_ARGB2554:
-          case DSPF_ARGB4444:
-          case DSPF_ARGB:
-          case DSPF_AiRGB:
-          case DSPF_RGB555:
-          case DSPF_BGR555:
-          case DSPF_RGB444:
-               sw_only = true;
-               break;
-
           default:
                return DR_UNSUPPORTED;
      }
@@ -1536,33 +1463,28 @@ SH7722_JPEG_Decode( SH7722_JPEG_context   *context,
           clip = &_clip;
      }
 
-     if (!context->mode444 && !sw_only)
+     if (!context->mode444)
           ret = DecodeHW( &data, context, rect, clip, format, phys, pitch, width, height );
 
      if (ret) {
-          if (addr) {
-               ret = DecodeSW( context, rect, clip, format, addr, pitch, width, height );
-          }
-          else {
-               int fd, len = direct_page_align( DFB_PLANE_MULTIPLY( format, height ) * pitch );
+          int fd, len = direct_page_align( DFB_PLANE_MULTIPLY( format, height ) * pitch );
 
-               fd = open( "/dev/mem", O_RDWR | O_SYNC );
-               if (fd < 0) {
-                    D_PERROR( "SH7722/JPEG: Could not open /dev/mem!\n" );
-                    return DR_INIT;
-               }
+          fd = open( "/dev/mem", O_RDWR | O_SYNC );
+          if (fd < 0) {
+               D_PERROR( "SH7722/JPEG: Could not open /dev/mem!\n" );
+               return DR_INIT;
+          }
 
-               addr = mmap( NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, phys );
-               if (addr == MAP_FAILED) {
-                    D_PERROR( "SH7722/JPEG: Could not map /dev/mem at 0x%08lx (length %d)!\n", phys, len );
-                    close( fd );
-                    return DR_INIT;
-               }
+          addr = mmap( NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, phys );
+          if (addr == MAP_FAILED) {
+               D_PERROR( "SH7722/JPEG: Could not map /dev/mem at 0x%08lx (length %d)!\n", phys, len );
+               close( fd );
+               return DR_INIT;
+          }
 
-               ret = DecodeSW( context, rect, clip, format, addr, pitch, width, height );
+          ret = DecodeSW( context, rect, clip, format, addr, pitch, width, height );
 
-               munmap( addr, len );
-          }
+          munmap( addr, len );
      }
 
      return ret;
@@ -1580,6 +1502,7 @@ SH7722_JPEG_Close( SH7722_JPEG_context *context )
 DirectResult
 SH7722_JPEG_Encode( const char            *filename,
                     const DFBRectangle    *rect,
+                    const DFBRegion       *clip,
                     DFBSurfacePixelFormat  format,
                     unsigned long          phys,
                     int                    pitch,
@@ -1587,6 +1510,7 @@ SH7722_JPEG_Encode( const char            *filename,
                     unsigned int           height )
 {
      DFBRectangle _rect;
+     DFBRegion    _clip;
 
      if (!data.ref_count)
           return DR_DEAD;
@@ -1612,6 +1536,15 @@ SH7722_JPEG_Encode( const char            *filename,
           rect = &_rect;
      }
 
-     return EncodeHW( &data, filename, rect, format, phys, pitch, width, height );
+     if (!clip) {
+          _clip.x1 = _rect.x;
+          _clip.y1 = _rect.y;
+          _clip.x2 = _rect.x + _rect.w - 1;
+          _clip.y2 = _rect.y + _rect.h - 1;
+
+          clip = &_clip;
+     }
+
+     return EncodeHW( &data, filename, rect, clip, format, phys, pitch, width, height );
 }
 
diff --git a/DirectFB-1.3.0/gfxdrivers/sh7722/sh7722_jpeglib.h b/DirectFB-1.3.0/gfxdrivers/sh7722/sh7722_jpeglib.h
index fbc4fb0..cb57827 100644
--- a/DirectFB-1.3.0/gfxdrivers/sh7722/sh7722_jpeglib.h
+++ b/DirectFB-1.3.0/gfxdrivers/sh7722/sh7722_jpeglib.h
@@ -36,6 +36,7 @@ DirectResult SH7722_JPEG_Close ( SH7722_JPEG_context   *context );
 
 DirectResult SH7722_JPEG_Encode( const char            *filename,
                                  const DFBRectangle    *rect,
+                                 const DFBRegion       *clip,
                                  DFBSurfacePixelFormat  format,
                                  unsigned long          phys,
                                  int                    pitch,
diff --git a/DirectFB-1.3.0/gfxdrivers/sh7722/sh7722_layer.c b/DirectFB-1.3.0/gfxdrivers/sh7722/sh7722_layer.c
index f4f3668..80899a1 100644
--- a/DirectFB-1.3.0/gfxdrivers/sh7722/sh7722_layer.c
+++ b/DirectFB-1.3.0/gfxdrivers/sh7722/sh7722_layer.c
@@ -505,9 +505,6 @@ sh7722UpdateRegion( CoreLayer             *layer,
      /* Start operation! */
      BEU_Start( sdrv, sdev );
 
-     if (!(surface->config.caps & DSCAPS_FLIPPING))
-          BEU_Wait( sdrv, sdev );
-
      return DFB_OK;
 }
 
diff --git a/DirectFB-1.3.0/gfxdrivers/sh7722/sh7722_regs.h b/DirectFB-1.3.0/gfxdrivers/sh7722/sh7722_regs.h
index c0ef019..5a5a887 100644
--- a/DirectFB-1.3.0/gfxdrivers/sh7722/sh7722_regs.h
+++ b/DirectFB-1.3.0/gfxdrivers/sh7722/sh7722_regs.h
@@ -611,7 +611,7 @@
 #define JIFDCNT_SWAP_4321     0x00000006
 #define JIFDCNT_RELOAD_ENABLE 0x00000008
 
-#define JINTS_MASK            0x00007C68
+#define JINTS_MASK            0x00007CE8
 #define JINTS_INS3_HEADER     0x00000008
 #define JINTS_INS5_ERROR      0x00000020
 #define JINTS_INS6_DONE       0x00000040
diff --git a/DirectFB-1.3.0/gfxdrivers/sh7722/sh7722_types.h b/DirectFB-1.3.0/gfxdrivers/sh7722/sh7722_types.h
index ea367da..73a0807 100644
--- a/DirectFB-1.3.0/gfxdrivers/sh7722/sh7722_types.h
+++ b/DirectFB-1.3.0/gfxdrivers/sh7722/sh7722_types.h
@@ -3,7 +3,7 @@
 
 #include <core/layers.h>
 
-#include <sh772x_gfx.h>
+#include <sh7722gfx.h>
 
 
 #define SH7722GFX_MAX_PREPARE             8192
@@ -48,8 +48,6 @@ typedef struct {
 
 
 typedef struct {
-     int                      sh772x;
-
      int                      lcd_width;
      int                      lcd_height;
      int                      lcd_offset;
@@ -98,11 +96,6 @@ typedef struct {
 
      /* locking */
      FusionSkirmish           beu_lock;
-
-
-     /* sh7723 */
-     u32                      rclr;
-     u32                      color16;
 } SH7722DeviceData;
 
 
@@ -120,7 +113,7 @@ typedef struct {
      CoreLayer               *input3;
 
      int                      gfx_fd;
-     SH772xGfxSharedArea     *gfx_shared;
+     SH7722GfxSharedArea     *gfx_shared;
 
      int                      prep_num;
      __u32                    prep_buf[SH7722GFX_MAX_PREPARE];
diff --git a/DirectFB-1.3.0/gfxdrivers/unichrome/Makefile.am b/DirectFB-1.3.0/gfxdrivers/unichrome/Makefile.am
old mode 100755
new mode 100644
diff --git a/DirectFB-1.3.0/gfxdrivers/unichrome/Readme.txt b/DirectFB-1.3.0/gfxdrivers/unichrome/Readme.txt
new file mode 100644
index 0000000..e74fc37
--- /dev/null
+++ b/DirectFB-1.3.0/gfxdrivers/unichrome/Readme.txt
@@ -0,0 +1,101 @@
+Unichrome driver readme
+-----------------------
+
+Recommended VESA framebuffer settings (use them on the kernel command line):
+
+vga=789 video=vesa:ywrap,vram:32
+
+vga=789 sets 800x600 pixels, 32 bits per pixel.
+vesa:ywrap is makes it possible to flip the primary surface.
+vram:32 forces the VESA framebuffer to use 32Mb video RAM.
+Adjust 32 to match your BIOS settings, eg 64 or 128.
+
+For best performance, the viafb framebuffer driver should be used.
+There are a number of variants of this: the best for use with DirectFB
+is kept in the linux-viafb directory in the DirectFB CVS repository.
+
+Reporting bugs
+--------------
+
+If you want to report any problem, please make an effort to figure
+out what is going on. Please also provide a small code example that
+reliably replicates your problem and only relies on DirectFB.
+
+A single .c file + makefile is preferred, so that it can be built and
+tested easily.
+
+Just stating that "this or that doesn't work" is a way of giving the
+developer a load of work, beyond fixing the actual problem.
+
+Unimplemented features (TODOs)
+------------------------------
+
+* Colorkeyed stretch blits.
+* Support for interlaced surfaces.
+* Second video overlay (for picture-in-picture video)
+* HQV video blitter support.
+* System->Video RAM blits. (AGPGART support)
+
+Special features
+----------------
+
+* The video overlay layer can be placed beneath the primary layer,
+  which can have an alpha channel.
+  
+  To enable this, set the level of the overlay to -1 (using SetLevel)
+  and enable the DLOP_ALPHACHANNEL option on the primary.  Then use
+  either AiRGB as the primary pixel format (see also 'known bugs and
+  quirks' below).
+  
+* The FIELD_PARITY option is supported for the video overlay but this
+  requires that the DirectFB version of the viafb framebuffer driver
+  is used.
+
+Limitations (of the hardware)
+-----------------------------
+
+* These drawing and blitting flags are not supported:
+  DSDRAW_DST_PREMULTIPLY, DSDRAW_DEMULTIPLY
+  DSBLIT_SRC_PREMULTIPLY, DSBLIT_DST_PREMULTIPLY, DSBLIT_DEMULTIPLY
+
+* You can not combine source and destination color keying when
+  blitting opaque surfaces. Both functions work, just not at the
+  same time.
+  
+* The hardware does not support 24-bit (3 bytes/pixel) surfaces. 
+
+* The blitter does not support YUV->RGB pixel-format conversion.
+  Video surfaces does the conversion automatically.
+
+* Hardware accelerated blending is not available on AiRGB surfaces.
+
+Known bugs and quirks
+---------------------
+
+* In underlay mode (see 'special features', above), the video
+  is fully visible where the primary layer's alpha is 255, and
+  invisible (= graphics visible) where the alpha is 0.
+
+  This requires the special pixel format AiRGB.  Accelerated blitting
+  to AiRGB surfaces is supported but blending is not.  If blending is
+  required, use a convential RGB surface first and blit the composed
+  image to the AiRGB layer surface.
+
+* Do not use the CPU to write into VRAM surfaces, unless where
+  absolutely needed (ie system -> video blits). CPU accesses
+  into VRAM run at 1/4 speed.
+
+* Colorkeyed stretched blits are not supported => will be software
+  rendered => will be very slow, if the source surface is in VRAM.
+
+* Blitting outside the screen is buggy (e.g with negative surface
+  coordinates). The result is clipped, but does not look right.
+
+* There are different hardware variants of the Unichrome chips.  Since
+  the revision number can only be read by superuser processes, a utility
+  'find_revision.sh' is provided.  The value it reports should be used
+  in /etc/directfbrc in a line of the form 'unichrome-revision=xx'.
+  
+  Symptoms of an incorrect revision number are corrupt images on the
+  video overlay layer or incorrect colors when using YUY2 or YV12
+  pixel formats.
diff --git a/DirectFB-1.3.0/gfxdrivers/unichrome/find_revision.sh b/DirectFB-1.3.0/gfxdrivers/unichrome/find_revision.sh
new file mode 100755
index 0000000..7a54d1e
--- /dev/null
+++ b/DirectFB-1.3.0/gfxdrivers/unichrome/find_revision.sh
@@ -0,0 +1,26 @@
+#!/bin/sh
+
+# The CLE266 revision number can be found at offset 0xf6 from the host
+# bridge's PCI configuration space.  However, it can only be read by
+# a superuser process.
+#
+# This script prints the revision number which can then be set in
+# DirectFB's configuration file /etc/directfbrc.
+
+if [ `id -u` -ne 0 ]; then
+	echo Only root can read the necessary bytes to determine the
+	echo revision number.
+	exit 1
+fi
+
+set `od -j246 -N1 -Ax -td1 /proc/bus/pci/00/00.0`
+unichrome_revision=$2
+
+if [ "$unichrome_revision" = "" ]; then
+	echo Failed to read CLE266 revision number.
+	exit 1
+fi
+
+echo Your CLE266 revision number is $unichrome_revision.
+echo To use this value, add the following line to /etc/directfbrc:
+echo "   " unichrome-revision=$unichrome_revision
diff --git a/DirectFB-1.3.0/gfxdrivers/unichrome/mmio.h b/DirectFB-1.3.0/gfxdrivers/unichrome/mmio.h
old mode 100755
new mode 100644
diff --git a/DirectFB-1.3.0/gfxdrivers/unichrome/regs2d.h b/DirectFB-1.3.0/gfxdrivers/unichrome/regs2d.h
old mode 100755
new mode 100644
diff --git a/DirectFB-1.3.0/gfxdrivers/unichrome/regs3d.h b/DirectFB-1.3.0/gfxdrivers/unichrome/regs3d.h
old mode 100755
new mode 100644
diff --git a/DirectFB-1.3.0/gfxdrivers/unichrome/uc_accel.c b/DirectFB-1.3.0/gfxdrivers/unichrome/uc_accel.c
old mode 100755
new mode 100644
diff --git a/DirectFB-1.3.0/gfxdrivers/unichrome/uc_accel.h b/DirectFB-1.3.0/gfxdrivers/unichrome/uc_accel.h
old mode 100755
new mode 100644
diff --git a/DirectFB-1.3.0/gfxdrivers/unichrome/uc_fifo.c b/DirectFB-1.3.0/gfxdrivers/unichrome/uc_fifo.c
old mode 100755
new mode 100644
diff --git a/DirectFB-1.3.0/gfxdrivers/unichrome/uc_fifo.h b/DirectFB-1.3.0/gfxdrivers/unichrome/uc_fifo.h
old mode 100755
new mode 100644
diff --git a/DirectFB-1.3.0/gfxdrivers/unichrome/uc_hw.h b/DirectFB-1.3.0/gfxdrivers/unichrome/uc_hw.h
old mode 100755
new mode 100644
diff --git a/DirectFB-1.3.0/gfxdrivers/unichrome/uc_hwmap.c b/DirectFB-1.3.0/gfxdrivers/unichrome/uc_hwmap.c
old mode 100755
new mode 100644
diff --git a/DirectFB-1.3.0/gfxdrivers/unichrome/uc_hwset.c b/DirectFB-1.3.0/gfxdrivers/unichrome/uc_hwset.c
old mode 100755
new mode 100644
diff --git a/DirectFB-1.3.0/gfxdrivers/unichrome/uc_overlay.c b/DirectFB-1.3.0/gfxdrivers/unichrome/uc_overlay.c
old mode 100755
new mode 100644
diff --git a/DirectFB-1.3.0/gfxdrivers/unichrome/uc_overlay.h b/DirectFB-1.3.0/gfxdrivers/unichrome/uc_overlay.h
old mode 100755
new mode 100644
diff --git a/DirectFB-1.3.0/gfxdrivers/unichrome/uc_ovl_hwmap.c b/DirectFB-1.3.0/gfxdrivers/unichrome/uc_ovl_hwmap.c
old mode 100755
new mode 100644
diff --git a/DirectFB-1.3.0/gfxdrivers/unichrome/uc_ovl_hwset.c b/DirectFB-1.3.0/gfxdrivers/unichrome/uc_ovl_hwset.c
old mode 100755
new mode 100644
diff --git a/DirectFB-1.3.0/gfxdrivers/unichrome/uc_primary.c b/DirectFB-1.3.0/gfxdrivers/unichrome/uc_primary.c
old mode 100755
new mode 100644
diff --git a/DirectFB-1.3.0/gfxdrivers/unichrome/uc_probe.h b/DirectFB-1.3.0/gfxdrivers/unichrome/uc_probe.h
old mode 100755
new mode 100644
diff --git a/DirectFB-1.3.0/gfxdrivers/unichrome/uc_spic.c b/DirectFB-1.3.0/gfxdrivers/unichrome/uc_spic.c
old mode 100755
new mode 100644
diff --git a/DirectFB-1.3.0/gfxdrivers/unichrome/uc_state.c b/DirectFB-1.3.0/gfxdrivers/unichrome/uc_state.c
old mode 100755
new mode 100644
diff --git a/DirectFB-1.3.0/gfxdrivers/unichrome/uc_state.h b/DirectFB-1.3.0/gfxdrivers/unichrome/uc_state.h
old mode 100755
new mode 100644
diff --git a/DirectFB-1.3.0/gfxdrivers/unichrome/ucio.c b/DirectFB-1.3.0/gfxdrivers/unichrome/ucio.c
new file mode 100644
index 0000000..6850480
--- /dev/null
+++ b/DirectFB-1.3.0/gfxdrivers/unichrome/ucio.c
@@ -0,0 +1,424 @@
+/*
+   Copyright (c) 2003, 2004 Andreas Robinson, All rights reserved.
+   Kernel v2.6 code by Andr Kriehn.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+*/
+
+/* Standalone Unichrome IO-registers mmap driver.
+ * Tested on Linux 2.4.20 and 2.6.0-test3.
+ * 
+ * Compilation:
+ *
+ * make -f ucio.mk v24-devfs
+ * make -f ucio.mk v24
+ * make -f ucio.mk v26-devfs
+ * make -f ucio.mk v26
+ *
+ * Explanation
+ *
+ * v24-devfs compiles for a 2.4 kernel, relying on devfs.
+ * v24 compiles for a 2.4 kernel, without relying on devfs.
+ * v26-devfs compiles for a 2.6 kernel, relying on devfs.
+ * v26 compiles for a 2.6 kernel, without relying on devfs.
+ *
+ * If in doubt use v24 or v26, since devfs is not a standard
+ * kernel feature.
+ *
+ * If you select v24 or v26, you must create a device node in
+ * your /dev directory, by executing the following  command:
+ * (If you have devfs and select v24 or v26, you should
+ * not do this.)
+ *
+ * mknod -m 666 /dev/ucio c 245 0
+ * (You need to have root privileges)
+ *
+ * IMPORTANT: If you forget to do this, DirectFB programs will
+ * run, but won't be accelerated, even if you install the module
+ * properly.
+ *
+ * The non-devfs options allocates a major device number, 245.
+ * This number is for experimental use only, and can possibly conflict
+ * with something else if you have other experimental drivers installed.
+ * If you need to change it, edit VIADEV_MAJOR below and adjust your
+ * mknod command if you use it.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/major.h>
+#include <linux/pci.h>
+#include <linux/devfs_fs_kernel.h>
+#include <linux/version.h>
+#include <linux/wait.h>
+#include <asm/uaccess.h> /* copy_from_user() */
+
+#include "uc_probe.h"
+
+// Test
+#define FBIO_WAITFORVSYNC       _IOW('F', 0x20, u_int32_t)
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+#include <linux/vermagic.h>
+#endif
+
+
+// Module configuration ------------------------------------------------------
+
+#define VIADEV_MAJOR 245
+
+// VIA register declarations -------------------------------------------------
+
+/* defines for VIA 3D registers */
+#define VIA_REG_INTERRUPT       0x200
+#define VIA_REG_STATUS          0x400
+
+/* VIA_REG_INTERRUPT */
+#define VIA_IRQ_GLOBAL          (1 << 31)
+#define VIA_IRQ_VBI_ENABLE      (1 << 19)
+#define VIA_IRQ_VBI_PENDING     (1 << 3)
+
+/* VIA_REG_STATUS(0x400): Engine Status */
+#define VIA_CMD_RGTR_BUSY       0x00000080  /* Command Regulator is busy */
+#define VIA_2D_ENG_BUSY         0x00000001  /* 2D Engine is busy */
+#define VIA_3D_ENG_BUSY         0x00000002  /* 3D Engine is busy */
+#define VIA_VR_QUEUE_BUSY       0x00020000  /* Virtual Queue is busy */
+
+#define VIA_OUT(hwregs, reg, val) *(volatile u32 *)((hwregs) + (reg)) = (val)
+#define VIA_IN(hwregs, reg)       *(volatile u32 *)((hwregs) + (reg))
+
+#define MAXLOOP 0xffffff
+
+// Private declarations ------------------------------------------------------
+
+#define MODULE_NAME "ucio"
+#define MY_ASSERT(test, msg, exitcode) if (!test) { printk(msg); return exitcode; }
+
+struct via_devinfo
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+#ifndef UC_STATIC_DEVNUM
+    devfs_handle_t devhnd;
+#endif
+#endif
+    u16 pciid;                  // PCI id
+    char* name;                 // Device name
+    struct pci_dev* pcidev;     // PCI device (see linux/pci.h)
+    u32 io_base_phy;            // Physical IO register address
+    u8* iobase;                 // Kernel-mapped IO register address
+    u32 size;                   // IO memory size in bytes
+
+    int busy;
+
+    int irq_num;                // Vertical blanking IRQ number
+    int irq_cnt;                // Vertical blanking IRQ counter
+
+    wait_queue_head_t wq;
+};
+
+// ----------------------------------------------------------------------------
+
+/// Global device info
+static struct via_devinfo di;
+
+/// Get chipset revision.
+
+static int via_get_revision(void)
+{
+    u8 rev;
+    struct pci_dev* dev;
+    dev = pci_find_slot(0,0);
+    if (dev == NULL) return -1;
+
+    pci_read_config_byte(dev, 0xf6, &rev);
+    return rev;
+}
+
+/// Probe for Unichrome device
+
+static int via_probe(void)
+{
+    int i;
+    u16 id;
+
+    for (i = 0, id = 0xffff; id > 0; i++) {
+        id = uc_via_devices[i].id;
+        di.pcidev = pci_find_device(PCI_VENDOR_ID_VIA, id, NULL);
+        if (di.pcidev) break;
+    }
+    di.pciid = id;
+    di.name = uc_via_devices[i].name;
+    return id;
+}
+
+static void via_enable_mmio(void)
+{
+    // in/out only works when the Unichrome VGA is the primary device.
+    // Refer to the XFree86 VIA driver for info on how to set it up
+    // when used as secondary driver.
+
+    //outb(inb(0x3c3) | 0x01, 0x3c3);
+    //outb(inb(0x3cc) | 0x01, 0x3c2);
+
+    // Unlock Extended IO Space
+
+    outb(0x10, 0x3c4);
+    outb(0x01, 0x3c5);
+
+    // Enable MMIO
+
+    outb(0x1a, 0x3c4);
+    //outb(inb(0x3c5) | 0x68, 0x3c5);
+}
+
+static int via_wait_idle(void)
+{
+    int loop = 0;
+
+    while (!(VIA_IN(di.iobase, VIA_REG_STATUS) 
+        & VIA_VR_QUEUE_BUSY) && 
+        (loop++ < MAXLOOP));
+
+    while ((VIA_IN(di.iobase, VIA_REG_STATUS) &
+      (VIA_CMD_RGTR_BUSY | VIA_2D_ENG_BUSY | VIA_3D_ENG_BUSY)) &&
+      (loop++ < MAXLOOP));
+
+    return loop >= MAXLOOP;
+}
+
+void via_vga_irqhandler(int irq, void *dev_id, struct pt_regs *regs)
+{
+    struct via_devinfo* vdi = (struct via_devinfo*) dev_id;
+    u32 status = VIA_IN(di.iobase, VIA_REG_INTERRUPT);
+
+    if (status & VIA_IRQ_VBI_PENDING) {
+        VIA_OUT(di.iobase, VIA_REG_INTERRUPT, status | VIA_IRQ_VBI_PENDING);
+
+        vdi->irq_cnt++;
+        wake_up_interruptible(&di.wq);
+    }
+}
+
+static int install_irq_handler(int irq_num)
+{
+    int retval;
+
+    retval = request_irq(irq_num, via_vga_irqhandler,
+    SA_SHIRQ | SA_INTERRUPT, MODULE_NAME, (void *) &di);
+
+    if (retval == -EINVAL) {
+        printk(MODULE_NAME ": No IRQ handler installed, "
+            "IRQ number %d is not valid.\n", irq_num);
+    }
+    else if (retval == -EBUSY) {
+        printk(MODULE_NAME ": No IRQ handler installed, "
+            "IRQ %d is busy. Check BIOS.\n", irq_num);
+    }
+    else if (retval < 0) {
+        printk(MODULE_NAME ": No IRQ handler installed. "
+            "Tried IRQ number %d.\n", irq_num);
+    }
+
+    di.irq_cnt = 0;
+    if (retval >= 0) {
+        di.irq_num = irq_num;
+
+        // Enable vertical sync IRQ.
+        // BUG WARNING: May conflict with other VIA drivers using vsync IRQ.
+        // TODO: Contact VIA to get the same functionality into viafb.
+
+        VIA_OUT(di.iobase, VIA_REG_INTERRUPT,
+            VIA_IN(di.iobase, VIA_REG_INTERRUPT) |
+                VIA_IRQ_GLOBAL | VIA_IRQ_VBI_ENABLE | VIA_IRQ_VBI_PENDING);
+
+        outb(0x11, 0x3d4);
+        outb(inb(0x3d5) | 0x30, 0x3d5);
+
+        printk("IRQ(0x200) = %x\n", VIA_IN(di.iobase, VIA_REG_INTERRUPT));
+    }
+
+    return retval;
+}
+
+// Module and device file I/O functions --------------------------------------
+
+static int viadev_open(struct inode *inode, struct file *filp)
+{
+    return 0; 
+}
+        
+static int viadev_release(struct inode *inode, struct file *filp)
+{
+    return 0;
+}
+
+/* BUG warning: This function is probably not thread/process-safe.
+ * However, the kernel uses spinlocks in the wq, so maybe it is...? */
+
+static int viadev_ioctl(struct inode *inode, struct file *filp,
+                        unsigned int cmd, unsigned long arg)
+{
+    switch(cmd)
+    {
+    case FBIO_WAITFORVSYNC:
+        interruptible_sleep_on(&di.wq);
+        return 0;
+    default:
+        return -ENOTTY;
+    }
+}
+
+static int viadev_mmap(struct file* filp, struct vm_area_struct* vma)
+{
+    unsigned long off = vma->vm_pgoff << PAGE_SHIFT;
+    unsigned long phy = di.io_base_phy + off;
+    unsigned long vsize = vma->vm_end - vma->vm_start;
+    unsigned long psize = di.size - off;
+
+    if (vsize > psize) return -EINVAL;
+
+    vma->vm_pgoff = phy >> PAGE_SHIFT;
+
+    if (boot_cpu_data.x86 > 3)
+        pgprot_val(vma->vm_page_prot) |= _PAGE_PCD;
+
+    vma->vm_flags |= VM_IO | VM_RESERVED | VM_DONTEXPAND;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+    if (io_remap_page_range(vma,vma->vm_start, phy, vsize, vma->vm_page_prot))
+       return -EAGAIN;
+#else
+    if (io_remap_page_range(vma->vm_start, phy, vsize, vma->vm_page_prot))
+       return -EAGAIN;
+#endif
+
+    return 0;
+}
+
+static struct file_operations viadev_fops = {
+    .owner = THIS_MODULE,
+    .ioctl = viadev_ioctl,
+    .mmap = viadev_mmap,
+    .open = viadev_open,
+    .release = viadev_release,
+};
+
+static int __init viadev_init(void)
+{
+    // Find the device
+
+    via_probe();
+    MY_ASSERT(di.pcidev,
+        MODULE_NAME ": No VIA Unichrome graphics device found.\n", -ENODEV);
+    MY_ASSERT(!di.pcidev->driver,
+        MODULE_NAME ": Another driver already controls the Unichrome graphics device.\n", -EBUSY);
+
+    // Map physical IO memory address into kernel space.
+
+    di.io_base_phy = pci_resource_start(di.pcidev, 1);
+    di.size = pci_resource_len(di.pcidev, 1);
+    MY_ASSERT(request_mem_region(di.io_base_phy, di.size, MODULE_NAME),
+        MODULE_NAME ": Memory mapping failed (1).\n", -EBUSY);
+
+    di.iobase = ioremap(di.io_base_phy, di.size);
+    MY_ASSERT(di.iobase, MODULE_NAME ": Memory mapping failed (2).\n", -EBUSY);
+
+    init_waitqueue_head(&di.wq);
+
+    // Try to install a vertical blanking interrupt handler.
+    // Failure is not fatal.
+    install_irq_handler(di.pcidev->irq);
+
+    // TODO: Register PCI device driver. Or not. We don't really have to.
+
+    // Register a character device.
+
+#if UC_STATIC_DEVNUM
+    int result;
+    result = register_chrdev(VIADEV_MAJOR, MODULE_NAME, &viadev_fops);
+    MY_ASSERT(!result, MODULE_NAME " Unable to register driver\n", result);
+#else
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+    int result;
+    result = register_chrdev(VIADEV_MAJOR, MODULE_NAME, &viadev_fops);
+    MY_ASSERT(!result, MODULE_NAME " Unable to register driver\n", result);
+    devfs_mk_cdev(MKDEV(VIADEV_MAJOR, 0), S_IFCHR | S_IRUSR | S_IWUSR, MODULE_NAME);
+#else
+    di.devhnd = devfs_register(NULL, MODULE_NAME, DEVFS_FL_AUTO_DEVNUM,
+        0, 0, S_IFCHR | S_IRUGO | S_IWUGO, &viadev_fops, &di);
+    MY_ASSERT(di.devhnd, MODULE_NAME ": Could not register a /dev entry.\n", -EAGAIN);
+#endif
+
+#endif // UC_STATIC_DEVNUM
+
+    printk(MODULE_NAME " installed. VIA %s rev %d detected. ",
+        di.name, via_get_revision());
+
+    if (di.irq_num != 0)
+        printk("Using IRQ %d.\n", di.irq_num);
+    else
+        printk("\n");
+
+    via_enable_mmio();
+    
+    return 0;
+}
+
+static void __exit viadev_exit(void)
+{
+    if (di.irq_num != 0) {
+
+        // Disable vertical sync IRQ.
+        // BUG WARNING: May conflict with other VIA drivers using vsync IRQ.
+
+        VIA_OUT(di.iobase, VIA_REG_INTERRUPT,
+            (VIA_IN(di.iobase, VIA_REG_INTERRUPT) & ~VIA_IRQ_VBI_ENABLE)
+            | VIA_IRQ_VBI_PENDING);
+
+        outb(0x11, 0x3d4);
+        outb(inb(0x3d5) & ~0x30, 0x3d5);
+
+        free_irq(di.irq_num, (void *) &di);
+        printk(MODULE_NAME ": %d interrupt requests serviced.\n", di.irq_cnt);
+    }
+#if UC_STATIC_DEVNUM
+    unregister_chrdev(VIADEV_MAJOR, MODULE_NAME);
+#else
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+    unregister_chrdev(VIADEV_MAJOR, MODULE_NAME);
+    devfs_remove(MODULE_NAME);
+#else
+    devfs_unregister(di.devhnd);
+#endif
+
+#endif // UC_STATIC_DEVNUM
+
+    via_wait_idle();
+    iounmap(di.iobase);
+    release_mem_region(di.io_base_phy, di.size);
+
+    printk(MODULE_NAME " removed.\n");
+}
+
+module_init(viadev_init);
+module_exit(viadev_exit);
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+
+MODULE_INFO(vermagic, VERMAGIC_STRING);
+
+static const char __module_depends[]
+__attribute_used__
+__attribute__((section(".modinfo"))) =
+"depends=";
+
+#endif
+
+MODULE_AUTHOR("Andreas Robinson");
+MODULE_DESCRIPTION("VIA UniChrome Driver");
+MODULE_LICENSE("GPL");
diff --git a/DirectFB-1.3.0/gfxdrivers/unichrome/ucio.mk b/DirectFB-1.3.0/gfxdrivers/unichrome/ucio.mk
new file mode 100644
index 0000000..1101fd1
--- /dev/null
+++ b/DirectFB-1.3.0/gfxdrivers/unichrome/ucio.mk
@@ -0,0 +1,46 @@
+# The makefile for the Unichrome IO module.
+# Build-command: make -f ucio.mk
+
+.SILENT:
+
+all:
+	echo Usage:
+	echo     make -f ucio.mk v24-devfs
+	echo     make -f ucio.mk v24
+	echo     make -f ucio.mk v26-devfs
+	echo     make -f ucio.mk v26
+	echo
+	echo v24: Compile for a 2.4 kernel.
+	echo v26: Compile for a 2.6 kernel.
+	echo
+	echo -devfs suffix: Module will use devfs.
+	echo   You will need to manually create a /dev device entry
+	echo   if you do not use it.
+	echo
+	echo See ucio.c for more details.
+	echo
+	echo You need to have kernel header files matching the version you
+	echo are trying to compile to, in /usr/src/linux/include.
+	echo
+	echo ... the kernel driver has not been built.
+
+v24-devfs:
+	echo Compiling v2.4 kernel module with devfs support.
+	gcc -D__KERNEL__  -DMODULE -O2 -Wall -I/usr/src/linux/include -c ucio.c
+
+v24:
+	echo Compiling v2.4 kernel module not depending on devfs.
+	gcc -D__KERNEL__  -DMODULE -DUC_STATIC_DEVNUM -O2 -Wall -I/usr/src/linux/include -c ucio.c
+
+v26-devfs:
+	echo Compiling v2.6 kernel module with devfs support.
+	gcc -Wall -Wstrict-prototypes -Wno-trigraphs -O2 -fno-strict-aliasing -fno-common -pipe -mpreferred-stack-boundary=2 -march=i486 -falign-functions=0 -falign-jumps=0 -falign-loops=0 -D__KERNEL__  -DMODULE -DKBUILD_MODNAME=ucio -DKBUILD_BASENAME=ucio -I/usr/src/linux/include -c ucio.c -o ucio.o
+	ld -m elf_i386 -r -o ucio.ko ucio.o
+
+v26:
+	echo Compiling v2.6 kernel module.
+	gcc -Wall -Wstrict-prototypes -Wno-trigraphs -O2 -fno-strict-aliasing -fno-common -pipe -mpreferred-stack-boundary=2 -march=i486 -falign-functions=0 -falign-jumps=0 -falign-loops=0 -DUC_STATIC_DEVNUM -D__KERNEL__  -DMODULE -DKBUILD_MODNAME=ucio -DKBUILD_BASENAME=ucio -I/usr/src/linux/include -c ucio.c -o ucio.o
+	ld -m elf_i386 -r -o ucio.ko ucio.o
+
+clean:
+	rm -f ucio.o ucio.ko
diff --git a/DirectFB-1.3.0/gfxdrivers/unichrome/unichrome.c b/DirectFB-1.3.0/gfxdrivers/unichrome/unichrome.c
old mode 100755
new mode 100644
diff --git a/DirectFB-1.3.0/gfxdrivers/unichrome/unichrome.h b/DirectFB-1.3.0/gfxdrivers/unichrome/unichrome.h
old mode 100755
new mode 100644
diff --git a/DirectFB-1.3.0/gfxdrivers/unichrome/vidregs.h b/DirectFB-1.3.0/gfxdrivers/unichrome/vidregs.h
old mode 100755
new mode 100644
diff --git a/DirectFB-1.3.0/hd1_config b/DirectFB-1.3.0/hd1_config
new file mode 100755
index 0000000..c98e4b1
--- /dev/null
+++ b/DirectFB-1.3.0/hd1_config
@@ -0,0 +1,24 @@
+#!/bin/sh
+
+PREFIX=/hd1
+CCPATH=
+HOST=arm-cx2450x-linux-gnueabi
+
+export PKG_CONFIG_PATH=$PREFIX/lib/pkgconfig
+export CC=$CCPATH$HOST-gcc
+export AR=$CCPATH$HOST-ar
+export NM=$CCPATH$HOST-nm
+export RANLIB=$CCPATH$HOST-ranlib
+export OBJDUMP=$CCPATH$HOST-objdump
+export STRIP=$CCPATH$HOST-strip
+
+export CFLAGS="-I"$PREFIX"/include"
+export LDFLAGS="-L"$PREFIX"/lib"
+
+./configure --prefix=/$PREFIX --build=i686-pc-linux-gnu --host=$HOST \
+            --with-inputdrivers=linuxinput --with-gfxdrivers=cx2450x --disable-video4linux \
+            --disable-video4linux2 --enable-zlib --disable-x11 --disable-osx --disable-vnc \
+            --enable-debug --disable-network --disable-devmem --disable-sysfs --enable-fbdev \
+	    --enable-jpeg --with-tests
+
+#--with-smooth-scaling 
diff --git a/DirectFB-1.3.0/include/directfb.h b/DirectFB-1.3.0/include/directfb.h
index c0b1e2b..97ee87e 100644
--- a/DirectFB-1.3.0/include/directfb.h
+++ b/DirectFB-1.3.0/include/directfb.h
@@ -600,10 +600,7 @@ typedef enum {
                                            surfaces is specified, or resource id of window,
                                            layer, user is returned */
 
-     DSDESC_HINTS        = 0x00000200,  /* Flags for optimized allocation and pixel format selection are set.
-                                           See also DFBSurfaceHintFlags. */
-
-     DSDESC_ALL          = 0x0000033F   /* all of these */
+     DSDESC_ALL          = 0x0000013F   /* all of these */
 } DFBSurfaceDescriptionFlags;
 
 /*
@@ -653,9 +650,7 @@ typedef enum {
 
      DSCAPS_SHARED        = 0x00100000,  /* The surface will be accessible among processes. */
 
-     DSCAPS_ROTATED       = 0x01000000,  /* The back buffers are allocated with swapped width/height (unimplemented!). */
-
-     DSCAPS_ALL           = 0x011113F7,  /* All of these. */
+     DSCAPS_ALL           = 0x001113F7,  /* All of these. */
 
 
      DSCAPS_FLIPPING      = DSCAPS_DOUBLE | DSCAPS_TRIPLE /* Surface needs Flip() calls to make
@@ -713,9 +708,7 @@ typedef enum {
                                                 source pixels after premultiplication */
      DSBLIT_INDEX_TRANSLATION  = 0x00000800, /* do fast indexed to indexed translation,
                                                 this flag is mutual exclusive with all others */
-     DSBLIT_ROTATE90           = 0x00002000, /* rotate the image by 90 degree */
      DSBLIT_ROTATE180          = 0x00001000, /* rotate the image by 180 degree */
-     DSBLIT_ROTATE270          = 0x00004000, /* rotate the image by 270 degree */
      DSBLIT_COLORKEY_PROTECT   = 0x00010000, /* make sure written pixels don't match color key (internal only ATM) */
      DSBLIT_SRC_MASK_ALPHA     = 0x00100000, /* modulate source alpha channel with alpha channel from source mask,
                                                 see also IDirectFBSurface::SetSourceMask() */
@@ -1103,10 +1096,10 @@ typedef enum {
      /*  1 bit alpha (1 byte/ 8 pixel, most significant bit used first) */
      DSPF_A1        = DFB_SURFACE_PIXELFORMAT( 14,  0, 1, 1, 1, 0, 7, 0, 0, 0, 0 ),
 
-     /* 12 bit   YUV (8 bit Y plane followed by one 16 bit quarter size Cb|Cr [7:0|7:0] plane) */
+     /* 12 bit   YUV (8 bit Y plane followed by one 16 bit quarter size CbCr [15:0] plane) */
      DSPF_NV12      = DFB_SURFACE_PIXELFORMAT( 15, 12, 0, 0, 0, 1, 0, 2, 0, 0, 0 ),
 
-     /* 16 bit   YUV (8 bit Y plane followed by one 16 bit half width Cb|Cr [7:0|7:0] plane) */
+     /* 16 bit   YUV (8 bit Y plane followed by one 16 bit half width CbCr [15:0] plane) */
      DSPF_NV16      = DFB_SURFACE_PIXELFORMAT( 16, 24, 0, 0, 0, 1, 0, 0, 1, 0, 0 ),
 
      /* 16 bit  ARGB (2 byte, alpha 2@14, red 5@9, green 5@4, blue 4@0) */
@@ -1115,7 +1108,7 @@ typedef enum {
      /* 16 bit  ARGB (2 byte, alpha 4@12, red 4@8, green 4@4, blue 4@0) */
      DSPF_ARGB4444  = DFB_SURFACE_PIXELFORMAT( 18, 12, 4, 1, 0, 2, 0, 0, 0, 0, 0 ),
 
-     /* 12 bit   YUV (8 bit Y plane followed by one 16 bit quarter size Cr|Cb [7:0|7:0] plane) */
+     /* 12 bit   YUV (8 bit Y plane followed by one 16 bit quarter size CrCb [15:0] plane) */
      DSPF_NV21      = DFB_SURFACE_PIXELFORMAT( 19, 12, 0, 0, 0, 1, 0, 2, 0, 0, 0 ),
 
      /* 32 bit  AYUV (4 byte, alpha 8@24, Y 8@16, Cb 8@8, Cr 8@0) */
@@ -1136,7 +1129,7 @@ typedef enum {
      /*  2 bit   LUT (1 byte/ 4 pixel, 2 bit color and alpha lookup from palette) */
      DSPF_LUT2      = DFB_SURFACE_PIXELFORMAT( 25,  2, 0, 1, 2, 0, 3, 0, 0, 1, 0 ),
 
-     /* 16 bit   RGB (2 byte, nothing @12, red 4@8, green 4@4, blue 4@0) */
+	 /* 16 bit   RGB (2 byte, nothing @12, red 4@8, green 4@4, blue 4@0) */
      DSPF_RGB444    = DFB_SURFACE_PIXELFORMAT( 26, 12, 0, 0, 0, 2, 0, 0, 0, 0, 0 ),
 
      /* 16 bit   RGB (2 byte, nothing @15, red 5@10, green 5@5, blue 5@0) */
@@ -1175,19 +1168,6 @@ typedef enum {
 
 #define DFB_PIXELFORMAT_INV_ALPHA(fmt)  (((fmt) & 0x80000000) !=  0)
 
-/*
- * Hint flags for optimized allocation, format selection etc.
- */
-typedef enum {
-     DSHF_NONE                = 0x00000000,
-
-     DSHF_LAYER               = 0x00000001,       /* Surface optimized for display layer usage */
-     DSHF_WINDOW              = 0x00000002,       /* Surface optimized for being a window buffer */
-     DSHF_CURSOR              = 0x00000004,       /* Surface optimized for usage as a cursor shape */
-     DSHF_FONT                = 0x00000008,       /* Surface optimized for text rendering */
-
-     DSHF_ALL                 = 0x0000000F
-} DFBSurfaceHintFlags;
 
 /*
  * Description of the surface that is to be created.
@@ -1212,8 +1192,6 @@ typedef struct {
 
      unsigned long                      resource_id;   /* universal resource id, either user specified for general
                                                           purpose surfaces or id of layer or window */
-
-     DFBSurfaceHintFlags                hints;       /* usage hints for optimized allocation, format selection etc. */
 } DFBSurfaceDescription;
 
 /*
@@ -3072,22 +3050,14 @@ DEFINE_INTERFACE(   IDirectFBDisplayLayer,
       *
       * Only available in exclusive or administrative mode.
       *
-      * Any <b>rotation</b> other than 0, 90, 180 or 270 is not supported.
+      * Any <b>rotation</b> other than 0 or 180 is not supported yet.
       *
-      * No layer hardware feature usage, only rotated blitting is used.
+      * No layer hardware feature usage, only rotated blitting yet.
       */
      DFBResult (*SetRotation) (
           IDirectFBDisplayLayer              *thiz,
           int                                 rotation
      );
-
-     /*
-      * Get the rotation of data within the layer.
-      */
-     DFBResult (*GetRotation) (
-          IDirectFBDisplayLayer              *thiz,
-          int                                *ret_rotation
-     );
 )
 
 
@@ -5327,14 +5297,6 @@ DEFINE_INTERFACE(   IDirectFBWindow,
           const char                    *key,
           void                         **ret_value
      );
-
-     /*
-      * Set window rotation.
-      */
-     DFBResult (*SetRotation) (
-          IDirectFBWindow               *thiz,
-          int                            rotation
-     );
 )
 
 
diff --git a/DirectFB-1.3.0/include/directfb_util.h b/DirectFB-1.3.0/include/directfb_util.h
index 7e24d68..a69d261 100644
--- a/DirectFB-1.3.0/include/directfb_util.h
+++ b/DirectFB-1.3.0/include/directfb_util.h
@@ -39,8 +39,6 @@ extern "C"
 {
 #endif
 
-#include <directfb_strings.h>
-
 #include <direct/types.h>
 #include <direct/debug.h>
 
@@ -201,139 +199,6 @@ static inline void dfb_region_from_rectangle( DFBRegion          *region,
      region->y2 = rect->y + rect->h - 1;
 }
 
-static inline void dfb_region_from_rotated( DFBRegion          *region,
-                                            const DFBRegion    *from,
-                                            const DFBDimension *size,
-                                            int                 rotation )
-{
-     D_ASSERT( region != NULL );
-
-     DFB_REGION_ASSERT( from );
-     D_ASSERT( size != NULL );
-     D_ASSERT( size->w > 0 );
-     D_ASSERT( size->h > 0 );
-     D_ASSUME( rotation == 0 || rotation == 90 || rotation == 180 || rotation == 270 );
-
-     switch (rotation) {
-          default:
-               D_BUG( "invalid rotation %d", rotation );
-          case 0:
-               *region = *from;
-               break;
-
-          case 90:
-               region->x1 = from->y1;
-               region->y1 = size->w - from->x2 - 1;
-               region->x2 = from->y2;
-               region->y2 = size->w - from->x1 - 1;
-               break;
-
-          case 180:
-               region->x1 = size->w - from->x2 - 1;
-               region->y1 = size->h - from->y2 - 1;
-               region->x2 = size->w - from->x1 - 1;
-               region->y2 = size->h - from->y1 - 1;
-               break;
-
-          case 270:
-               region->x1 = size->h - from->y2 - 1;
-               region->y1 = from->x1;
-               region->x2 = size->h - from->y1 - 1;
-               region->y2 = from->x2;
-               break;
-     }
-
-     DFB_REGION_ASSERT( region );
-}
-
-static inline void dfb_rectangle_from_rotated( DFBRectangle       *rectangle,
-                                               const DFBRectangle *from,
-                                               const DFBDimension *size,
-                                               int                 rotation )
-{
-     D_ASSERT( rectangle != NULL );
-
-     DFB_RECTANGLE_ASSERT( from );
-     D_ASSERT( size != NULL );
-     D_ASSERT( size->w > 0 );
-     D_ASSERT( size->h > 0 );
-     D_ASSUME( rotation == 0 || rotation == 90 || rotation == 180 || rotation == 270 );
-
-     switch (rotation) {
-          default:
-               D_BUG( "invalid rotation %d", rotation );
-          case 0:
-               *rectangle = *from;
-               break;
-
-          case 90:
-               rectangle->x = from->y;
-               rectangle->y = size->w - from->x - from->w;
-               rectangle->w = from->h;
-               rectangle->h = from->w;
-               break;
-
-          case 180:
-               rectangle->x = size->w - from->x - from->w;
-               rectangle->y = size->h - from->y - from->h;
-               rectangle->w = from->w;
-               rectangle->h = from->h;
-               break;
-
-          case 270:
-               rectangle->x = size->h - from->y - from->h;
-               rectangle->y = from->x;
-               rectangle->w = from->h;
-               rectangle->h = from->w;
-               break;
-     }
-
-     DFB_RECTANGLE_ASSERT( rectangle );
-}
-
-static inline void dfb_point_from_rotated_region( DFBPoint           *point,
-                                                  const DFBRegion    *from,
-                                                  const DFBDimension *size,
-                                                  int                 rotation )
-{
-     D_ASSERT( point != NULL );
-
-     DFB_REGION_ASSERT( from );
-     D_ASSERT( size != NULL );
-     D_ASSERT( size->w > 0 );
-     D_ASSERT( size->h > 0 );
-     D_ASSUME( rotation == 0 || rotation == 90 || rotation == 180 || rotation == 270 );
-
-     switch (rotation) {
-          default:
-               D_BUG( "invalid rotation %d", rotation );
-          case 0:
-               point->x = from->x1;
-               point->y = from->y1;
-               break;
-
-          case 90:
-               point->x = from->y1;
-               point->y = size->w - from->x2 - 1;
-               break;
-
-          case 180:
-               point->x = size->w - from->x2 - 1;
-               point->y = size->h - from->y2 - 1;
-               break;
-
-          case 270:
-               point->x = size->h - from->y2 - 1;
-               point->y = from->x1;
-               break;
-     }
-
-     D_ASSERT( point->x >= 0 );
-     D_ASSERT( point->y >= 0 );
-     D_ASSERT( point->x < size->w );
-     D_ASSERT( point->y < size->h );
-}
-
 
 static inline void dfb_rectangle_translate( DFBRectangle *rect,
                                             int           dx,
@@ -531,10 +396,6 @@ static inline bool dfb_line_segment_intersect( const DFBRegion *line,
 }
 
 
-/*
- * Copied declaration of DFBPixelFormatName from directfb_strings.h
- */
-extern const struct DFBPixelFormatName dfb_pixelformat_names[];
 
 
 const char *dfb_input_event_type_name ( DFBInputEventType     type );
diff --git a/DirectFB-1.3.0/inputdrivers/gunze/dfb-calib.c b/DirectFB-1.3.0/inputdrivers/gunze/dfb-calib.c
new file mode 100644
index 0000000..487ce6d
--- /dev/null
+++ b/DirectFB-1.3.0/inputdrivers/gunze/dfb-calib.c
@@ -0,0 +1,469 @@
+/*
+   (c) Copyright 2001-2008  The world wide DirectFB Open Source Community (directfb.org)
+   (c) Copyright 2000-2004  Convergence (integrated media) GmbH
+
+   All rights reserved.
+
+   Written by Denis Oliver Kropp <dok@directfb.org>,
+              Andreas Hundt <andi@fischlustig.de>,
+              Sven Neumann <neo@directfb.org>,
+              Ville Syrjl <syrjala@sci.fi> and
+              Claudio Ciccani <klan@users.sf.net>.
+
+   This file is subject to the terms and conditions of the MIT License:
+
+   Permission is hereby granted, free of charge, to any person
+   obtaining a copy of this software and associated documentation
+   files (the "Software"), to deal in the Software without restriction,
+   including without limitation the rights to use, copy, modify, merge,
+   publish, distribute, sublicense, and/or sell copies of the Software,
+   and to permit persons to whom the Software is furnished to do so,
+   subject to the following conditions:
+
+   The above copyright notice and this permission notice shall be
+   included in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include <errno.h>
+#include <fcntl.h>
+#include <termios.h>
+
+#include <math.h>
+#include <directfb.h>
+
+static IDirectFB *dfb = NULL;
+static IDirectFBSurface *primary = NULL;
+static IDirectFBEventBuffer *buffer = NULL;
+static IDirectFBInputDevice *mouse = NULL;
+static IDirectFBFont *gara_reg_12 = NULL;
+
+static int screen_width  = 0;
+static int screen_height = 0;
+
+#define DFBCHECK(x...)                                       \
+{                                                            \
+   DFBResult err = x;                                        \
+                                                             \
+   if (err != DFB_OK)                                        \
+   {                                                         \
+      fprintf( stderr, "%s <%d>:\n\t", __FILE__, __LINE__ ); \
+      DirectFBErrorFatal( #x, err );                         \
+   }                                                         \
+}
+
+
+#define BUFFER_SIZE         64          /* size of reception buffer */
+#define GUNZE_MAXPHYSCOORD  1023
+#define GUNZE_MAXCOORD      (64*1024-1) /* oversampled, synthetic value */
+#define FLAG_TAPPING        1
+#define FLAG_WAS_UP         2
+#define BAUDRATE            B9600
+static const char *default_options[] =
+{
+	"BaudRate", "9600",
+	"StopBits", "1",
+	"DataBits", "8",
+	"Parity", "None",
+	"Vmin", "1",
+	"Vtime", "10",
+	"FlowControl", "None",
+	NULL
+};
+
+typedef struct 
+{
+    char	*gunDevice;	/* device file name */
+    int		flags;		/* various flags */
+    int		gunType;        /* TYPE_SERIAL, etc */
+    int		gunBaud;	/* 9600 or 19200 */
+    int		gunDlen;	/* data length (3 or 11) */
+    int		gunAvgX;	/* previous X position */
+    int		gunAvgY;	/* previous Y position */
+    int		gunSmooth;	/* how smooth the motion is */
+    int		gunTapping;	/* move-and-tap (or press-only) */
+    int		gunPrevButton;	/* previous button state */
+    int		gunBytes;	/* number of bytes read */
+    unsigned char gunData[16];	/* data read on the device */
+    struct timeval *gunTv;      /* release time */
+    char	*gunConfig;     /* filename for configuration */
+    int     fd;
+} GunzeDevice, *GunzeDevicePtr;
+
+enum devicetypeitems {
+    TYPE_UNKNOWN = 0,
+    TYPE_SERIAL = 1,
+    TYPE_PS2,
+    TYPE_USB
+};
+
+#define GUNZE_SERIAL_DLEN 11
+#define GUNZE_PS2_DLEN     3
+
+#define GUNZE_SECTION_NAME    "GunzeTS"
+#define GUNZE_DEFAULT_CFGFILE "/etc/gunzets.calib"
+
+
+#define SYSCALL(call) while(((call) == -1) && (errno == EINTR))
+struct axis_coord {
+    int x;
+    int y;
+} coords;
+
+static void GetCalibData(GunzeDevicePtr priv)
+{
+    unsigned char *pkt = priv->gunData;
+    int len, loop;
+    int x, y;
+    coords.x = 0;
+    coords.y = 0;
+    unsigned char buffer[BUFFER_SIZE];
+
+    while ((len = read( priv->fd, buffer, BUFFER_SIZE)) >= 0 || errno == EINTR)
+    {
+        if (len <= 0) 
+        {
+            fprintf(stderr,"error reading Gunze touch screen device %d %d\n",errno,priv->fd);
+            perror(NULL);
+            return;
+        }
+
+        for(loop=0; loop<len; loop++) 
+        {
+            // if first byte, ensure that the packet is syncronized
+            if (priv->gunBytes == 0) 
+            {
+                int error  = 0;
+                if (priv->gunDlen == GUNZE_SERIAL_DLEN) 
+                {
+                    // First byte is 'R' (0x52) or 'T' (0x54)
+                    if ((buffer[loop] != 'R') && (buffer[loop] != 'T'))
+                        error = 1;
+                }
+                else // PS/2 
+                {
+                    if ( !(buffer[loop] & 0x80) || (len > loop+1 && !(buffer[loop+1] & 0x80)) || (len > loop+2 && (buffer[loop+2]  & 0x80)))
+                        error = 1;
+                }
+                if (error) 
+                {
+                    fprintf(stderr,"GunzeReadInput: bad first byte 0x%x %c\n",buffer[loop],buffer[loop]);
+                    continue;
+                }
+            }
+
+            pkt[priv->gunBytes++] = buffer[loop];
+
+            // Hack: sometimes a serial packet gets corrupted. If so, drop it
+            if (buffer[loop] == 0x0d && priv->gunBytes != priv->gunDlen && priv->gunDlen == GUNZE_SERIAL_DLEN) 
+            {
+                pkt[priv->gunBytes-1] = '\0';
+                fprintf(stderr,"Bad packet \"%s\", dropping it\n", pkt);
+                priv->gunBytes = 0; // for next time
+                continue;
+            }
+
+            // if whole packet collected, decode it
+            if (priv->gunBytes == priv->gunDlen)
+            {
+                priv->gunBytes = 0; // for next time
+                if (priv->gunDlen == GUNZE_SERIAL_DLEN) 
+                {
+                    x = atoi((char *)pkt+1);
+                    y = atoi((char *)pkt+6);
+                }
+
+                if (x>1023 || x<0 || y>1023 || y<0) 
+                {
+                    fprintf(stderr,"Bad packet \"%s\" -> %i,%i\n", pkt, x, y);
+                    priv->gunBytes = 0; // for next time 
+                    continue;
+                }
+
+                if (pkt[0] == 'R')
+                {
+                    printf ("Returning %c %d %d\n",pkt[0],x,y);
+                    coords.x = x;
+                    coords.y = y;
+                    return;
+                }
+                printf ("Continuing %c %d %d\n",pkt[0],x,y);
+
+                priv->gunAvgX = x;
+                priv->gunAvgY = y;
+            }
+        }
+    }
+}
+
+
+static int GunzeOpen(GunzeDevicePtr priv)
+{
+    struct termios  newtio,termios_tty;
+    int err;
+
+    // Is it a serial port or something else? 
+    priv->gunType = TYPE_SERIAL;
+    priv->gunDlen = GUNZE_SERIAL_DLEN;
+
+    SYSCALL(priv->fd = open(priv->gunDevice, O_RDWR | O_NOCTTY));
+    if (priv->fd == -1) 
+    {
+        fprintf(stderr,"Error opening device %s\n",priv->gunDevice);
+        return -1;
+    }
+
+    SYSCALL(err = tcgetattr(priv->fd, &newtio));
+
+    if (err == -1) {
+        fprintf(stderr,"Gunze touch screen tcgetattr\n");
+        return -1;
+    }
+
+    memset(&newtio,0, sizeof(newtio)); /* clear struct for new port settings */
+
+/*
+    BAUDRATE: Set bps rate. You could also use cfsetispeed and cfsetospeed.
+    CRTSCTS : output hardware flow control (only used if the cable has
+            all necessary lines. See sect. 7 of Serial-HOWTO)
+    CS8     : 8n1 (8bit,no parity,1 stopbit)
+    CLOCAL  : local connection, no modem contol
+    CREAD   : enable receiving characters
+*/
+    newtio.c_cflag = BAUDRATE | CRTSCTS | CS8 | CLOCAL | CREAD;
+/*
+    IGNPAR  : ignore bytes with parity errors
+    ICRNL   : map CR to NL (otherwise a CR input on the other computer will not terminate input)
+    otherwise make device raw (no other input processing)
+*/
+    newtio.c_iflag = IGNPAR | ICRNL;
+//  Raw output
+    newtio.c_oflag = 0;
+/*
+    ICANON  : enable canonical input
+    disable all echo functionality, and don't send signals to calling program
+*/
+    newtio.c_lflag = ICANON;
+
+/*
+    initialize all control characters 
+    default values can be found in /usr/include/termios.h, and are given
+    in the comments, but we don't need them here
+*/
+    newtio.c_cc[VINTR]    = 0;     /* Ctrl-c */ 
+    newtio.c_cc[VQUIT]    = 0;     /* Ctrl-\ */
+    newtio.c_cc[VERASE]   = 0;     /* del */
+    newtio.c_cc[VKILL]    = 0;     /* @ */
+    newtio.c_cc[VEOF]     = 4;     /* Ctrl-d */
+    newtio.c_cc[VTIME]    = 0;     /* inter-character timer unused */
+    newtio.c_cc[VMIN]     = 1;     /* blocking read until 1 character arrives */
+    newtio.c_cc[VSWTC]    = 0;     /* '\0' */
+    newtio.c_cc[VSTART]   = 0;     /* Ctrl-q */ 
+    newtio.c_cc[VSTOP]    = 0;     /* Ctrl-s */
+    newtio.c_cc[VSUSP]    = 0;     /* Ctrl-z */
+    newtio.c_cc[VEOL]     = 0;     /* '\0' */
+    newtio.c_cc[VREPRINT] = 0;     /* Ctrl-r */
+    newtio.c_cc[VDISCARD] = 0;     /* Ctrl-u */
+    newtio.c_cc[VWERASE]  = 0;     /* Ctrl-w */
+    newtio.c_cc[VLNEXT]   = 0;     /* Ctrl-v */
+    newtio.c_cc[VEOL2]    = 0;     /* '\0' */
+
+    //now clean the modem line and activate the settings for the port
+
+    tcflush(priv->fd, TCIFLUSH);
+    err = tcsetattr(priv->fd, TCSANOW, &newtio);
+    if (err == -1) {
+        fprintf(stderr,"Gunze touch screen tcsetattr TCSANOW\n");
+        return -1;
+    }
+
+/*
+    DBG(2, fprintf(stderr,"%s opened as fd %d\n", priv->gunDevice, priv->fd));
+    DBG(1, fprintf(stderr,"initializing Gunze touch screen\n"));
+*/
+    // Hmm... close it, so it doens't say anything before we're ready
+    // FIX ME
+
+    // Clear any pending input
+    tcflush(priv->fd, TCIFLUSH);
+    // FIX ME: is there something to write-and-read here?
+
+    return 0;
+}
+
+static GunzeDevicePtr GunzeAllocate()
+{
+    GunzeDevicePtr priv = (GunzeDevicePtr)malloc(sizeof(GunzeDevice));
+
+    priv->gunDevice = "/dev/ttyS0";         /* device file name */
+    priv->gunConfig = GUNZE_DEFAULT_CFGFILE;
+    priv->gunDlen = 0;            /* unknown */
+    priv->gunType = TYPE_SERIAL;
+    priv->gunBaud = 9600;
+    priv->gunTapping = 0;         /* default */
+    priv->gunSmooth = 9;          /* quite smooth */
+    priv->gunAvgX = -1;           /* previous (avg) X position */
+    priv->gunAvgY = -1;           /* previous (avg) Y position */
+    priv->gunPrevButton = 0;      /* previous buttons state */
+    priv->flags = FLAG_WAS_UP;    /* first event is button-down */
+    priv->gunBytes = 0;           /* number of bytes read */
+    priv->fd = -1;
+
+    return priv;
+}
+
+//-----------------------------------------------------------------------------------------------
+void SetupFonts()
+{
+    DFBFontDescription font_dsc;
+    font_dsc.flags = DFDESC_HEIGHT;
+    font_dsc.height=25;
+    DFBCHECK(dfb->CreateFont(dfb,"/usr/local/gnatfb/GARA.TTF",&font_dsc,&gara_reg_12));
+}
+
+//-----------------------------------------------------------------------------------------------
+void ReleaseFonts()
+{
+    DFBCHECK(gara_reg_12->Release(gara_reg_12));
+}
+
+void DrawRects(char *input)
+{
+    int wid = screen_width; //[winfo screenwidth .]
+    int hei = screen_height; //[winfo screenheight .]
+
+    int x = screen_width/8;//[expr $wid/8]
+    int y = screen_height/8;//[expr $hei/8]
+    int LX = wid-x;//[expr $wid - $x]
+    int LY = hei-y;//[expr $hei - $y]
+    int hx = screen_width/2;//[expr $wid/2]
+    int hy = screen_height/2;//[expr $hei/2]
+    int cwid = 2*x;//[expr 2*$x]
+    int chei = 2*y;//[expr 2*$y]
+
+    DFBCHECK(primary->Clear(primary,55,18,5,0));
+    DFBCHECK(primary->Flip(primary,NULL,DSFLIP_NONE));
+    DFBCHECK(primary->Clear(primary,55,18,5,0));
+    DFBCHECK(primary->SetFont(primary,gara_reg_12));
+
+    DFBCHECK(primary->SetColor(primary,0xFF,0xEF,0xB5,0));
+    //Bottom Rectangle
+    DFBCHECK(primary->DrawRectangle(primary,50,hei-chei,cwid,chei));
+    // Top Rectangle
+    DFBCHECK(primary->DrawRectangle(primary,wid-cwid-50,0,cwid,chei));
+
+    // Draw Two Cross Hairs
+    DFBCHECK(primary->DrawLine(primary,50,hei-chei+50,150,hei-chei+50));
+    DFBCHECK(primary->DrawLine(primary,100,hei-chei,100,hei-chei+100));
+
+    DFBCHECK(primary->DrawLine(primary,wid-(cwid/2), 0 ,wid-(cwid/2), 100));
+    DFBCHECK(primary->DrawLine(primary,wid-(cwid/2)-50, 50 ,wid-(cwid/2)+50, 50));
+    DFBCHECK(primary->DrawString(primary,input,-1,screen_width/2,screen_height/2,DSTF_CENTER));
+    DFBCHECK(primary->Flip(primary,NULL,DSFLIP_NONE));
+    sleep(1);
+}
+
+//-----------------------------------------------------------------------------------------------
+int main(int argc, char *argv[])
+{
+    int quit = 0;
+
+    DFBSurfaceDescription dsc;
+    DFBCHECK (DirectFBInit (&argc, &argv));
+    DFBCHECK (DirectFBCreate (&dfb));
+
+    DFBCHECK (dfb->SetCooperativeLevel (dfb,DFSCL_EXCLUSIVE));// DFSCL_FULLSCREEN));
+    DFBCHECK (dfb->SetVideoMode(dfb,1024,768,16));
+    dsc.flags = DSDESC_CAPS | DSDESC_WIDTH | DSDESC_HEIGHT;
+    dsc.caps = DSCAPS_PRIMARY | DSCAPS_FLIPPING;
+    dsc.width = 1024;
+    dsc.height = 768;
+
+    // Surface Creation
+    DFBCHECK (dfb->CreateSurface(dfb, &dsc, &primary));
+    DFBCHECK (primary->GetSize(primary, &screen_width, &screen_height));
+    DFBCHECK (primary->SetBlittingFlags(primary,DSBLIT_BLEND_ALPHACHANNEL));
+
+    // Event Handlers
+    DFBCHECK(dfb->CreateInputEventBuffer(dfb,DICAPS_ALL,DFB_FALSE,&buffer));
+    //Cursor
+
+    SetupFonts();
+
+    GunzeDevice *priv = GunzeAllocate();
+    if(GunzeOpen(priv) != 0){
+        fprintf(stderr,"Error Opening device!\n");
+        return -1;
+    }
+
+    //The offset variables account for window manager borders etc
+
+    //DFBCHECK(primary->DrawLine(primary,wid-cwid-50, 0 ,wid-cwid+50, 50));
+    DrawRects("Touch Left Cross");
+
+    GetCalibData(priv);
+    int x1 = coords.x;
+    int y1 = coords.y;
+    DrawRects("Touch Right Cross");
+
+    GetCalibData(priv);
+    int x2 = coords.x;
+    int y2 = coords.y;
+
+    DrawRects("Done");
+    char tmp[100];
+    memset(tmp,0,100);
+    sprintf(tmp,"X1:%d Y1:%d X2:%d Y2:%d",x1,y1,x2,y2);
+    DFBCHECK(primary->DrawString(primary,tmp,-1,screen_width/2,(screen_height/2)-150,DSTF_CENTER));
+    DFBCHECK(primary->Flip(primary,NULL,DSFLIP_NONE));
+    memset(tmp,0,100);
+    sprintf(tmp,"# Calibration coordinates for Gunze Device\n%d %d %d %d",x1,y1,x2,y2);
+    int fd = 0;
+    SYSCALL(fd = open(priv->gunConfig, O_RDWR | O_TRUNC | O_CREAT));
+    SYSCALL(write(fd,tmp,strlen(tmp)));
+    close(fd);
+
+    DFBInputEvent event;
+
+    while(!quit)
+    {
+        buffer->WaitForEvent(buffer);
+        while ( buffer->GetEvent(buffer, DFB_EVENT(&event)) == DFB_OK)
+        {
+            if(event.type == DIET_KEYPRESS)
+            {
+                if(event.key_id == DIKI_ESCAPE || event.key_id == DIKI_Q)
+                {
+                    printf("Q||ESC KEY pressed event\n");
+                    fflush(NULL);
+
+                    quit = 1;
+                }
+            }
+        }
+    }
+
+    close(priv->fd);
+    free(priv);
+
+    ReleaseFonts();
+    if(mouse != NULL)
+        mouse->Release(mouse);
+
+    buffer->Release(buffer);
+    primary->Release(primary);
+    dfb->Release(dfb);
+    return 0;
+}
diff --git a/DirectFB-1.3.0/inputdrivers/penmount/Makefile.am b/DirectFB-1.3.0/inputdrivers/penmount/Makefile.am
old mode 100755
new mode 100644
diff --git a/DirectFB-1.3.0/inputdrivers/penmount/penmount.c b/DirectFB-1.3.0/inputdrivers/penmount/penmount.c
old mode 100755
new mode 100644
diff --git a/DirectFB-1.3.0/interfaces/IDirectFBFont/default_font.png b/DirectFB-1.3.0/interfaces/IDirectFBFont/default_font.png
new file mode 100644
index 0000000..e28d66a
Binary files /dev/null and b/DirectFB-1.3.0/interfaces/IDirectFBFont/default_font.png differ
diff --git a/DirectFB-1.3.0/interfaces/IDirectFBFont/idirectfbfont_default.c b/DirectFB-1.3.0/interfaces/IDirectFBFont/idirectfbfont_default.c
index 99f4d80..848ec19 100644
--- a/DirectFB-1.3.0/interfaces/IDirectFBFont/idirectfbfont_default.c
+++ b/DirectFB-1.3.0/interfaces/IDirectFBFont/idirectfbfont_default.c
@@ -224,7 +224,7 @@ Construct( IDirectFBFont      *thiz,
      {
           CoreSurfaceBufferLock lock;
 
-          ret = dfb_surface_lock_buffer( surface, CSBR_BACK, CSAID_CPU, CSAF_WRITE, &lock );
+          ret = dfb_surface_lock_buffer( surface, CSBR_BACK, CSAF_CPU_WRITE, &lock );
           if (ret) {
                D_DERROR( ret, "IDirectFBFont_Default: Could not lock surface buffer!\n" );
           }
diff --git a/DirectFB-1.3.0/interfaces/IDirectFBFont/idirectfbfont_ft2.c b/DirectFB-1.3.0/interfaces/IDirectFBFont/idirectfbfont_ft2.c
index 2179e9e..cc34cfa 100644
--- a/DirectFB-1.3.0/interfaces/IDirectFBFont/idirectfbfont_ft2.c
+++ b/DirectFB-1.3.0/interfaces/IDirectFBFont/idirectfbfont_ft2.c
@@ -269,7 +269,7 @@ render_glyph( CoreFont      *thiz,
 
      pthread_mutex_unlock ( &library_mutex );
 
-     err = dfb_surface_lock_buffer( surface, CSBR_BACK, CSAID_CPU, CSAF_WRITE, &lock );
+     err = dfb_surface_lock_buffer( surface, CSBR_BACK, CSAF_CPU_WRITE, &lock );
      if (err) {
           D_DERROR( err, "DirectFB/FontFT2: Unable to lock surface!\n" );
           return err;
diff --git a/DirectFB-1.3.0/interfaces/IDirectFBImageProvider/idirectfbimageprovider_gif.c b/DirectFB-1.3.0/interfaces/IDirectFBImageProvider/idirectfbimageprovider_gif.c
index c939276..9e728fc 100644
--- a/DirectFB-1.3.0/interfaces/IDirectFBImageProvider/idirectfbimageprovider_gif.c
+++ b/DirectFB-1.3.0/interfaces/IDirectFBImageProvider/idirectfbimageprovider_gif.c
@@ -305,7 +305,7 @@ IDirectFBImageProvider_GIF_RenderTo( IDirectFBImageProvider *thiz,
      if (dfb_rectangle_region_intersects( &rect, &clip )) {
           CoreSurfaceBufferLock lock;
 
-          ret = dfb_surface_lock_buffer( dst_surface, CSBR_BACK, CSAID_CPU, CSAF_WRITE, &lock );
+          ret = dfb_surface_lock_buffer( dst_surface, CSBR_BACK, CSAF_CPU_WRITE, &lock );
           if (ret)
                return ret;
 
diff --git a/DirectFB-1.3.0/interfaces/IDirectFBImageProvider/idirectfbimageprovider_jpeg.c b/DirectFB-1.3.0/interfaces/IDirectFBImageProvider/idirectfbimageprovider_jpeg.c
index b5956aa..8bb85cf 100644
--- a/DirectFB-1.3.0/interfaces/IDirectFBImageProvider/idirectfbimageprovider_jpeg.c
+++ b/DirectFB-1.3.0/interfaces/IDirectFBImageProvider/idirectfbimageprovider_jpeg.c
@@ -249,32 +249,19 @@ copy_line_nv16( u16 *yy, u16 *cbcr, const u8 *src_ycbcr, int width )
 {
      int x;
 
+     D_ASSUME( !(width & 1) );
+
      for (x=0; x<width/2; x++) {
 #ifdef WORDS_BIGENDIAN
           yy[x] = (src_ycbcr[0] << 8) | src_ycbcr[3];
-
-          cbcr[x] = (((src_ycbcr[1] + src_ycbcr[4]) << 7) & 0xff00) |
-                     ((src_ycbcr[2] + src_ycbcr[5]) >> 1);
 #else
           yy[x] = (src_ycbcr[3] << 8) | src_ycbcr[0];
-
-          cbcr[x] = (((src_ycbcr[2] + src_ycbcr[5]) << 7) & 0xff00) |
-                     ((src_ycbcr[1] + src_ycbcr[4]) >> 1);
 #endif
 
-          src_ycbcr += 6;
-     }
-
-     if (width & 1) {
-          u8 *y = (u8*) yy;
-
-          y[width-1] = src_ycbcr[0];
+          cbcr[x] = (((src_ycbcr[1] + src_ycbcr[4]) << 7) & 0xff00) |
+                     ((src_ycbcr[2] + src_ycbcr[5]) >> 1);
 
-#ifdef WORDS_BIGENDIAN
-          cbcr[x] = (src_ycbcr[1] << 8) | src_ycbcr[2];
-#else
-          cbcr[x] = (src_ycbcr[2] << 8) | src_ycbcr[1];
-#endif
+          src_ycbcr += 6;
      }
 }
 
@@ -435,7 +422,7 @@ IDirectFBImageProvider_JPEG_RenderTo( IDirectFBImageProvider *thiz,
           rect = dst_data->area.wanted;
      }
 
-     ret = dfb_surface_lock_buffer( dst_surface, CSBR_BACK, CSAID_CPU, CSAF_WRITE, &lock );
+     ret = dfb_surface_lock_buffer( dst_surface, CSBR_BACK, CSAF_CPU_WRITE, &lock );
      if (ret)
           return ret;
 
diff --git a/DirectFB-1.3.0/interfaces/IDirectFBImageProvider/idirectfbimageprovider_png.c b/DirectFB-1.3.0/interfaces/IDirectFBImageProvider/idirectfbimageprovider_png.c
index 574e82a..68ba241 100644
--- a/DirectFB-1.3.0/interfaces/IDirectFBImageProvider/idirectfbimageprovider_png.c
+++ b/DirectFB-1.3.0/interfaces/IDirectFBImageProvider/idirectfbimageprovider_png.c
@@ -305,7 +305,6 @@ IDirectFBImageProvider_PNG_RenderTo( IDirectFBImageProvider *thiz,
      DFBRectangle           rect;
      png_infop              info;
      int                    x, y;
-     DFBRectangle           clipped;
 
      DIRECT_INTERFACE_GET_DATA (IDirectFBImageProvider_PNG)
 
@@ -348,26 +347,11 @@ IDirectFBImageProvider_PNG_RenderTo( IDirectFBImageProvider *thiz,
                return ret;
      }
 
-     clipped = rect;
-
-     if (!dfb_rectangle_intersect_by_region( &clipped, &clip ))
-          return DFB_INVAREA;
-
      /* actual rendering */
-     if (rect.w == data->width && rect.h == data->height &&
-         (data->color_type == PNG_COLOR_TYPE_RGB || data->color_type == PNG_COLOR_TYPE_RGBA) &&
-         (dst_surface->config.format == DSPF_RGB32 || dst_surface->config.format == DSPF_ARGB))
-     {
-          ret = dfb_surface_write_buffer( dst_surface, CSBR_BACK,
-                                          data->image +
-                                             (clipped.x - rect.x) * 4 +
-                                             (clipped.y - rect.y) * data->width * 4,
-                                          data->width * 4, &clipped );
-     }
-     else {
+     if (dfb_rectangle_region_intersects( &rect, &clip )) {
           CoreSurfaceBufferLock lock;
 
-          ret = dfb_surface_lock_buffer( dst_surface, CSBR_BACK, CSAID_CPU, CSAF_WRITE, &lock );
+          ret = dfb_surface_lock_buffer( dst_surface, CSBR_BACK, CSAF_CPU_WRITE, &lock );
           if (ret)
                return ret;
 
diff --git a/DirectFB-1.3.0/interfaces/IDirectFBVideoProvider/idirectfbvideoprovider_gif.c b/DirectFB-1.3.0/interfaces/IDirectFBVideoProvider/idirectfbvideoprovider_gif.c
index 119f5f1..29e04e8 100644
--- a/DirectFB-1.3.0/interfaces/IDirectFBVideoProvider/idirectfbvideoprovider_gif.c
+++ b/DirectFB-1.3.0/interfaces/IDirectFBVideoProvider/idirectfbvideoprovider_gif.c
@@ -784,7 +784,7 @@ GIFVideo( DirectThread *self, void *arg )
           D_MAGIC_ASSERT( surface, CoreSurface );
 
           if (dfb_rectangle_region_intersects( &rect, &clip ) &&
-              dfb_surface_lock_buffer( surface, CSBR_BACK, CSAID_CPU, CSAF_WRITE, &lock ) == DFB_OK)
+              dfb_surface_lock_buffer( surface, CSBR_BACK, CSAF_CPU_WRITE, &lock ) == DFB_OK)
           {
                dfb_scale_linear_32( data->image, data->Width, data->Height,
                                     lock.addr, lock.pitch, &rect, data->dst_data->surface, &clip );
diff --git a/DirectFB-1.3.0/interfaces/IDirectFBVideoProvider/idirectfbvideoprovider_v4l.c b/DirectFB-1.3.0/interfaces/IDirectFBVideoProvider/idirectfbvideoprovider_v4l.c
new file mode 100644
index 0000000..601bb21
--- /dev/null
+++ b/DirectFB-1.3.0/interfaces/IDirectFBVideoProvider/idirectfbvideoprovider_v4l.c
@@ -0,0 +1,1481 @@
+/*
+   (c) Copyright 2001-2008  The world wide DirectFB Open Source Community (directfb.org)
+   (c) Copyright 2000-2004  Convergence (integrated media) GmbH
+
+   All rights reserved.
+
+   Written by Denis Oliver Kropp <dok@directfb.org>,
+              Andreas Hundt <andi@fischlustig.de>,
+              Sven Neumann <neo@directfb.org>,
+              Ville Syrjl <syrjala@sci.fi> and
+              Claudio Ciccani <klan@users.sf.net>.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#if defined(__dietlibc__) && !defined(_BSD_SOURCE)
+#define _BSD_SOURCE
+#endif
+
+#include <config.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <stdarg.h>
+
+#include <string.h>
+
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/select.h>
+#include <sys/mman.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+
+#ifdef HAVE_LINUX_COMPILER_H
+#include <linux/compiler.h>
+#endif
+#include "videodev.h"
+
+#include <directfb.h>
+
+#include <media/idirectfbvideoprovider.h>
+#include <media/idirectfbdatabuffer.h>
+
+#include <core/core.h>
+#include <core/coredefs.h>
+#include <core/coretypes.h>
+
+#include <core/state.h>
+#include <core/gfxcard.h>
+#include <core/layers.h>
+#include <core/layer_control.h>
+#include <core/surface.h>
+#include <core/surfacemanager.h>
+
+#include <display/idirectfbsurface.h>
+
+#include <misc/util.h>
+
+#include <direct/interface.h>
+#include <direct/mem.h>
+#include <direct/memcpy.h>
+#include <direct/messages.h>
+#include <direct/thread.h>
+#include <direct/util.h>
+
+#ifdef DFB_HAVE_V4L2
+#include "videodev2.h"
+#endif
+
+static DFBResult
+Probe( IDirectFBVideoProvider_ProbeContext *ctx );
+
+static DFBResult
+Construct( IDirectFBVideoProvider *thiz,
+           ... );
+
+#include <direct/interface_implementation.h>
+
+DIRECT_INTERFACE_IMPLEMENTATION( IDirectFBVideoProvider, V4L )
+
+/*
+ * private data struct of IDirectFBVideoProvider
+ */
+typedef struct {
+     int                      ref;       /* reference counter */
+
+     char                    *filename;
+     int                      fd;
+#ifdef DFB_HAVE_V4L2
+#define NUMBER_OF_BUFFERS 2
+     bool is_v4l2;
+
+     struct v4l2_format fmt;
+     struct v4l2_capability caps;
+
+     struct v4l2_queryctrl brightness;
+     struct v4l2_queryctrl contrast;
+     struct v4l2_queryctrl saturation;
+     struct v4l2_queryctrl hue;
+
+     struct v4l2_requestbuffers req;
+     struct v4l2_buffer vidbuf[NUMBER_OF_BUFFERS];
+     char *ptr[NUMBER_OF_BUFFERS]; /* only used for capture to system memory */
+     bool framebuffer_or_system;
+#endif
+     struct video_capability  vcap;
+     struct video_mmap        vmmap;
+     struct video_mbuf        vmbuf;
+     void                    *buffer;
+     bool                     grab_mode;
+
+     DirectThread            *thread;
+     CoreSurface             *destination;
+     DVFrameCallback          callback;
+     void                    *ctx;
+
+     CoreCleanup             *cleanup;
+
+     bool                     running;
+     pthread_mutex_t          lock;
+
+     Reaction                 reaction; /* for the destination listener */
+
+     CoreDFB                 *core;
+} IDirectFBVideoProvider_V4L_data;
+
+static const unsigned int zero = 0;
+static const unsigned int one = 1;
+
+static void* OverlayThread( DirectThread *thread, void *context );
+static void* GrabThread( DirectThread *thread, void *context );
+static ReactionResult v4l_videosurface_listener( const void *msg_data, void *ctx );
+static ReactionResult v4l_systemsurface_listener( const void *msg_data, void *ctx );
+static DFBResult v4l_to_surface_overlay( CoreSurface *surface, DFBRectangle *rect,
+                                         IDirectFBVideoProvider_V4L_data *data );
+static DFBResult v4l_to_surface_grab( CoreSurface *surface, DFBRectangle *rect,
+                                      IDirectFBVideoProvider_V4L_data *data );
+static DFBResult v4l_stop( IDirectFBVideoProvider_V4L_data *data, bool detach );
+static void v4l_deinit( IDirectFBVideoProvider_V4L_data *data );
+static void v4l_cleanup( void *data, int emergency );
+
+#ifdef DFB_HAVE_V4L2
+static DFBResult v4l2_playto(CoreSurface * surface, DFBRectangle * rect, IDirectFBVideoProvider_V4L_data * data);
+#endif
+
+static void IDirectFBVideoProvider_V4L_Destruct( IDirectFBVideoProvider *thiz )
+{
+     IDirectFBVideoProvider_V4L_data *data =
+     (IDirectFBVideoProvider_V4L_data*)thiz->priv;
+
+     if (data->cleanup)
+          dfb_core_cleanup_remove( NULL, data->cleanup );
+
+     v4l_deinit( data );
+
+     D_FREE( data->filename );
+
+     pthread_mutex_destroy( &data->lock );
+
+     DIRECT_DEALLOCATE_INTERFACE( thiz );
+}
+
+static DirectResult IDirectFBVideoProvider_V4L_AddRef( IDirectFBVideoProvider *thiz )
+{
+     DIRECT_INTERFACE_GET_DATA (IDirectFBVideoProvider_V4L)
+
+     data->ref++;
+
+     return DFB_OK;
+}
+
+static DirectResult IDirectFBVideoProvider_V4L_Release( IDirectFBVideoProvider *thiz )
+{
+     DIRECT_INTERFACE_GET_DATA (IDirectFBVideoProvider_V4L)
+
+     if (--data->ref == 0) {
+          IDirectFBVideoProvider_V4L_Destruct( thiz );
+     }
+
+     return DFB_OK;
+}
+
+static DFBResult IDirectFBVideoProvider_V4L_GetCapabilities (
+                                                            IDirectFBVideoProvider       *thiz,
+                                                            DFBVideoProviderCapabilities *caps )
+{
+     DIRECT_INTERFACE_GET_DATA (IDirectFBVideoProvider_V4L)
+
+     if (!caps)
+          return DFB_INVARG;
+
+#ifdef DFB_HAVE_V4L2
+     if ( 0 != data->is_v4l2 ) {
+
+          *caps = 0;
+
+          data->saturation.id = V4L2_CID_SATURATION;
+          if ( 0 != ioctl(data->fd, VIDIOC_G_CTRL, &data->saturation)) {
+               *caps |= DVCAPS_SATURATION;
+          }
+          else {
+               data->saturation.id = 0;
+          }
+          data->brightness.id = V4L2_CID_BRIGHTNESS;
+          if ( 0 != ioctl(data->fd, VIDIOC_G_CTRL, &data->brightness)) {
+               *caps |= DVCAPS_BRIGHTNESS;
+          }
+          else {
+               data->brightness.id = 0;
+          }
+          data->contrast.id = V4L2_CID_CONTRAST;
+          if ( 0 != ioctl(data->fd, VIDIOC_G_CTRL, &data->contrast)) {
+               *caps |= DVCAPS_CONTRAST;
+          }
+          else {
+               data->contrast.id = 0;
+          }
+          data->hue.id = V4L2_CID_HUE;
+          if ( 0 != ioctl(data->fd, VIDIOC_G_CTRL, &data->hue)) {
+               *caps |= DVCAPS_HUE;
+          }
+          else {
+               data->hue.id = 0;
+          }
+          /* fixme: interlaced might not be true for field capture */
+          *caps |= DVCAPS_BASIC | DVCAPS_SCALE | DVCAPS_INTERLACED;
+     }
+     else
+#endif
+     {
+          *caps = ( DVCAPS_BASIC      |
+                    DVCAPS_BRIGHTNESS |
+                    DVCAPS_CONTRAST   |
+                    DVCAPS_HUE        |
+                    DVCAPS_SATURATION |
+                    DVCAPS_INTERLACED );
+
+          if (data->vcap.type & VID_TYPE_SCALES)
+               *caps |= DVCAPS_SCALE;
+     }
+
+     return DFB_OK;
+}
+
+static DFBResult IDirectFBVideoProvider_V4L_GetSurfaceDescription(
+                                                                 IDirectFBVideoProvider *thiz,
+                                                                 DFBSurfaceDescription  *desc )
+{
+     IDirectFBVideoProvider_V4L_data *data;
+
+     if (!thiz || !desc)
+          return DFB_INVARG;
+
+     data = (IDirectFBVideoProvider_V4L_data*)thiz->priv;
+
+     if (!data)
+          return DFB_DEAD;
+
+     desc->flags  = DSDESC_WIDTH | DSDESC_HEIGHT | DSDESC_PIXELFORMAT | DSDESC_CAPS;
+#ifdef DFB_HAVE_V4L2
+     if ( 0 != data->is_v4l2 ) {
+          desc->width = 720;  /* fimxe: depends on the selected standard: query standard and set accordingly */
+          desc->height = 576;
+     }
+     else
+#endif
+     {
+          desc->width  = data->vcap.maxwidth;
+          desc->height = data->vcap.maxheight;
+     }
+     desc->pixelformat = dfb_primary_layer_pixelformat();
+     desc->caps = DSCAPS_INTERLACED;
+
+     return DFB_OK;
+}
+
+static DFBResult IDirectFBVideoProvider_V4L_GetStreamDescription(
+                                                                 IDirectFBVideoProvider *thiz,
+                                                                 DFBStreamDescription   *desc )
+{
+     DIRECT_INTERFACE_GET_DATA (IDirectFBVideoProvider_V4L)
+
+     if (!desc)
+          return DFB_INVARG;
+
+     desc->caps = DVSCAPS_VIDEO;
+     
+     desc->video.encoding[0] = 0;
+     desc->video.framerate   = 10; // assume 10fps
+#ifdef DFB_HAVE_V4L2
+     desc->video.aspect      = 720.0/576.0;
+#else
+     desc->video.aspect      = (double)data->vcap.maxwidth /
+                               (double)data->vcap.maxheight;
+#endif
+     desc->video.bitrate     = 0;
+
+     desc->title[0] = desc->author[0] = desc->album[0]   =
+     desc->year     = desc->genre[0]  = desc->comment[0] = 0;
+
+     return DFB_OK;
+}
+
+static DFBResult IDirectFBVideoProvider_V4L_PlayTo(
+                                                  IDirectFBVideoProvider *thiz,
+                                                  IDirectFBSurface       *destination,
+                                                  const DFBRectangle     *dstrect,
+                                                  DVFrameCallback         callback,
+                                                  void                   *ctx )
+{
+     DFBRectangle           rect;
+     IDirectFBSurface_data *dst_data;
+     CoreSurface           *surface = 0;
+     DFBResult              ret;
+
+     DIRECT_INTERFACE_GET_DATA (IDirectFBVideoProvider_V4L)
+
+     if (!destination)
+          return DFB_INVARG;
+
+     dst_data = (IDirectFBSurface_data*)destination->priv;
+
+     if (!dst_data)
+          return DFB_DEAD;
+
+     if (!dst_data->area.current.w || !dst_data->area.current.h)
+          return DFB_INVAREA;
+
+     if (dstrect) {
+          if (dstrect->w < 1  ||  dstrect->h < 1)
+               return DFB_INVARG;
+
+          rect = *dstrect;
+
+          rect.x += dst_data->area.wanted.x;
+          rect.y += dst_data->area.wanted.y;
+     }
+     else
+          rect = dst_data->area.wanted;
+
+     if (!dfb_rectangle_intersect( &rect, &dst_data->area.current ))
+          return DFB_INVAREA;
+
+     v4l_stop( data, true );
+
+     pthread_mutex_lock( &data->lock );
+
+     data->callback = callback;
+     data->ctx      = ctx;
+
+     surface = dst_data->surface;
+
+#ifdef DFB_HAVE_V4L2
+     if ( 0 != data->is_v4l2 ) {
+          ret = v4l2_playto(surface, &rect, data);
+     }
+     else
+#endif
+     {
+          data->grab_mode = 0;
+          if ( getenv("DFB_V4L_GRAB") || surface->caps & DSCAPS_SYSTEMONLY
+               || surface->caps & DSCAPS_FLIPPING
+               || !(VID_TYPE_OVERLAY & data->vcap.type))
+               data->grab_mode = 1;
+          else {
+               dfb_surfacemanager_lock( surface->manager );
+
+               /*
+                * Because we're constantly writing to the surface we
+                * permanently lock it.
+                */
+               ret = dfb_surface_hardware_lock( data->core, surface,
+                                                DSLF_WRITE | CSLF_FORCE, false );
+
+               dfb_surfacemanager_unlock( surface->manager );
+
+               if (ret) {
+                    pthread_mutex_unlock( &data->lock );
+                    return ret;
+               }
+          }
+
+          if (data->grab_mode)
+               ret = v4l_to_surface_grab( surface, &rect, data );
+          else
+               ret = v4l_to_surface_overlay( surface, &rect, data );
+     }
+     if (DFB_OK != ret && !data->grab_mode)
+          dfb_surface_unlock( surface, false );
+
+     pthread_mutex_unlock( &data->lock );
+
+     return ret;
+}
+
+static DFBResult IDirectFBVideoProvider_V4L_Stop(
+                                                IDirectFBVideoProvider *thiz )
+{
+     DIRECT_INTERFACE_GET_DATA (IDirectFBVideoProvider_V4L)
+
+     return v4l_stop( data, true );
+}
+
+static DFBResult IDirectFBVideoProvider_V4L_GetStatus( 
+                                                     IDirectFBVideoProvider *thiz,
+                                                     DFBVideoProviderStatus *status )
+{
+     DIRECT_INTERFACE_GET_DATA (IDirectFBVideoProvider_V4L)
+
+     if (!status)
+          return DFB_INVARG;
+
+     *status = data->running ? DVSTATE_PLAY : DVSTATE_STOP;
+
+     return DFB_OK;
+}
+
+static DFBResult IDirectFBVideoProvider_V4L_SeekTo(
+                                                  IDirectFBVideoProvider *thiz,
+                                                  double                  seconds )
+{
+     DIRECT_INTERFACE_GET_DATA (IDirectFBVideoProvider_V4L)
+
+     return DFB_UNIMPLEMENTED;
+}
+
+static DFBResult IDirectFBVideoProvider_V4L_GetPos(
+                                                  IDirectFBVideoProvider *thiz,
+                                                  double                 *seconds )
+{
+     DIRECT_INTERFACE_GET_DATA (IDirectFBVideoProvider_V4L)
+
+     return DFB_UNSUPPORTED;
+}
+
+static DFBResult IDirectFBVideoProvider_V4L_GetLength(
+                                                     IDirectFBVideoProvider *thiz,
+                                                     double                 *seconds )
+{
+     DIRECT_INTERFACE_GET_DATA (IDirectFBVideoProvider_V4L)
+
+     return DFB_UNSUPPORTED;
+}
+
+static DFBResult IDirectFBVideoProvider_V4L_GetColorAdjustment(
+                                                              IDirectFBVideoProvider *thiz,
+                                                              DFBColorAdjustment     *adj )
+{
+     struct video_picture pic;
+
+     DIRECT_INTERFACE_GET_DATA (IDirectFBVideoProvider_V4L)
+
+     if (!adj)
+          return DFB_INVARG;
+
+#ifdef DFB_HAVE_V4L2
+     if ( 0 != data->is_v4l2 ) {
+          struct v4l2_control ctrl;
+
+          if (data->brightness.id != 0) {
+               ctrl.id = data->brightness.id;
+               if ( 0 == ioctl(data->fd, VIDIOC_G_CTRL, &ctrl)) {
+                    adj->flags |= DCAF_BRIGHTNESS;
+                    adj->brightness = 0xffff * ctrl.value / (data->brightness.maximum - data->brightness.minimum);
+               }
+          }
+          if (data->contrast.id != 0) {
+               ctrl.id = data->contrast.id;
+               if ( 0 == ioctl(data->fd, VIDIOC_G_CTRL, &ctrl)) {
+                    adj->flags |= DCAF_CONTRAST;
+                    adj->contrast = 0xffff * ctrl.value / (data->contrast.maximum - data->contrast.minimum);
+               }
+          }
+          if (data->hue.id != 0) {
+               ctrl.id = data->hue.id;
+               if ( 0 == ioctl(data->fd, VIDIOC_G_CTRL, &ctrl)) {
+                    adj->flags |= DCAF_HUE;
+                    adj->hue = 0xffff * ctrl.value / (data->hue.maximum - data->hue.minimum);
+               }
+          }
+          if (data->saturation.id != 0) {
+               ctrl.id = data->saturation.id;
+               if ( 0 == ioctl(data->fd, VIDIOC_G_CTRL, &ctrl)) {
+                    adj->flags |= DCAF_SATURATION;
+                    adj->saturation = 0xffff * ctrl.value / (data->saturation.maximum - data->saturation.minimum);
+               }
+          }
+     }
+     else
+#endif
+     {
+          ioctl( data->fd, VIDIOCGPICT, &pic );
+
+          adj->flags = DCAF_BRIGHTNESS | DCAF_CONTRAST | DCAF_HUE | DCAF_SATURATION;
+
+          adj->brightness = pic.brightness;
+          adj->contrast   = pic.contrast;
+          adj->hue        = pic.hue;
+          adj->saturation = pic.colour;
+     }
+     return DFB_OK;
+}
+
+static DFBResult IDirectFBVideoProvider_V4L_SetColorAdjustment( IDirectFBVideoProvider   *thiz,
+                                                                const DFBColorAdjustment *adj )
+{
+     struct video_picture pic;
+
+     DIRECT_INTERFACE_GET_DATA (IDirectFBVideoProvider_V4L)
+
+     if (!adj)
+          return DFB_INVARG;
+
+     if (adj->flags == DCAF_NONE)
+          return DFB_OK;
+
+#ifdef DFB_HAVE_V4L2
+     if ( 0 != data->is_v4l2 ) {
+          struct v4l2_control ctrl;
+          if (adj->flags & DCAF_BRIGHTNESS && data->brightness.id != 0) {
+               ctrl.id = data->brightness.id;
+               ctrl.value = (adj->brightness * (data->brightness.maximum - data->brightness.minimum)) / 0xfff;
+               ioctl(data->fd, VIDIOC_S_CTRL, &ctrl);
+          }
+          if (adj->flags & DCAF_CONTRAST && data->contrast.id != 0) {
+               ctrl.id = data->contrast.id;
+               ctrl.value = (adj->contrast * (data->contrast.maximum - data->contrast.minimum)) / 0xfff;
+               ioctl(data->fd, VIDIOC_S_CTRL, &ctrl);
+          }
+          if (adj->flags & DCAF_HUE && data->hue.id != 0) {
+               ctrl.id = data->hue.id;
+               ctrl.value = (adj->hue * (data->hue.maximum - data->hue.minimum)) / 0xfff;
+               ioctl(data->fd, VIDIOC_S_CTRL, &ctrl);
+          }
+          if (adj->flags & DCAF_SATURATION && data->saturation.id != 0) {
+               ctrl.id = data->saturation.id;
+               ctrl.value = (adj->saturation * (data->saturation.maximum - data->saturation.minimum)) / 0xfff;
+               ioctl(data->fd, VIDIOC_S_CTRL, &ctrl);
+          }
+     }
+     else
+#endif
+     {
+          if (ioctl( data->fd, VIDIOCGPICT, &pic ) < 0) {
+               DFBResult ret = errno2result( errno );
+
+               D_PERROR( "DirectFB/Video4Linux: VIDIOCGPICT failed!\n" );
+
+               return ret;
+          }
+
+          if (adj->flags & DCAF_BRIGHTNESS) pic.brightness = adj->brightness;
+          if (adj->flags & DCAF_CONTRAST)   pic.contrast   = adj->contrast;
+          if (adj->flags & DCAF_HUE)        pic.hue        = adj->hue;
+          if (adj->flags & DCAF_SATURATION) pic.colour     = adj->saturation;
+
+          if (ioctl( data->fd, VIDIOCSPICT, &pic ) < 0) {
+               DFBResult ret = errno2result( errno );
+
+               D_PERROR( "DirectFB/Video4Linux: VIDIOCSPICT failed!\n" );
+
+               return ret;
+          }
+     }
+
+     return DFB_OK;
+}
+
+static DFBResult IDirectFBVideoProvider_V4L_SendEvent( IDirectFBVideoProvider *thiz,
+                                                       const DFBEvent         *evt )
+{
+     DIRECT_INTERFACE_GET_DATA (IDirectFBVideoProvider_V4L)
+
+     return DFB_UNSUPPORTED;
+}
+
+
+/* exported symbols */
+
+static DFBResult
+Probe( IDirectFBVideoProvider_ProbeContext *ctx )
+{
+     if (ctx->filename) {
+          if (strncmp( ctx->filename, "/dev/video", 10 ) == 0)
+               return DFB_OK;
+
+          if (strncmp( ctx->filename, "/dev/v4l/video", 14 ) == 0)
+               return DFB_OK;
+     }
+
+     return DFB_UNSUPPORTED;
+}
+
+static DFBResult
+Construct( IDirectFBVideoProvider *thiz, ... )
+{
+     int fd;
+     IDirectFBDataBuffer *buffer;
+     IDirectFBDataBuffer_data *buffer_data;
+     CoreDFB             *core;
+     va_list              tag;
+
+     DIRECT_ALLOCATE_INTERFACE_DATA(thiz, IDirectFBVideoProvider_V4L)
+
+     va_start( tag, thiz );
+     buffer = va_arg( tag, IDirectFBDataBuffer * );
+     core = va_arg( tag, CoreDFB * );
+     va_end( tag );
+
+
+     data->ref  = 1;
+     data->core = core;
+
+     buffer_data = (IDirectFBDataBuffer_data*) buffer->priv;
+
+     fd = open( buffer_data->filename, O_RDWR );     
+     if (fd < 0) {
+          DFBResult ret = errno2result( errno );
+
+          D_PERROR( "DirectFB/Video4Linux: Cannot open `%s'!\n",
+                     buffer_data->filename );
+
+          DIRECT_DEALLOCATE_INTERFACE( thiz );
+          return ret;
+     }
+
+     direct_util_recursive_pthread_mutex_init( &data->lock );
+
+#ifdef DFB_HAVE_V4L2
+     data->is_v4l2 = 0;
+
+     /* look if the device is a v4l2 device */
+     if (0 == ioctl(fd, VIDIOC_QUERYCAP, &data->caps)) {
+          D_INFO("DirectFB/Video4Linux: This is a Video4Linux-2 device.\n");
+          data->is_v4l2 = 1;
+     }
+
+     if ( 0 != data->is_v4l2 ) {
+          /* hmm, anything to do here? */
+     }
+     else
+#endif
+     {
+          D_INFO("DirectFB/Video4Linux: This is a Video4Linux-1 device.\n");
+
+          ioctl( fd, VIDIOCGCAP, &data->vcap );
+          ioctl( fd, VIDIOCCAPTURE, &zero );
+
+          ioctl( fd, VIDIOCGMBUF, &data->vmbuf );
+
+          data->buffer = mmap( NULL, data->vmbuf.size,
+                               PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0 );
+     }
+
+     data->filename = D_STRDUP( buffer_data->filename );
+     data->fd       = fd;
+
+     thiz->AddRef    = IDirectFBVideoProvider_V4L_AddRef;
+     thiz->Release   = IDirectFBVideoProvider_V4L_Release;
+     thiz->GetCapabilities = IDirectFBVideoProvider_V4L_GetCapabilities;
+     thiz->GetSurfaceDescription = IDirectFBVideoProvider_V4L_GetSurfaceDescription;
+     thiz->GetStreamDescription = IDirectFBVideoProvider_V4L_GetStreamDescription;
+     thiz->PlayTo    = IDirectFBVideoProvider_V4L_PlayTo;
+     thiz->Stop      = IDirectFBVideoProvider_V4L_Stop;
+     thiz->GetStatus = IDirectFBVideoProvider_V4L_GetStatus;
+     thiz->SeekTo    = IDirectFBVideoProvider_V4L_SeekTo;
+     thiz->GetPos    = IDirectFBVideoProvider_V4L_GetPos;
+     thiz->GetLength = IDirectFBVideoProvider_V4L_GetLength;
+     thiz->GetColorAdjustment = IDirectFBVideoProvider_V4L_GetColorAdjustment;
+     thiz->SetColorAdjustment = IDirectFBVideoProvider_V4L_SetColorAdjustment;
+     thiz->SendEvent = IDirectFBVideoProvider_V4L_SendEvent;
+
+     return DFB_OK;
+}
+
+
+/*****************/
+
+/*
+ * bogus thread to generate callback,
+ * because video4linux does not support syncing in overlay mode
+ */
+static void* OverlayThread( DirectThread *thread, void *ctx )
+{
+     IDirectFBVideoProvider_V4L_data *data =
+     (IDirectFBVideoProvider_V4L_data*)ctx;
+
+     int field = 0;
+     struct timeval tv;
+
+     while (data->running) {
+          tv.tv_sec = 0;
+          tv.tv_usec = 20000;
+          select( 0, 0, 0, 0, &tv );
+
+          if (!data->running)
+               break;
+
+          if (data->destination &&
+              data->destination->caps & DSCAPS_INTERLACED) {
+               dfb_surface_set_field( data->destination, field );
+
+               field = !field;
+          }
+
+          if (!data->running)
+               break;
+
+          if (data->callback)
+               data->callback( data->ctx );
+     }
+
+     return NULL;
+}
+
+/*
+ * thread to capture data from v4l buffers and generate callback
+ */
+static void* GrabThread( DirectThread *thread, void *ctx )
+{
+     IDirectFBVideoProvider_V4L_data *data =
+     (IDirectFBVideoProvider_V4L_data*)ctx;
+     CoreSurface *surface = data->destination;
+     void *src, *dst;
+     int dst_pitch, src_pitch, h;
+     int frame = 0;
+
+     D_DEBUG( "DirectFB/Video4Linux: %s started.\n", __FUNCTION__ );
+
+     src_pitch = DFB_BYTES_PER_LINE( surface->config.format, surface->config.size.w );
+
+     while (frame < data->vmbuf.frames) {
+          data->vmmap.frame = frame;
+          ioctl( data->fd, VIDIOCMCAPTURE, &data->vmmap );
+          frame++;
+     }
+
+     if (dfb_surface_ref( surface )) {
+          D_ERROR( "DirectFB/Video4Linux: dfb_surface_ref() failed!\n" );
+          return NULL;
+     }
+
+     frame = 0;
+     while (data->running) {
+          ioctl( data->fd, VIDIOCSYNC, &frame );
+
+          if (!data->running)
+               break;
+
+          h = surface->config.size.h;
+          src = data->buffer + data->vmbuf.offsets[frame];
+          dfb_surface_soft_lock( data->core, surface, DSLF_WRITE, &dst, &dst_pitch, 0 );
+          while (h--) {
+               direct_memcpy( dst, src, src_pitch );
+               dst += dst_pitch;
+               src += src_pitch;
+          }
+          if (surface->config.format == DSPF_I420) {
+               h = surface->config.size.h;
+               while (h--) {
+                    direct_memcpy( dst, src, src_pitch >> 1 );
+                    dst += dst_pitch >> 1;
+                    src += src_pitch >> 1;
+               }
+          }
+          else if (surface->config.format == DSPF_YV12) {
+               h = surface->config.size.h >> 1;
+               src += h * (src_pitch >> 1);
+               while (h--) {
+                    direct_memcpy( dst, src, src_pitch >> 1 );
+                    dst += dst_pitch >> 1;
+                    src += src_pitch >> 1;
+               }
+               h = surface->config.size.h >> 1;
+               src -=  2 * h * (src_pitch >> 1);
+               while (h--) {
+                    direct_memcpy( dst, src, src_pitch >> 1 );
+                    dst += dst_pitch >> 1;
+                    src += src_pitch >> 1;
+               }
+          }
+          dfb_surface_unlock( surface, 0 );
+
+          data->vmmap.frame = frame;
+          ioctl( data->fd, VIDIOCMCAPTURE, &data->vmmap );
+
+          if (!data->running)
+               break;
+
+          if (surface->caps & DSCAPS_INTERLACED)
+               dfb_surface_set_field( surface, 0 );
+
+          if (data->callback)
+               data->callback(data->ctx);
+
+          if (!data->running)
+               break;
+
+          sched_yield();
+
+          if (surface->caps & DSCAPS_INTERLACED) {
+               if (!data->running)
+                    break;
+
+               dfb_surface_set_field( surface, 1 );
+
+               if (data->callback)
+                    data->callback(data->ctx);
+
+               if (!data->running)
+                    break;
+
+               sched_yield();
+          }
+
+          if (++frame == data->vmbuf.frames)
+               frame = 0;
+     }
+
+     dfb_surface_unref( surface );
+
+     return NULL;
+}
+
+static ReactionResult v4l_videosurface_listener( const void *msg_data, void *ctx )
+{
+     const CoreSurfaceNotification   *notification = msg_data;
+     IDirectFBVideoProvider_V4L_data *data         = ctx;
+     CoreSurface                     *surface      = notification->surface;
+
+     if ((notification->flags & CSNF_SIZEFORMAT) ||
+         (surface->back_buffer->video.health != CSH_STORED)) {
+          v4l_stop( data, false );
+          return RS_REMOVE;
+     }
+
+     return RS_OK;
+}
+
+static ReactionResult v4l_systemsurface_listener( const void *msg_data, void *ctx )
+{
+     const CoreSurfaceNotification   *notification = msg_data;
+     IDirectFBVideoProvider_V4L_data *data         = ctx;
+     CoreSurface                     *surface      = notification->surface;
+
+     if ((notification->flags & CSNF_SIZEFORMAT) ||
+         (surface->back_buffer->system.health != CSH_STORED &&
+          surface->back_buffer->video.health != CSH_STORED)) {
+          v4l_stop( data, false );
+          return RS_REMOVE;
+     }
+
+     return RS_OK;
+}
+
+
+/************/
+
+static DFBResult v4l_to_surface_overlay( CoreSurface *surface, DFBRectangle *rect,
+                                         IDirectFBVideoProvider_V4L_data *data )
+{
+     int bpp, palette;
+     SurfaceBuffer *buffer = surface->back_buffer;
+
+     D_DEBUG( "DirectFB/Video4Linux: %s (%p, %d,%d - %dx%d)\n", __FUNCTION__,
+              surface, rect->x, rect->y, rect->w, rect->h );
+
+     /*
+      * Sanity check. Overlay to system surface isn't possible.
+      */
+     if (surface->caps & DSCAPS_SYSTEMONLY)
+          return DFB_UNSUPPORTED;
+
+     switch (surface->config.format) {
+          case DSPF_YUY2:
+               bpp = 16;
+               palette = VIDEO_PALETTE_YUYV;
+               break;
+          case DSPF_UYVY:
+               bpp = 16;
+               palette = VIDEO_PALETTE_UYVY;
+               break;
+          case DSPF_I420:
+               bpp = 8;
+               palette = VIDEO_PALETTE_YUV420P;
+               break;
+          case DSPF_ARGB1555:
+               bpp = 15;
+               palette = VIDEO_PALETTE_RGB555;
+               break;
+          case DSPF_RGB16:
+               bpp = 16;
+               palette = VIDEO_PALETTE_RGB565;
+               break;
+          case DSPF_RGB24:
+               bpp = 24;
+               palette = VIDEO_PALETTE_RGB24;
+               break;
+          case DSPF_ARGB:
+          case DSPF_AiRGB:
+          case DSPF_RGB32:
+               bpp = 32;
+               palette = VIDEO_PALETTE_RGB32;
+               break;
+          default:
+               return DFB_UNSUPPORTED;
+     }
+
+     {
+          struct video_buffer b;
+
+          b.base = (void*)dfb_gfxcard_memory_physical( NULL, buffer->video.offset );
+          b.width = buffer->video.pitch / ((bpp + 7) / 8);
+          b.height = surface->config.size.h;
+          b.depth = bpp;
+          b.bytesperline = buffer->video.pitch;
+
+          if (ioctl( data->fd, VIDIOCSFBUF, &b ) < 0) {
+               DFBResult ret = errno2result( errno );
+
+               D_PERROR( "DirectFB/Video4Linux: VIDIOCSFBUF failed, must run being root!\n" );
+
+               return ret;
+          }
+     }
+     {
+          struct video_picture p;
+
+          if (ioctl( data->fd, VIDIOCGPICT, &p ) < 0) {
+               DFBResult ret = errno2result( errno );
+
+               D_PERROR( "DirectFB/Video4Linux: VIDIOCGPICT failed!\n" );
+
+               return ret;
+          }
+
+          p.depth = bpp;
+          p.palette = palette;
+
+          if (ioctl( data->fd, VIDIOCSPICT, &p ) < 0) {
+               DFBResult ret = errno2result( errno );
+
+               D_PERROR( "DirectFB/Video4Linux: VIDIOCSPICT failed!\n" );
+
+               return ret;
+          }
+     }
+     {
+          struct video_window win;
+
+          win.width = rect->w;
+          win.height = rect->h;
+          win.x = rect->x;
+          win.y = rect->y;
+          win.flags = 0;
+          win.clips = NULL;
+          win.clipcount = 0;
+          win.chromakey = 0;
+
+          if (ioctl( data->fd, VIDIOCSWIN, &win ) < 0) {
+               DFBResult ret = errno2result( errno );
+
+               D_PERROR( "DirectFB/Video4Linux: VIDIOCSWIN failed!\n" );
+
+               return ret;
+          }
+     }
+
+     if (!data->cleanup)
+          data->cleanup = dfb_core_cleanup_add( NULL, v4l_cleanup, data, true );
+
+     if (ioctl( data->fd, VIDIOCCAPTURE, &one ) < 0) {
+          DFBResult ret = errno2result( errno );
+
+          D_PERROR( "DirectFB/Video4Linux: Could not start capturing (VIDIOCCAPTURE failed)!\n" );
+
+          return ret;
+     }
+
+     data->destination = surface;
+
+     dfb_surface_attach( surface, v4l_videosurface_listener,
+                         data, &data->reaction );
+
+     data->running = true;
+
+     if (data->callback || surface->caps & DSCAPS_INTERLACED)
+          data->thread = direct_thread_create( DTT_CRITICAL, OverlayThread, data, "V4L Overlay" );
+
+     return DFB_OK;
+}
+
+static DFBResult v4l_to_surface_grab( CoreSurface *surface, DFBRectangle *rect,
+                                      IDirectFBVideoProvider_V4L_data *data )
+{
+     int palette;
+
+     D_DEBUG( "DirectFB/Video4Linux: %s...\n", __FUNCTION__ );
+
+     if (!data->vmbuf.frames)
+          return DFB_UNSUPPORTED;
+
+     switch (surface->config.format) {
+          case DSPF_YUY2:
+               palette = VIDEO_PALETTE_YUYV;
+               break;
+          case DSPF_UYVY:
+               palette = VIDEO_PALETTE_UYVY;
+               break;
+          case DSPF_I420:
+          case DSPF_YV12:
+               palette = VIDEO_PALETTE_YUV420P;
+               break;
+          case DSPF_ARGB1555:
+               palette = VIDEO_PALETTE_RGB555;
+               break;
+          case DSPF_RGB16:
+               palette = VIDEO_PALETTE_RGB565;
+               break;
+          case DSPF_RGB24:
+               palette = VIDEO_PALETTE_RGB24;
+               break;
+          case DSPF_ARGB:
+          case DSPF_AiRGB:
+          case DSPF_RGB32:
+               palette = VIDEO_PALETTE_RGB32;
+               break;
+          default:
+               return DFB_UNSUPPORTED;
+     }
+
+     data->vmmap.width = surface->config.size.w;
+     data->vmmap.height = surface->config.size.h;
+     data->vmmap.format = palette;
+     data->vmmap.frame = 0;
+     if (ioctl(data->fd, VIDIOCMCAPTURE, &data->vmmap) < 0) {
+          DFBResult ret = errno2result(errno);
+
+          D_PERROR("DirectFB/Video4Linux: Could not start capturing (VIDIOCMCAPTURE failed)!\n");
+
+          return ret;
+     }
+
+     if (!data->cleanup)
+          data->cleanup = dfb_core_cleanup_add( NULL, v4l_cleanup, data, true );
+
+     data->destination = surface;
+
+     dfb_surface_attach( surface, v4l_systemsurface_listener,
+                         data, &data->reaction );
+
+     data->running = true;
+
+     data->thread = direct_thread_create( DTT_INPUT, GrabThread, data, "V4L Grabber" );
+
+     return DFB_OK;
+}
+
+static DFBResult v4l_stop( IDirectFBVideoProvider_V4L_data *data, bool detach )
+{
+     CoreSurface *destination;
+
+     D_DEBUG( "DirectFB/Video4Linux: %s...\n", __FUNCTION__ );
+
+     pthread_mutex_lock( &data->lock );
+
+     if (!data->running) {
+          pthread_mutex_unlock( &data->lock );
+          return DFB_OK;
+     }
+
+     if (data->thread) {
+          data->running = false;
+          direct_thread_join( data->thread );
+          direct_thread_destroy( data->thread );
+          data->thread = NULL;
+     }
+
+#ifdef DFB_HAVE_V4L2
+     if ( 0 != data->is_v4l2 ) {
+          /* turn off streaming */
+          int type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+          int err = ioctl(data->fd, VIDIOC_STREAMOFF, &type);
+          if (err) {
+               D_PERROR("DirectFB/Video4Linux2: VIDIOC_STREAMOFF.\n");
+               /* don't quit here */
+          }
+     }
+     else
+#endif
+     {
+          if (!data->grab_mode) {
+               if (ioctl( data->fd, VIDIOCCAPTURE, &zero ) < 0)
+                    D_PERROR( "DirectFB/Video4Linux: "
+                              "Could not stop capturing (VIDIOCCAPTURE failed)!\n" );
+          }
+     }
+
+     destination = data->destination;
+
+     if (!destination) {
+          pthread_mutex_unlock( &data->lock );
+          return DFB_OK;
+     }
+
+#ifdef DFB_HAVE_V4L2
+     if ( 0 != data->is_v4l2 ) {
+          /* unmap all buffers, if necessary */
+          if (0 != data->framebuffer_or_system) {
+               int i;
+               for (i = 0; i < data->req.count; i++) {
+                    struct v4l2_buffer *vidbuf = &data->vidbuf[i];
+                    D_DEBUG("DirectFB/Video4Linux2: %d => 0x%08x, len:%d\n", i, (u32) data->ptr[i], vidbuf->length);
+                    if (0 != munmap(data->ptr[i], vidbuf->length)) {
+                         D_PERROR("DirectFB/Video4Linux2: munmap().\n");
+                    }
+               }
+          }
+     }
+     else
+#endif
+     {
+          if (!data->grab_mode)
+               dfb_surface_unlock( destination, false );
+     }
+
+     data->destination = NULL;
+
+     pthread_mutex_unlock( &data->lock );
+
+     if (detach)
+          dfb_surface_detach( destination, &data->reaction );
+
+     return DFB_OK;
+}
+
+static void v4l_deinit( IDirectFBVideoProvider_V4L_data *data )
+{
+     if (data->fd == -1) {
+          D_BUG( "v4l_deinit with 'fd == -1'" );
+          return;
+     }
+
+     v4l_stop( data, true );
+
+     munmap( data->buffer, data->vmbuf.size );
+     close( data->fd );
+     data->fd = -1;
+}
+
+static void v4l_cleanup( void *ctx, int emergency )
+{
+     IDirectFBVideoProvider_V4L_data *data =
+     (IDirectFBVideoProvider_V4L_data*)ctx;
+
+     if (emergency)
+          v4l_stop( data, false );
+     else
+          v4l_deinit( data );
+}
+
+/* v4l2 specific stuff */
+#ifdef DFB_HAVE_V4L2
+static int wait_for_buffer(int vid, struct v4l2_buffer *cur)
+{
+     fd_set rdset;
+     struct timeval timeout;
+     int n, err;
+
+//	D_DEBUG("DirectFB/Video4Linux2: %s...\n", __FUNCTION__);
+
+     cur->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+     FD_ZERO(&rdset);
+     FD_SET(vid, &rdset);
+
+     timeout.tv_sec = 5;
+     timeout.tv_usec = 0;
+
+     n = select(vid + 1, &rdset, NULL, NULL, &timeout);
+     if (n == -1) {
+          D_PERROR("DirectFB/Video4Linux2: select().\n");
+          return -1;     /* fixme */
+     }
+     else if (n == 0) {
+          D_PERROR("DirectFB/Video4Linux2: select(), timeout.\n");
+          return -1;     /* fixme */
+     }
+     else if (FD_ISSET(vid, &rdset)) {
+          err = ioctl(vid, VIDIOC_DQBUF, cur);
+          if (err) {
+               D_PERROR("DirectFB/Video4Linux2: VIDIOC_DQBUF.\n");
+               return -1;     /* fixme */
+          }
+     }
+     return 0;
+}
+
+static void *V4L2_Thread(DirectThread * thread, void *ctx)
+{
+     int type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+     int i, err;
+
+     IDirectFBVideoProvider_V4L_data *data = (IDirectFBVideoProvider_V4L_data *) ctx;
+     CoreSurface *surface = data->destination;
+     SurfaceBuffer *buffer = surface->back_buffer;
+     void *src, *dst;
+     int dst_pitch, src_pitch, h;
+
+     D_DEBUG("DirectFB/Video4Linux2: %s started.\n", __FUNCTION__);
+
+     src_pitch = DFB_BYTES_PER_LINE(surface->config.format, surface->config.size.w);
+
+     /* Queue all buffers */
+     for (i = 0; i < data->req.count; i++) {
+          struct v4l2_buffer *vidbuf = &data->vidbuf[i];
+
+          if (0 == data->framebuffer_or_system) {
+               vidbuf->m.offset = buffer->video.offset;
+          }
+
+          err = ioctl(data->fd, VIDIOC_QBUF, vidbuf);
+          if (err) {
+               D_PERROR("DirectFB/Video4Linux2: VIDIOC_QBUF.\n");
+               return NULL;
+          }
+     }
+
+     /* start streaming */
+     if (ioctl(data->fd, VIDIOC_STREAMON, &type)) {
+          D_PERROR("DirectFB/Video4Linux2: VIDIOC_STREAMON.\n");
+          return NULL;   /* fixme */
+     }
+
+     while (data->running) {
+
+          struct v4l2_buffer cur;
+
+          if (0 != wait_for_buffer(data->fd, &cur)) {
+               return NULL;
+          }
+
+          if (0 != data->framebuffer_or_system) {
+
+               D_DEBUG("DirectFB/Video4Linux2: index:%d, to system memory.\n", cur.index);
+
+               h = surface->config.size.h;
+               src = data->ptr[cur.index];
+               dfb_surface_soft_lock(data->core, surface, DSLF_WRITE, &dst, &dst_pitch, 0);
+               while (h--) {
+                    direct_memcpy(dst, src, src_pitch);
+                    dst += dst_pitch;
+                    src += src_pitch;
+               }
+               if (surface->config.format == DSPF_I420) {
+                    h = surface->config.size.h;
+                    while (h--) {
+                         direct_memcpy(dst, src, src_pitch >> 1);
+                         dst += dst_pitch >> 1;
+                         src += src_pitch >> 1;
+                    }
+               }
+               else if (surface->config.format == DSPF_YV12) {
+                    h = surface->config.size.h >> 1;
+                    src += h * (src_pitch >> 1);
+                    while (h--) {
+                         direct_memcpy(dst, src, src_pitch >> 1);
+                         dst += dst_pitch >> 1;
+                         src += src_pitch >> 1;
+                    }
+                    h = surface->config.size.h >> 1;
+                    src -= 2 * h * (src_pitch >> 1);
+                    while (h--) {
+                         direct_memcpy(dst, src, src_pitch >> 1);
+                         dst += dst_pitch >> 1;
+                         src += src_pitch >> 1;
+                    }
+               }
+               else if (surface->config.format == DSPF_NV12 ||
+                        surface->config.format == DSPF_NV21) {
+                    h = surface->config.size.h >> 1;
+                    while (h--) {
+                         direct_memcpy(dst, src, src_pitch);
+                         dst += dst_pitch;
+                         src += src_pitch;
+                    }
+               }
+               dfb_surface_unlock(surface, 0);
+          }
+          else {
+               D_DEBUG("DirectFB/Video4Linux2: index:%d, to overlay surface\n", cur.index);
+          }
+
+          if (data->callback)
+               data->callback(data->ctx);
+
+          if (0 != ioctl(data->fd, VIDIOC_QBUF, &cur)) {
+               D_PERROR("DirectFB/Video4Linux2: VIDIOC_QBUF.\n");
+               return NULL;
+          }
+     }
+
+     return NULL;
+}
+
+static DFBResult v4l2_playto(CoreSurface * surface, DFBRectangle * rect, IDirectFBVideoProvider_V4L_data * data)
+{
+     SurfaceBuffer *buffer = surface->back_buffer;
+     int palette;
+
+     int err;
+     int i;
+
+     D_DEBUG("DirectFB/Video4Linux2: %s...\n", __FUNCTION__);
+
+     switch (surface->config.format) {
+          case DSPF_YUY2:
+               palette = V4L2_PIX_FMT_YUYV;
+               break;
+          case DSPF_UYVY:
+               palette = V4L2_PIX_FMT_UYVY;
+               break;
+          case DSPF_I420:
+               palette = V4L2_PIX_FMT_YUV420;
+               break;
+          case DSPF_YV12:
+               palette = V4L2_PIX_FMT_YVU420;
+               break;
+          case DSPF_NV12:
+               palette = V4L2_PIX_FMT_NV12;
+               break;
+          case DSPF_NV21:
+               palette = V4L2_PIX_FMT_NV21;
+               break;
+          case DSPF_RGB332:
+               palette = V4L2_PIX_FMT_RGB332;
+               break;
+          case DSPF_ARGB1555:
+               palette = V4L2_PIX_FMT_RGB555;
+               break;
+          case DSPF_RGB16:
+               palette = V4L2_PIX_FMT_RGB565;
+               break;
+          case DSPF_RGB24:
+               palette = V4L2_PIX_FMT_BGR24;
+               break;
+          case DSPF_ARGB:
+          case DSPF_AiRGB:
+          case DSPF_RGB32:
+               palette = V4L2_PIX_FMT_BGR32;
+               break;
+          default:
+               return DFB_UNSUPPORTED;
+     }
+
+     data->fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+     data->fmt.fmt.pix.width = surface->config.size.w;
+     data->fmt.fmt.pix.height = surface->config.size.h;
+     data->fmt.fmt.pix.pixelformat = palette;
+     data->fmt.fmt.pix.bytesperline = buffer->video.pitch;
+     data->fmt.fmt.pix.field = V4L2_FIELD_INTERLACED; /* fixme: we can do field based capture, too */
+
+     D_DEBUG("DirectFB/Video4Linux2: surface->config.size.w:%d, surface->config.size.h:%d.\n", surface->config.size.w, surface->config.size.h);
+
+     err = ioctl(data->fd, VIDIOC_S_FMT, &data->fmt);
+     if (err) {
+          D_PERROR("DirectFB/Video4Linux2: VIDIOC_S_FMT.\n");
+          return err;
+     }
+
+     if (data->fmt.fmt.pix.width != surface->config.size.w || data->fmt.fmt.pix.height != surface->config.size.h) {
+          D_PERROR("DirectFB/Video4Linux2: driver cannot fulfill application request.\n");
+          return DFB_UNSUPPORTED;  /* fixme */
+     }
+
+     if ( 0 != data->brightness.id ) {
+          ioctl(data->fd, VIDIOC_G_CTRL, &data->brightness);
+     }
+     if ( 0 != data->contrast.id ) {
+          ioctl(data->fd, VIDIOC_G_CTRL, &data->contrast);
+     }
+     if ( 0 != data->saturation.id ) {
+          ioctl(data->fd, VIDIOC_G_CTRL, &data->saturation);
+     }
+     if ( 0 != data->hue.id ) {
+          ioctl(data->fd, VIDIOC_G_CTRL, &data->hue);
+     }
+
+     if (surface->caps & DSCAPS_SYSTEMONLY) {
+          data->framebuffer_or_system = 1;
+          data->req.memory = V4L2_MEMORY_MMAP;
+     }
+     else {
+          struct v4l2_framebuffer fb;
+
+          data->framebuffer_or_system = 0;
+          data->req.memory = V4L2_MEMORY_OVERLAY;
+
+          fb.base = (void *) dfb_gfxcard_memory_physical(NULL, 0);
+          fb.fmt.width = surface->config.size.w;
+          fb.fmt.height = surface->config.size.h;
+          fb.fmt.pixelformat = palette;
+
+          D_DEBUG("w:%d, h:%d, bpl:%d, base:0x%08lx\n",fb.fmt.width, fb.fmt.height, fb.fmt.bytesperline, (unsigned long)fb.base);
+
+          if (ioctl(data->fd, VIDIOC_S_FBUF, &fb) < 0) {
+               DFBResult ret = errno2result(errno);
+
+               D_PERROR("DirectFB/Video4Linux2: VIDIOC_S_FBUF failed, must run being root!\n");
+
+               return ret;
+          }
+     }
+
+     /* Ask Video Device for Buffers */
+     data->req.count = NUMBER_OF_BUFFERS;
+     data->req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+     err = ioctl(data->fd, VIDIOC_REQBUFS, &data->req);
+     if (err < 0 || data->req.count < NUMBER_OF_BUFFERS) {
+          D_PERROR("DirectFB/Video4Linux2: VIDIOC_REQBUFS: %d, %d.\n", err, data->req.count);
+          return err;
+     }
+
+     /* Query each buffer and map it to the video device if necessary */
+     for (i = 0; i < data->req.count; i++) {
+          struct v4l2_buffer *vidbuf = &data->vidbuf[i];
+
+          vidbuf->index = i;
+          vidbuf->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+          err = ioctl(data->fd, VIDIOC_QUERYBUF, vidbuf);
+          if (err < 0) {
+               D_PERROR("DirectFB/Video4Linux2: VIDIOC_QUERYBUF.\n");
+               return err;
+          }
+
+/*
+          if (vidbuf->length == 0) {
+               D_PERROR("DirectFB/Video4Linux2: length is zero!\n");
+               return -EINVAL;
+          }
+*/
+          if (0 != data->framebuffer_or_system) {
+               data->ptr[i] = mmap(0, vidbuf->length, PROT_READ | PROT_WRITE, MAP_SHARED, data->fd, vidbuf->m.offset);
+               if (data->ptr[i] == MAP_FAILED) {
+                    D_PERROR("DirectFB/Video4Linux2: mmap().\n");
+                    return err;
+               }
+          }
+          D_DEBUG("DirectFB/Video4Linux2: len:0x%08x, %d => 0x%08x\n", vidbuf->length, i, (u32) data->ptr[i]);
+     }
+
+     if (!data->cleanup)
+          data->cleanup = dfb_core_cleanup_add( NULL, v4l_cleanup, data, true );
+
+     data->destination = surface;
+
+     dfb_surface_attach(surface, v4l_systemsurface_listener, data, &data->reaction);
+
+     data->running = true;
+
+     data->thread = direct_thread_create(DTT_DEFAULT, V4L2_Thread, data, "Video4Linux 2");
+
+     return DFB_OK;
+}
+#endif
diff --git a/DirectFB-1.3.0/lib/direct/interface.c b/DirectFB-1.3.0/lib/direct/interface.c
index 1f63af6..772a50d 100644
--- a/DirectFB-1.3.0/lib/direct/interface.c
+++ b/DirectFB-1.3.0/lib/direct/interface.c
@@ -52,10 +52,6 @@
 #define DYNAMIC_LINKING
 #endif
 
-
-D_DEBUG_DOMAIN( Direct_Interface, "Direct/Interface", "Direct Interface" );
-
-
 typedef struct {
      DirectLink            link;
 
@@ -82,8 +78,6 @@ DirectRegisterInterface( DirectInterfaceFuncs *funcs )
 {
      DirectInterfaceImplementation *impl;
 
-     D_DEBUG_AT( Direct_Interface, "%s( %p )\n", __FUNCTION__, funcs );
-
      impl = D_CALLOC( 1, sizeof(DirectInterfaceImplementation) );
 
      impl->funcs          = funcs;
@@ -92,8 +86,6 @@ DirectRegisterInterface( DirectInterfaceFuncs *funcs )
 
      D_MAGIC_SET( impl, DirectInterfaceImplementation );
 
-     D_DEBUG_AT( Direct_Interface, "  -> %s | %s\n", impl->type, impl->implementation );
-
      pthread_mutex_lock( &implementations_mutex );
      direct_list_prepend( &implementations, &impl->link );
      pthread_mutex_unlock( &implementations_mutex );
@@ -151,9 +143,6 @@ DirectGetInterface( DirectInterfaceFuncs     **funcs,
 
      DirectLink *link;
 
-     D_DEBUG_AT( Direct_Interface, "%s( %p, '%s', '%s', %p, %p )\n", __FUNCTION__,
-                 funcs, type, implementation, probe, probe_ctx );
-
      pthread_mutex_lock( &implementations_mutex );
 
      /*
@@ -168,8 +157,6 @@ DirectGetInterface( DirectInterfaceFuncs     **funcs,
           if (implementation && strcmp( implementation, impl->implementation ))
                continue;
 
-          D_DEBUG_AT( Direct_Interface, "  -> Probing '%s'...\n", impl->implementation );
-
           if (probe && !probe( impl->funcs, probe_ctx ))
                continue;
           else {
diff --git a/DirectFB-1.3.0/lib/direct/thread.c b/DirectFB-1.3.0/lib/direct/thread.c
index 4aea9d7..dbd797a 100644
--- a/DirectFB-1.3.0/lib/direct/thread.c
+++ b/DirectFB-1.3.0/lib/direct/thread.c
@@ -55,29 +55,26 @@ D_DEBUG_DOMAIN( Direct_ThreadInit, "Direct/Thread/Init", "Thread initialization"
 struct __D_DirectThread {
      int                   magic;
 
-     pthread_t             thread;      /* The pthread thread identifier. */
+     pthread_t             thread;   /* The pthread thread identifier. */
      pid_t                 tid;
 
      char                 *name;
 
-     DirectThreadType      type;        /* The thread's type, e.g. input thread. */
-     DirectThreadMainFunc  main;        /* The thread's main routine (or entry point). */
-     void                 *arg;         /* Custom argument passed to the main routine. */
+     DirectThreadType      type;     /* The thread's type, e.g. input thread. */
+     DirectThreadMainFunc  main;     /* The thread's main routine (or entry point). */
+     void                 *arg;      /* Custom argument passed to the main routine. */
 
-     bool                  canceled;    /* Set when direct_thread_cancel() is called. */
-     bool                  joining;     /* Set when direct_thread_join() is called. */
-     bool                  joined;      /* Set when direct_thread_join() has finished. */
-     bool                  detached;    /* Set when direct_thread_detach() is called. */
-     bool                  terminated;  /* Set when direct_thread_terminate() is called. */
+     bool                  canceled; /* Set when direct_thread_cancel() is called. */
+     bool                  joining;  /* Set when direct_thread_join() is called. */
+     bool                  joined;   /* Set when direct_thread_join() has finished. */
+     bool                  detached; /* Set when direct_thread_detach() is called. */
 
 #ifdef DIRECT_THREAD_WAIT_INIT
-     bool                  init;        /* Set to true before calling the main routine. */
+     bool                  init;     /* Set to true before calling the main routine. */
 #endif
 
      pthread_mutex_t       lock;
      pthread_cond_t        cond;
-
-     unsigned int          counter;
 };
 
 struct __D_DirectThreadInitHandler {
@@ -375,8 +372,6 @@ direct_thread_set_name( const char *name )
           thread->thread = pthread_self();
           thread->tid    = direct_gettid();
 
-          D_MAGIC_SET( thread, DirectThread );
-
           pthread_setspecific( thread_key, thread );
      }
      else
@@ -397,89 +392,6 @@ direct_thread_set_name( const char *name )
      thread->name = copy;
 }
 
-DirectResult
-direct_thread_wait( DirectThread *thread, int timeout_ms )
-{
-     unsigned int old_counter = thread->counter;
-
-     D_MAGIC_ASSERT( thread, DirectThread );
-     D_ASSERT( thread->thread != -1 );
-
-     D_ASSUME( !thread->canceled );
-
-     D_DEBUG_AT( Direct_Thread, "%s( %p, '%s' %d, %dms )\n", __FUNCTION__,
-                 thread->main, thread->name, thread->tid, timeout_ms );
-
-     while (old_counter == thread->counter && !thread->terminated)
-          pthread_cond_wait( &thread->cond, &thread->lock );
-
-     if (thread->terminated)
-          return DR_DEAD;
-
-     return DR_OK;
-}
-
-void
-direct_thread_notify( DirectThread *thread )
-{
-     D_MAGIC_ASSERT( thread, DirectThread );
-     D_ASSERT( thread->thread != -1 );
-
-     D_ASSUME( !thread->canceled );
-
-     D_DEBUG_AT( Direct_Thread, "%s( %p, '%s' %d )\n", __FUNCTION__, thread->main, thread->name, thread->tid );
-
-     pthread_mutex_lock( &thread->lock );
-
-     thread->counter++;
-
-     pthread_mutex_unlock( &thread->lock );
-
-     pthread_cond_broadcast( &thread->cond );
-}
-
-void
-direct_thread_lock( DirectThread *thread )
-{
-     D_MAGIC_ASSERT( thread, DirectThread );
-     D_ASSERT( thread->thread != -1 );
-
-     D_ASSUME( !thread->canceled );
-
-     D_DEBUG_AT( Direct_Thread, "%s( %p, '%s' %d )\n", __FUNCTION__, thread->main, thread->name, thread->tid );
-
-     pthread_mutex_lock( &thread->lock );
-}
-
-void
-direct_thread_unlock( DirectThread *thread )
-{
-     D_MAGIC_ASSERT( thread, DirectThread );
-     D_ASSERT( thread->thread != -1 );
-
-     D_ASSUME( !thread->canceled );
-
-     D_DEBUG_AT( Direct_Thread, "%s( %p, '%s' %d )\n", __FUNCTION__, thread->main, thread->name, thread->tid );
-
-     pthread_mutex_unlock( &thread->lock );
-}
-
-void
-direct_thread_terminate( DirectThread *thread )
-{
-     D_MAGIC_ASSERT( thread, DirectThread );
-     D_ASSERT( thread->thread != -1 );
-     D_ASSUME( !pthread_equal( thread->thread, pthread_self() ) );
-
-     D_ASSUME( !thread->canceled );
-
-     D_DEBUG_AT( Direct_Thread, "%s( %p, '%s' %d )\n", __FUNCTION__, thread->main, thread->name, thread->tid );
-
-     thread->terminated = true;
-
-     direct_thread_notify( thread );
-}
-
 void
 direct_thread_cancel( DirectThread *thread )
 {
diff --git a/DirectFB-1.3.0/lib/direct/thread.h b/DirectFB-1.3.0/lib/direct/thread.h
index 75c01bb..8ed3672 100644
--- a/DirectFB-1.3.0/lib/direct/thread.h
+++ b/DirectFB-1.3.0/lib/direct/thread.h
@@ -94,25 +94,6 @@ const char   *direct_thread_self_name  ( void );
 void          direct_thread_set_name   ( const char   *name );
 
 /*
- * Wait on the thread object to be notified via direct_thread_notify().
- */
-DirectResult  direct_thread_wait       ( DirectThread *thread,
-                                         int           timeout_ms );
-
-/*
- * Notify the thread object waking up callers of direct_thread_wait().
- */
-void direct_thread_notify     ( DirectThread *thread );
-
-void direct_thread_lock       ( DirectThread *thread );
-void direct_thread_unlock     ( DirectThread *thread );
-
-/*
- * Kindly ask the thread to terminate (for joining without thread cancellation).
- */
-void direct_thread_terminate  ( DirectThread *thread );
-
-/*
  * Cancel a running thread.
  */
 void direct_thread_cancel     ( DirectThread *thread );
diff --git a/DirectFB-1.3.0/lib/direct/trace.c b/DirectFB-1.3.0/lib/direct/trace.c
index 9e0cfe3..5aceb78 100644
--- a/DirectFB-1.3.0/lib/direct/trace.c
+++ b/DirectFB-1.3.0/lib/direct/trace.c
@@ -383,11 +383,9 @@ find_table( const char *filename )
      return NULL;
 }
 
-/**************************************************************************************************/
-
 __attribute__((no_instrument_function))
-const char *
-direct_trace_lookup_symbol( const char *filename, long offset )
+static const char *
+lookup_symbol( const char *filename, long offset )
 {
      Symbol      *symbol;
      SymbolTable *table;
@@ -413,28 +411,7 @@ direct_trace_lookup_symbol( const char *filename, long offset )
      return symbol ? symbol->name : NULL;
 }
 
-__attribute__((no_instrument_function))
-const char *
-direct_trace_lookup_file( void *address, void **ret_base )
-{
-#ifdef DYNAMIC_LINKING
-     Dl_info info;
-
-     if (dladdr( address, &info )) {
-          if (ret_base)
-               *ret_base = info.dli_fbase;
-
-          return info.dli_fname;
-     }
-     else
-#endif
-     {
-          if (ret_base)
-               *ret_base = NULL;
-     }
-
-     return NULL;
-}
+/**************************************************************************************************/
 
 __attribute__((no_instrument_function))
 void
@@ -484,9 +461,9 @@ direct_trace_print_stack( DirectTraceBuffer *buffer )
                     const char *symbol = NULL;//info.dli_sname;
 
                     if (!symbol) {
-                         symbol = direct_trace_lookup_symbol(info.dli_fname, (long)(fn - info.dli_fbase));
+                         symbol = lookup_symbol(info.dli_fname, (long)(fn - info.dli_fbase));
                          if (!symbol) {
-                              symbol = direct_trace_lookup_symbol(info.dli_fname, (long)(fn));
+                              symbol = lookup_symbol(info.dli_fname, (long)(fn));
                               if (!symbol) {
                                    if (info.dli_sname)
                                         symbol = info.dli_sname;
@@ -510,7 +487,7 @@ direct_trace_print_stack( DirectTraceBuffer *buffer )
           else
 #endif
           {
-               const char *symbol = direct_trace_lookup_symbol(NULL, (long)(fn));
+               const char *symbol = lookup_symbol(NULL, (long)(fn));
                direct_log_printf( NULL, "  #%-2d 0x%08lx in %s ()\n",
                                   level - i - 1, (unsigned long) fn, symbol ? symbol : "??" );
           }
@@ -638,21 +615,6 @@ __cyg_profile_func_exit (void *this_fn,
 
 #else
 
-const char *
-direct_trace_lookup_symbol( const char *filename, long offset )
-{
-     return NULL;
-}
-
-const char *
-direct_trace_lookup_file( void *address, void **ret_base )
-{
-     if (ret_base)
-          *ret_base = NULL;
-          
-     return NULL;
-}
-
 void
 direct_trace_print_stack( DirectTraceBuffer *buffer )
 {
diff --git a/DirectFB-1.3.0/lib/direct/trace.h b/DirectFB-1.3.0/lib/direct/trace.h
index 0f403b1..d65c8d2 100644
--- a/DirectFB-1.3.0/lib/direct/trace.h
+++ b/DirectFB-1.3.0/lib/direct/trace.h
@@ -31,67 +31,12 @@
 
 #include <direct/types.h>
 
-/***********************************************************************************************************************
-** Symbols
-*/
-
-/*
- * Returns filename on success or NULL.
- *
- * Stores load address of object in 'ret_base' on success.
- */
-const char *direct_trace_lookup_file  ( void        *address,
-                                        void       **ret_base );
-
-/*
- * Look up a symbol by filename and offset.
- *
- * Returns symbol name on success or NULL.
- */
-const char *direct_trace_lookup_symbol( const char  *filename,
-                                        long         offset );
-
-/*
- * Convenience function combining direct_trace_lookup_file() and direct_trace_lookup_symbol().
- */
-static inline const char *
-direct_trace_lookup_symbol_at( void *address )
-{
-     void       *base;
-     const char *filename;
-
-     filename = direct_trace_lookup_file( address, &base );
-
-     return direct_trace_lookup_symbol( filename, (unsigned long) address - (unsigned long) base );
-}
-
-/***********************************************************************************************************************
-** Stacks
-*/
-
-/*
- * Print stack in 'buffer' or current if NULL.
- */
 void direct_trace_print_stack( DirectTraceBuffer *buffer );
-
-/*
- * Print stack of each known thread.
- */
 void direct_trace_print_stacks( void );
 
-/*
- * Returns indent level for debug output.
- */
 int  direct_trace_debug_indent( void );
 
-/*
- * Create a copy of a stack in 'buffer' or of current if NULL.
- */
 DirectTraceBuffer *direct_trace_copy_buffer( DirectTraceBuffer *buffer );
-
-/*
- * Free a (copied) stack buffer.
- */
 void               direct_trace_free_buffer( DirectTraceBuffer *buffer );
 
 #endif
diff --git a/DirectFB-1.3.0/lib/direct/util.h b/DirectFB-1.3.0/lib/direct/util.h
index 7d91e48..f8b1f00 100644
--- a/DirectFB-1.3.0/lib/direct/util.h
+++ b/DirectFB-1.3.0/lib/direct/util.h
@@ -81,11 +81,6 @@
 
 #define D_ARRAY_SIZE(array)        ((int)(sizeof(array) / sizeof((array)[0])))
 
-#define D_UTIL_SWAP(a,b)                                    \
-     do {                                                   \
-          const typeof(a) x = (a); (a) = (b); (b) = x;      \
-     } while (0)
-
 
 #if __GNUC__ >= 3
 #define D_CONST_FUNC               __attribute__((const))
diff --git a/DirectFB-1.3.0/lib/fusion/call.c b/DirectFB-1.3.0/lib/fusion/call.c
index 3547841..160f7e3 100644
--- a/DirectFB-1.3.0/lib/fusion/call.c
+++ b/DirectFB-1.3.0/lib/fusion/call.c
@@ -44,9 +44,6 @@
 #include "fusion_internal.h"
 
 
-D_DEBUG_DOMAIN( Fusion_Call, "Fusion/Call", "Fusion Call" );
-
-
 #if FUSION_BUILD_MULTI
 
 #if FUSION_BUILD_KERNEL
@@ -59,9 +56,6 @@ fusion_call_init (FusionCall        *call,
 {
      FusionCallNew call_new;
 
-     D_DEBUG_AT( Fusion_Call, "%s( %p, %p <%s>, %p, %p )\n", __FUNCTION__, call, handler,
-                 direct_trace_lookup_symbol_at( handler ), ctx, world );
-
      D_ASSERT( call != NULL );
      D_ASSERT( handler != NULL );
      D_MAGIC_ASSERT( world, FusionWorld );
@@ -97,8 +91,6 @@ fusion_call_init (FusionCall        *call,
      /* Keep back pointer to shared world data. */
      call->shared = world->shared;
 
-     D_DEBUG_AT( Fusion_Call, "  -> call id %d\n", call->call_id );
-
      return DR_OK;
 }
 
@@ -109,15 +101,11 @@ fusion_call_execute (FusionCall          *call,
                      void                *call_ptr,
                      int                 *ret_val)
 {
-     D_DEBUG_AT( Fusion_Call, "%s( %p, 0x%x, %d, %p )\n", __FUNCTION__, call, flags, call_arg, call_ptr );
-
      D_ASSERT( call != NULL );
 
      if (!call->handler)
           return DR_DESTROYED;
 
-     D_DEBUG_AT( Fusion_Call, "  -> %s\n", direct_trace_lookup_symbol_at( call->handler ) );
-
      if (!(flags & FCEF_NODIRECT) && call->fusion_id == _fusion_id( call->shared )) {
           int                     ret;
           FusionCallHandlerResult result;
@@ -170,12 +158,8 @@ fusion_call_return( FusionCall   *call,
 {
      FusionCallReturn call_ret;
 
-     D_DEBUG_AT( Fusion_Call, "%s( %p, %u, %d )\n", __FUNCTION__, call, serial, val );
-
      D_ASSERT( call != NULL );
 
-     D_DEBUG_AT( Fusion_Call, "  -> %s\n", direct_trace_lookup_symbol_at( call->handler ) );
-
      call_ret.call_id = call->call_id;
      call_ret.val     = val;
      call_ret.serial  = serial;
@@ -205,13 +189,9 @@ fusion_call_return( FusionCall   *call,
 DirectResult
 fusion_call_destroy (FusionCall *call)
 {
-     D_DEBUG_AT( Fusion_Call, "%s( %p )\n", __FUNCTION__, call );
-
      D_ASSERT( call != NULL );
      D_ASSERT( call->handler != NULL );
 
-     D_DEBUG_AT( Fusion_Call, "  -> %s\n", direct_trace_lookup_symbol_at( call->handler ) );
-
      while (ioctl (_fusion_fd( call->shared ), FUSION_CALL_DESTROY, &call->call_id)) {
           switch (errno) {
                case EINTR:
@@ -240,8 +220,6 @@ _fusion_call_process( FusionWorld *world, int call_id, FusionCallMessage *msg )
      FusionCallReturn        call_ret;
      FusionCallHandlerResult result;
 
-     D_DEBUG_AT( Fusion_Call, "%s()\n", __FUNCTION__ );
-
      D_MAGIC_ASSERT( world, FusionWorld );
      D_ASSERT( msg != NULL );
 
@@ -249,8 +227,6 @@ _fusion_call_process( FusionWorld *world, int call_id, FusionCallMessage *msg )
 
      D_ASSERT( call_handler != NULL );
 
-     D_DEBUG_AT( Fusion_Call, "  -> %s\n", direct_trace_lookup_symbol_at( call_handler ) );
-
      call_ret.call_id = call_id;
      call_ret.serial  = msg->serial;
      call_ret.val     = 0;
diff --git a/DirectFB-1.3.0/lib/fusion/fusion.c b/DirectFB-1.3.0/lib/fusion/fusion.c
index 4e374dc..4db3fa2 100644
--- a/DirectFB-1.3.0/lib/fusion/fusion.c
+++ b/DirectFB-1.3.0/lib/fusion/fusion.c
@@ -719,27 +719,6 @@ error:
      return ret;
 }
 
-DirectResult
-fusion_stop_dispatcher( FusionWorld *world,
-                        bool         emergency )
-{
-     if (!emergency) {
-          fusion_sync( world );
-
-          direct_thread_lock( world->dispatch_loop );
-     }
-          
-     world->dispatch_stop = true;
-
-     if (!emergency) {
-          direct_thread_unlock( world->dispatch_loop );
-
-          fusion_sync( world );
-     }
-
-     return DR_OK;
-}
-
 /*
  * Exits the fusion world.
  *
@@ -769,6 +748,7 @@ fusion_exit( FusionWorld *world,
           return DR_OK;
      }
 
+
      if (!emergency) {
           int               foo;
           FusionSendMessage msg;
@@ -781,8 +761,7 @@ fusion_exit( FusionWorld *world,
 
           while (ioctl( world->fusion_fd, FUSION_SEND_MESSAGE, &msg ) < 0) {
                if (errno != EINTR) {
-                    D_PERROR( "FUSION_SEND_MESSAGE" );
-                    direct_thread_cancel( world->dispatch_loop );
+                    D_PERROR ("FUSION_SEND_MESSAGE");
                     break;
                }
           }
@@ -793,6 +772,7 @@ fusion_exit( FusionWorld *world,
 
      direct_thread_destroy( world->dispatch_loop );
 
+
      /* Master has to deinitialize shared data. */
      if (fusion_master( world )) {
           shared->refs--;
@@ -924,55 +904,40 @@ fusion_dispatch_loop( DirectThread *thread, void *arg )
 
                D_DEBUG_AT( Fusion_Main_Dispatch, "  -> got %d bytes...\n", len );
 
-               direct_thread_lock( world->dispatch_loop );
+               while (buf_p < buf + len) {
+                    FusionReadMessage *header = (FusionReadMessage*) buf_p;
+                    void              *data   = buf_p + sizeof(FusionReadMessage);
 
-               if (world->dispatch_stop) {
-                    D_DEBUG_AT( Fusion_Main_Dispatch, "  -> IGNORING (dispatch_stop!)\n" );
-               }
-               else {
-                    while (buf_p < buf + len) {
-                         FusionReadMessage *header = (FusionReadMessage*) buf_p;
-                         void              *data   = buf_p + sizeof(FusionReadMessage);
+                    D_MAGIC_ASSERT( world, FusionWorld );
+                    D_ASSERT( (buf + len - buf_p) >= sizeof(FusionReadMessage) );
 
-                         if (world->dispatch_stop) {
-                              D_DEBUG_AT( Fusion_Main_Dispatch, "  -> ABORTING (dispatch_stop!)\n" );
+                    switch (header->msg_type) {
+                         case FMT_SEND:
+                              D_DEBUG_AT( Fusion_Main_Dispatch, "  -> FMT_SEND!\n" );
+                              if (!world->refs) {
+                                   D_DEBUG_AT( Fusion_Main_Dispatch, "  -> good bye!\n" );
+                                   return NULL;
+                              }
+                              break; 
+                         case FMT_CALL:
+                              D_DEBUG_AT( Fusion_Main_Dispatch, "  -> FMT_CALL...\n" );
+                              _fusion_call_process( world, header->msg_id, data );
+                              break;
+                         case FMT_REACTOR:
+                              D_DEBUG_AT( Fusion_Main_Dispatch, "  -> FMT_REACTOR...\n" );
+                              _fusion_reactor_process_message( world, header->msg_id, header->msg_channel, data );
+                              break;
+                         case FMT_SHMPOOL:
+                              D_DEBUG_AT( Fusion_Main_Dispatch, "  -> FMT_SHMPOOL...\n" );
+                              _fusion_shmpool_process( world, header->msg_id, data );
+                              break;
+                         default:
+                              D_DEBUG( "Fusion/Receiver: discarding message of unknown type '%d'\n",
+                                       header->msg_type );
                               break;
-                         }
-
-                         D_MAGIC_ASSERT( world, FusionWorld );
-                         D_ASSERT( (buf + len - buf_p) >= sizeof(FusionReadMessage) );
-
-                         switch (header->msg_type) {
-                              case FMT_SEND:
-                                   D_DEBUG_AT( Fusion_Main_Dispatch, "  -> FMT_SEND!\n" );
-                                   break; 
-                              case FMT_CALL:
-                                   D_DEBUG_AT( Fusion_Main_Dispatch, "  -> FMT_CALL...\n" );
-                                   _fusion_call_process( world, header->msg_id, data );
-                                   break;
-                              case FMT_REACTOR:
-                                   D_DEBUG_AT( Fusion_Main_Dispatch, "  -> FMT_REACTOR...\n" );
-                                   _fusion_reactor_process_message( world, header->msg_id, header->msg_channel, data );
-                                   break;
-                              case FMT_SHMPOOL:
-                                   D_DEBUG_AT( Fusion_Main_Dispatch, "  -> FMT_SHMPOOL...\n" );
-                                   _fusion_shmpool_process( world, header->msg_id, data );
-                                   break;
-                              default:
-                                   D_DEBUG( "Fusion/Receiver: discarding message of unknown type '%d'\n",
-                                            header->msg_type );
-                                   break;
-                         }
-
-                         buf_p = data + ((header->msg_size + 3) & ~3);
                     }
-               }
-
-               direct_thread_unlock( world->dispatch_loop );
 
-               if (!world->refs) {
-                    D_DEBUG_AT( Fusion_Main_Dispatch, "  -> good bye!\n" );
-                    return NULL;
+                    buf_p = data + ((header->msg_size + 3) & ~3);
                }
           }
      }
@@ -1874,27 +1839,6 @@ error:
      return ret;
 }
 
-DirectResult
-fusion_stop_dispatcher( FusionWorld *world,
-                        bool         emergency )
-{
-     if (!emergency) {
-          fusion_sync( world );
-
-          direct_thread_lock( world->dispatch_loop );
-     }
-
-     world->dispatch_stop = true;
-
-     if (!emergency) {
-          direct_thread_unlock( world->dispatch_loop );
-
-          fusion_sync( world );
-     }
-
-     return DR_OK;
-}
-
 /*
  * Exits the fusion world.
  *
@@ -1929,15 +1873,15 @@ fusion_exit( FusionWorld *world,
  
      if (!emergency) {
           FusionMessageType msg = FMT_SEND;
-
+          
           /* Wakeup dispatcher. */
           if (_fusion_send_message( world->fusion_fd, &msg, sizeof(msg), NULL ))
                direct_thread_cancel( world->dispatch_loop );
-
+          
           /* Wait for its termination. */
           direct_thread_join( world->dispatch_loop );
      }
-
+     
      direct_thread_destroy( world->dispatch_loop );
 
      /* Remove ourselves from list. */
@@ -2157,74 +2101,64 @@ fusion_dispatch_loop( DirectThread *self, void *arg )
                pthread_setcancelstate( PTHREAD_CANCEL_DISABLE, NULL );
 
                D_DEBUG_AT( Fusion_Main_Dispatch, " -> message from '%s'...\n", addr.sun_path );
+               
+               switch (msg->type) {
+                    case FMT_SEND:
+                         D_DEBUG_AT( Fusion_Main_Dispatch, "  -> FMT_SEND...\n" );
+                         if (!world->refs) {
+                              D_DEBUG_AT( Fusion_Main_Dispatch, "  -> good bye!\n" );
+                              return NULL;
+                         }
+                         break;
 
-               direct_thread_lock( world->dispatch_loop );
-
-               if (world->dispatch_stop) {
-                    D_DEBUG_AT( Fusion_Main_Dispatch, "  -> IGNORING (dispatch_stop!)\n" );
-               }
-               else {
-                    switch (msg->type) {
-                         case FMT_SEND:
-                              D_DEBUG_AT( Fusion_Main_Dispatch, "  -> FMT_SEND...\n" );
+                    case FMT_ENTER:
+                         D_DEBUG_AT( Fusion_Main_Dispatch, "  -> FMT_ENTER...\n" ); 
+                         if (!fusion_master( world )) {
+                              D_ERROR( "Fusion/Dispatch: Got ENTER request, but I'm not master!\n" );
                               break;
-
-                         case FMT_ENTER:
-                              D_DEBUG_AT( Fusion_Main_Dispatch, "  -> FMT_ENTER...\n" ); 
-                              if (!fusion_master( world )) {
-                                   D_ERROR( "Fusion/Dispatch: Got ENTER request, but I'm not master!\n" );
-                                   break;
-                              }
-                              if (msg->enter.fusion_id == world->fusion_id) {
-                                   D_ERROR( "Fusion/Dispatch: Received ENTER request from myself!\n" );
-                                   break;
-                              }
-                              /* Nothing to do here. Send back message. */
-                              _fusion_send_message( world->fusion_fd, msg, sizeof(FusionEnter), &addr );
+                         }
+                         if (msg->enter.fusion_id == world->fusion_id) {
+                              D_ERROR( "Fusion/Dispatch: Received ENTER request from myself!\n" );
                               break;
+                         }
+                         /* Nothing to do here. Send back message. */
+                         _fusion_send_message( world->fusion_fd, msg, sizeof(FusionEnter), &addr );
+                         break;
 
-                         case FMT_LEAVE:
-                              D_DEBUG_AT( Fusion_Main_Dispatch, "  -> FMT_LEAVE...\n" );
-                              if (!fusion_master( world )) {
-                                   D_ERROR( "Fusion/Dispatch: Got LEAVE request, but I'm not master!\n" );
-                                   break;
-                              }
-                              if (msg->leave.fusion_id == world->fusion_id) {
-                                   D_ERROR( "Fusion/Dispatch: Received LEAVE request from myself!\n" );
-                                   break;
-                              }
-                              _fusion_remove_fusionee( world, msg->leave.fusion_id );
+                    case FMT_LEAVE:
+                         D_DEBUG_AT( Fusion_Main_Dispatch, "  -> FMT_LEAVE...\n" );
+                         if (!fusion_master( world )) {
+                              D_ERROR( "Fusion/Dispatch: Got LEAVE request, but I'm not master!\n" );
                               break;
-
-                         case FMT_CALL:
-                              D_DEBUG_AT( Fusion_Main_Dispatch, "  -> FMT_CALL...\n" );
-                              _fusion_call_process( world, msg->call.call_id, &msg->call );
+                         }
+                         if (msg->leave.fusion_id == world->fusion_id) {
+                              D_ERROR( "Fusion/Dispatch: Received LEAVE request from myself!\n" );
                               break;
-
-                         case FMT_REACTOR:
-                              D_DEBUG_AT( Fusion_Main_Dispatch, "  -> FMT_REACTOR...\n" );
-                              _fusion_reactor_process_message( world, msg->reactor.id, msg->reactor.channel, 
-                                                               &buf[sizeof(FusionReactorMessage)] );
-                              if (msg->reactor.ref) {
-                                   fusion_ref_down( msg->reactor.ref, true );
-                                   if (fusion_ref_zero_trylock( msg->reactor.ref ) == DR_OK) {
-                                        fusion_ref_destroy( msg->reactor.ref );
-                                        SHFREE( world->shared->main_pool, msg->reactor.ref );
-                                   }
+                         }
+                         _fusion_remove_fusionee( world, msg->leave.fusion_id );
+                         break;
+                          
+                    case FMT_CALL:
+                         D_DEBUG_AT( Fusion_Main_Dispatch, "  -> FMT_CALL...\n" );
+                         _fusion_call_process( world, msg->call.call_id, &msg->call );
+                         break;
+                         
+                    case FMT_REACTOR:
+                         D_DEBUG_AT( Fusion_Main_Dispatch, "  -> FMT_REACTOR...\n" );
+                         _fusion_reactor_process_message( world, msg->reactor.id, msg->reactor.channel, 
+                                                          &buf[sizeof(FusionReactorMessage)] );
+                         if (msg->reactor.ref) {
+                              fusion_ref_down( msg->reactor.ref, true );
+                              if (fusion_ref_zero_trylock( msg->reactor.ref ) == DR_OK) {
+                                   fusion_ref_destroy( msg->reactor.ref );
+                                   SHFREE( world->shared->main_pool, msg->reactor.ref );
                               }
-                              break;                    
-
-                         default:
-                              D_BUG( "unexpected message type (%d)", msg->type );
-                              break;
-                    }
-               }
-
-               direct_thread_unlock( world->dispatch_loop );
-
-               if (!world->refs) {
-                    D_DEBUG_AT( Fusion_Main_Dispatch, "  -> good bye!\n" );
-                    return NULL;
+                         }
+                         break;                    
+                         
+                    default:
+                         D_BUG( "unexpected message type (%d)", msg->type );
+                         break;
                }
 
                D_DEBUG_AT( Fusion_Main_Dispatch, " ...done\n" );
@@ -2504,21 +2438,13 @@ error:
      return ret;
 }
 
-DirectResult
-fusion_stop_dispatcher( FusionWorld *world,
-                        bool         emergency )
-{
-     return DR_OK;
-}
-
 /*
  * Exits the fusion world.
  *
  * If 'emergency' is true the function won't join but kill the dispatcher thread.
  */
-DirectResult
-fusion_exit( FusionWorld *world,
-             bool         emergency )
+DirectResult fusion_exit( FusionWorld *world,
+                          bool         emergency )
 {
      D_MAGIC_ASSERT( world, FusionWorld );
      D_MAGIC_ASSERT( world->shared, FusionWorldShared );
diff --git a/DirectFB-1.3.0/lib/fusion/fusion.h b/DirectFB-1.3.0/lib/fusion/fusion.h
index 54cab78..e0bb3c3 100644
--- a/DirectFB-1.3.0/lib/fusion/fusion.h
+++ b/DirectFB-1.3.0/lib/fusion/fusion.h
@@ -71,9 +71,6 @@ DirectResult fusion_enter( int               world_index,
 DirectResult fusion_exit( FusionWorld *world,
                           bool         emergency );
 
-DirectResult fusion_stop_dispatcher( FusionWorld *world,
-                                     bool         emergency );
-
 /*
  * Sets the fork() action of the calling Fusionee within the world.
  */
diff --git a/DirectFB-1.3.0/lib/fusion/fusion_internal.h b/DirectFB-1.3.0/lib/fusion/fusion_internal.h
index 5c110b9..18cba68 100644
--- a/DirectFB-1.3.0/lib/fusion/fusion_internal.h
+++ b/DirectFB-1.3.0/lib/fusion/fusion_internal.h
@@ -101,7 +101,6 @@ struct __Fusion_FusionWorld {
      FusionID             fusion_id;
 
      DirectThread        *dispatch_loop;
-     bool                 dispatch_stop;
 
      /*
       * List of reactors with at least one local reaction attached.
diff --git a/DirectFB-1.3.0/mkchlog b/DirectFB-1.3.0/mkchlog
new file mode 100644
index 0000000..8f74dd9
--- /dev/null
+++ b/DirectFB-1.3.0/mkchlog
@@ -0,0 +1,80 @@
+#!/usr/bin/perl
+
+# Generate a ChangeLog file from a CVS log.
+# Written by Robert Krawitz <rlk@alum.mit.edu>
+# This code is in the public domain and may be used
+# for any purpose.
+
+%logmsgs = ();			# Index by date, time, and author
+$skipme = 0;
+
+$names{"dok"} = 'Denis Oliver Kropp <dok@directfb.org>';
+$names{"andi"} = 'Andreas Hundt <andi@fischlustig.de>';
+$names{"neo"} = 'Sven Neumann <sven@gimp.org>';
+$names{"mitch"} = 'Michael Natterer <mitch@convergence.de>';
+$names{"holger"} = 'Holger Waechtler <holger@convergence.de>';
+$names{"count"} = 'Andreas Kotes <count@convergence.de>';
+$names{"mm"} = 'Martin Mueller <mm@convergence.de>';
+$names{"syrjala"} = 'Ville Syrjala <syrjala@sci.fi>';
+$names{"andros"} = 'Andreas Robinson <andro134+student.liu.se>';
+$names{"klan"} = 'Claudio Ciccani <klan@users.sf.net>';
+$names{"obi"} = 'Andreas Oberritter <obi@tuxbox.org>';
+$names{"adaplas"} = 'Antonino Daplas <adaplas@users.sourceforge.net>';
+
+while (<>) {
+    if (/^Working file: /) {
+	chomp;
+	($ignore, $ignore, $currentfile) = split;
+	while (<>) {
+	    if (/^----------------------------$/) {
+		last;
+	    }
+	}
+	next;
+    } elsif (/^----------------------------$/) {
+	next;
+    } elsif (/^revision /) {
+	($ignore, $revision) = split;
+	@junk = split(/\./, $revision);
+    } elsif (/^date: /) {
+	($ignore, $date, $time, $ignore, $author, $ignore, $ignore,
+	 $ignore, $plus, $minus, $ignore, $ignore, $ignore, $commitid) = split;
+	$time =~ s/:[0-9][0-9];$//;
+	$author =~ s/;$//;
+	$datetimeauthor = "$date $time $author $commitid";
+	$body = "";
+	$firstline = 1;
+	while (<>) {
+	    if (/^----------------------------$/) {
+		last;
+	    } elsif (/^=============================================================================$/) {
+		last;
+	    } elsif ($firstline && /^branches:[ \t]+[0-9]+(\.[0-9]+)+;$/) {
+		next;
+	    } else {
+		$body .= $_;
+		$firstline = 0;
+	    }
+	}
+	if ($skipme == 0) {
+	    if ($logmsgs{$datetimeauthor}) {
+		$stuff = $logmsgs{$datetimeauthor};
+		$stuff =~ s/\n/\n\t$currentfile ($revision) ($plus $minus)\n/;
+		$logmsgs{$datetimeauthor} = $stuff;
+	    } else {
+		$logmsgs{$datetimeauthor} = "Files:\t$currentfile ($revision) ($plus $minus)\n\n$body"
+		}
+	}
+    }				# Other junk we ignore
+}
+
+@chlog = reverse sort keys %logmsgs;
+foreach $_ (@chlog) {
+    ($date, $time, $author) = split;
+    $date =~ s,/,-,g;
+    $msg = $logmsgs{$_};
+    print "$date   $author\t$time\t$names{$author}\n\n";
+    $msg =~ s/^/\t/g;
+    $msg =~ s/\n/\n\t/g;
+    print "$msg\n";
+}
diff --git a/DirectFB-1.3.0/patches/README.radeonfb-r300fix b/DirectFB-1.3.0/patches/README.radeonfb-r300fix
new file mode 100644
index 0000000..e7f7290
--- /dev/null
+++ b/DirectFB-1.3.0/patches/README.radeonfb-r300fix
@@ -0,0 +1,2 @@
+Apply the patch if own a Radeon 9500 or newer and
+you want to make it work with Linux Framebuffer.
diff --git a/DirectFB-1.3.0/patches/agpgart-noroot-2.6.10.patch.bz2 b/DirectFB-1.3.0/patches/agpgart-noroot-2.6.10.patch.bz2
new file mode 100644
index 0000000..92229eb
Binary files /dev/null and b/DirectFB-1.3.0/patches/agpgart-noroot-2.6.10.patch.bz2 differ
diff --git a/DirectFB-1.3.0/patches/matroxfb-full-memory-linux-2.6.6.patch.bz2 b/DirectFB-1.3.0/patches/matroxfb-full-memory-linux-2.6.6.patch.bz2
new file mode 100644
index 0000000..7ef82e2
Binary files /dev/null and b/DirectFB-1.3.0/patches/matroxfb-full-memory-linux-2.6.6.patch.bz2 differ
diff --git a/DirectFB-1.3.0/patches/matroxfb-g400-clock-2.6.6.patch.bz2 b/DirectFB-1.3.0/patches/matroxfb-g400-clock-2.6.6.patch.bz2
new file mode 100644
index 0000000..8e66c7c
Binary files /dev/null and b/DirectFB-1.3.0/patches/matroxfb-g400-clock-2.6.6.patch.bz2 differ
diff --git a/DirectFB-1.3.0/patches/radeonfb-r300fix-2.6.17.patch.bz2 b/DirectFB-1.3.0/patches/radeonfb-r300fix-2.6.17.patch.bz2
new file mode 100644
index 0000000..b104bb1
Binary files /dev/null and b/DirectFB-1.3.0/patches/radeonfb-r300fix-2.6.17.patch.bz2 differ
diff --git a/DirectFB-1.3.0/patches/radeonfb-r300fix-2.6.18.patch.bz2 b/DirectFB-1.3.0/patches/radeonfb-r300fix-2.6.18.patch.bz2
new file mode 100644
index 0000000..aca5f01
Binary files /dev/null and b/DirectFB-1.3.0/patches/radeonfb-r300fix-2.6.18.patch.bz2 differ
diff --git a/DirectFB-1.3.0/patches/radeonfb-r300fix-2.6.22.patch.bz2 b/DirectFB-1.3.0/patches/radeonfb-r300fix-2.6.22.patch.bz2
new file mode 100644
index 0000000..057daf9
Binary files /dev/null and b/DirectFB-1.3.0/patches/radeonfb-r300fix-2.6.22.patch.bz2 differ
diff --git a/DirectFB-1.3.0/patches/rivafb-nv2030fix-2.6.10.patch.bz2 b/DirectFB-1.3.0/patches/rivafb-nv2030fix-2.6.10.patch.bz2
new file mode 100644
index 0000000..17ab12f
Binary files /dev/null and b/DirectFB-1.3.0/patches/rivafb-nv2030fix-2.6.10.patch.bz2 differ
diff --git a/DirectFB-1.3.0/patches/rivafb-nv2030fix-2.6.9.patch.bz2 b/DirectFB-1.3.0/patches/rivafb-nv2030fix-2.6.9.patch.bz2
new file mode 100644
index 0000000..14abe36
Binary files /dev/null and b/DirectFB-1.3.0/patches/rivafb-nv2030fix-2.6.9.patch.bz2 differ
diff --git a/DirectFB-1.3.0/patches/rivafb-nv20fix-2.4.28.patch.bz2 b/DirectFB-1.3.0/patches/rivafb-nv20fix-2.4.28.patch.bz2
new file mode 100644
index 0000000..b693515
Binary files /dev/null and b/DirectFB-1.3.0/patches/rivafb-nv20fix-2.4.28.patch.bz2 differ
diff --git a/DirectFB-1.3.0/proxy/dispatcher/idirectfbfoo_dispatcher.c b/DirectFB-1.3.0/proxy/dispatcher/idirectfbfoo_dispatcher.c
new file mode 100644
index 0000000..b55ebf0
--- /dev/null
+++ b/DirectFB-1.3.0/proxy/dispatcher/idirectfbfoo_dispatcher.c
@@ -0,0 +1,178 @@
+/*
+   (c) Copyright 2001-2008  The world wide DirectFB Open Source Community (directfb.org)
+   (c) Copyright 2000-2004  Convergence (integrated media) GmbH
+
+   All rights reserved.
+
+   Written by Denis Oliver Kropp <dok@directfb.org>,
+              Andreas Hundt <andi@fischlustig.de>,
+              Sven Neumann <neo@directfb.org>,
+              Ville Syrjl <syrjala@sci.fi> and
+              Claudio Ciccani <klan@users.sf.net>.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+
+#include <directfb.h>
+
+#include <direct/interface.h>
+#include <direct/mem.h>
+#include <direct/memcpy.h>
+#include <direct/messages.h>
+#include <direct/util.h>
+
+#include <voodoo/interface.h>
+#include <voodoo/manager.h>
+
+#include "idirectfbfoo_dispatcher.h"
+
+
+static DFBResult Probe();
+static DFBResult Construct( IDirectFBFoo     *thiz,
+                            IDirectFBFoo     *real,
+                            VoodooManager    *manager,
+                            VoodooInstanceID  super,
+                            void             *arg,
+                            VoodooInstanceID *ret_instance );
+
+#include <direct/interface_implementation.h>
+
+DIRECT_INTERFACE_IMPLEMENTATION( IDirectFBFoo, Dispatcher )
+
+
+/**************************************************************************************************/
+
+static void
+IDirectFBFoo_Dispatcher_Destruct( IDirectFBFoo *thiz )
+{
+     D_DEBUG( "%s (%p)\n", __FUNCTION__, thiz );
+
+     DIRECT_DEALLOCATE_INTERFACE( thiz );
+}
+
+/**************************************************************************************************/
+
+static DFBResult
+IDirectFBFoo_Dispatcher_AddRef( IDirectFBFoo *thiz )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBFoo_Dispatcher)
+
+     data->ref++;
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBFoo_Dispatcher_Release( IDirectFBFoo *thiz )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBFoo_Dispatcher)
+
+     if (--data->ref == 0)
+          IDirectFBFoo_Dispatcher_Destruct( thiz );
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBFoo_Dispatcher_Bar( IDirectFBFoo *thiz )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBFoo_Dispatcher)
+
+     D_UNIMPLEMENTED();
+
+     return DFB_UNIMPLEMENTED;
+}
+
+/**************************************************************************************************/
+
+static DirectResult
+Dispatch_Bar( IDirectFBFoo *thiz, IDirectFBFoo *real,
+              VoodooManager *manager, VoodooRequestMessage *msg )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBFoo_Dispatcher)
+
+     D_UNIMPLEMENTED();
+
+     return DFB_UNIMPLEMENTED;
+}
+
+static DirectResult
+Dispatch( void *dispatcher, void *real, VoodooManager *manager, VoodooRequestMessage *msg )
+{
+     D_DEBUG( "IDirectFBFoo/Dispatcher: "
+              "Handling request for instance %u with method %u...\n", msg->instance, msg->method );
+
+     switch (msg->method) {
+          case IDIRECTFBFOO_METHOD_ID_Bar:
+               return Dispatch_Bar( dispatcher, real, manager, msg );
+     }
+
+     return DFB_NOSUCHMETHOD;
+}
+
+/**************************************************************************************************/
+
+static DFBResult
+Probe()
+{
+     /* This implementation has to be loaded explicitly. */
+     return DFB_UNSUPPORTED;
+}
+
+static DFBResult
+Construct( IDirectFBFoo     *thiz,     /* Dispatcher interface */
+           IDirectFBFoo     *real,     /* Real interface implementation */
+           VoodooManager    *manager,  /* Manager of the Voodoo framework */
+           VoodooInstanceID  super,    /* Instance ID of the super interface */
+           void             *arg,      /* Optional arguments to constructor */
+           VoodooInstanceID *ret_instance )
+{
+     DFBResult        ret;
+     VoodooInstanceID instance;
+
+     DIRECT_ALLOCATE_INTERFACE_DATA(thiz, IDirectFBFoo_Dispatcher)
+
+     D_ASSERT( real != NULL );
+     D_ASSERT( manager != NULL );
+     D_ASSERT( super != VOODOO_INSTANCE_NONE );
+     D_ASSERT( ret_instance != NULL );
+
+     /* Register the dispatcher, getting a new instance ID that refers to it. */
+     ret = voodoo_manager_register_local( manager, false, thiz, real, Dispatch, &instance );
+     if (ret) {
+          DIRECT_DEALLOCATE_INTERFACE( thiz );
+          return ret;
+     }
+
+     /* Return the new instance. */
+     *ret_instance = instance;
+
+     /* Initialize interface data. */
+     data->ref   = 1;
+     data->real  = real;
+     data->self  = instance;
+     data->super = super;
+
+     /* Initialize interface methods. */
+     thiz->AddRef  = IDirectFBFoo_Dispatcher_AddRef;
+     thiz->Release = IDirectFBFoo_Dispatcher_Release;
+     thiz->Bar     = IDirectFBFoo_Dispatcher_Bar;
+
+     return DFB_OK;
+}
+
diff --git a/DirectFB-1.3.0/proxy/dispatcher/idirectfbfoo_dispatcher.h b/DirectFB-1.3.0/proxy/dispatcher/idirectfbfoo_dispatcher.h
new file mode 100644
index 0000000..fa15da9
--- /dev/null
+++ b/DirectFB-1.3.0/proxy/dispatcher/idirectfbfoo_dispatcher.h
@@ -0,0 +1,48 @@
+/*
+   (c) Copyright 2001-2008  The world wide DirectFB Open Source Community (directfb.org)
+   (c) Copyright 2000-2004  Convergence (integrated media) GmbH
+
+   All rights reserved.
+
+   Written by Denis Oliver Kropp <dok@directfb.org>,
+              Andreas Hundt <andi@fischlustig.de>,
+              Sven Neumann <neo@directfb.org>,
+              Ville Syrjl <syrjala@sci.fi> and
+              Claudio Ciccani <klan@users.sf.net>.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#ifndef __IDIRECTFBFOO_DISPATCHER_H__
+#define __IDIRECTFBFOO_DISPATCHER_H__
+
+#define IDIRECTFBFOO_METHOD_ID_AddRef                     1
+#define IDIRECTFBFOO_METHOD_ID_Release                    2
+#define IDIRECTFBFOO_METHOD_ID_Bar                        3
+
+/*
+ * private data struct of IDirectFBFoo_Dispatcher
+ */
+typedef struct {
+     int                  ref;      /* reference counter */
+
+     IDirectFBFoo        *real;
+
+     VoodooInstanceID     self;
+     VoodooInstanceID     super;
+} IDirectFBFoo_Dispatcher_data;
+
+#endif
diff --git a/DirectFB-1.3.0/proxy/requestor/idirectfbfoo_requestor.c b/DirectFB-1.3.0/proxy/requestor/idirectfbfoo_requestor.c
new file mode 100644
index 0000000..fc60f09
--- /dev/null
+++ b/DirectFB-1.3.0/proxy/requestor/idirectfbfoo_requestor.c
@@ -0,0 +1,129 @@
+/*
+   (c) Copyright 2001-2008  The world wide DirectFB Open Source Community (directfb.org)
+   (c) Copyright 2000-2004  Convergence (integrated media) GmbH
+
+   All rights reserved.
+
+   Written by Denis Oliver Kropp <dok@directfb.org>,
+              Andreas Hundt <andi@fischlustig.de>,
+              Sven Neumann <neo@directfb.org>,
+              Ville Syrjl <syrjala@sci.fi> and
+              Claudio Ciccani <klan@users.sf.net>.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+
+#include <directfb.h>
+
+#include <direct/interface.h>
+#include <direct/mem.h>
+#include <direct/memcpy.h>
+#include <direct/messages.h>
+#include <direct/util.h>
+
+#include <voodoo/client.h>
+#include <voodoo/interface.h>
+#include <voodoo/manager.h>
+
+#include <idirectfbfoo_dispatcher.h>
+
+#include "idirectfbfoo_requestor.h"
+
+
+static DFBResult Probe();
+static DFBResult Construct( IDirectFBFoo     *thiz,
+                            VoodooManager    *manager,
+                            VoodooInstanceID  instance,
+                            void             *arg );
+
+#include <direct/interface_implementation.h>
+
+DIRECT_INTERFACE_IMPLEMENTATION( IDirectFBFoo, Requestor )
+
+
+/**************************************************************************************************/
+
+static void
+IDirectFBFoo_Requestor_Destruct( IDirectFBFoo *thiz )
+{
+     D_DEBUG( "%s (%p)\n", __FUNCTION__, thiz );
+
+     DIRECT_DEALLOCATE_INTERFACE( thiz );
+}
+
+/**************************************************************************************************/
+
+static DFBResult
+IDirectFBFoo_Requestor_AddRef( IDirectFBFoo *thiz )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBFoo_Requestor)
+
+     data->ref++;
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBFoo_Requestor_Release( IDirectFBFoo *thiz )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBFoo_Requestor)
+
+     if (--data->ref == 0)
+          IDirectFBFoo_Requestor_Destruct( thiz );
+
+     return DFB_OK;
+}
+
+static DFBResult
+IDirectFBFoo_Requestor_Bar( IDirectFBFoo *thiz )
+{
+     DIRECT_INTERFACE_GET_DATA(IDirectFBFoo_Requestor)
+
+     D_UNIMPLEMENTED();
+
+     return DFB_UNIMPLEMENTED;
+}
+
+/**************************************************************************************************/
+
+static DFBResult
+Probe()
+{
+     /* This implementation has to be loaded explicitly. */
+     return DFB_UNSUPPORTED;
+}
+
+static DFBResult
+Construct( IDirectFBFoo     *thiz,
+           VoodooManager    *manager,
+           VoodooInstanceID  instance,
+           void             *arg )
+{
+     DIRECT_ALLOCATE_INTERFACE_DATA(thiz, IDirectFBFoo_Requestor)
+
+     data->ref      = 1;
+     data->manager  = manager;
+     data->instance = instance;
+
+     thiz->AddRef  = IDirectFBFoo_Requestor_AddRef;
+     thiz->Release = IDirectFBFoo_Requestor_Release;
+     thiz->Bar     = IDirectFBFoo_Requestor_Bar;
+
+     return DFB_OK;
+}
+
diff --git a/DirectFB-1.3.0/proxy/requestor/idirectfbfoo_requestor.h b/DirectFB-1.3.0/proxy/requestor/idirectfbfoo_requestor.h
new file mode 100644
index 0000000..cc02973
--- /dev/null
+++ b/DirectFB-1.3.0/proxy/requestor/idirectfbfoo_requestor.h
@@ -0,0 +1,45 @@
+/*
+   (c) Copyright 2001-2008  The world wide DirectFB Open Source Community (directfb.org)
+   (c) Copyright 2000-2004  Convergence (integrated media) GmbH
+
+   All rights reserved.
+
+   Written by Denis Oliver Kropp <dok@directfb.org>,
+              Andreas Hundt <andi@fischlustig.de>,
+              Sven Neumann <neo@directfb.org>,
+              Ville Syrjl <syrjala@sci.fi> and
+              Claudio Ciccani <klan@users.sf.net>.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#ifndef __IDIRECTFBFOO_REQUESTOR_H__
+#define __IDIRECTFBFOO_REQUESTOR_H__
+
+#include <voodoo/manager.h>
+
+/*
+ * private data struct of IDirectFBFoo_Requestor
+ */
+typedef struct {
+     int                  ref;      /* reference counter */
+
+     VoodooManager       *manager;
+     VoodooInstanceID     instance;
+} IDirectFBFoo_Requestor_data;
+
+#endif
+
diff --git a/DirectFB-1.3.0/src/core/Makefile.am b/DirectFB-1.3.0/src/core/Makefile.am
index e387345..bfeba0d 100644
--- a/DirectFB-1.3.0/src/core/Makefile.am
+++ b/DirectFB-1.3.0/src/core/Makefile.am
@@ -42,7 +42,6 @@ internalinclude_HEADERS = \
 	surface.h		\
 	surface_buffer.h	\
 	surface_pool.h		\
-	surface_pool_bridge.h	\
 	system.h		\
 	windows.h		\
 	windows_internal.h	\
@@ -77,7 +76,6 @@ libdirectfb_core_la_SOURCES = \
 	surface_buffer.c	\
 	surface_core.c		\
 	surface_pool.c		\
-	surface_pool_bridge.c	\
 	system.c		\
 	windows.c		\
 	windowstack.c		\
diff --git a/DirectFB-1.3.0/src/core/core.c b/DirectFB-1.3.0/src/core/core.c
index c6d97e1..359fdcc 100644
--- a/DirectFB-1.3.0/src/core/core.c
+++ b/DirectFB-1.3.0/src/core/core.c
@@ -915,8 +915,6 @@ dfb_core_shutdown( CoreDFB *core, bool emergency )
      if (dfb_input_core.initialized)
           dfb_input_core.Suspend( dfb_input_core.data_local );
 
-     fusion_stop_dispatcher( core->world, emergency );
-
      /* Destroy window objects. */
      fusion_object_pool_destroy( shared->window_pool, core->world );
 
diff --git a/DirectFB-1.3.0/src/core/coredefs.h b/DirectFB-1.3.0/src/core/coredefs.h
index 15239ca..4bf871b 100644
--- a/DirectFB-1.3.0/src/core/coredefs.h
+++ b/DirectFB-1.3.0/src/core/coredefs.h
@@ -34,15 +34,14 @@
 #define DFB_DYNAMIC_LINKING
 #endif
 
-#define MAX_INPUTDEVICES          16
-#define MAX_LAYERS                16
-#define MAX_SCREENS                4
+#define MAX_INPUTDEVICES     16
+#define MAX_LAYERS           16
+#define MAX_SCREENS           4
 
-#define MAX_INPUT_GLOBALS          8
+#define MAX_INPUT_GLOBALS     8
 
-#define MAX_SURFACE_BUFFERS        6
-#define MAX_SURFACE_POOLS          8
-#define MAX_SURFACE_POOL_BRIDGES   4
+#define MAX_SURFACE_BUFFERS   6
+#define MAX_SURFACE_POOLS     6
 
 #endif
 
diff --git a/DirectFB-1.3.0/src/core/coretypes.h b/DirectFB-1.3.0/src/core/coretypes.h
index a70eb27..f4e658f 100644
--- a/DirectFB-1.3.0/src/core/coretypes.h
+++ b/DirectFB-1.3.0/src/core/coretypes.h
@@ -68,13 +68,10 @@ typedef struct __DFB_CoreLayerRegion         CoreLayerRegion;
 typedef struct __DFB_CoreLayerRegionConfig   CoreLayerRegionConfig;
 
 typedef struct __DFB_CoreSurface             CoreSurface;
-typedef struct __DFB_CoreSurfaceAccessor     CoreSurfaceAccessor;
 typedef struct __DFB_CoreSurfaceAllocation   CoreSurfaceAllocation;
 typedef struct __DFB_CoreSurfaceBuffer       CoreSurfaceBuffer;
 typedef struct __DFB_CoreSurfaceBufferLock   CoreSurfaceBufferLock;
 typedef struct __DFB_CoreSurfacePool         CoreSurfacePool;
-typedef struct __DFB_CoreSurfacePoolBridge   CoreSurfacePoolBridge;
-typedef struct __DFB_CoreSurfacePoolTransfer CoreSurfacePoolTransfer;
 
 typedef struct __DFB_CoreWindow              CoreWindow;
 typedef struct __DFB_CoreWindowConfig        CoreWindowConfig;
@@ -82,7 +79,6 @@ typedef struct __DFB_CoreWindowStack         CoreWindowStack;
 
 
 typedef unsigned int CoreSurfacePoolID;
-typedef unsigned int CoreSurfacePoolBridgeID;
 
 #endif
 
diff --git a/DirectFB-1.3.0/src/core/fonts.c b/DirectFB-1.3.0/src/core/fonts.c
index abb768a..4e99234 100644
--- a/DirectFB-1.3.0/src/core/fonts.c
+++ b/DirectFB-1.3.0/src/core/fonts.c
@@ -250,8 +250,8 @@ dfb_font_get_glyph_data( CoreFont        *font,
 
      D_MAGIC_SET( data, CoreGlyphData );
 
-     align = (8 / (DFB_BYTES_PER_PIXEL( font->pixel_format ) ? : 1)) *
-                  (DFB_PIXELFORMAT_ALIGNMENT( font->pixel_format ) + 1) - 1;
+     align = MAX( 8 / (DFB_BYTES_PER_PIXEL( font->pixel_format ) ? : 1),
+                  DFB_PIXELFORMAT_ALIGNMENT( font->pixel_format ) );
 
      ret = font->GetGlyphData( font, index, data );
      if (ret) {
diff --git a/DirectFB-1.3.0/src/core/gfxcard.c b/DirectFB-1.3.0/src/core/gfxcard.c
index c8636da..0623767 100644
--- a/DirectFB-1.3.0/src/core/gfxcard.c
+++ b/DirectFB-1.3.0/src/core/gfxcard.c
@@ -693,8 +693,7 @@ dfb_gfxcard_state_check( CardState *state, DFBAccelerationMask accel )
       * available.
       */
      if (dst_buffer->policy == CSP_SYSTEMONLY || /* Special check required if driver does not check itself. */
-                                                 ( !(card->caps.flags & CCF_RENDEROPTS) &&
-                                                    (state->render_options & DSRO_MATRIX) ))
+                                                 (!(card->caps.flags & CCF_RENDEROPTS) && state->render_options))
      {
           /* Clear 'accelerated functions'. */
           state->accel   = DFXL_NONE;
@@ -734,7 +733,7 @@ dfb_gfxcard_state_acquire( CardState *state, DFBAccelerationMask accel )
      CoreSurface            *dst;
      CoreSurface            *src;
      DFBGraphicsCoreShared  *shared;
-     CoreSurfaceAccessFlags  access = CSAF_WRITE;
+     CoreSurfaceAccessFlags  access = CSAF_GPU_WRITE;
 
      D_ASSERT( card != NULL );
      D_ASSERT( card->shared != NULL );
@@ -752,10 +751,10 @@ dfb_gfxcard_state_acquire( CardState *state, DFBAccelerationMask accel )
           if (state->blittingflags & (DSBLIT_BLEND_ALPHACHANNEL |
                                       DSBLIT_BLEND_COLORALPHA   |
                                       DSBLIT_DST_COLORKEY))
-               access |= CSAF_READ;
+               access |= CSAF_GPU_READ;
      }
      else if (state->drawingflags & (DSDRAW_BLEND | DSDRAW_DST_COLORKEY))
-          access |= CSAF_READ;
+          access |= CSAF_GPU_READ;
 
      if (DFB_BLITTING_FUNCTION(accel)) {
           D_DEBUG_AT( Core_GfxState, "%s( %p, 0x%08x )  blitting %p -> %p\n", __FUNCTION__,
@@ -767,7 +766,7 @@ dfb_gfxcard_state_acquire( CardState *state, DFBAccelerationMask accel )
      }
 
      /* lock destination */
-     ret = dfb_surface_lock_buffer( dst, state->to, CSAID_GPU, access, &state->dst );
+     ret = dfb_surface_lock_buffer( dst, state->to, access, &state->dst );
      if (ret) {
           D_DEBUG_AT( Core_Graphics, "Could not lock destination for GPU access!\n" );
           return false;
@@ -776,7 +775,7 @@ dfb_gfxcard_state_acquire( CardState *state, DFBAccelerationMask accel )
      /* if blitting... */
      if (DFB_BLITTING_FUNCTION( accel )) {
           /* ...lock source for reading */
-          ret = dfb_surface_lock_buffer( src, state->from, CSAID_GPU, CSAF_READ, &state->src );
+          ret = dfb_surface_lock_buffer( src, state->from, CSAF_GPU_READ, &state->src );
           if (ret) {
                D_DEBUG_AT( Core_Graphics, "Could not lock source for GPU access!\n" );
                dfb_surface_unlock_buffer( dst, &state->dst );
@@ -788,7 +787,7 @@ dfb_gfxcard_state_acquire( CardState *state, DFBAccelerationMask accel )
           /* if using a mask... */
           if (state->blittingflags & (DSBLIT_SRC_MASK_ALPHA | DSBLIT_SRC_MASK_COLOR)) {
                /* ...lock source mask for reading */
-               ret = dfb_surface_lock_buffer( state->source_mask, state->from, CSAID_GPU, CSAF_READ, &state->src_mask );
+               ret = dfb_surface_lock_buffer( state->source_mask, state->from, CSAF_GPU_READ, &state->src_mask );
                if (ret) {
                     D_DEBUG_AT( Core_Graphics, "Could not lock source mask for GPU access!\n" );
                     dfb_surface_unlock_buffer( src, &state->src );
@@ -1641,72 +1640,10 @@ void dfb_gfxcard_filltriangles( const DFBTriangle *tris, int num, CardState *sta
      dfb_state_unlock( state );
 }
 
-static void
-clip_blit_rotated( DFBRectangle *srect, DFBRectangle *drect, const DFBRegion *clip, DFBSurfaceBlittingFlags flags )
-{
-     DFBRegion dest    = DFB_REGION_INIT_FROM_RECTANGLE( drect );
-     DFBRegion clipped = dest;
-
-     if (flags & (DSBLIT_ROTATE90 | DSBLIT_ROTATE270)) {
-          D_ASSERT( srect->w == drect->h );
-          D_ASSERT( srect->h == drect->w );
-     }
-     else {
-          D_ASSERT( srect->w == drect->w );
-          D_ASSERT( srect->h == drect->h );
-     }
-
-     dfb_region_region_intersect( &clipped, clip );
-     dfb_rectangle_from_region( drect, &clipped );
-
-     if (flags & DSBLIT_ROTATE90) {
-          srect->x += dest.y2 - clipped.y2;
-          srect->y += clipped.x1 - dest.x1;
-          srect->w  = drect->h;
-          srect->h  = drect->w;
-
-          D_DEBUG_AT( Core_GraphicsOps, "  => %4d,%4d-%4dx%4d -> %4d,%4d-%4dx%4d (90)\n",
-                      DFB_RECTANGLE_VALS(srect), DFB_RECTANGLE_VALS(drect) );
-     }
-     else if (flags & DSBLIT_ROTATE180) {
-          srect->x += dest.x2 - clipped.x2;
-          srect->y += dest.y2 - clipped.y2;
-          srect->w  = drect->w;
-          srect->h  = drect->h;
-
-          D_DEBUG_AT( Core_GraphicsOps, "  => %4d,%4d-%4dx%4d -> %4d,%4d-%4dx%4d (180)\n",
-                      DFB_RECTANGLE_VALS(srect), DFB_RECTANGLE_VALS(drect) );
-     }
-     else if (flags & DSBLIT_ROTATE270) {
-          srect->x += clipped.y1 - dest.y1;
-          srect->y += dest.x2 - clipped.x2;
-          srect->w  = drect->h;
-          srect->h  = drect->w;
-
-          D_DEBUG_AT( Core_GraphicsOps, "  => %4d,%4d-%4dx%4d -> %4d,%4d-%4dx%4d (270)\n",
-                      DFB_RECTANGLE_VALS(srect), DFB_RECTANGLE_VALS(drect) );
-     }
-     else {
-          srect->x += clipped.x1 - dest.x1;
-          srect->y += clipped.y1 - dest.y1;
-          srect->w  = drect->w;
-          srect->h  = drect->h;
-
-          D_DEBUG_AT( Core_GraphicsOps, "  => %4d,%4d-%4dx%4d -> %4d,%4d-%4dx%4d\n",
-                      DFB_RECTANGLE_VALS(srect), DFB_RECTANGLE_VALS(drect) );
-     }
-}
 
 void dfb_gfxcard_blit( DFBRectangle *rect, int dx, int dy, CardState *state )
 {
-     bool         hw    = false;
-     DFBRectangle drect = { dx, dy, rect->w, rect->h };
-
-     if (state->blittingflags & (DSBLIT_ROTATE90 | DSBLIT_ROTATE270))
-          D_UTIL_SWAP( drect.w, drect.h );
-
-     D_DEBUG_AT( Core_GraphicsOps, "%s( %4d,%4d-%4dx%4d -> %4d,%4d-%4dx%4d, %p )\n",
-                 __FUNCTION__, DFB_RECTANGLE_VALS(rect), DFB_RECTANGLE_VALS(&drect), state );
+     bool hw = false;
 
      D_ASSERT( card != NULL );
      D_ASSERT( card->shared != NULL );
@@ -1720,6 +1657,9 @@ void dfb_gfxcard_blit( DFBRectangle *rect, int dx, int dy, CardState *state )
      D_ASSERT( rect->x + rect->w - 1 < state->source->config.size.w );
      D_ASSERT( rect->y + rect->h - 1 < state->source->config.size.h );
 
+     D_DEBUG_AT( Core_GraphicsOps, "%s( %d,%d - %dx%d -> %d,%d, %p )\n",
+                 __FUNCTION__, DFB_RECTANGLE_VALS(rect), dx, dy, state );
+
      /* The state is locked during graphics operations. */
      dfb_state_lock( state );
 
@@ -1727,8 +1667,7 @@ void dfb_gfxcard_blit( DFBRectangle *rect, int dx, int dy, CardState *state )
      dfb_state_start_drawing( state, card );
 
      if (!(state->render_options & DSRO_MATRIX) &&
-         !dfb_clip_blit_precheck( &state->clip, drect.w, drect.h, drect.x, drect.y ))
-     {
+         !dfb_clip_blit_precheck( &state->clip, rect->w, rect->h, dx, dy )) {
           /* no work at all */
           dfb_state_unlock( state );
           return;
@@ -1739,9 +1678,10 @@ void dfb_gfxcard_blit( DFBRectangle *rect, int dx, int dy, CardState *state )
      {
           if (!D_FLAGS_IS_SET( card->caps.flags, CCF_CLIPPING ) &&
               !D_FLAGS_IS_SET( card->caps.clip, DFXL_BLIT ))
-               clip_blit_rotated( rect, &drect, &state->clip, state->blittingflags );
+               dfb_clip_blit( &state->clip, rect, &dx, &dy );
 
-          hw = card->funcs.Blit( card->driver_data, card->device_data, rect, drect.x, drect.y );
+          hw = card->funcs.Blit( card->driver_data, card->device_data,
+                                 rect, dx, dy );
 
           dfb_gfxcard_state_release( state );
      }
@@ -1775,10 +1715,8 @@ void dfb_gfxcard_blit( DFBRectangle *rect, int dx, int dy, CardState *state )
           }
           else {
                if (gAcquire( state, DFXL_BLIT )) {
-                    clip_blit_rotated( rect, &drect, &state->clip, state->blittingflags );
-
-                    gBlit( state, rect, drect.x, drect.y );
-
+                    dfb_clip_blit( &state->clip, rect, &dx, &dy );
+                    gBlit( state, rect, dx, dy );
                     gRelease( state );
                }
           }
@@ -2047,17 +1985,9 @@ void dfb_gfxcard_stretchblit( DFBRectangle *srect, DFBRectangle *drect,
      D_DEBUG_AT( Core_GraphicsOps, "%s( %d,%d - %dx%d -> %d,%d - %dx%d, %p )\n",
                  __FUNCTION__, DFB_RECTANGLE_VALS(srect), DFB_RECTANGLE_VALS(drect), state );
 
-     if (state->blittingflags & (DSBLIT_ROTATE90 | DSBLIT_ROTATE270)) {
-          if (srect->w == drect->h && srect->h == drect->w) {
-               dfb_gfxcard_blit( srect, drect->x, drect->y, state );
-               return;
-          }
-     }
-     else {
-          if (srect->w == drect->w && srect->h == drect->h) {
-               dfb_gfxcard_blit( srect, drect->x, drect->y, state );
-               return;
-          }
+     if (srect->w == drect->w && srect->h == drect->h) {
+          dfb_gfxcard_blit( srect, drect->x, drect->y, state );
+          return;
      }
 
      /* The state is locked during graphics operations. */
diff --git a/DirectFB-1.3.0/src/core/layer_context.c b/DirectFB-1.3.0/src/core/layer_context.c
index f8697fd..d0a71b4 100644
--- a/DirectFB-1.3.0/src/core/layer_context.c
+++ b/DirectFB-1.3.0/src/core/layer_context.c
@@ -125,6 +125,8 @@ context_destructor( FusionObject *object, bool zombie, void *ctx )
      if (context->primary.config.clips)
           SHFREE( context->shmpool, context->primary.config.clips );
 
+     dfb_layer_context_unlock( context );
+
      D_MAGIC_CLEAR( context );
 
      /* Destroy the object. */
@@ -144,54 +146,11 @@ dfb_layer_context_pool_create( const FusionWorld *world )
 
 /**********************************************************************************************************************/
 
-static void
-update_stack_geometry( CoreLayerContext *context )
-{
-     DFBDimension     size;
-     int              rotation;
-     CoreLayerRegion *region;
-     CoreSurface     *surface;
-
-     D_MAGIC_ASSERT( context, CoreLayerContext );
-
-     rotation = context->rotation;
-
-     switch (rotation) {
-          default:
-               D_BUG( "invalid rotation %d", rotation );
-          case 0:
-          case 180:
-               size.w = context->config.width;
-               size.h = context->config.height;
-               break;
-
-          case 90:
-          case 270:
-               size.w = context->config.height;
-               size.h = context->config.width;
-               break;
-     }
-
-     region = context->primary.region;
-     if (region) {
-          surface = region->surface;
-          if (surface) {
-               D_MAGIC_ASSERT( surface, CoreSurface );
-
-               rotation -= surface->rotation;
-               if (rotation < 0)
-                    rotation += 360;
-          }
-     }
-
-     dfb_windowstack_resize( context->stack, size.w, size.h, rotation );
-}
-
 DFBResult
 dfb_layer_context_init( CoreLayerContext *context,
                         CoreLayer        *layer )
 {
-     CoreLayerShared *shared;
+     CoreLayerShared  *shared;
 
      D_ASSERT( context != NULL );
      D_ASSERT( layer != NULL );
@@ -252,7 +211,9 @@ dfb_layer_context_init( CoreLayerContext *context,
      }
 
      /* Tell the window stack about its size. */
-     update_stack_geometry( context );
+     dfb_windowstack_resize( context->stack,
+                             context->config.width,
+                             context->config.height );
 
      dfb_layer_context_unlock( context );
 
@@ -810,7 +771,9 @@ dfb_layer_context_set_configuration( CoreLayerContext            *context,
           if (config->flags & (DLCONF_WIDTH | DLCONF_HEIGHT |
                                DLCONF_PIXELFORMAT | DLCONF_BUFFERMODE | DLCONF_SURFACE_CAPS))
           {
-               update_stack_geometry( context );
+               dfb_windowstack_resize( stack,
+                                       region_config.width,
+                                       region_config.height );
 
                /* FIXME: call only if really needed */
                dfb_windowstack_repaint_all( stack );
@@ -1172,8 +1135,6 @@ dfb_layer_context_set_rotation( CoreLayerContext *context,
      if (context->rotation != rotation) {
           context->rotation = rotation;
 
-          update_stack_geometry( context );
-
           dfb_windowstack_repaint_all( context->stack );
      }
 
@@ -1530,7 +1491,6 @@ build_updated_config( CoreLayer                   *layer,
      /* Update source and destination rectangle. */
      if (update->flags & (DLCONF_WIDTH | DLCONF_HEIGHT)) {
           int width, height;
-          DFBResult ret;
 
           flags |= CLRCF_SOURCE | CLRCF_DEST;
 
@@ -1541,11 +1501,10 @@ build_updated_config( CoreLayer                   *layer,
 
           switch (context->screen.mode) {
                case CLLM_CENTER:
-                    ret = dfb_screen_get_layer_dimension( layer->screen, layer, &width, &height );
-                    if( ret == DFB_OK ) {
-                         ret_config->dest.x = (width  - ret_config->width)  / 2;
-                         ret_config->dest.y = (height - ret_config->height) / 2;
-                    }
+                    dfb_screen_get_layer_dimension( layer->screen, layer, &width, &height );
+
+                    ret_config->dest.x = (width  - ret_config->width)  / 2;
+                    ret_config->dest.y = (height - ret_config->height) / 2;
                     /* fall through */
 
                case CLLM_POSITION:
@@ -1607,7 +1566,6 @@ allocate_surface( CoreLayer             *layer,
 {
      DFBResult                ret;
      const DisplayLayerFuncs *funcs;
-     CoreLayerContext        *context;
      CoreSurface             *surface = NULL;
      DFBSurfaceCapabilities   caps    = DSCAPS_VIDEOONLY;
      CoreSurfaceTypeFlags     type    = CSTF_LAYER;
@@ -1623,9 +1581,6 @@ allocate_surface( CoreLayer             *layer,
      D_ASSERT( config != NULL );
      D_ASSERT( config->buffermode != DLBM_WINDOWS );
 
-     context = region->context;
-     D_MAGIC_ASSERT( context, CoreLayerContext );
-
      funcs = layer->funcs;
 
      /*
@@ -1664,9 +1619,6 @@ allocate_surface( CoreLayer             *layer,
                     break;
           }
 
-          if (context->rotation == 90 || context->rotation == 270)
-               caps |= DSCAPS_ROTATED;
-
           /* FIXME: remove this? */
           if (config->options & DLOP_DEINTERLACING)
                caps |= DSCAPS_INTERLACED;
@@ -1696,11 +1648,6 @@ allocate_surface( CoreLayer             *layer,
                surface->buffers[1]->policy = CSP_SYSTEMONLY;
      }
 
-     if (surface->config.caps & DSCAPS_ROTATED)
-          surface->rotation = context->rotation;
-     else
-          surface->rotation = (context->rotation == 180) ? 180 : 0;
-
      /* Tell the region about its new surface (adds a global reference). */
      ret = dfb_layer_region_set_surface( region, surface );
 
@@ -1717,7 +1664,6 @@ reallocate_surface( CoreLayer             *layer,
 {
      DFBResult                ret;
      const DisplayLayerFuncs *funcs;
-     CoreLayerContext        *context;
      CoreSurface             *surface;
      CoreSurfaceConfig        sconfig;
 
@@ -1730,9 +1676,6 @@ reallocate_surface( CoreLayer             *layer,
      D_ASSERT( config != NULL );
      D_ASSERT( config->buffermode != DLBM_WINDOWS );
 
-     context = region->context;
-     D_MAGIC_ASSERT( context, CoreLayerContext );
-
      funcs   = layer->funcs;
      surface = region->surface;
 
@@ -1745,7 +1688,7 @@ reallocate_surface( CoreLayer             *layer,
      sconfig.flags = CSCONF_SIZE | CSCONF_FORMAT | CSCONF_CAPS;
 
      sconfig.caps = surface->config.caps & ~(DSCAPS_FLIPPING  | DSCAPS_INTERLACED |
-                                             DSCAPS_SEPARATED | DSCAPS_PREMULTIPLIED | DSCAPS_ROTATED);
+                                             DSCAPS_SEPARATED | DSCAPS_PREMULTIPLIED);
 
      switch (config->buffermode) {
           case DLBM_TRIPLE:
@@ -1765,9 +1708,6 @@ reallocate_surface( CoreLayer             *layer,
                return DFB_BUG;
      }
 
-     if (context->rotation == 90 || context->rotation == 270)
-          sconfig.caps |= DSCAPS_ROTATED;
-
      /* Add available surface capabilities. */
      sconfig.caps |= config->surface_caps & (DSCAPS_INTERLACED |
                                              DSCAPS_SEPARATED  |
@@ -1799,11 +1739,6 @@ reallocate_surface( CoreLayer             *layer,
      if (config->buffermode == DLBM_BACKSYSTEM)
           surface->buffers[1]->policy = CSP_SYSTEMONLY;
 
-     if (surface->config.caps & DSCAPS_ROTATED)
-          surface->rotation = context->rotation;
-     else
-          surface->rotation = (context->rotation == 180) ? 180 : 0;
-
      dfb_surface_unlock( surface );
      
      return DFB_OK;
diff --git a/DirectFB-1.3.0/src/core/layer_region.c b/DirectFB-1.3.0/src/core/layer_region.c
index 8060d89..33b0c8a 100644
--- a/DirectFB-1.3.0/src/core/layer_region.c
+++ b/DirectFB-1.3.0/src/core/layer_region.c
@@ -416,7 +416,6 @@ dfb_layer_region_flip_update( CoreLayerRegion     *region,
                               DFBSurfaceFlipFlags  flags )
 {
      DFBResult                ret = DFB_OK;
-     DFBRegion                rotated;
      CoreLayer               *layer;
      CoreLayerContext        *context;
      CoreSurface             *surface;
@@ -481,7 +480,7 @@ dfb_layer_region_flip_update( CoreLayerRegion     *region,
           case DLBM_TRIPLE:
           case DLBM_BACKVIDEO:
                /* Check if simply swapping the buffers is possible... */
-               if (!(flags & DSFLIP_BLIT) && !surface->rotation &&
+               if (!(flags & DSFLIP_BLIT) && !context->rotation &&
                    (!update || (update->x1 == 0 &&
                                 update->y1 == 0 &&
                                 update->x2 == surface->config.size.w - 1 &&
@@ -535,7 +534,10 @@ dfb_layer_region_flip_update( CoreLayerRegion     *region,
                D_DEBUG_AT( Core_Layers, "  -> Copying content from back to front buffer...\n" );
 
                /* ...or copy updated contents from back to front buffer. */
-               dfb_back_to_front_copy_rotation( surface, update, surface->rotation );
+               if (context->rotation == 180)
+                    dfb_back_to_front_copy_180( surface, update );
+               else
+                    dfb_back_to_front_copy( surface, update );
 
                if ((flags & DSFLIP_WAITFORSYNC) == DSFLIP_WAIT) {
                     D_DEBUG_AT( Core_Layers, "  -> Waiting for VSync...\n" );
@@ -548,37 +550,31 @@ dfb_layer_region_flip_update( CoreLayerRegion     *region,
           case DLBM_FRONTONLY:
                /* Tell the driver about the update if the region is realized. */
                if (funcs->UpdateRegion && D_FLAGS_IS_SET( region->state, CLRSF_REALIZED )) {
-                    if (surface) {
+                    if (region->surface) {
                          CoreSurfaceAllocation *allocation;
 
                          allocation = region->surface_lock.allocation;
                          D_ASSERT( allocation != NULL );
 
                          /* If hardware has written or is writing... */
-                         if (allocation->accessed[CSAID_GPU] & CSAF_WRITE) {
+                         if (allocation->accessed & CSAF_GPU_WRITE) {
                               D_DEBUG_AT( Core_Layers, "  -> Waiting for pending writes...\n" );
 
                               /* ...wait for the operation to finish. */
                               if (!(flags & DSFLIP_PIPELINE))
                                    dfb_gfxcard_sync(); /* TODO: wait for serial instead */
 
-                              allocation->accessed[CSAID_GPU] &= ~CSAF_WRITE;
+                              allocation->accessed &= ~CSAF_GPU_WRITE;
                          }
-
-                         dfb_surface_lock( surface );
-                         dfb_surface_allocation_update( allocation, CSAF_READ );
-                         dfb_surface_unlock( surface );
                     }
 
                     D_DEBUG_AT( Core_Layers, "  -> Notifying driver about updated content...\n" );
 
-                    dfb_region_from_rotated( &rotated, update, &surface->config.size, surface->rotation );
-
                     ret = funcs->UpdateRegion( layer,
                                                layer->driver_data,
                                                layer->layer_data,
                                                region->region_data,
-                                               surface, &rotated, &region->surface_lock );
+                                               surface, update, &region->surface_lock );
                }
                break;
 
@@ -854,16 +850,10 @@ region_buffer_lock( CoreLayerRegion       *region,
                     CoreSurface           *surface,
                     CoreSurfaceBufferRole  role )
 {
-     DFBResult              ret;
-     CoreSurfaceBuffer     *buffer;
-     CoreSurfaceAllocation *allocation;
-     CoreLayerContext      *context;
-
-     D_ASSERT( region != NULL );
-     D_MAGIC_ASSERT( surface, CoreSurface );
-
-     context = region->context;
-     D_MAGIC_ASSERT( context, CoreLayerContext );
+     DFBResult               ret;
+     CoreSurfaceAccessFlags  flags;
+     CoreSurfaceBuffer      *buffer;
+     CoreSurfaceAllocation  *allocation;
 
      /* First unlock any previously locked buffer. */
      if (region->surface_lock.buffer) {
@@ -872,6 +862,12 @@ region_buffer_lock( CoreLayerRegion       *region,
           dfb_surface_unlock_buffer( region->surface_lock.buffer->surface, &region->surface_lock );
      }
 
+     /* Determine flags to use. */
+     if (surface->config.caps & DSCAPS_SYSTEMONLY)
+          flags = CSAF_CPU_READ;
+     else
+          flags = CSAF_GPU_READ;
+         
      if (dfb_surface_lock( surface ))
           return DFB_FUSION;
 
@@ -879,7 +875,7 @@ region_buffer_lock( CoreLayerRegion       *region,
      D_MAGIC_ASSERT( buffer, CoreSurfaceBuffer );
 
      /* Lock the surface buffer. */
-     ret = dfb_surface_buffer_lock( buffer, CSAID_LAYER0 + context->layer_id, CSAF_READ, &region->surface_lock );
+     ret = dfb_surface_buffer_lock( buffer, flags, &region->surface_lock );
      if (ret) {
           D_DERROR( ret, "Core/LayerRegion: Could not lock region surface for SetRegion()!\n" );
           dfb_surface_unlock( surface );
@@ -890,17 +886,15 @@ region_buffer_lock( CoreLayerRegion       *region,
      D_ASSERT( allocation != NULL );
 
      /* If hardware has written or is writing... */
-     if (allocation->accessed[CSAID_GPU] & CSAF_WRITE) {
+     if (allocation->accessed & CSAF_GPU_WRITE) {
           D_DEBUG_AT( Core_Layers, "  -> Waiting for pending writes...\n" );
 
           /* ...wait for the operation to finish. */
           dfb_gfxcard_sync(); /* TODO: wait for serial instead */
 
-          allocation->accessed[CSAID_GPU] &= ~CSAF_WRITE;
+          allocation->accessed &= ~CSAF_GPU_WRITE;
      }
 
-     /* surface is unlocked by caller */
-
      return DFB_OK;
 }
 
diff --git a/DirectFB-1.3.0/src/core/local_surface_pool.c b/DirectFB-1.3.0/src/core/local_surface_pool.c
index d795c88..b3826e8 100644
--- a/DirectFB-1.3.0/src/core/local_surface_pool.c
+++ b/DirectFB-1.3.0/src/core/local_surface_pool.c
@@ -105,10 +105,10 @@ localInitPool( CoreDFB                    *core,
      D_ASSERT( pool_local != NULL );
      D_ASSERT( ret_desc != NULL );
 
-     ret_desc->caps              = CSPCAPS_NONE;
-     ret_desc->access[CSAID_CPU] = CSAF_READ | CSAF_WRITE;
-     ret_desc->types             = CSTF_FONT | CSTF_INTERNAL;
-     ret_desc->priority          = CSPP_PREFERED;
+     ret_desc->caps     = CSPCAPS_NONE;
+     ret_desc->access   = CSAF_CPU_READ | CSAF_CPU_WRITE;
+     ret_desc->types    = CSTF_FONT | CSTF_INTERNAL;
+     ret_desc->priority = CSPP_PREFERED;
 
      snprintf( ret_desc->name, DFB_SURFACE_POOL_DESC_NAME_LENGTH, "System Memory" );
 
diff --git a/DirectFB-1.3.0/src/core/prealloc_surface_pool.c b/DirectFB-1.3.0/src/core/prealloc_surface_pool.c
index 3df31b5..cda60a3 100644
--- a/DirectFB-1.3.0/src/core/prealloc_surface_pool.c
+++ b/DirectFB-1.3.0/src/core/prealloc_surface_pool.c
@@ -61,10 +61,10 @@ preallocInitPool( CoreDFB                    *core,
      D_MAGIC_ASSERT( pool, CoreSurfacePool );
      D_ASSERT( ret_desc != NULL );
 
-     ret_desc->caps              = CSPCAPS_NONE;
-     ret_desc->access[CSAID_CPU] = CSAF_READ | CSAF_WRITE;
-     ret_desc->types             = CSTF_PREALLOCATED;
-     ret_desc->priority          = CSPP_DEFAULT;
+     ret_desc->caps     = CSPCAPS_NONE;
+     ret_desc->access   = CSAF_CPU_READ | CSAF_CPU_WRITE;
+     ret_desc->types    = CSTF_PREALLOCATED;
+     ret_desc->priority = CSPP_DEFAULT;
 
      snprintf( ret_desc->name, DFB_SURFACE_POOL_DESC_NAME_LENGTH, "Preallocated Memory" );
 
diff --git a/DirectFB-1.3.0/src/core/shared_surface_pool.c b/DirectFB-1.3.0/src/core/shared_surface_pool.c
index 3e44951..2f3237e 100644
--- a/DirectFB-1.3.0/src/core/shared_surface_pool.c
+++ b/DirectFB-1.3.0/src/core/shared_surface_pool.c
@@ -99,10 +99,10 @@ sharedInitPool( CoreDFB                    *core,
      if (ret)
           return ret;
 
-     ret_desc->caps              = CSPCAPS_NONE;
-     ret_desc->access[CSAID_CPU] = CSAF_READ | CSAF_WRITE | CSAF_SHARED;
-     ret_desc->types             = CSTF_LAYER | CSTF_WINDOW | CSTF_CURSOR | CSTF_FONT | CSTF_SHARED | CSTF_INTERNAL;
-     ret_desc->priority          = CSPP_DEFAULT;
+     ret_desc->caps     = CSPCAPS_NONE;
+     ret_desc->access   = CSAF_CPU_READ | CSAF_CPU_WRITE | CSAF_SHARED;
+     ret_desc->types    = CSTF_LAYER | CSTF_WINDOW | CSTF_CURSOR | CSTF_FONT | CSTF_SHARED | CSTF_INTERNAL;
+     ret_desc->priority = CSPP_DEFAULT;
 
      snprintf( ret_desc->name, DFB_SURFACE_POOL_DESC_NAME_LENGTH, "Shared Memory" );
 
diff --git a/DirectFB-1.3.0/src/core/surface.c b/DirectFB-1.3.0/src/core/surface.c
index 3e08a7f..b3c6f3e 100644
--- a/DirectFB-1.3.0/src/core/surface.c
+++ b/DirectFB-1.3.0/src/core/surface.c
@@ -151,10 +151,7 @@ dfb_surface_create( CoreDFB                  *core,
           if (config->flags & CSCONF_CAPS) {
                D_DEBUG_AT( Core_Surface, "  -> caps 0x%08x\n", config->caps );
 
-               if (config->caps & DSCAPS_ROTATED)
-                    D_UNIMPLEMENTED();
-
-               surface->config.caps = config->caps & ~DSCAPS_ROTATED;
+               surface->config.caps = config->caps;
           }
 
           if (config->flags & CSCONF_PREALLOCATED) {
@@ -184,12 +181,9 @@ dfb_surface_create( CoreDFB                  *core,
           buffers = 3;
      else if (surface->config.caps & DSCAPS_DOUBLE)
           buffers = 2;
-     else {
+     else
           buffers = 1;
 
-          surface->config.caps &= ~DSCAPS_ROTATED;
-     }
-
      surface->notifications = CSNF_ALL & ~CSNF_FLIP;
 
      surface->alpha_ramp[0] = 0x00;
@@ -377,7 +371,7 @@ dfb_surface_flip( CoreSurface *surface, bool swap )
      D_ASSERT( surface->buffer_indices[CSBR_FRONT] < surface->num_buffers );
 
      if (surface->buffers[surface->buffer_indices[CSBR_BACK]]->policy !=
-         surface->buffers[surface->buffer_indices[CSBR_FRONT]]->policy || (surface->config.caps & DSCAPS_ROTATED))
+         surface->buffers[surface->buffer_indices[CSBR_FRONT]]->policy)
           return DFB_UNSUPPORTED;
 
      if (swap) {
@@ -431,7 +425,6 @@ dfb_surface_reconfig( CoreSurface             *surface,
           return DFB_OK;
      }
 
-#if 1
      /* Precheck the Surface Buffers. */
      for (i=0; i<surface->num_buffers; i++) {
           if (surface->buffers[i]->locked) {
@@ -439,7 +432,6 @@ dfb_surface_reconfig( CoreSurface             *surface,
                return DFB_LOCKED;
           }
      }
-#endif
 
      /* Destroy the Surface Buffers. */
      for (i=0; i<surface->num_buffers; i++) {
@@ -455,12 +447,8 @@ dfb_surface_reconfig( CoreSurface             *surface,
      if (config->flags & CSCONF_FORMAT)
           surface->config.format = config->format;
 
-     if (config->flags & CSCONF_CAPS) {
-          if (config->caps & DSCAPS_ROTATED)
-               D_UNIMPLEMENTED();
-
-          surface->config.caps = config->caps & ~DSCAPS_ROTATED;
-     }
+     if (config->flags & CSCONF_CAPS)
+          surface->config.caps = config->caps;
 
      if (surface->config.caps & DSCAPS_SYSTEMONLY)
           surface->type = (surface->type & ~CSTF_EXTERNAL) | CSTF_INTERNAL;
@@ -473,12 +461,9 @@ dfb_surface_reconfig( CoreSurface             *surface,
           buffers = 3;
      else if (surface->config.caps & DSCAPS_DOUBLE)
           buffers = 2;
-     else {
+     else
           buffers = 1;
 
-          surface->config.caps &= ~DSCAPS_ROTATED;
-     }
-
      /* Recreate the Surface Buffers. */
      for (i=0; i<buffers; i++) {
           CoreSurfaceBuffer *buffer;
@@ -544,7 +529,6 @@ dfb_surface_destroy_buffers( CoreSurface *surface )
 DFBResult
 dfb_surface_lock_buffer( CoreSurface            *surface,
                          CoreSurfaceBufferRole   role,
-                         CoreSurfaceAccessorID   accessor,
                          CoreSurfaceAccessFlags  access,
                          CoreSurfaceBufferLock  *ret_lock )
 {
@@ -559,7 +543,7 @@ dfb_surface_lock_buffer( CoreSurface            *surface,
      buffer = dfb_surface_get_buffer( surface, role );
      D_MAGIC_ASSERT( buffer, CoreSurfaceBuffer );
 
-     ret = dfb_surface_buffer_lock( buffer, accessor, access, ret_lock );
+     ret = dfb_surface_buffer_lock( buffer, access, ret_lock );
 
      fusion_skirmish_dismiss( &surface->lock );
 
diff --git a/DirectFB-1.3.0/src/core/surface.h b/DirectFB-1.3.0/src/core/surface.h
index e44790c..b842d88 100644
--- a/DirectFB-1.3.0/src/core/surface.h
+++ b/DirectFB-1.3.0/src/core/surface.h
@@ -123,43 +123,17 @@ typedef enum {
 typedef enum {
      CSAF_NONE           = 0x00000000,
 
-     CSAF_READ           = 0x00000001,  /* accessor may read */
-     CSAF_WRITE          = 0x00000002,  /* accessor may write */
+     CSAF_GPU_READ       = 0x00000001,  /* accelerator can read */
+     CSAF_GPU_WRITE      = 0x00000002,  /* accelerator can write */
+     CSAF_CPU_READ       = 0x00000004,  /* software can read */
+     CSAF_CPU_WRITE      = 0x00000008,  /* software can write */
 
-     CSAF_SHARED         = 0x00000010,  /* other processes can read/write at the same time (shared mapping) */
+     CSAF_SHARED         = 0x00000010,  /* other processes can read/write as well */
 
-     CSAF_ALL            = 0x00000013
+     CSAF_ALL            = 0x0000001F
 } CoreSurfaceAccessFlags;
 
 typedef enum {
-     CSAID_NONE          = 0x00000000,  /* none or unknown accessor */
-
-     CSAID_CPU           = 0x00000001,  /* local processor, where DirectFB is running on, could be app or sw fallback */
-
-     CSAID_GPU           = 0x00000002,  /* primary accelerator, as in traditional 'gfxcard' core (ACCEL0) */
-
-     CSAID_ACCEL0        = 0x00000002,  /* accelerators, decoders etc. (CSAID_ACCEL0 + accel_id<0-5>) */
-     CSAID_ACCEL1        = 0x00000003,
-     CSAID_ACCEL2        = 0x00000004,
-     CSAID_ACCEL3        = 0x00000005,
-     CSAID_ACCEL4        = 0x00000006,
-     CSAID_ACCEL5        = 0x00000007,
-
-     CSAID_LAYER0        = 0x00000008,  /* display layers, registered by layer core (CSAID_LAYER0 + layer_id<0-7>) */
-     CSAID_LAYER1        = 0x00000009,
-     CSAID_LAYER2        = 0x0000000a,
-     CSAID_LAYER3        = 0x0000000b,
-     CSAID_LAYER4        = 0x0000000c,
-     CSAID_LAYER5        = 0x0000000d,
-     CSAID_LAYER6        = 0x0000000e,
-     CSAID_LAYER7        = 0x0000000f,
-
-     _CSAID_NUM          = 0x00000010,  /* number of statically assigned IDs for usage in static arrays */
-
-     CSAID_ANY           = 0x00000100,  /* any other accessor needs to be registered using IDs starting from here */
-} CoreSurfaceAccessorID;
-
-typedef enum {
      CSBR_FRONT          = 0,
      CSBR_BACK           = 1,
      CSBR_IDLE           = 2
@@ -186,8 +160,6 @@ struct __DFB_CoreSurface
      CoreSurfaceTypeFlags     type;
      unsigned long            resource_id;   /* layer id, window id, or user specified */
 
-     int                      rotation;
-
      CoreSurfaceNotificationFlags notifications;
 
      DirectSerial             serial;
@@ -253,7 +225,6 @@ DFBResult dfb_surface_destroy_buffers( CoreSurface                 *surface );
 
 DFBResult dfb_surface_lock_buffer   ( CoreSurface                  *surface,
                                       CoreSurfaceBufferRole         role,
-                                      CoreSurfaceAccessorID         accessor,
                                       CoreSurfaceAccessFlags        access,
                                       CoreSurfaceBufferLock        *ret_lock );
 
diff --git a/DirectFB-1.3.0/src/core/surface_buffer.c b/DirectFB-1.3.0/src/core/surface_buffer.c
index 3b29eb7..8e36741 100644
--- a/DirectFB-1.3.0/src/core/surface_buffer.c
+++ b/DirectFB-1.3.0/src/core/surface_buffer.c
@@ -26,8 +26,6 @@
    Boston, MA 02111-1307, USA.
 */
 
-//#define DIRECT_ENABLE_DEBUG
-
 #include <config.h>
 
 #include <string.h>
@@ -53,7 +51,6 @@
 #include <core/surface.h>
 #include <core/surface_buffer.h>
 #include <core/surface_pool.h>
-#include <core/surface_pool_bridge.h>
 
 #include <misc/conf.h>
 
@@ -142,52 +139,33 @@ dfb_surface_buffer_destroy( CoreSurfaceBuffer *buffer )
      return DFB_OK;
 }
 
-static CoreSurfaceAllocation *
-find_allocation( CoreSurfaceBuffer       *buffer,
-                 CoreSurfaceAccessorID    accessor,
-                 CoreSurfaceAccessFlags   flags,
-                 bool                     lock )
-{
-     int                    i;
-     CoreSurfaceAllocation *alloc;
-     CoreSurfaceAllocation *uptodate = NULL;
-     CoreSurfaceAllocation *outdated = NULL;
-
-     /* Prefer allocations which are up to date. */
-     fusion_vector_foreach (alloc, i, buffer->allocs) {
-          if (direct_serial_check( &alloc->serial, &buffer->serial )) {
-               /* Return immediately if up to date allocation has required flags. */
-               if (D_FLAGS_ARE_SET( alloc->access[accessor], flags ))
-                    return alloc;
-
-               /* Remember up to date allocation in case none has supported flags. */
-               uptodate = alloc;
-          }
-          else if (D_FLAGS_ARE_SET( alloc->access[accessor], flags )) {
-               /* Remember outdated allocation which has supported flags though. */
-               outdated = alloc;
-          }
-     }
-
-     /* In case of a lock the flags are mandatory and the outdated allocation has to be used... */
-     if (lock)
-          return outdated;
-
-     /* ...otherwise we can still prefer the up to date allocation for Read/Write()! */
-     return uptodate ?: outdated;
-}
-
 DFBResult
 dfb_surface_buffer_lock( CoreSurfaceBuffer      *buffer,
-                         CoreSurfaceAccessorID   accessor,
                          CoreSurfaceAccessFlags  access,
                          CoreSurfaceBufferLock  *lock )
 {
      DFBResult              ret;
+     int                    i;
      CoreSurface           *surface;
+     CoreSurfaceAllocation *alloc      = NULL;
      CoreSurfaceAllocation *allocation = NULL;
      bool                   allocated  = false;
 
+#if DIRECT_BUILD_DEBUG
+     D_DEBUG_AT( Core_SurfBuffer, "dfb_surface_buffer_lock( %p, 0x%08x, %p )\n", buffer, access, lock );
+
+     if (access & CSAF_GPU_READ)
+          D_DEBUG_AT( Core_SurfBuffer, "  -> GPU READ\n" );
+     if (access & CSAF_GPU_WRITE)
+          D_DEBUG_AT( Core_SurfBuffer, "  -> GPU WRITE\n" );
+     if (access & CSAF_CPU_READ)
+          D_DEBUG_AT( Core_SurfBuffer, "  -> CPU READ\n" );
+     if (access & CSAF_CPU_WRITE)
+          D_DEBUG_AT( Core_SurfBuffer, "  -> CPU WRITE\n" );
+     if (access & CSAF_SHARED)
+          D_DEBUG_AT( Core_SurfBuffer, "  -> PROCESS SHARED\n" );
+#endif
+
      D_MAGIC_ASSERT( buffer, CoreSurfaceBuffer );
      D_FLAGS_ASSERT( access, CSAF_ALL );
      D_ASSERT( lock != NULL );
@@ -197,68 +175,29 @@ dfb_surface_buffer_lock( CoreSurfaceBuffer      *buffer,
 
      FUSION_SKIRMISH_ASSERT( &surface->lock );
 
-     D_ASSERT( accessor >= CSAID_CPU );
-     D_ASSUME( accessor < _CSAID_NUM );
-     if (accessor >= CSAID_ANY) {
-          D_UNIMPLEMENTED();
-          return DFB_UNIMPLEMENTED;
-     }
-
-     if (accessor < 0 || accessor >= _CSAID_NUM)
-          return DFB_INVARG;
-
-#if DIRECT_BUILD_DEBUG
-     D_DEBUG_AT( Core_SurfBuffer, "dfb_surface_buffer_lock( %p, 0x%02x, %p ) <- %dx%d %s [%d]\n", buffer, access, lock,
-                 surface->config.size.w, surface->config.size.h, dfb_pixelformat_name(buffer->format),
-                 dfb_surface_buffer_index(buffer) );
-
-     switch (accessor) {
-          case CSAID_CPU:
-               D_DEBUG_AT( Core_SurfBuffer, "  -> CPU %s%s\n",
-                           (access & CSAF_READ) ? "READ" : "", (access & CSAF_WRITE) ? "WRITE" : "" );
-               break;
-
-          case CSAID_GPU:
-               D_DEBUG_AT( Core_SurfBuffer, "  -> GPU %s%s\n",
-                           (access & CSAF_READ) ? "READ" : "", (access & CSAF_WRITE) ? "WRITE" : "" );
-               break;
-
-          case CSAID_LAYER0:
-          case CSAID_LAYER1:
-          case CSAID_LAYER2:
-          case CSAID_LAYER3:
-          case CSAID_LAYER4:
-          case CSAID_LAYER5:
-          case CSAID_LAYER6:
-          case CSAID_LAYER7:
-               D_DEBUG_AT( Core_SurfBuffer, "  -> LAYER %d %s%s\n", accessor - CSAID_LAYER0,
-                           (access & CSAF_READ) ? "READ" : "", (access & CSAF_WRITE) ? "WRITE" : "" );
-               break;
+     fusion_vector_foreach (alloc, i, buffer->allocs) {
+          D_MAGIC_ASSERT( alloc, CoreSurfaceAllocation );
 
-          default:
-               D_DEBUG_AT( Core_SurfBuffer, "  -> other\n" );
-               break;
+          if (D_FLAGS_ARE_SET( alloc->access, access )) {
+               /* Take last up to date or first available. */
+               if (!allocation || direct_serial_check( &alloc->serial, &buffer->serial ))
+                    allocation = alloc;
+               //break;
+          }
      }
 
-     if (access & CSAF_SHARED)
-          D_DEBUG_AT( Core_SurfBuffer, "  -> SHARED\n" );
-#endif
-
-     /* Look for allocation with proper access. */
-     allocation = find_allocation( buffer, accessor, access, true );
      if (!allocation) {
-          /* If no allocation exists, create one. */
-          ret = dfb_surface_pools_allocate( buffer, accessor, access, &allocation );
-          if (ret) {
-               D_DERROR( ret, "Core/SurfBuffer: Buffer allocation failed!\n" );
+          D_DEBUG_AT( Core_SurfBuffer, "  -> no suitable allocation (yet)!\n" );
+
+          ret = dfb_surface_pools_allocate( buffer, access, &allocation );
+          if (ret)
                return ret;
-          }
+
+          D_MAGIC_ASSERT( allocation, CoreSurfaceAllocation );
 
           allocated = true;
      }
 
-     CORE_SURFACE_ALLOCATION_ASSERT( allocation );
-
      /* Synchronize with other allocations. */
      ret = dfb_surface_allocation_update( allocation, access );
      if (ret) {
@@ -269,13 +208,13 @@ dfb_surface_buffer_lock( CoreSurfaceBuffer      *buffer,
      }
 
      /* Lock the allocation. */
-     dfb_surface_buffer_lock_init( lock, accessor, access );
+     dfb_surface_buffer_lock_init( lock, access );
 
      ret = dfb_surface_pool_lock( allocation->pool, allocation, lock );
      if (ret) {
           D_DERROR( ret, "Core/SurfBuffer: Locking allocation failed! [%s]\n",
                     allocation->pool->desc.name );
-          dfb_surface_buffer_lock_deinit( lock );
+          D_MAGIC_CLEAR( lock );
 
           /* Destroy if newly created. */
           if (allocated)
@@ -284,16 +223,18 @@ dfb_surface_buffer_lock( CoreSurfaceBuffer      *buffer,
           return ret;
      }
 
-#if 1
+     lock->allocation = allocation;
+
+
      /*
       * Manage access interlocks.
       *
       * SOON FIXME: Clearing flags only when not locked yet. Otherwise nested GPU/CPU locks are a problem.
       */
      /* Software read/write access... */
-     if (accessor == CSAID_CPU) {
+     if (access & (CSAF_CPU_READ | CSAF_CPU_WRITE)) {
           /* If hardware has written or is writing... */
-          if (allocation->accessed[CSAID_GPU] & CSAF_WRITE) {
+          if (allocation->accessed & CSAF_GPU_WRITE) {
                /* ...wait for the operation to finish. */
                dfb_gfxcard_sync(); /* TODO: wait for serial instead */
 
@@ -302,54 +243,50 @@ dfb_surface_buffer_lock( CoreSurfaceBuffer      *buffer,
 
                if (!buffer->locked) {
                     /* ...clear hardware write access. */
-                    allocation->accessed[CSAID_GPU] &= ~CSAF_WRITE;
+                    allocation->accessed &= ~CSAF_GPU_WRITE;
 
                     /* ...clear hardware read access (to avoid syncing twice). */
-                    allocation->accessed[CSAID_GPU] &= ~CSAF_READ;
+                    allocation->accessed &= ~CSAF_GPU_READ;
                }
           }
 
           /* Software write access... */
-          if (access & CSAF_WRITE) {
+          if (access & CSAF_CPU_WRITE) {
                /* ...if hardware has (to) read... */
-               if (allocation->accessed[CSAID_GPU] & CSAF_READ) {
+               if (allocation->accessed & CSAF_GPU_READ) {
                     /* ...wait for the operation to finish. */
                     dfb_gfxcard_sync(); /* TODO: wait for serial instead */
 
                     /* ...clear hardware read access. */
                     if (!buffer->locked)
-                         allocation->accessed[CSAID_GPU] &= ~CSAF_READ;
+                         allocation->accessed &= ~CSAF_GPU_READ;
                }
           }
      }
 
      /* Hardware read access... */
-     if (accessor == CSAID_GPU && access & CSAF_READ) {
+     if (access & CSAF_GPU_READ) {
           /* ...if software has written before... */
-          if (allocation->accessed[CSAID_CPU] & CSAF_WRITE) {
+          if (allocation->accessed & CSAF_CPU_WRITE) {
                /* ...flush texture cache. */
                dfb_gfxcard_flush_texture_cache();
 
                /* ...clear software write access. */
                if (!buffer->locked)
-                    allocation->accessed[CSAID_CPU] &= ~CSAF_WRITE;
+                    allocation->accessed &= ~CSAF_CPU_WRITE;
           }
      }
 
-     if (! D_FLAGS_ARE_SET( allocation->accessed[accessor], access )) {
-          /* FIXME: surface_enter */
+     if (! D_FLAGS_ARE_SET( allocation->accessed, access )) {
+          /* surface_enter */
      }
-#endif
 
      /* Collect... */
-     allocation->accessed[accessor] |= access;
+     allocation->accessed |= access;
 
-#if 1
-     /* FIXME: don't use weak counter */
      buffer->locked++;
 
      D_DEBUG_AT( Core_SurfBuffer, "  -> locked %dx now\n", buffer->locked );
-#endif
 
      return DFB_OK;
 }
@@ -372,7 +309,7 @@ dfb_surface_buffer_unlock( CoreSurfaceBufferLock *lock )
      FUSION_SKIRMISH_ASSERT( &lock->buffer->surface->lock );
 
      allocation = lock->allocation;
-     CORE_SURFACE_ALLOCATION_ASSERT( allocation );
+     D_MAGIC_ASSERT( allocation, CoreSurfaceAllocation );
 
      buffer = lock->buffer;
      D_MAGIC_ASSERT( buffer, CoreSurfaceBuffer );
@@ -391,13 +328,18 @@ dfb_surface_buffer_unlock( CoreSurfaceBufferLock *lock )
           return ret;
      }
 
-#if 1
      buffer->locked--;
-#endif
 
-     dfb_surface_buffer_lock_reset( lock );
+     lock->buffer     = NULL;
+     lock->allocation = NULL;
+
+     lock->addr       = NULL;
+     lock->phys       = 0;
+     lock->offset     = 0;
+     lock->pitch      = 0;
+     lock->handle     = NULL;
 
-     dfb_surface_buffer_lock_deinit( lock );
+     D_MAGIC_CLEAR( lock );
 
      return DFB_OK;
 }
@@ -409,12 +351,13 @@ dfb_surface_buffer_read( CoreSurfaceBuffer  *buffer,
                          const DFBRectangle *prect )
 {
      DFBResult              ret;
-     int                    y;
-     int                    bytes;
      DFBRectangle           rect;
+     int                    i, y;
+     int                    bytes;
      CoreSurface           *surface;
+     CoreSurfaceBufferLock  lock;
+     CoreSurfaceAllocation *alloc;
      CoreSurfaceAllocation *allocation = NULL;
-     bool                   allocated  = false;
      DFBSurfacePixelFormat  format;
 
      D_DEBUG_AT( Core_SurfBuffer, "%s( %p, %p [%d] )\n", __FUNCTION__, buffer, destination, pitch );
@@ -456,72 +399,51 @@ dfb_surface_buffer_read( CoreSurfaceBuffer  *buffer,
           return DFB_OK;
      }
 
-     /* Use last written allocation if it's up to date... */
-     if (buffer->written && direct_serial_check( &buffer->written->serial, &buffer->serial ))
-          allocation = buffer->written;
-     else {
-          /* ...otherwise look for allocation with CPU access. */
-          allocation = find_allocation( buffer, CSAID_CPU, CSAF_READ, false );
-          if (!allocation) {
-               /* If no allocation exists, create one. */
-               ret = dfb_surface_pools_allocate( buffer, CSAID_CPU, CSAF_READ, &allocation );
-               if (ret) {
-                    D_DERROR( ret, "Core/SurfBuffer: Buffer allocation failed!\n" );
-                    return ret;
-               }
-
-               allocated = true;
+     /* Look for allocation with CPU access. */
+     fusion_vector_foreach (alloc, i, buffer->allocs) {
+          if (D_FLAGS_ARE_SET( alloc->access, CSAF_CPU_READ )) {
+               allocation = alloc;
+               break;
           }
      }
 
-     CORE_SURFACE_ALLOCATION_ASSERT( allocation );
+     /* FIXME: use Read() */
+     if (!allocation)
+          return DFB_UNIMPLEMENTED;
 
      /* Synchronize with other allocations. */
-     ret = dfb_surface_allocation_update( allocation, CSAF_READ );
-     if (ret) {
-          /* Destroy if newly created. */
-          if (allocated)
-               dfb_surface_pool_deallocate( allocation->pool, allocation );
+     ret = dfb_surface_allocation_update( allocation, CSAF_CPU_READ );
+     if (ret)
           return ret;
-     }
 
-     /* Try reading from allocation directly... */
-     ret = dfb_surface_pool_read( allocation->pool, allocation, destination, pitch, &rect );
-     if (ret) {
-          /* ...otherwise use fallback method via locking if possible. */
-          if (allocation->access[CSAID_CPU] & CSAF_READ) {
-               CoreSurfaceBufferLock lock;
-
-               /* Lock the allocation. */
-               dfb_surface_buffer_lock_init( &lock, CSAID_CPU, CSAF_READ );
+     /* Lock the allocation. */
+     dfb_surface_buffer_lock_init( &lock, CSAF_CPU_READ );
 
-               ret = dfb_surface_pool_lock( allocation->pool, allocation, &lock );
-               if (ret) {
-                    D_DERROR( ret, "Core/SurfBuffer: Locking allocation failed! [%s]\n",
-                              allocation->pool->desc.name );
-                    dfb_surface_buffer_lock_deinit( &lock );
-                    return ret;
-               }
+     ret = dfb_surface_pool_lock( allocation->pool, allocation, &lock );
+     if (ret) {
+          D_DERROR( ret, "Core/SurfBuffer: Locking allocation failed! [%s]\n",
+                    allocation->pool->desc.name );
+          D_MAGIC_CLEAR( &lock );
+          return ret;
+     }
 
-               /* Move to start of read. */
-               lock.addr += DFB_BYTES_PER_LINE( format, rect.x ) + rect.y * lock.pitch;
+     /* Move to start of read. */
+     lock.addr += DFB_BYTES_PER_LINE( format, rect.x ) + rect.y * lock.pitch;
 
-               /* Copy the data. */
-               for (y=0; y<rect.h; y++) {
-                    direct_memcpy( destination, lock.addr, bytes );
+     /* Copy the data. */
+     for (y=0; y<rect.h; y++) {
+          direct_memcpy( destination, lock.addr, bytes );
 
-                    destination += pitch;
-                    lock.addr   += lock.pitch;
-               }
+          destination += pitch;
+          lock.addr   += lock.pitch;
+     }
 
-               /* Unlock the allocation. */
-               ret = dfb_surface_pool_unlock( allocation->pool, allocation, &lock );
-               if (ret)
-                    D_DERROR( ret, "Core/SurfBuffer: Unlocking allocation failed! [%s]\n", allocation->pool->desc.name );
+     /* Unlock the allocation. */
+     ret = dfb_surface_pool_unlock( allocation->pool, allocation, &lock );
+     if (ret)
+          D_DERROR( ret, "Core/SurfBuffer: Unlocking allocation failed! [%s]\n", allocation->pool->desc.name );
 
-               dfb_surface_buffer_lock_deinit( &lock );
-          }
-     }
+     D_MAGIC_CLEAR( &lock );
 
      return ret;
 }
@@ -534,8 +456,13 @@ dfb_surface_buffer_write( CoreSurfaceBuffer  *buffer,
 {
      DFBResult              ret;
      DFBRectangle           rect;
+     int                    i, y;
+     int                    bytes;
      CoreSurface           *surface;
+     CoreSurfaceBufferLock  lock;
+     CoreSurfaceAllocation *alloc      = NULL;
      CoreSurfaceAllocation *allocation = NULL;
+     DFBSurfacePixelFormat  format;
      bool                   allocated  = false;
 
      D_DEBUG_AT( Core_SurfBuffer, "%s( %p, %p [%d] )\n", __FUNCTION__, buffer, source, pitch );
@@ -558,31 +485,38 @@ dfb_surface_buffer_write( CoreSurfaceBuffer  *buffer,
      if (prect && (!dfb_rectangle_intersect( &rect, prect ) || !DFB_RECTANGLE_EQUAL( rect, *prect )))
           return DFB_INVAREA;
 
+     /* Calculate bytes per written line. */
+     format = surface->config.format;
+     bytes  = DFB_BYTES_PER_LINE( format, rect.w );
+
      D_DEBUG_AT( Core_SurfBuffer, "  -> %d,%d - %dx%d (%s)\n", DFB_RECTANGLE_VALS(&rect),
-                 dfb_pixelformat_name( surface->config.format ) );
+                 dfb_pixelformat_name( format ) );
 
-     /* Use last read allocation if it's up to date... */
-     if (buffer->read && direct_serial_check( &buffer->read->serial, &buffer->serial ))
-          allocation = buffer->read;
+     /* If no allocations exists, create one. */
+     if (fusion_vector_is_empty( &buffer->allocs )) {
+          ret = dfb_surface_pools_allocate( buffer, CSAF_CPU_WRITE, &allocation );
+          if (ret) {
+               D_DERROR( ret, "Core/SurfBuffer: Buffer allocation failed!\n" );
+               return ret;
+          }
+          allocated = true;
+     }
      else {
-          /* ...otherwise look for allocation with CPU access. */
-          allocation = find_allocation( buffer, CSAID_CPU, CSAF_WRITE, false );
-          if (!allocation) {
-               /* If no allocation exists, create one. */
-               ret = dfb_surface_pools_allocate( buffer, CSAID_CPU, CSAF_WRITE, &allocation );
-               if (ret) {
-                    D_DERROR( ret, "Core/SurfBuffer: Buffer allocation failed!\n" );
-                    return ret;
+          /* Look for allocation with CPU access. */
+          fusion_vector_foreach (alloc, i, buffer->allocs) {
+               if (D_FLAGS_ARE_SET( alloc->access, CSAF_CPU_WRITE )) {
+                    allocation = alloc;
+                    break;
                }
-
-               allocated = true;
           }
      }
 
-     CORE_SURFACE_ALLOCATION_ASSERT( allocation );
+     /* FIXME: use Write() */
+     if (!allocation)
+          return DFB_UNIMPLEMENTED;
 
      /* Synchronize with other allocations. */
-     ret = dfb_surface_allocation_update( allocation, CSAF_WRITE );
+     ret = dfb_surface_allocation_update( allocation, CSAF_CPU_WRITE );
      if (ret) {
           /* Destroy if newly created. */
           if (allocated)
@@ -590,55 +524,39 @@ dfb_surface_buffer_write( CoreSurfaceBuffer  *buffer,
           return ret;
      }
 
-     /* Try writing to allocation directly... */
-     ret = source ? dfb_surface_pool_write( allocation->pool, allocation, source, pitch, &rect ) : DFB_UNSUPPORTED;
-     if (ret) {
-          /* ...otherwise use fallback method via locking if possible. */
-          if (allocation->access[CSAID_CPU] & CSAF_WRITE) {
-               int                   y;
-               int                   bytes;
-               DFBSurfacePixelFormat format;
-               CoreSurfaceBufferLock lock;
-
-               /* Calculate bytes per written line. */
-               format = surface->config.format;
-               bytes  = DFB_BYTES_PER_LINE( format, rect.w );
-
-               /* Lock the allocation. */
-               dfb_surface_buffer_lock_init( &lock, CSAID_CPU, CSAF_WRITE );
+     /* Lock the allocation. */
+     dfb_surface_buffer_lock_init( &lock, CSAF_CPU_WRITE );
 
-               ret = dfb_surface_pool_lock( allocation->pool, allocation, &lock );
-               if (ret) {
-                    D_DERROR( ret, "Core/SurfBuffer: Locking allocation failed! [%s]\n",
-                              allocation->pool->desc.name );
-                    dfb_surface_buffer_lock_deinit( &lock );
-                    return ret;
-               }
+     ret = dfb_surface_pool_lock( allocation->pool, allocation, &lock );
+     if (ret) {
+          D_DERROR( ret, "Core/SurfBuffer: Locking allocation failed! [%s]\n",
+                    allocation->pool->desc.name );
+          D_MAGIC_CLEAR( &lock );
+          return ret;
+     }
 
-               /* Move to start of write. */
-               lock.addr += DFB_BYTES_PER_LINE( format, rect.x ) + rect.y * lock.pitch;
+     /* Move to start of write. */
+     lock.addr += DFB_BYTES_PER_LINE( format, rect.x ) + rect.y * lock.pitch;
 
-               /* Copy the data. */
-               for (y=0; y<rect.h; y++) {
-                    if (source) {
-                         direct_memcpy( lock.addr, source, bytes );
+     /* Copy the data. */
+     for (y=0; y<rect.h; y++) {
+          if (source) {
+               direct_memcpy( lock.addr, source, bytes );
 
-                         source += pitch;
-                    }
-                    else
-                         memset( lock.addr, 0, bytes );
+               source += pitch;
+          }
+          else
+               memset( lock.addr, 0, bytes );
 
-                    lock.addr += lock.pitch;
-               }
+          lock.addr += lock.pitch;
+     }
 
-               /* Unlock the allocation. */
-               ret = dfb_surface_pool_unlock( allocation->pool, allocation, &lock );
-               if (ret)
-                    D_DERROR( ret, "Core/SurfBuffer: Unlocking allocation failed! [%s]\n", allocation->pool->desc.name );
+     /* Unlock the allocation. */
+     ret = dfb_surface_pool_unlock( allocation->pool, allocation, &lock );
+     if (ret)
+          D_DERROR( ret, "Core/SurfBuffer: Unlocking allocation failed! [%s]\n", allocation->pool->desc.name );
 
-               dfb_surface_buffer_lock_deinit( &lock );
-          }
-     }
+     D_MAGIC_CLEAR( &lock );
 
      return ret;
 }
@@ -730,7 +648,7 @@ dfb_surface_buffer_dump( CoreSurfaceBuffer *buffer,
      }
 
      /* Lock the surface buffer, get the data pointer and pitch. */
-     ret = dfb_surface_buffer_lock( buffer, CSAID_CPU, CSAF_READ, &lock );
+     ret = dfb_surface_buffer_lock( buffer, CSAF_CPU_READ, &lock );
      if (ret) {
           if (palette)
                dfb_palette_unref( palette );
@@ -839,49 +757,206 @@ dfb_surface_buffer_dump( CoreSurfaceBuffer *buffer,
 
      /* Write the pixmap (and graymap) data. */
      for (i=0; i<surface->config.size.h; i++) {
-          int n3;
+          int    n3;
+          u8    *data8;
+          u16 *data16;
+          u32 *data32;
+
+          u8 buf_p[surface->config.size.w * 3];
+          u8 buf_g[surface->config.size.w];
 
           /* Prepare one row. */
-          u8 *src8 = dfb_surface_data_offset( surface, lock.addr, lock.pitch, 0, i );
+          data8  = dfb_surface_data_offset( surface, lock.addr, lock.pitch, 0, i );
+          data16 = (u16*) data8;
+          data32 = (u32*) data8;
 
-          /* Write color buffer to pixmap file. */
-          if (rgb) {
-               u8 buf_p[surface->config.size.w * 3];
+          switch (buffer->format) {
+               case DSPF_LUT8:
+                    for (n=0, n3=0; n<surface->config.size.w; n++, n3+=3) {
+                         buf_p[n3+0] = palette->entries[data8[n]].r;
+                         buf_p[n3+1] = palette->entries[data8[n]].g;
+                         buf_p[n3+2] = palette->entries[data8[n]].b;
 
-               if (buffer->format == DSPF_LUT8) {
+                         buf_g[n] = palette->entries[data8[n]].a;
+                    }
+                    break;
+               case DSPF_A8:
+                    direct_memcpy( &buf_g[0], data8, surface->config.size.w );
+                    break;
+               case DSPF_AiRGB:
+                    for (n=0, n3=0; n<surface->config.size.w; n++, n3+=3) {
+                         buf_p[n3+0] = (data32[n] & 0xFF0000) >> 16;
+                         buf_p[n3+1] = (data32[n] & 0x00FF00) >>  8;
+                         buf_p[n3+2] = (data32[n] & 0x0000FF);
+
+                         buf_g[n] = ~(data32[n] >> 24);
+                    }
+                    break;
+               case DSPF_ARGB:
                     for (n=0, n3=0; n<surface->config.size.w; n++, n3+=3) {
-                         buf_p[n3+0] = palette->entries[src8[n]].r;
-                         buf_p[n3+1] = palette->entries[src8[n]].g;
-                         buf_p[n3+2] = palette->entries[src8[n]].b;
+                         buf_p[n3+0] = (data32[n] & 0xFF0000) >> 16;
+                         buf_p[n3+1] = (data32[n] & 0x00FF00) >>  8;
+                         buf_p[n3+2] = (data32[n] & 0x0000FF);
+
+                         buf_g[n] = data32[n] >> 24;
+                    }
+                    break;
+               case DSPF_ARGB1555:
+                    for (n=0, n3=0; n<surface->config.size.w; n++, n3+=3) {
+                         buf_p[n3+0] = (data16[n] & 0x7C00) >> 7;
+                         buf_p[n3+1] = (data16[n] & 0x03E0) >> 2;
+                         buf_p[n3+2] = (data16[n] & 0x001F) << 3;
+
+                         buf_g[n] = (data16[n] & 0x8000) ? 0xff : 0x00;
                     }
+                    break;
+               case DSPF_RGB555:
+                    for (n=0, n3=0; n<surface->config.size.w; n++, n3+=3) {
+                         buf_p[n3+0] = (data16[n] & 0x7C00) >> 7;
+                         buf_p[n3+1] = (data16[n] & 0x03E0) >> 2;
+                         buf_p[n3+2] = (data16[n] & 0x001F) << 3;
+                    }
+                    break;
+
+               case DSPF_BGR555:
+                    for (n=0, n3=0; n<surface->config.size.w; n++, n3+=3) {
+                         buf_p[n3+2] = (data16[n] & 0x7C00) >> 7;
+                         buf_p[n3+1] = (data16[n] & 0x03E0) >> 2;
+                         buf_p[n3+0] = (data16[n] & 0x001F) << 3;
+                    }
+                    break;
+
+               case DSPF_ARGB2554:
+                    for (n=0, n3=0; n<surface->config.size.w; n++, n3+=3) {
+                         buf_p[n3+0] = (data16[n] & 0x3E00) >> 6;
+                         buf_p[n3+1] = (data16[n] & 0x01F0) >> 1;
+                         buf_p[n3+2] = (data16[n] & 0x000F) << 4;
+
+                         switch (data16[n] >> 14) {
+                              case 0:
+                                   buf_g[n] = 0x00;
+                                   break;
+                              case 1:
+                                   buf_g[n] = 0x55;
+                                   break;
+                              case 2:
+                                   buf_g[n] = 0xAA;
+                                   break;
+                              case 3:
+                                   buf_g[n] = 0xFF;
+                                   break;
+                         }
+                    }
+                    break;
+               case DSPF_ARGB4444:
+                    for (n=0, n3=0; n<surface->config.size.w; n++, n3+=3) {
+                         buf_p[n3+0] = (data16[n] & 0x0F00) >> 4;
+                         buf_p[n3+1] = (data16[n] & 0x00F0);
+                         buf_p[n3+2] = (data16[n] & 0x000F) << 4;
+
+                         buf_g[n]  = (data16[n] >> 12);
+                         buf_g[n] |= buf_g[n] << 4;
+                    }
+                    break;
+              case DSPF_RGB444:
+                    for (n=0, n3=0; n<surface->config.size.w; n++, n3+=3) {
+                         buf_p[n3+0] = (data16[n] & 0x0F00) >> 4;
+                         buf_p[n3+1] = (data16[n] & 0x00F0);
+                         buf_p[n3+2] = (data16[n] & 0x000F) << 4;
+                    }
+                    break;
+               case DSPF_RGB332:
+                    for (n=0, n3=0; n<surface->config.size.w; n++, n3+=3) {
+                         buf_p[n3+0] = lookup3to8[ (data8[n] >> 5)        ];
+                         buf_p[n3+1] = lookup3to8[ (data8[n] >> 2) & 0x07 ];
+                         buf_p[n3+2] = lookup2to8[ (data8[n]     ) & 0x03 ];
+                    }
+                    break;
+               case DSPF_RGB16:
+                    for (n=0, n3=0; n<surface->config.size.w; n++, n3+=3) {
+                         buf_p[n3+0] = (data16[n] & 0xF800) >> 8;
+                         buf_p[n3+1] = (data16[n] & 0x07E0) >> 3;
+                         buf_p[n3+2] = (data16[n] & 0x001F) << 3;
+                    }
+                    break;
+               case DSPF_RGB24:
+                    for (n=0, n3=0; n<surface->config.size.w; n++, n3+=3) {
+#ifdef WORDS_BIGENDIAN
+                         buf_p[n3+0] = data8[n3+0];
+                         buf_p[n3+1] = data8[n3+1];
+                         buf_p[n3+2] = data8[n3+2];
+#else
+                         buf_p[n3+0] = data8[n3+2];
+                         buf_p[n3+1] = data8[n3+1];
+                         buf_p[n3+2] = data8[n3+0];
+#endif
+                    }
+                    break;
+               case DSPF_RGB32:
+                    for (n=0, n3=0; n<surface->config.size.w; n++, n3+=3) {
+                         buf_p[n3+0] = (data32[n] & 0xFF0000) >> 16;
+                         buf_p[n3+1] = (data32[n] & 0x00FF00) >>  8;
+                         buf_p[n3+2] = (data32[n] & 0x0000FF);
+                    }
+                    break;
+               case DSPF_YUY2:
+                    for (n=0, n3=0; n<surface->config.size.w/2; n++, n3+=6) {
+                         register u32 y0, cb, y1, cr;
+                         y0 = (data32[n] & 0x000000FF);
+                         cb = (data32[n] & 0x0000FF00) >>  8;
+                         y1 = (data32[n] & 0x00FF0000) >> 16;
+                         cr = (data32[n] & 0xFF000000) >> 24;
+                         YCBCR_TO_RGB( y0, cb, cr,
+                                       buf_p[n3+0], buf_p[n3+1], buf_p[n3+2] );
+                         YCBCR_TO_RGB( y1, cb, cr,
+                                       buf_p[n3+3], buf_p[n3+4], buf_p[n3+5] );
+                    }
+                    break;
+               case DSPF_UYVY:
+                    for (n=0, n3=0; n<surface->config.size.w/2; n++, n3+=6) {
+                         register u32 y0, cb, y1, cr;
+                         cb = (data32[n] & 0x000000FF);
+                         y0 = (data32[n] & 0x0000FF00) >>  8;
+                         cr = (data32[n] & 0x00FF0000) >> 16;
+                         y1 = (data32[n] & 0xFF000000) >> 24;
+                         YCBCR_TO_RGB( y0, cb, cr,
+                                       buf_p[n3+0], buf_p[n3+1], buf_p[n3+2] );
+                         YCBCR_TO_RGB( y1, cb, cr,
+                                       buf_p[n3+3], buf_p[n3+4], buf_p[n3+5] );
+                    }
+                    break;
+               case DSPF_NV16: {
+                    u16 *cbcr = (u16*)(data8 + surface->config.size.h * lock.pitch);
+
+                    for (n=0, n3=0; n<surface->config.size.w/2; n++, n3+=6) {
+                         YCBCR_TO_RGB( data8[n*2+0], cbcr[n] >> 8, cbcr[n] & 0xff,
+                                       buf_p[n3+0], buf_p[n3+1], buf_p[n3+2] );
+
+                         YCBCR_TO_RGB( data8[n*2+1], cbcr[n] >> 8, cbcr[n] & 0xff,
+                                       buf_p[n3+3], buf_p[n3+4], buf_p[n3+5] );
+                    }
+                    break;
                }
-               else
-                    dfb_convert_to_rgb24( buffer->format, src8, lock.pitch, surface->config.size.h,
-                                          buf_p, surface->config.size.w * 3, surface->config.size.w, 1 );
+               default:
+                    D_BUG( "unexpected pixelformat" );
+                    break;
+          }
+
+          /* Write color buffer to pixmap file. */
+          if (rgb)
 #ifdef USE_ZLIB
                gzwrite( gz_p, buf_p, surface->config.size.w * 3 );
 #else
                write( fd_p, buf_p, surface->config.size.w * 3 );
 #endif
-          }
 
           /* Write alpha buffer to graymap file. */
-          if (alpha) {
-               u8 buf_g[surface->config.size.w];
-
-               if (buffer->format == DSPF_LUT8) {
-                    for (n=0; n<surface->config.size.w; n++)
-                         buf_g[n] = palette->entries[src8[n]].a;
-               }
-               else
-                    dfb_convert_to_a8( buffer->format, src8, lock.pitch, surface->config.size.h,
-                                       buf_g, surface->config.size.w, surface->config.size.w, 1 );
+          if (alpha)
 #ifdef USE_ZLIB
                gzwrite( gz_g, buf_g, surface->config.size.w );
 #else
                write( fd_g, buf_g, surface->config.size.w );
 #endif
-          }
      }
 
      /* Unlock the surface buffer. */
@@ -980,142 +1055,6 @@ transfer_buffer( CoreSurfaceBuffer *buffer,
      }
 }
 
-static DFBResult
-allocation_update_copy( CoreSurfaceAllocation *allocation,
-                        CoreSurfaceAllocation *source )
-{
-     DFBResult              ret;
-     CoreSurfaceBufferLock  src;
-     CoreSurfaceBufferLock  dst;
-     CoreSurfaceBuffer     *buffer;
-
-     D_DEBUG_AT( Core_SurfBuffer, "%s()\n", __FUNCTION__ );
-
-     D_ASSERT( allocation != source );
-
-     D_MAGIC_ASSERT( allocation, CoreSurfaceAllocation );
-     D_MAGIC_ASSERT( source, CoreSurfaceAllocation );
-
-     D_ASSERT( source->buffer == allocation->buffer );
-
-     buffer = allocation->buffer;
-     D_MAGIC_ASSERT( buffer, CoreSurfaceBuffer );
-
-     /* Lock the source allocation. */
-     dfb_surface_buffer_lock_init( &src, CSAID_CPU, CSAF_READ );
-
-     ret = dfb_surface_pool_lock( source->pool, source, &src );
-     if (ret) {
-          D_DERROR( ret, "Core/SurfBuffer: Could not lock source for transfer!\n" );
-          dfb_surface_buffer_lock_deinit( &src );
-          return ret;
-     }
-
-     /* Lock the destination allocation. */
-     dfb_surface_buffer_lock_init( &dst, CSAID_CPU, CSAF_WRITE );
-
-     ret = dfb_surface_pool_lock( allocation->pool, allocation, &dst );
-     if (ret) {
-          D_DERROR( ret, "Core/SurfBuffer: Could not lock destination for transfer!\n" );
-          dfb_surface_pool_unlock( source->pool, source, &src );
-          return ret;
-     }
-
-     transfer_buffer( buffer, src.addr, dst.addr, src.pitch, dst.pitch );
-
-     dfb_surface_pool_unlock( allocation->pool, allocation, &dst );
-     dfb_surface_pool_unlock( source->pool, source, &src );
-
-     dfb_surface_buffer_lock_deinit( &dst );
-     dfb_surface_buffer_lock_deinit( &src );
-
-     return DFB_OK;
-}
-
-static DFBResult
-allocation_update_write( CoreSurfaceAllocation *allocation,
-                         CoreSurfaceAllocation *source )
-{
-     DFBResult              ret;
-     CoreSurfaceBufferLock  src;
-     CoreSurfaceBuffer     *buffer;
-
-     D_DEBUG_AT( Core_SurfBuffer, "%s()\n", __FUNCTION__ );
-
-     D_ASSERT( allocation != source );
-
-     D_MAGIC_ASSERT( allocation, CoreSurfaceAllocation );
-     D_MAGIC_ASSERT( source, CoreSurfaceAllocation );
-
-     D_ASSERT( source->buffer == allocation->buffer );
-
-     buffer = allocation->buffer;
-     D_MAGIC_ASSERT( buffer, CoreSurfaceBuffer );
-
-     /* Lock the source allocation. */
-     dfb_surface_buffer_lock_init( &src, CSAID_CPU, CSAF_READ );
-
-     ret = dfb_surface_pool_lock( source->pool, source, &src );
-     if (ret) {
-          D_DERROR( ret, "Core/SurfBuffer: Could not lock source for transfer!\n" );
-          dfb_surface_buffer_lock_deinit( &src );
-          return ret;
-     }
-
-     /* Write to the destination allocation. */
-     ret = dfb_surface_pool_write( allocation->pool, allocation, src.addr, src.pitch, NULL );
-     if (ret)
-          D_DERROR( ret, "Core/SurfBuffer: Could not write from destination allocation!\n" );
-
-     dfb_surface_pool_unlock( source->pool, source, &src );
-
-     dfb_surface_buffer_lock_deinit( &src );
-
-     return ret;
-}
-
-static DFBResult
-allocation_update_read( CoreSurfaceAllocation *allocation,
-                        CoreSurfaceAllocation *source )
-{
-     DFBResult              ret;
-     CoreSurfaceBufferLock  dst;
-     CoreSurfaceBuffer     *buffer;
-
-     D_DEBUG_AT( Core_SurfBuffer, "%s()\n", __FUNCTION__ );
-
-     D_ASSERT( allocation != source );
-
-     D_MAGIC_ASSERT( allocation, CoreSurfaceAllocation );
-     D_MAGIC_ASSERT( source, CoreSurfaceAllocation );
-
-     D_ASSERT( source->buffer == allocation->buffer );
-
-     buffer = allocation->buffer;
-     D_MAGIC_ASSERT( buffer, CoreSurfaceBuffer );
-
-     /* Lock the destination allocation. */
-     dfb_surface_buffer_lock_init( &dst, CSAID_CPU, CSAF_WRITE );
-
-     ret = dfb_surface_pool_lock( allocation->pool, allocation, &dst );
-     if (ret) {
-          D_DERROR( ret, "Core/SurfBuffer: Could not lock destination for transfer!\n" );
-          dfb_surface_buffer_lock_deinit( &dst );
-          return ret;
-     }
-
-     /* Read from the source allocation. */
-     ret = dfb_surface_pool_read( source->pool, source, dst.addr, dst.pitch, NULL );
-     if (ret)
-          D_DERROR( ret, "Core/SurfBuffer: Could not read from source allocation!\n" );
-
-     dfb_surface_pool_unlock( allocation->pool, allocation, &dst );
-
-     dfb_surface_buffer_lock_deinit( &dst );
-
-     return ret;
-}
-
 DFBResult
 dfb_surface_allocation_update( CoreSurfaceAllocation  *allocation,
                                CoreSurfaceAccessFlags  access )
@@ -1136,34 +1075,49 @@ dfb_surface_allocation_update( CoreSurfaceAllocation  *allocation,
      if (direct_serial_update( &allocation->serial, &buffer->serial ) && buffer->written) {
           CoreSurfaceAllocation *source = buffer->written;
 
-          D_ASSUME( allocation != source );
-
           D_DEBUG_AT( Core_SurfBuffer, "  -> updating allocation...\n" );
 
           D_MAGIC_ASSERT( source, CoreSurfaceAllocation );
           D_ASSERT( source->buffer == allocation->buffer );
 
-          ret = dfb_surface_pool_bridges_transfer( buffer, source, allocation, NULL, 0 );
-          if (ret) {
-               if ((source->access[CSAID_CPU] & CSAF_READ) && (allocation->access[CSAID_CPU] & CSAF_WRITE))
-                    ret = allocation_update_copy( allocation, source );
-               else if (source->access[CSAID_CPU] & CSAF_READ)
-                    ret = allocation_update_write( allocation, source );
-               else if (allocation->access[CSAID_CPU] & CSAF_WRITE)
-                    ret = allocation_update_read( allocation, source );
-               else {
-                    D_UNIMPLEMENTED();
-                    ret = DFB_UNSUPPORTED;
+          if ((source->access & CSAF_CPU_READ) && (allocation->access & CSAF_CPU_WRITE)) {
+               CoreSurfaceBufferLock src;
+               CoreSurfaceBufferLock dst;
+
+               /* Lock the allocation. */
+               dfb_surface_buffer_lock_init( &src, CSAF_CPU_READ );
+
+               ret = dfb_surface_pool_lock( source->pool, source, &src );
+               if (ret) {
+                    D_DERROR( ret, "Core/SurfBuffer: Could not lock source for transfer!\n" );
+                    D_MAGIC_CLEAR( &src );
+                    return ret;
                }
-          }
 
-          if (ret) {
-               D_DERROR( ret, "Core/SurfaceBuffer: Updating allocation failed!\n" );
-               return ret;
+               /* Lock the allocation. */
+               dfb_surface_buffer_lock_init( &dst, CSAF_CPU_WRITE );
+
+               ret = dfb_surface_pool_lock( allocation->pool, allocation, &dst );
+               if (ret) {
+                    D_DERROR( ret, "Core/SurfBuffer: Could not lock destination for transfer!\n" );
+                    dfb_surface_pool_unlock( source->pool, source, &src );
+                    return ret;
+               }
+
+               transfer_buffer( buffer, src.addr, dst.addr, src.pitch, dst.pitch );
+
+               dfb_surface_pool_unlock( allocation->pool, allocation, &dst );
+               dfb_surface_pool_unlock( source->pool, source, &src );
+
+               D_MAGIC_CLEAR( &dst );
+               D_MAGIC_CLEAR( &src );
+          }
+          else {
+               D_UNIMPLEMENTED();
           }
      }
 
-     if (access & CSAF_WRITE) {
+     if (access & (CSAF_CPU_WRITE | CSAF_GPU_WRITE)) {
           D_DEBUG_AT( Core_SurfBuffer, "  -> increasing serial...\n" );
 
           direct_serial_increase( &buffer->serial );
@@ -1171,7 +1125,6 @@ dfb_surface_allocation_update( CoreSurfaceAllocation  *allocation,
           direct_serial_copy( &allocation->serial, &buffer->serial );
 
           buffer->written = allocation;
-          buffer->read    = NULL;
 
           /* Zap volatile allocations (freed when no longer up to date). */
           fusion_vector_foreach (alloc, i, buffer->allocs) {
@@ -1183,12 +1136,10 @@ dfb_surface_allocation_update( CoreSurfaceAllocation  *allocation,
                }
           }
      }
-     else
-          buffer->read = allocation;
 
      /* Zap all other allocations? */
      if (dfb_config->thrifty_surface_buffers) {
-          buffer->written = buffer->read = allocation;
+          buffer->written = allocation;
 
           fusion_vector_foreach (alloc, i, buffer->allocs) {
                D_MAGIC_ASSERT( alloc, CoreSurfaceAllocation );
diff --git a/DirectFB-1.3.0/src/core/surface_buffer.h b/DirectFB-1.3.0/src/core/surface_buffer.h
index 0e12588..3e1cfa2 100644
--- a/DirectFB-1.3.0/src/core/surface_buffer.h
+++ b/DirectFB-1.3.0/src/core/surface_buffer.h
@@ -75,16 +75,15 @@ struct __DFB_CoreSurfaceAllocation {
      DirectSerial                   serial;       /* Equals serial of buffer if content is up to date. */
 
      CoreSurfaceBuffer             *buffer;       /* Surface Buffer owning this allocation. */
-     CoreSurface                   *surface;      /* Surface owning the Buffer of this allocation. */
      CoreSurfacePool               *pool;         /* Surface Pool providing the allocation. */
      void                          *data;         /* Pool's private data for this allocation. */
      int                            size;         /* Amount of data used by this allocation. */
      unsigned long                  offset;       /* Offset within address range of pool if contiguous. */
 
+     CoreSurfaceAccessFlags         access;       /* Possible access flags. */
      CoreSurfaceAllocationFlags     flags;        /* Pool can return CSALF_ONEFORALL upon allocation of first buffer. */
 
-     const CoreSurfaceAccessFlags  *access;                 /* Possible access flags (pointer to pool description). */
-     CoreSurfaceAccessFlags         accessed[_CSAID_NUM];   /* Access since last synchronization. */
+     CoreSurfaceAccessFlags         accessed;     /* Access since last synchronization. */
 };
 
 #define CORE_SURFACE_ALLOCATION_ASSERT(alloc)                                                  \
@@ -93,11 +92,9 @@ struct __DFB_CoreSurfaceAllocation {
           D_ASSUME( (alloc)->size > 0 );                                                       \
           D_ASSERT( (alloc)->size >= 0 );                                                      \
           D_ASSERT( (alloc)->offset + (alloc)->size <= ((alloc)->pool->desc.size ?:~0UL) );    \
-          D_FLAGS_ASSERT( (alloc)->access[CSAID_CPU], CSAF_ALL );                              \
-          D_FLAGS_ASSERT( (alloc)->access[CSAID_GPU], CSAF_ALL );                              \
+          D_FLAGS_ASSERT( (alloc)->access, CSAF_ALL );                                         \
           D_FLAGS_ASSERT( (alloc)->flags, CSALF_ALL );                                         \
-          D_FLAGS_ASSERT( (alloc)->accessed[CSAID_CPU], CSAF_ALL );                            \
-          D_FLAGS_ASSERT( (alloc)->accessed[CSAID_GPU], CSAF_ALL );                            \
+          D_FLAGS_ASSERT( (alloc)->accessed, CSAF_ALL );                                       \
      } while (0)
 
 /*
@@ -106,7 +103,6 @@ struct __DFB_CoreSurfaceAllocation {
 struct __DFB_CoreSurfaceBufferLock {
      int                      magic;              /* Must be valid before calling dfb_surface_pool_lock() */
 
-     CoreSurfaceAccessorID    accessor;           /* " */
      CoreSurfaceAccessFlags   access;             /* " */
 
      CoreSurfaceBuffer       *buffer;             /* Set by dfb_surface_pool_lock() */
@@ -135,27 +131,15 @@ dfb_surface_buffer_lock_reset( CoreSurfaceBufferLock *lock )
 }
 
 static inline void
-dfb_surface_buffer_lock_init( CoreSurfaceBufferLock *lock, CoreSurfaceAccessorID accessor, CoreSurfaceAccessFlags access )
+dfb_surface_buffer_lock_init( CoreSurfaceBufferLock *lock, CoreSurfaceAccessFlags access )
 {
      D_MAGIC_SET( lock, CoreSurfaceBufferLock );
 
-     lock->accessor = accessor;
-     lock->access   = access;
+     lock->access = access;
 
      dfb_surface_buffer_lock_reset( lock );
 }
 
-static inline void
-dfb_surface_buffer_lock_deinit( CoreSurfaceBufferLock *lock )
-{
-     D_MAGIC_ASSERT( lock, CoreSurfaceBufferLock );
-
-     lock->accessor = CSAID_NONE;
-     lock->access   = CSAF_NONE;
-
-     D_MAGIC_CLEAR( lock );
-}
-
 #define CORE_SURFACE_BUFFER_LOCK_ASSERT(lock)                                                       \
      do {                                                                                           \
           D_MAGIC_ASSERT( lock, CoreSurfaceBufferLock );                                            \
@@ -163,9 +147,12 @@ dfb_surface_buffer_lock_deinit( CoreSurfaceBufferLock *lock )
           if ((lock)->buffer) {                                                                     \
                D_ASSERT( (lock)->allocation != NULL );                                              \
                D_ASSERT( (lock)->buffer == (lock)->allocation->buffer );                            \
-               D_ASSUME( (lock)->addr != NULL || (lock)->phys != 0 || (lock)->offset != ~0 || (lock)->handle != NULL );\
+               D_ASSUME( (lock)->addr != NULL ||                                                    \
+                         !((lock)->access & (CSAF_CPU_READ|CSAF_CPU_WRITE)) );                      \
+               D_ASSUME( (lock)->phys != 0 || (lock)->offset != ~0 || (lock)->handle != NULL ||     \
+                         !((lock)->access & (CSAF_GPU_READ|CSAF_GPU_WRITE)) );                      \
                D_ASSUME( (lock)->offset == (lock)->allocation->offset || (lock)->offset == ~0 );    \
-               D_ASSERT( (lock)->pitch > 0 || ((lock)->addr == NULL && (lock)->phys == 0) );        \
+               D_ASSERT( (lock)->pitch > 0 );                                                       \
           }                                                                                         \
           else {                                                                                    \
                D_ASSERT( (lock)->allocation == NULL );                                              \
@@ -185,7 +172,6 @@ struct __DFB_CoreSurfaceBuffer {
 
      DirectSerial             serial;        /* Increased when content is written. */
      CoreSurfaceAllocation   *written;       /* Allocation with the last write access. */
-     CoreSurfaceAllocation   *read;          /* Allocation with the last read access. */
 
      CoreSurface             *surface;       /* Surface owning this Surface Buffer. */
      CoreSurfacePolicy        policy;
@@ -195,9 +181,7 @@ struct __DFB_CoreSurfaceBuffer {
 
      FusionVector             allocs;        /* Allocations within Surface Pools. */
 
-#if 1
      unsigned int             locked;        /* Lock count. FIXME: Add fail safe cleanup! */
-#endif
 };
 
 
@@ -209,7 +193,6 @@ DFBResult dfb_surface_buffer_destroy( CoreSurfaceBuffer       *buffer );
 
 
 DFBResult dfb_surface_buffer_lock   ( CoreSurfaceBuffer       *buffer,
-                                      CoreSurfaceAccessorID    accessor,
                                       CoreSurfaceAccessFlags   access,
                                       CoreSurfaceBufferLock   *ret_lock );
 
diff --git a/DirectFB-1.3.0/src/core/surface_pool.c b/DirectFB-1.3.0/src/core/surface_pool.c
index 87eb4d5..d96d447 100644
--- a/DirectFB-1.3.0/src/core/surface_pool.c
+++ b/DirectFB-1.3.0/src/core/surface_pool.c
@@ -306,7 +306,6 @@ dfb_surface_pool_leave( CoreSurfacePool *pool )
 
 DFBResult
 dfb_surface_pools_negotiate( CoreSurfaceBuffer       *buffer,
-                             CoreSurfaceAccessorID    accessor,
                              CoreSurfaceAccessFlags   access,
                              CoreSurfacePool        **ret_pools,
                              unsigned int             max_pools,
@@ -335,16 +334,6 @@ dfb_surface_pools_negotiate( CoreSurfaceBuffer       *buffer,
      D_MAGIC_ASSERT( surface, CoreSurface );
      FUSION_SKIRMISH_ASSERT( &surface->lock );
 
-     D_ASSERT( accessor >= CSAID_CPU );
-     D_ASSUME( accessor < _CSAID_NUM );
-     if (accessor >= CSAID_ANY) {
-          D_UNIMPLEMENTED();
-          return DFB_UNIMPLEMENTED;
-     }
-
-     if (accessor < 0 || accessor >= _CSAID_NUM)
-          return DFB_INVARG;
-
      type = surface->type & ~(CSTF_INTERNAL | CSTF_EXTERNAL);
 
      switch (buffer->policy) {
@@ -371,13 +360,13 @@ dfb_surface_pools_negotiate( CoreSurfaceBuffer       *buffer,
           pool = pool_array[pool_order[i]];
           D_MAGIC_ASSERT( pool, CoreSurfacePool );
 
-          if (D_FLAGS_ARE_SET( pool->desc.access[accessor], access ) &&
-              D_FLAGS_ARE_SET( pool->desc.types, type ))
+          if (D_FLAGS_ARE_SET( pool->desc.access, access ) &&
+              D_FLAGS_ARE_SET( pool->desc.types,  type ))
           {
                const SurfacePoolFuncs *funcs;
 
                D_DEBUG_AT( Core_SurfacePool, "  -> [%d] 0x%02x 0x%03x (%d) [%s]\n", pool->pool_id,
-                           pool->desc.caps, pool->desc.types, pool->desc.priority, pool->desc.name );
+                           pool->desc.access, pool->desc.types, pool->desc.priority, pool->desc.name );
 
                funcs = get_funcs( pool );
 
@@ -438,7 +427,6 @@ dfb_surface_pools_enumerate( CoreSurfacePoolCallback  callback,
 
 DFBResult
 dfb_surface_pools_allocate( CoreSurfaceBuffer       *buffer,
-                            CoreSurfaceAccessorID    accessor,
                             CoreSurfaceAccessFlags   access,
                             CoreSurfaceAllocation  **ret_allocation )
 {
@@ -470,18 +458,8 @@ dfb_surface_pools_allocate( CoreSurfaceBuffer       *buffer,
                  (surface->type & CSTF_INTERNAL) ? "INTERNAL" : "",
                  (surface->type & CSTF_EXTERNAL) ? "EXTERNAL" : "" );
 
-     D_ASSERT( accessor >= CSAID_CPU );
-     D_ASSUME( accessor < _CSAID_NUM );
-     if (accessor >= CSAID_ANY) {
-          D_UNIMPLEMENTED();
-          return DFB_UNIMPLEMENTED;
-     }
-
-     if (accessor < 0 || accessor >= _CSAID_NUM)
-          return DFB_INVARG;
-
      /* Build a list of possible pools being free or out of memory */
-     ret = dfb_surface_pools_negotiate( buffer, accessor, access, pools, pool_count, &num_pools );
+     ret = dfb_surface_pools_negotiate( buffer, access, pools, pool_count, &num_pools );
      if (ret && ret != DFB_NOVIDEOMEMORY) {
           D_DEBUG_AT( Core_SurfacePool, "  -> NEGOTIATION FAILED! (%s)\n", DirectFBErrorString( ret ) );
           return ret;
@@ -532,7 +510,7 @@ dfb_surface_pools_allocate( CoreSurfaceBuffer       *buffer,
           return DFB_FAILURE;
      }
 
-     CORE_SURFACE_ALLOCATION_ASSERT( allocation );
+     D_MAGIC_ASSERT( allocation, CoreSurfaceAllocation );
 
      D_DEBUG_AT( Core_SurfacePool, "  -> %p\n", allocation );
 
@@ -573,10 +551,9 @@ dfb_surface_pool_allocate( CoreSurfacePool        *pool,
      if (!allocation)
           return D_OOSHM();
 
-     allocation->buffer  = buffer;
-     allocation->surface = surface;
-     allocation->pool    = pool;
-     allocation->access  = pool->desc.access;
+     allocation->buffer = buffer;
+     allocation->pool   = pool;
+     allocation->access = pool->desc.access;
 
      if (pool->alloc_data_size) {
           allocation->data = SHCALLOC( pool->shmpool, 1, pool->alloc_data_size );
@@ -631,8 +608,6 @@ dfb_surface_pool_allocate( CoreSurfacePool        *pool,
 
      fusion_skirmish_dismiss( &pool->lock );
 
-     CORE_SURFACE_ALLOCATION_ASSERT( allocation );
-
      *ret_allocation = allocation;
 
      return DFB_OK;
@@ -657,7 +632,7 @@ dfb_surface_pool_deallocate( CoreSurfacePool       *pool,
      CoreSurface            *surface;
 
      D_MAGIC_ASSERT( pool, CoreSurfacePool );
-     CORE_SURFACE_ALLOCATION_ASSERT( allocation );
+     D_MAGIC_ASSERT( allocation, CoreSurfaceAllocation );
 
      D_DEBUG_AT( Core_SurfacePool, "%s( %p [%d], %p )\n", __FUNCTION__, pool, pool->pool_id, allocation );
 
@@ -748,7 +723,7 @@ dfb_surface_pool_displace( CoreSurfacePool        *pool,
      /* FIXME: Solve potential dead lock, until then do a few retries... */
 fixme_retry:
      fusion_vector_foreach (allocation, i, pool->allocs) {
-          CORE_SURFACE_ALLOCATION_ASSERT( allocation );
+          D_MAGIC_ASSERT( allocation, CoreSurfaceAllocation );
 
           if (allocation->flags & CSALF_MUCKOUT) {
                CoreSurface       *alloc_surface;
@@ -806,7 +781,7 @@ fixme_retry:
 
 error_cleanup:
      fusion_vector_foreach (allocation, i, pool->allocs) {
-          CORE_SURFACE_ALLOCATION_ASSERT( allocation );
+          D_MAGIC_ASSERT( allocation, CoreSurfaceAllocation );
 
           if (allocation->flags & CSALF_MUCKOUT)
                allocation->flags &= ~CSALF_MUCKOUT;
@@ -826,13 +801,12 @@ dfb_surface_pool_lock( CoreSurfacePool       *pool,
      const SurfacePoolFuncs *funcs;
 
      D_MAGIC_ASSERT( pool, CoreSurfacePool );
-
-     D_DEBUG_AT( Core_SurfPoolLock, "%s( %p [%d], %p )\n", __FUNCTION__, pool, pool->pool_id, allocation );
-
-     CORE_SURFACE_ALLOCATION_ASSERT( allocation );
+     D_MAGIC_ASSERT( allocation, CoreSurfaceAllocation );
      CORE_SURFACE_BUFFER_LOCK_ASSERT( lock );
      D_ASSERT( lock->buffer == NULL );
 
+     D_DEBUG_AT( Core_SurfPoolLock, "%s( %p [%d], %p )\n", __FUNCTION__, pool, pool->pool_id, allocation );
+
      D_ASSERT( pool == allocation->pool );
 
      funcs = get_funcs( pool );
@@ -864,13 +838,12 @@ dfb_surface_pool_unlock( CoreSurfacePool       *pool,
      const SurfacePoolFuncs *funcs;
 
      D_MAGIC_ASSERT( pool, CoreSurfacePool );
-
-     D_DEBUG_AT( Core_SurfPoolLock, "%s( %p [%d], %p )\n", __FUNCTION__, pool, pool->pool_id, allocation );
-
-     CORE_SURFACE_ALLOCATION_ASSERT( allocation );
+     D_MAGIC_ASSERT( allocation, CoreSurfaceAllocation );
      CORE_SURFACE_BUFFER_LOCK_ASSERT( lock );
      D_ASSERT( lock->buffer != NULL );
 
+     D_DEBUG_AT( Core_SurfPoolLock, "%s( %p [%d], %p )\n", __FUNCTION__, pool, pool->pool_id, allocation );
+
      D_ASSERT( pool == allocation->pool );
 
      funcs = get_funcs( pool );
@@ -892,100 +865,6 @@ dfb_surface_pool_unlock( CoreSurfacePool       *pool,
 }
 
 DFBResult
-dfb_surface_pool_read( CoreSurfacePool       *pool,
-                       CoreSurfaceAllocation *allocation,
-                       void                  *data,
-                       int                    pitch,
-                       const DFBRectangle    *rect )
-{
-     DFBResult               ret;
-     const SurfacePoolFuncs *funcs;
-     CoreSurface            *surface;
-     DFBRectangle            area;
-
-     D_MAGIC_ASSERT( pool, CoreSurfacePool );
-
-     D_DEBUG_AT( Core_SurfPoolLock, "%s( %p [%d], %p )\n", __FUNCTION__, pool, pool->pool_id, allocation );
-
-     CORE_SURFACE_ALLOCATION_ASSERT( allocation );
-     D_ASSERT( data != NULL );
-     D_ASSERT( pitch >= 0 );
-     DFB_RECTANGLE_ASSERT_IF( rect );
-
-     D_ASSERT( pool == allocation->pool );
-
-     funcs = get_funcs( pool );
-     D_ASSERT( funcs != NULL );
-
-     if (!funcs->Read)
-          return DFB_UNSUPPORTED;
-
-     surface = allocation->surface;
-     D_MAGIC_ASSERT( surface, CoreSurface );
-
-     area.x = 0;
-     area.y = 0;
-     area.w = surface->config.size.w;
-     area.h = surface->config.size.h;
-
-     if (rect && !dfb_rectangle_intersect( &area, rect ))
-          return DFB_INVAREA;
-
-     ret = funcs->Read( pool, pool->data, get_local(pool), allocation, allocation->data, data, pitch, &area );
-     if (ret)
-          D_DERROR( ret, "Core/SurfacePool: Could not read from allocation!\n" );
-
-     return ret;
-}
-
-DFBResult
-dfb_surface_pool_write( CoreSurfacePool       *pool,
-                        CoreSurfaceAllocation *allocation,
-                        const void            *data,
-                        int                    pitch,
-                        const DFBRectangle    *rect )
-{
-     DFBResult               ret;
-     const SurfacePoolFuncs *funcs;
-     CoreSurface            *surface;
-     DFBRectangle            area;
-
-     D_MAGIC_ASSERT( pool, CoreSurfacePool );
-
-     D_DEBUG_AT( Core_SurfPoolLock, "%s( %p [%d], %p )\n", __FUNCTION__, pool, pool->pool_id, allocation );
-
-     CORE_SURFACE_ALLOCATION_ASSERT( allocation );
-     D_ASSERT( data != NULL );
-     D_ASSERT( pitch >= 0 );
-     DFB_RECTANGLE_ASSERT_IF( rect );
-
-     D_ASSERT( pool == allocation->pool );
-
-     funcs = get_funcs( pool );
-     D_ASSERT( funcs != NULL );
-
-     if (!funcs->Write)
-          return DFB_UNSUPPORTED;
-
-     surface = allocation->surface;
-     D_MAGIC_ASSERT( surface, CoreSurface );
-
-     area.x = 0;
-     area.y = 0;
-     area.w = surface->config.size.w;
-     area.h = surface->config.size.h;
-
-     if (rect && !dfb_rectangle_intersect( &area, rect ))
-          return DFB_INVAREA;
-
-     ret = funcs->Write( pool, pool->data, get_local(pool), allocation, allocation->data, data, pitch, &area );
-     if (ret)
-          D_DERROR( ret, "Core/SurfacePool: Could not write to allocation!\n" );
-
-     return ret;
-}
-
-DFBResult
 dfb_surface_pool_enumerate ( CoreSurfacePool          *pool,
                              CoreSurfaceAllocCallback  callback,
                              void                     *ctx )
@@ -1143,7 +1022,7 @@ remove_allocation( CoreSurfacePool       *pool,
 
      D_MAGIC_ASSERT( pool, CoreSurfacePool );
      D_MAGIC_ASSERT( buffer, CoreSurfaceBuffer );
-     CORE_SURFACE_ALLOCATION_ASSERT( allocation );
+     D_MAGIC_ASSERT( allocation, CoreSurfaceAllocation );
      D_MAGIC_ASSERT( buffer->surface, CoreSurface );
      FUSION_SKIRMISH_ASSERT( &buffer->surface->lock );
      FUSION_SKIRMISH_ASSERT( &pool->lock );
@@ -1167,7 +1046,8 @@ remove_allocation( CoreSurfacePool       *pool,
 
           /* Iterate through remaining allocations */
           fusion_vector_foreach (allocation, index_buffer, buffer->allocs) {
-               CORE_SURFACE_ALLOCATION_ASSERT( allocation );
+               D_MAGIC_ASSERT( allocation, CoreSurfaceAllocation );
+               D_ASSERT( allocation->pool == pool );
 
                /* Check if allocation is up to date and set it as 'written' allocation */
                if (direct_serial_check( &allocation->serial, &buffer->serial )) {
@@ -1176,10 +1056,6 @@ remove_allocation( CoreSurfacePool       *pool,
                }
           }
      }
-
-     /* Reset 'read' allocation pointer of buffer */
-     if (buffer->read == allocation)
-          buffer->read = NULL;
 }
 
 static DFBResult
@@ -1195,7 +1071,7 @@ backup_allocation( CoreSurfacePool       *pool,
 
      D_MAGIC_ASSERT( pool, CoreSurfacePool );
      D_MAGIC_ASSERT( buffer, CoreSurfaceBuffer );
-     CORE_SURFACE_ALLOCATION_ASSERT( allocation );
+     D_MAGIC_ASSERT( allocation, CoreSurfaceAllocation );
      D_MAGIC_ASSERT( buffer->surface, CoreSurface );
      FUSION_SKIRMISH_ASSERT( &buffer->surface->lock );
      FUSION_SKIRMISH_ASSERT( &pool->lock );
diff --git a/DirectFB-1.3.0/src/core/surface_pool.h b/DirectFB-1.3.0/src/core/surface_pool.h
index a9e6804..efc1c02 100644
--- a/DirectFB-1.3.0/src/core/surface_pool.h
+++ b/DirectFB-1.3.0/src/core/surface_pool.h
@@ -38,12 +38,9 @@
 
 
 typedef enum {
-     CSPCAPS_NONE        = 0x00000000,
+     CSPCAPS_NONE   = 0x00000000,
 
-     CSPCAPS_PHYSICAL    = 0x00000001,  /* pool provides physical address to buffer */
-     CSPCAPS_VIRTUAL     = 0x00000002,  /* pool provides virtual address to buffer */
-
-     CSPCAPS_ALL         = 0x00000003
+     CSPCAPS_ALL    = 0x00000000
 } CoreSurfacePoolCapabilities;
 
 typedef enum {
@@ -57,12 +54,12 @@ typedef enum {
  */
 #define DFB_SURFACE_POOL_ABI_VERSION           1
 
-#define DFB_SURFACE_POOL_DESC_NAME_LENGTH     44
+#define DFB_SURFACE_POOL_DESC_NAME_LENGTH     40
 
 
 typedef struct {
      CoreSurfacePoolCapabilities   caps;
-     CoreSurfaceAccessFlags        access[_CSAID_NUM];
+     CoreSurfaceAccessFlags        access;
      CoreSurfaceTypeFlags          types;
      CoreSurfacePoolPriority       priority;
      char                          name[DFB_SURFACE_POOL_DESC_NAME_LENGTH];
@@ -203,7 +200,6 @@ typedef DFBEnumerationResult (*CoreSurfaceAllocCallback)( CoreSurfaceAllocation
 
 
 DFBResult dfb_surface_pools_negotiate( CoreSurfaceBuffer       *buffer,
-                                       CoreSurfaceAccessorID    accessor,
                                        CoreSurfaceAccessFlags   access,
                                        CoreSurfacePool        **ret_pools,
                                        unsigned int             max_pools,
@@ -213,7 +209,6 @@ DFBResult dfb_surface_pools_enumerate( CoreSurfacePoolCallback  callback,
                                        void                    *ctx );
 
 DFBResult dfb_surface_pools_allocate ( CoreSurfaceBuffer       *buffer,
-                                       CoreSurfaceAccessorID    accessor,
                                        CoreSurfaceAccessFlags   access,
                                        CoreSurfaceAllocation  **ret_allocation );
 
@@ -251,18 +246,6 @@ DFBResult dfb_surface_pool_unlock    ( CoreSurfacePool         *pool,
                                        CoreSurfaceAllocation   *allocation,
                                        CoreSurfaceBufferLock   *lock );
 
-DFBResult dfb_surface_pool_read      ( CoreSurfacePool         *pool,
-                                       CoreSurfaceAllocation   *allocation,
-                                       void                    *data,
-                                       int                      pitch,
-                                       const DFBRectangle      *rect );
-
-DFBResult dfb_surface_pool_write     ( CoreSurfacePool         *pool,
-                                       CoreSurfaceAllocation   *allocation,
-                                       const void              *data,
-                                       int                      pitch,
-                                       const DFBRectangle      *rect );
-
 DFBResult dfb_surface_pool_enumerate ( CoreSurfacePool         *pool,
                                        CoreSurfaceAllocCallback  callback,
                                        void                    *ctx );
diff --git a/DirectFB-1.3.0/src/core/windows.c b/DirectFB-1.3.0/src/core/windows.c
index 6929d40..803e531 100644
--- a/DirectFB-1.3.0/src/core/windows.c
+++ b/DirectFB-1.3.0/src/core/windows.c
@@ -451,11 +451,8 @@ dfb_window_create( CoreWindowStack             *stack,
      /* Set toplevel window ID (new sub window feature) */
      window->toplevel_id = toplevel_id;
 
-     D_MAGIC_SET( window, CoreWindow );
-
      ret = dfb_wm_preconfigure_window( stack, window );
      if(ret) {
-          D_MAGIC_CLEAR( window );
           fusion_object_destroy( &window->object );
           dfb_windowstack_unlock( stack );
           return ret;
@@ -469,7 +466,6 @@ dfb_window_create( CoreWindowStack             *stack,
      if (caps & DWCAPS_SUBWINDOW) {
           ret = init_subwindow( window, stack, toplevel_id );
           if (ret) {
-               D_MAGIC_CLEAR( window );
                fusion_object_destroy( &window->object );
                dfb_windowstack_unlock( stack );
                return ret;
@@ -497,7 +493,6 @@ dfb_window_create( CoreWindowStack             *stack,
                ret = create_region( layer->core, context, window,
                                     pixelformat, surface_caps, &region, &surface );
                if (ret) {
-                    D_MAGIC_CLEAR( window );
                     fusion_object_destroy( &window->object );
                     dfb_windowstack_unlock( stack );
                     return ret;
@@ -517,7 +512,6 @@ dfb_window_create( CoreWindowStack             *stack,
                /* Get the primary region of the layer context. */
                ret = dfb_layer_context_get_primary_region( context, true, &region );
                if (ret) {
-                    D_MAGIC_CLEAR( window );
                     fusion_object_destroy( &window->object );
                     dfb_windowstack_unlock( stack );
                     return ret;
@@ -547,7 +541,6 @@ dfb_window_create( CoreWindowStack             *stack,
                                                      region->surface->palette : NULL, &surface );
                     if (ret) {
                          D_DERROR( ret, "Core/Windows: Failed to create window surface!\n" );
-                         D_MAGIC_CLEAR( window );
                          dfb_layer_region_unlink( &window->primary_region );
                          fusion_object_destroy( &window->object );
                          dfb_windowstack_unlock( stack );
@@ -571,8 +564,6 @@ dfb_window_create( CoreWindowStack             *stack,
      if (ret) {
           D_DERROR( ret, "Core/Windows: Failed to add window to manager!\n" );
 
-          D_MAGIC_CLEAR( window );
-
           if (window->surface)
                dfb_surface_unlink( &window->surface );
 
@@ -593,6 +584,8 @@ dfb_window_create( CoreWindowStack             *stack,
      /* Increase number of windows. */
      stack->num++;
 
+     D_MAGIC_SET( window, CoreWindow );
+
      /* Finally activate the object. */
      fusion_object_activate( &window->object );
 
@@ -1767,50 +1760,3 @@ core_window_filter( CoreWindow *window, const DFBWindowEvent *event )
      return false;
 }
 
-DFBResult
-dfb_window_set_rotation( CoreWindow *window,
-                         int         rotation )
-{
-     DFBResult        ret   = DFB_OK;
-     CoreWindowStack *stack = window->stack;
-
-     D_MAGIC_ASSERT( window, CoreWindow );
-
-     stack = window->stack;
-     D_MAGIC_ASSERT( stack, CoreWindowStack );
-     
-     /* Lock the window stack. */
-     if (dfb_windowstack_lock( stack ))
-          return DFB_FUSION;
-
-     /* Never call WM after destroying the window. */
-     if (DFB_WINDOW_DESTROYED( window )) {
-          dfb_windowstack_unlock( stack );
-          return DFB_DESTROYED;
-     }
-     
-     /* Do nothing if the rotation didn't change. */
-     if (window->config.rotation != rotation) {
-          CoreWindowConfig config;
-
-          switch (rotation) {
-               case 0:
-               case 90:
-               case 180:
-               case 270:
-                    config.rotation = rotation;
-
-                    dfb_wm_set_window_config( window, &config, CWCF_ROTATION );
-                    break;
-
-               default:
-                    ret = DFB_UNSUPPORTED;
-          }
-     }
-
-     /* Unlock the window stack. */
-     dfb_windowstack_unlock( stack );
-
-     return ret;
-}
-
diff --git a/DirectFB-1.3.0/src/core/windows.h b/DirectFB-1.3.0/src/core/windows.h
index 6914e1d..427dcb5 100644
--- a/DirectFB-1.3.0/src/core/windows.h
+++ b/DirectFB-1.3.0/src/core/windows.h
@@ -62,9 +62,7 @@ typedef enum {
      CWCF_SRC_GEOMETRY  = 0x00010000,
      CWCF_DST_GEOMETRY  = 0x00020000,
 
-     CWCF_ROTATION      = 0x00040000,
-
-     CWCF_ALL           = 0x0007133F
+     CWCF_ALL           = 0x0003133F
 } CoreWindowConfigFlags;
 
 struct __DFB_CoreWindowConfig {
@@ -82,8 +80,6 @@ struct __DFB_CoreWindowConfig {
 
      DFBWindowGeometry        src_geometry;   /* advanced source geometry */
      DFBWindowGeometry        dst_geometry;   /* advanced destination geometry */
-
-     int                      rotation;
 };
 
 
@@ -288,6 +284,4 @@ DFBWindowID dfb_window_id( const CoreWindow *window );
 
 CoreSurface *dfb_window_surface( const CoreWindow *window );
 
-DFBResult
-dfb_window_set_rotation( CoreWindow *window, int rotation );
 #endif
diff --git a/DirectFB-1.3.0/src/core/windows_internal.h b/DirectFB-1.3.0/src/core/windows_internal.h
index 2394a53..bf59c37 100644
--- a/DirectFB-1.3.0/src/core/windows_internal.h
+++ b/DirectFB-1.3.0/src/core/windows_internal.h
@@ -132,12 +132,6 @@ struct __DFB_CoreWindowStack {
      int                 width;
      int                 height;
 
-     int                 rotation;
-
-     int                      rotated_width;
-     int                      rotated_height;
-     DFBSurfaceBlittingFlags  rotated_blit;
-
      DFBWindowID         id_pool;
 
      int                 num;
diff --git a/DirectFB-1.3.0/src/core/windowstack.c b/DirectFB-1.3.0/src/core/windowstack.c
index bb8cc01..c069a2c 100644
--- a/DirectFB-1.3.0/src/core/windowstack.c
+++ b/DirectFB-1.3.0/src/core/windowstack.c
@@ -141,7 +141,7 @@ dfb_windowstack_create( CoreLayerContext *context )
      stack->cursor.policy = policy;
 
      /* Set default background mode. */
-     stack->bg.mode        = DLBM_DONTCARE;
+     stack->bg.mode        = DLBM_COLOR;
      stack->bg.color_index = -1;
 
      D_MAGIC_SET( stack, CoreWindowStack );
@@ -216,10 +216,9 @@ dfb_windowstack_destroy( CoreWindowStack *stack )
 void
 dfb_windowstack_resize( CoreWindowStack *stack,
                         int              width,
-                        int              height,
-                        int              rotation )
+                        int              height )
 {
-     D_DEBUG_AT( Core_WindowStack, "%s( %p, %dx%d, %d )\n", __FUNCTION__, stack, width, height, rotation );
+     D_DEBUG_AT( Core_WindowStack, "%s( %p, %dx%d )\n", __FUNCTION__, stack, width, height );
 
      D_MAGIC_ASSERT( stack, CoreWindowStack );
 
@@ -228,37 +227,8 @@ dfb_windowstack_resize( CoreWindowStack *stack,
           return;
 
      /* Store the width and height of the stack */
-     stack->width    = width;
-     stack->height   = height;
-     stack->rotation = rotation;
-
-     switch (stack->rotation) {
-          default:
-               D_BUG( "invalid rotation %d", stack->rotation );
-          case 0:
-               stack->rotated_blit   = DSBLIT_NOFX;
-               stack->rotated_width  = stack->width;
-               stack->rotated_height = stack->height;
-               break;
-
-          case 90:
-               stack->rotated_blit   = DSBLIT_ROTATE90;
-               stack->rotated_width  = stack->height;
-               stack->rotated_height = stack->width;
-               break;
-
-          case 180:
-               stack->rotated_blit   = DSBLIT_ROTATE180;
-               stack->rotated_width  = stack->width;
-               stack->rotated_height = stack->height;
-               break;
-
-          case 270:
-               stack->rotated_blit   = DSBLIT_ROTATE270;
-               stack->rotated_width  = stack->height;
-               stack->rotated_height = stack->width;
-               break;
-     }
+     stack->width  = width;
+     stack->height = height;
 
      /* Setup new cursor clipping region */
      stack->cursor.region.x1 = 0;
@@ -314,8 +284,8 @@ dfb_windowstack_repaint_all( CoreWindowStack *stack )
 
      region.x1 = 0;
      region.y1 = 0;
-     region.x2 = stack->rotated_width  - 1;
-     region.y2 = stack->rotated_height - 1;
+     region.x2 = stack->width  - 1;
+     region.y2 = stack->height - 1;
 
      ret = dfb_wm_update_stack( stack, &region, 0 );
 
@@ -819,7 +789,7 @@ load_default_cursor( CoreDFB *core, CoreWindowStack *stack )
      }
 
      /* lock the cursor surface */
-     ret = dfb_surface_lock_buffer( stack->cursor.surface, CSBR_BACK, CSAID_CPU, CSAF_WRITE, &lock );
+     ret = dfb_surface_lock_buffer( stack->cursor.surface, CSBR_BACK, CSAF_CPU_WRITE, &lock );
      if (ret) {
           D_ERROR( "Core/WindowStack: cannot lock the cursor surface!\n" );
           return ret;
diff --git a/DirectFB-1.3.0/src/core/windowstack.h b/DirectFB-1.3.0/src/core/windowstack.h
index f02aa17..4f41fe0 100644
--- a/DirectFB-1.3.0/src/core/windowstack.h
+++ b/DirectFB-1.3.0/src/core/windowstack.h
@@ -43,8 +43,7 @@ void             dfb_windowstack_destroy( CoreWindowStack  *stack );
 
 void             dfb_windowstack_resize ( CoreWindowStack  *stack,
                                           int               width,
-                                          int               height,
-                                          int               rotation );
+                                          int               height );
 
 DirectResult     dfb_windowstack_lock   ( CoreWindowStack  *stack );
 
diff --git a/DirectFB-1.3.0/src/core/wm.c b/DirectFB-1.3.0/src/core/wm.c
index 98776ff..5373104 100644
--- a/DirectFB-1.3.0/src/core/wm.c
+++ b/DirectFB-1.3.0/src/core/wm.c
@@ -421,33 +421,23 @@ dfb_wm_close_all_stacks( void *data )
 
      shared = local->shared;
 
-     D_MAGIC_ASSERT( shared, DFBWMCoreShared );
-
-     D_DEBUG_AT( Core_WM, "  -> checking %d stacks...\n", direct_list_count_elements_EXPENSIVE(shared->stacks) );
-
-     direct_list_foreach_safe (stack, next, shared->stacks) {
-          D_DEBUG_AT( Core_WM, "  -> checking %p...\n", stack );
+     D_MAGIC_ASSERT( local->shared, DFBWMCoreShared );
 
+     direct_list_foreach_safe (stack, next, wm_shared->stacks) {
           D_MAGIC_ASSERT( stack, CoreWindowStack );
 
           context = stack->context;
           D_MAGIC_ASSERT( context, CoreLayerContext );
 
-          D_DEBUG_AT( Core_WM, "  -> ref context %p...\n", context );
-
           dfb_layer_context_ref( context );
 
           dfb_layer_context_lock( context );
 
-          if (stack->flags & CWSF_INITIALIZED) {
-               D_DEBUG_AT( Core_WM, "  => CLOSING %p\n", stack );
+          if (stack->flags & CWSF_INITIALIZED)
                dfb_wm_close_stack( stack );
-          }
 
           dfb_layer_context_unlock( context );
 
-          D_DEBUG_AT( Core_WM, "  -> unref context %p...\n", context );
-
           dfb_layer_context_unref( context );
      }
 
@@ -526,8 +516,6 @@ dfb_wm_init_stack( CoreWindowStack *stack )
 {
      DFBResult ret;
 
-     D_DEBUG_AT( Core_WM, "%s( %p )\n", __FUNCTION__, stack );
-
      D_ASSERT( wm_local != NULL );
      D_ASSERT( wm_local->funcs != NULL );
      D_ASSERT( wm_local->funcs->InitStack != NULL );
@@ -573,8 +561,6 @@ dfb_wm_init_stack( CoreWindowStack *stack )
 DFBResult
 dfb_wm_close_stack( CoreWindowStack *stack )
 {
-     D_DEBUG_AT( Core_WM, "%s( %p )\n", __FUNCTION__, stack );
-
      D_ASSERT( wm_local != NULL );
      D_ASSERT( wm_local->funcs != NULL );
      D_ASSERT( wm_local->funcs->CloseStack != NULL );
@@ -614,8 +600,6 @@ dfb_wm_set_active( CoreWindowStack *stack,
 {
      DFBResult ret;
 
-     D_DEBUG_AT( Core_WM, "%s( %p, %sactive )\n", __FUNCTION__, stack, active ? "" : "in" );
-
      D_ASSERT( wm_local != NULL );
      D_ASSERT( wm_local->funcs != NULL );
      D_ASSERT( wm_local->funcs->SetActive != NULL );
@@ -655,8 +639,6 @@ dfb_wm_resize_stack( CoreWindowStack *stack,
                      int              width,
                      int              height )
 {
-     D_DEBUG_AT( Core_WM, "%s( %p, %dx%d )\n", __FUNCTION__, stack, width, height );
-
      D_ASSERT( wm_local != NULL );
      D_ASSERT( wm_local->funcs != NULL );
      D_ASSERT( wm_local->funcs->ResizeStack != NULL );
@@ -675,8 +657,6 @@ DFBResult
 dfb_wm_process_input( CoreWindowStack     *stack,
                       const DFBInputEvent *event )
 {
-     D_DEBUG_AT( Core_WM, "%s( %p, %p )\n", __FUNCTION__, stack, event );
-
      D_ASSERT( wm_local != NULL );
      D_ASSERT( wm_local->funcs != NULL );
      D_ASSERT( wm_local->funcs->ProcessInput != NULL );
@@ -696,8 +676,6 @@ dfb_wm_process_input( CoreWindowStack     *stack,
 DFBResult
 dfb_wm_flush_keys( CoreWindowStack *stack )
 {
-     D_DEBUG_AT( Core_WM, "%s( %p )\n", __FUNCTION__, stack );
-
      D_ASSERT( wm_local != NULL );
      D_ASSERT( wm_local->funcs != NULL );
      D_ASSERT( wm_local->funcs->FlushKeys != NULL );
@@ -717,8 +695,6 @@ dfb_wm_window_at( CoreWindowStack  *stack,
                   int               y,
                   CoreWindow      **ret_window )
 {
-     D_DEBUG_AT( Core_WM, "%s( %p, %d,%d )\n", __FUNCTION__, stack, x, y );
-
      D_ASSERT( wm_local != NULL );
      D_ASSERT( wm_local->funcs != NULL );
      D_ASSERT( wm_local->funcs->WindowAt != NULL );
@@ -739,8 +715,6 @@ dfb_wm_window_lookup( CoreWindowStack  *stack,
                       DFBWindowID       window_id,
                       CoreWindow      **ret_window )
 {
-     D_DEBUG_AT( Core_WM, "%s( %p, %u )\n", __FUNCTION__, stack, window_id );
-
      D_ASSERT( wm_local != NULL );
      D_ASSERT( wm_local->funcs != NULL );
      D_ASSERT( wm_local->funcs->WindowLookup != NULL );
@@ -762,8 +736,6 @@ dfb_wm_enum_windows( CoreWindowStack      *stack,
                      CoreWMWindowCallback  callback,
                      void                 *callback_ctx )
 {
-     D_DEBUG_AT( Core_WM, "%s( %p, %p, %p )\n", __FUNCTION__, stack, callback, callback_ctx );
-
      D_ASSERT( wm_local != NULL );
      D_ASSERT( wm_local->funcs != NULL );
      D_ASSERT( wm_local->funcs->EnumWindows != NULL );
@@ -825,9 +797,6 @@ dfb_wm_preconfigure_window( CoreWindowStack *stack,
      D_MAGIC_ASSERT( stack->context, CoreLayerContext );
      FUSION_SKIRMISH_ASSERT( &stack->context->lock );
 
-     D_DEBUG_AT( Core_WM, "%s( %p, %p [%d,%d-%dx%d] )\n", __FUNCTION__,
-                 stack, window, DFB_RECTANGLE_VALS(&window->config.bounds) );
-
      /* Allocate shared window data. */
      if (wm_shared->info.window_data_size) {
           window_data = SHCALLOC( wm_shared->shmpool, 1, wm_shared->info.window_data_size );
@@ -860,7 +829,6 @@ dfb_wm_add_window( CoreWindowStack *stack,
                    CoreWindow      *window )
 {
      DFBResult  ret;
-
      D_ASSERT( wm_local != NULL );
      D_ASSERT( wm_local->funcs != NULL );
      D_ASSERT( wm_local->funcs->AddWindow != NULL );
@@ -874,9 +842,6 @@ dfb_wm_add_window( CoreWindowStack *stack,
 
      D_ASSERT( window != NULL );
 
-     D_DEBUG_AT( Core_WM, "%s( %p, %p [%d,%d-%dx%d] )\n", __FUNCTION__,
-                 stack, window, DFB_RECTANGLE_VALS(&window->config.bounds) );
-
      /* Tell window manager about the new window. */
      ret = wm_local->funcs->AddWindow( stack, wm_local->data,
                                        stack->stack_data, window, window->window_data );
@@ -906,9 +871,6 @@ dfb_wm_remove_window( CoreWindowStack *stack,
 
      D_ASSERT( window != NULL );
 
-     D_DEBUG_AT( Core_WM, "%s( %p, %p [%d,%d-%dx%d] )\n", __FUNCTION__,
-                 stack, window, DFB_RECTANGLE_VALS(&window->config.bounds) );
-
      /* Remove window from window manager. */
      ret = wm_local->funcs->RemoveWindow( stack, wm_local->data,
                                           stack->stack_data, window, window->window_data );
@@ -943,9 +905,6 @@ dfb_wm_set_window_property( CoreWindowStack  *stack,
      D_ASSERT( window != NULL );
      D_ASSERT( key != NULL );
 
-     D_DEBUG_AT( Core_WM, "%s( %p, %p [%d,%d-%dx%d], '%s' = %p )\n", __FUNCTION__,
-                 stack, window, DFB_RECTANGLE_VALS(&window->config.bounds), key, value );
-
      return wm_local->funcs->SetWindowProperty( stack, wm_local->data, stack->stack_data,
                                                 window, window->window_data,
                                                 key, value, ret_old_value );
@@ -973,9 +932,6 @@ dfb_wm_get_window_property( CoreWindowStack  *stack,
      D_ASSERT( window != NULL );
      D_ASSERT( key != NULL );
 
-     D_DEBUG_AT( Core_WM, "%s( %p, %p [%d,%d-%dx%d], '%s' )\n", __FUNCTION__,
-                 stack, window, DFB_RECTANGLE_VALS(&window->config.bounds), key );
-
      return wm_local->funcs->GetWindowProperty( stack, wm_local->data, stack->stack_data,
                                                 window, window->window_data, key, ret_value );
 }
@@ -1002,9 +958,6 @@ dfb_wm_remove_window_property( CoreWindowStack  *stack,
      D_ASSERT( window != NULL );
      D_ASSERT( key != NULL );
 
-     D_DEBUG_AT( Core_WM, "%s( %p, %p [%d,%d-%dx%d], '%s' )\n", __FUNCTION__,
-                 stack, window, DFB_RECTANGLE_VALS(&window->config.bounds), key );
-
      return wm_local->funcs->RemoveWindowProperty( stack, wm_local->data, stack->stack_data,
                                                    window, window->window_data, key, ret_value );
 }
@@ -1025,9 +978,6 @@ dfb_wm_set_window_config( CoreWindow             *window,
      D_MAGIC_ASSERT( window->stack->context, CoreLayerContext );
      FUSION_SKIRMISH_ASSERT( &window->stack->context->lock );
 
-     D_DEBUG_AT( Core_WM, "%s( %p [%d,%d-%dx%d], %p, 0x%x )\n", __FUNCTION__,
-                 window, DFB_RECTANGLE_VALS(&window->config.bounds), config, flags );
-
      return wm_local->funcs->SetWindowConfig( window, wm_local->data,
                                               window->window_data, config, flags );
 }
@@ -1049,9 +999,6 @@ dfb_wm_restack_window( CoreWindow *window,
 
      D_ASSERT( relative == NULL || relative == window || relation != 0);
 
-     D_DEBUG_AT( Core_WM, "%s( %p [%d,%d-%dx%d], %p, %d )\n", __FUNCTION__,
-                 window, DFB_RECTANGLE_VALS(&window->config.bounds), relative, relation );
-
      return wm_local->funcs->RestackWindow( window, wm_local->data, window->window_data, relative,
                                             relative ? relative->window_data : NULL, relation );
 }
@@ -1072,9 +1019,6 @@ dfb_wm_grab( CoreWindow *window,
 
      D_ASSERT( grab != NULL );
 
-     D_DEBUG_AT( Core_WM, "%s( %p [%d,%d-%dx%d], %d )\n", __FUNCTION__,
-                 window, DFB_RECTANGLE_VALS(&window->config.bounds), grab->target );
-
      return wm_local->funcs->Grab( window, wm_local->data, window->window_data, grab );
 }
 
@@ -1094,9 +1038,6 @@ dfb_wm_ungrab( CoreWindow *window,
 
      D_ASSERT( grab != NULL );
 
-     D_DEBUG_AT( Core_WM, "%s( %p [%d,%d-%dx%d], %d )\n", __FUNCTION__,
-                 window, DFB_RECTANGLE_VALS(&window->config.bounds), grab->target );
-
      return wm_local->funcs->Ungrab( window, wm_local->data, window->window_data, grab );
 }
 
@@ -1113,9 +1054,6 @@ dfb_wm_request_focus( CoreWindow *window )
      D_MAGIC_ASSERT( window->stack->context, CoreLayerContext );
      FUSION_SKIRMISH_ASSERT( &window->stack->context->lock );
 
-     D_DEBUG_AT( Core_WM, "%s( %p [%d,%d-%dx%d] )\n", __FUNCTION__,
-                 window, DFB_RECTANGLE_VALS(&window->config.bounds) );
-
      return wm_local->funcs->RequestFocus( window, wm_local->data, window->window_data );
 }
 
@@ -1136,9 +1074,6 @@ dfb_wm_update_stack( CoreWindowStack     *stack,
 
      DFB_REGION_ASSERT( region );
 
-     D_DEBUG_AT( Core_WM, "%s( %p, [%d,%d-%dx%d], 0x%x )\n", __FUNCTION__,
-                 stack, DFB_RECTANGLE_VALS_FROM_REGION(region), flags );
-
      return wm_local->funcs->UpdateStack( stack, wm_local->data,
                                           stack->stack_data, region, flags );
 }
@@ -1160,10 +1095,6 @@ dfb_wm_update_window( CoreWindow          *window,
 
      DFB_REGION_ASSERT_IF( region );
 
-     D_DEBUG_AT( Core_WM, "%s( %p [%d,%d-%dx%d], [%d,%d-%dx%d], 0x%x )\n", __FUNCTION__,
-                 window, DFB_RECTANGLE_VALS(&window->config.bounds),
-                 DFB_RECTANGLE_VALS_FROM_REGION(region), flags );
-
      return wm_local->funcs->UpdateWindow( window, wm_local->data,
                                            window->window_data, region, flags );
 }
diff --git a/DirectFB-1.3.0/src/display/idirectfbdisplaylayer.c b/DirectFB-1.3.0/src/display/idirectfbdisplaylayer.c
index 2f9137b..1b62c10 100644
--- a/DirectFB-1.3.0/src/display/idirectfbdisplaylayer.c
+++ b/DirectFB-1.3.0/src/display/idirectfbdisplaylayer.c
@@ -891,32 +891,6 @@ IDirectFBDisplayLayer_SetRotation( IDirectFBDisplayLayer *thiz,
      return dfb_layer_context_set_rotation( data->context, rotation );
 }
 
-static DFBResult
-IDirectFBDisplayLayer_GetRotation( IDirectFBDisplayLayer *thiz,
-                                   int                   *ret_rotation )
-{
-     CoreLayerContext *context;
-
-     DIRECT_INTERFACE_GET_DATA(IDirectFBDisplayLayer)
-
-     if (!ret_rotation)
-          return DFB_INVARG;
-
-     context = data->context;
-     D_MAGIC_ASSERT( context, CoreLayerContext );
-
-     /* Lock the context. */
-     if (dfb_layer_context_lock( context ))
-          return DFB_FUSION;
-
-     *ret_rotation = context->rotation;
-
-     /* Unlock the context. */
-     dfb_layer_context_unlock( context );
-
-     return DFB_OK;
-}
-
 DFBResult
 IDirectFBDisplayLayer_Construct( IDirectFBDisplayLayer *thiz,
                                  CoreLayer             *layer,
@@ -991,7 +965,6 @@ IDirectFBDisplayLayer_Construct( IDirectFBDisplayLayer *thiz,
      thiz->SetScreenRectangle    = IDirectFBDisplayLayer_SetScreenRectangle;
      thiz->SwitchContext         = IDirectFBDisplayLayer_SwitchContext;
      thiz->SetRotation           = IDirectFBDisplayLayer_SetRotation;
-     thiz->GetRotation           = IDirectFBDisplayLayer_GetRotation;
 
      return DFB_OK;
 }
diff --git a/DirectFB-1.3.0/src/display/idirectfbsurface.c b/DirectFB-1.3.0/src/display/idirectfbsurface.c
index 565193c..33101d1 100644
--- a/DirectFB-1.3.0/src/display/idirectfbsurface.c
+++ b/DirectFB-1.3.0/src/display/idirectfbsurface.c
@@ -420,14 +420,14 @@ IDirectFBSurface_Lock( IDirectFBSurface *thiz,
           return DFB_INVAREA;
 
      if (flags & DSLF_READ)
-          access |= CSAF_READ;
+          access |= CSAF_CPU_READ;
 
      if (flags & DSLF_WRITE) {
-          access |= CSAF_WRITE;
+          access |= CSAF_CPU_WRITE;
           role = CSBR_BACK;
      }
 
-     ret = dfb_surface_lock_buffer( data->surface, role, CSAID_CPU, access, &data->lock );
+     ret = dfb_surface_lock_buffer( data->surface, role, access, &data->lock );
      if (ret)
           return ret;
 
@@ -1193,7 +1193,7 @@ IDirectFBSurface_DrawLine( IDirectFBSurface *thiz,
      if (data->locked)
           return DFB_LOCKED;
 
-     if ((x1 == x2 || y1 == y2) && !(data->state.render_options & DSRO_MATRIX)) {
+     if (x1 == x2 || y1 == y2) {
           DFBRectangle rect;
 
           if (x1 <= x2) {
diff --git a/DirectFB-1.3.0/src/gfx/convert.c b/DirectFB-1.3.0/src/gfx/convert.c
index 3b7b32d..b2c952e 100644
--- a/DirectFB-1.3.0/src/gfx/convert.c
+++ b/DirectFB-1.3.0/src/gfx/convert.c
@@ -29,7 +29,6 @@
 #include <config.h>
 
 #include <directfb.h>
-#include <directfb_util.h>
 
 #include "convert.h"
 
@@ -224,12 +223,97 @@ dfb_pixel_from_color( DFBSurfacePixelFormat  format,
 const char *
 dfb_pixelformat_name( DFBSurfacePixelFormat format )
 {
-     int i = 0;
+     switch (format) {
+          case DSPF_UNKNOWN:
+               return "UNKNOWN";
+
+          case DSPF_ARGB1555:
+               return "ARGB1555";
+
+          case DSPF_RGB555:
+               return "RGB555";
+
+          case DSPF_BGR555:
+               return "BGR555";
+
+          case DSPF_RGB16:
+               return "RGB16";
+
+          case DSPF_RGB18:
+               return "RGB18";
+
+          case DSPF_RGB24:
+               return "RGB24";
+
+          case DSPF_RGB32:
+               return "RGB32";
+
+          case DSPF_ARGB:
+               return "ARGB";
+
+          case DSPF_A8:
+               return "A8";
+
+          case DSPF_YUY2:
+               return "YUY2";
 
-     do {
-          if (format == dfb_pixelformat_names[i].format)
-               return dfb_pixelformat_names[i].name;
-     } while (dfb_pixelformat_names[i++].format != DSPF_UNKNOWN);
+          case DSPF_RGB332:
+               return "RGB332";
+
+          case DSPF_UYVY:
+               return "UYVY";
+
+          case DSPF_I420:
+               return "I420";
+
+          case DSPF_YV12:
+               return "YV12";
+
+          case DSPF_LUT8:
+               return "LUT8";
+
+          case DSPF_ALUT44:
+               return "ALUT44";
+
+          case DSPF_AiRGB:
+               return "AiRGB";
+
+          case DSPF_A1:
+               return "A1";
+
+          case DSPF_NV12:
+               return "NV12";
+
+          case DSPF_NV21:
+               return "NV21";
+
+          case DSPF_NV16:
+               return "NV16";
+
+          case DSPF_ARGB2554:
+               return "ARGB2554";
+
+          case DSPF_ARGB4444:
+               return "ARGB4444";
+
+          case DSPF_RGB444:
+               return "RGB444";
+
+          case DSPF_ARGB1666:
+               return "ARGB1666";
+
+          case DSPF_ARGB6666:
+               return "ARGB6666";
+
+          case DSPF_AYUV:
+               return "AYUV";
+
+          case DSPF_A4:
+               return "A4";
+
+          case DSPF_LUT2:
+               return "LUT2";
+     }
 
      return "<invalid>";
 }
@@ -267,13 +351,9 @@ dfb_convert_to_rgb16( DFBSurfacePixelFormat  format,
      
                     for (x=0; x<width; x++) {
                          int r, g, b;
-
-#ifdef WORDS_BIGENDIAN
-                         YCBCR_TO_RGB( src8[x], src16[x>>1] >> 8, src16[x>>1] & 0xff, r, g, b );
-#else
+     
                          YCBCR_TO_RGB( src8[x], src16[x>>1] & 0xff, src16[x>>1] >> 8, r, g, b );
-#endif
-
+     
                          dst[x] = PIXEL_RGB16( r, g, b );
                     }
 
@@ -394,11 +474,7 @@ dfb_convert_to_rgb555( DFBSurfacePixelFormat  format,
                     for (x=0; x<width; x++) {
                          int r, g, b;
      
-#ifdef WORDS_BIGENDIAN
-                         YCBCR_TO_RGB( src8[x], src16[x>>1] >> 8, src16[x>>1] & 0xff, r, g, b );
-#else
                          YCBCR_TO_RGB( src8[x], src16[x>>1] & 0xff, src16[x>>1] >> 8, r, g, b );
-#endif
      
                          dst[x] = PIXEL_RGB555( r, g, b );
                     }
@@ -536,11 +612,7 @@ dfb_convert_to_rgb32( DFBSurfacePixelFormat  format,
                     for (x=0; x<width; x++) {
                          int r, g, b;
      
-#ifdef WORDS_BIGENDIAN
-                         YCBCR_TO_RGB( src8[x], src16[x>>1] >> 8, src16[x>>1] & 0xff, r, g, b );
-#else
                          YCBCR_TO_RGB( src8[x], src16[x>>1] & 0xff, src16[x>>1] >> 8, r, g, b );
-#endif
      
                          dst[x] = PIXEL_RGB32( r, g, b );
                     }
@@ -676,11 +748,7 @@ dfb_convert_to_argb( DFBSurfacePixelFormat  format,
                     for (x=0; x<width; x++) {
                          int r, g, b;
 
-#ifdef WORDS_BIGENDIAN
-                         YCBCR_TO_RGB( src8[x], src16[x>>1] >> 8, src16[x>>1] & 0xff, r, g, b );
-#else
                          YCBCR_TO_RGB( src8[x], src16[x>>1] & 0xff, src16[x>>1] >> 8, r, g, b );
-#endif
 
                          dst[x] = PIXEL_ARGB( 0xff, r, g, b );
                     }
@@ -786,406 +854,6 @@ dfb_convert_to_argb( DFBSurfacePixelFormat  format,
 }
 
 void
-dfb_convert_to_rgb24( DFBSurfacePixelFormat  format,
-                      void                  *src,
-                      int                    spitch,
-                      int                    surface_height,
-                      u8                    *dst,
-                      int                    dpitch,
-                      int                    width,
-                      int                    height )
-{
-     int  n, n3;
-     u8  *src8;
-     u16 *src16;
-     u32 *src32;
-
-     switch (format) {
-          case DSPF_A8:
-               while (height--) {
-                    src8 = src;
-
-                    for (n=0, n3=0; n<width; n++, n3+=3) {
-                         dst[n3+0] = src8[n];
-                         dst[n3+1] = src8[n];
-                         dst[n3+2] = src8[n];
-                    }
-
-                    src += spitch;
-                    dst += dpitch;
-               }
-               break;
-          case DSPF_AiRGB:
-               while (height--) {
-                    src32 = src;
-
-                    for (n=0, n3=0; n<width; n++, n3+=3) {
-                         dst[n3+0] = (src32[n] & 0xFF0000) >> 16;
-                         dst[n3+1] = (src32[n] & 0x00FF00) >>  8;
-                         dst[n3+2] = (src32[n] & 0x0000FF);
-                    }
-
-                    src += spitch;
-                    dst += dpitch;
-               }
-               break;
-          case DSPF_ARGB:
-               while (height--) {
-                    src32 = src;
-
-                    for (n=0, n3=0; n<width; n++, n3+=3) {
-                         dst[n3+0] = (src32[n] & 0xFF0000) >> 16;
-                         dst[n3+1] = (src32[n] & 0x00FF00) >>  8;
-                         dst[n3+2] = (src32[n] & 0x0000FF);
-                    }
-
-                    src += spitch;
-                    dst += dpitch;
-               }
-               break;
-          case DSPF_ARGB1555:
-               while (height--) {
-                    src16 = src;
-
-                    for (n=0, n3=0; n<width; n++, n3+=3) {
-                         dst[n3+0] = (src16[n] & 0x7C00) >> 7;
-                         dst[n3+1] = (src16[n] & 0x03E0) >> 2;
-                         dst[n3+2] = (src16[n] & 0x001F) << 3;
-                    }
-
-                    src += spitch;
-                    dst += dpitch;
-               }
-               break;
-          case DSPF_RGB555:
-               while (height--) {
-                    src16 = src;
-
-                    for (n=0, n3=0; n<width; n++, n3+=3) {
-                         dst[n3+0] = (src16[n] & 0x7C00) >> 7;
-                         dst[n3+1] = (src16[n] & 0x03E0) >> 2;
-                         dst[n3+2] = (src16[n] & 0x001F) << 3;
-                    }
-
-                    src += spitch;
-                    dst += dpitch;
-               }
-               break;
-
-          case DSPF_BGR555:
-               while (height--) {
-                    src16 = src;
-
-                    for (n=0, n3=0; n<width; n++, n3+=3) {
-                         dst[n3+2] = (src16[n] & 0x7C00) >> 7;
-                         dst[n3+1] = (src16[n] & 0x03E0) >> 2;
-                         dst[n3+0] = (src16[n] & 0x001F) << 3;
-                    }
-
-                    src += spitch;
-                    dst += dpitch;
-               }
-               break;
-
-          case DSPF_ARGB2554:
-               while (height--) {
-                    src16 = src;
-
-                    for (n=0, n3=0; n<width; n++, n3+=3) {
-                         dst[n3+0] = (src16[n] & 0x3E00) >> 6;
-                         dst[n3+1] = (src16[n] & 0x01F0) >> 1;
-                         dst[n3+2] = (src16[n] & 0x000F) << 4;
-                    }
-
-                    src += spitch;
-                    dst += dpitch;
-               }
-               break;
-          case DSPF_ARGB4444:
-               while (height--) {
-                    src16 = src;
-
-                    for (n=0, n3=0; n<width; n++, n3+=3) {
-                         dst[n3+0] = (src16[n] & 0x0F00) >> 4;
-                         dst[n3+1] = (src16[n] & 0x00F0);
-                         dst[n3+2] = (src16[n] & 0x000F) << 4;
-                    }
-
-                    src += spitch;
-                    dst += dpitch;
-               }
-               break;
-          case DSPF_RGB444:
-               while (height--) {
-                    src16 = src;
-
-                    for (n=0, n3=0; n<width; n++, n3+=3) {
-                         dst[n3+0] = (src16[n] & 0x0F00) >> 4;
-                         dst[n3+1] = (src16[n] & 0x00F0);
-                         dst[n3+2] = (src16[n] & 0x000F) << 4;
-                    }
-
-                    src += spitch;
-                    dst += dpitch;
-               }
-               break;
-          case DSPF_RGB332:
-               while (height--) {
-                    src8 = src;
-
-                    for (n=0, n3=0; n<width; n++, n3+=3) {
-                         dst[n3+0] = lookup3to8[ (src8[n] >> 5)        ];
-                         dst[n3+1] = lookup3to8[ (src8[n] >> 2) & 0x07 ];
-                         dst[n3+2] = lookup2to8[ (src8[n]     ) & 0x03 ];
-                    }
-
-                    src += spitch;
-                    dst += dpitch;
-               }
-               break;
-          case DSPF_RGB16:
-               while (height--) {
-                    src16 = src;
-
-                    for (n=0, n3=0; n<width; n++, n3+=3) {
-                         dst[n3+0] = (src16[n] & 0xF800) >> 8;
-                         dst[n3+1] = (src16[n] & 0x07E0) >> 3;
-                         dst[n3+2] = (src16[n] & 0x001F) << 3;
-                    }
-
-                    src += spitch;
-                    dst += dpitch;
-               }
-               break;
-          case DSPF_RGB24:
-               while (height--) {
-                    src8 = src;
-
-                    for (n=0, n3=0; n<width; n++, n3+=3) {
-#ifdef WORDS_BIGENDIAN
-                         dst[n3+0] = src8[n3+0];
-                         dst[n3+1] = src8[n3+1];
-                         dst[n3+2] = src8[n3+2];
-#else
-                         dst[n3+0] = src8[n3+2];
-                         dst[n3+1] = src8[n3+1];
-                         dst[n3+2] = src8[n3+0];
-#endif
-                    }
-
-                    src += spitch;
-                    dst += dpitch;
-               }
-               break;
-          case DSPF_RGB32:
-               while (height--) {
-                    src32 = src;
-
-                    for (n=0, n3=0; n<width; n++, n3+=3) {
-                         dst[n3+0] = (src32[n] & 0xFF0000) >> 16;
-                         dst[n3+1] = (src32[n] & 0x00FF00) >>  8;
-                         dst[n3+2] = (src32[n] & 0x0000FF);
-                    }
-
-                    src += spitch;
-                    dst += dpitch;
-               }
-               break;
-          case DSPF_YUY2:
-               while (height--) {
-                    src32 = src;
-
-                    for (n=0, n3=0; n<width/2; n++, n3+=6) {
-                         register u32 y0, cb, y1, cr;
-                         y0 = (src32[n] & 0x000000FF);
-                         cb = (src32[n] & 0x0000FF00) >>  8;
-                         y1 = (src32[n] & 0x00FF0000) >> 16;
-                         cr = (src32[n] & 0xFF000000) >> 24;
-                         YCBCR_TO_RGB( y0, cb, cr,
-                                       dst[n3+0], dst[n3+1], dst[n3+2] );
-                         YCBCR_TO_RGB( y1, cb, cr,
-                                       dst[n3+3], dst[n3+4], dst[n3+5] );
-                    }
-
-                    src += spitch;
-                    dst += dpitch;
-               }
-               break;
-          case DSPF_UYVY:
-               while (height--) {
-                    src32 = src;
-
-                    for (n=0, n3=0; n<width/2; n++, n3+=6) {
-                         register u32 y0, cb, y1, cr;
-                         cb = (src32[n] & 0x000000FF);
-                         y0 = (src32[n] & 0x0000FF00) >>  8;
-                         cr = (src32[n] & 0x00FF0000) >> 16;
-                         y1 = (src32[n] & 0xFF000000) >> 24;
-                         YCBCR_TO_RGB( y0, cb, cr,
-                                       dst[n3+0], dst[n3+1], dst[n3+2] );
-                         YCBCR_TO_RGB( y1, cb, cr,
-                                       dst[n3+3], dst[n3+4], dst[n3+5] );
-                    }
-
-                    src += spitch;
-                    dst += dpitch;
-               }
-               break;
-          case DSPF_NV16: {
-               while (height--) {
-                    u16 *cbcr = (u16*)(src + surface_height * spitch);
-     
-                    src8 = src;
-
-                    for (n=0, n3=0; n<width/2; n++, n3+=6) {
-#ifdef WORDS_BIGENDIAN
-                         YCBCR_TO_RGB( src8[n*2+0], cbcr[n] >> 8, cbcr[n] & 0xff,
-                                       dst[n3+0], dst[n3+1], dst[n3+2] );
-     
-                         YCBCR_TO_RGB( src8[n*2+1], cbcr[n] >> 8, cbcr[n] & 0xff,
-                                       dst[n3+3], dst[n3+4], dst[n3+5] );
-#else
-                         YCBCR_TO_RGB( src8[n*2+0], cbcr[n] & 0xff, cbcr[n] >> 8,
-                                       dst[n3+0], dst[n3+1], dst[n3+2] );
-     
-                         YCBCR_TO_RGB( src8[n*2+1], cbcr[n] & 0xff, cbcr[n] >> 8,
-                                       dst[n3+3], dst[n3+4], dst[n3+5] );
-#endif
-                    }
-
-                    src += spitch;
-                    dst += dpitch;
-               }
-               break;
-          }
-          default:
-               D_ONCE( "unsupported format" );
-     }
-}
-
-void
-dfb_convert_to_a8( DFBSurfacePixelFormat  format,
-                   void                  *src,
-                   int                    spitch,
-                   int                    surface_height,
-                   u8                    *dst,
-                   int                    dpitch,
-                   int                    width,
-                   int                    height )
-{
-     int  n;
-     u8  *src8;
-     u16 *src16;
-     u32 *src32;
-
-     switch (format) {
-          case DSPF_A8:
-               while (height--) {
-                    src8 = src;
-
-                    direct_memcpy( dst, src8, width );
-
-                    src += spitch;
-                    dst += dpitch;
-               }
-               break;
-          case DSPF_AiRGB:
-               while (height--) {
-                    src32 = src;
-
-                    for (n=0; n<width; n++) {
-                         dst[n] = ~(src32[n] >> 24);
-                    }
-
-                    src += spitch;
-                    dst += dpitch;
-               }
-               break;
-          case DSPF_ARGB:
-               while (height--) {
-                    src32 = src;
-
-                    for (n=0; n<width; n++) {
-                         dst[n] = src32[n] >> 24;
-                    }
-
-                    src += spitch;
-                    dst += dpitch;
-               }
-               break;
-          case DSPF_ARGB1555:
-               while (height--) {
-                    src16 = src;
-
-                    for (n=0; n<width; n++) {
-                         dst[n] = (src16[n] & 0x8000) ? 0xff : 0x00;
-                    }
-
-                    src += spitch;
-                    dst += dpitch;
-               }
-               break;
-          case DSPF_ARGB2554:
-               while (height--) {
-                    src16 = src;
-
-                    for (n=0; n<width; n++) {
-                         switch (src16[n] >> 14) {
-                              case 0:
-                                   dst[n] = 0x00;
-                                   break;
-                              case 1:
-                                   dst[n] = 0x55;
-                                   break;
-                              case 2:
-                                   dst[n] = 0xAA;
-                                   break;
-                              case 3:
-                                   dst[n] = 0xFF;
-                                   break;
-                         }
-                    }
-
-                    src += spitch;
-                    dst += dpitch;
-               }
-               break;
-          case DSPF_ARGB4444:
-               while (height--) {
-                    src16 = src;
-
-                    for (n=0; n<width; n++) {
-                         dst[n]  = (src16[n] >> 12);
-                         dst[n] |= dst[n] << 4;
-                    }
-
-                    src += spitch;
-                    dst += dpitch;
-               }
-               break;
-
-          case DSPF_RGB332:
-          case DSPF_RGB444:
-          case DSPF_RGB555:
-          case DSPF_BGR555:
-          case DSPF_RGB16:
-          case DSPF_RGB24:
-          case DSPF_RGB32:
-          case DSPF_YUY2:
-          case DSPF_UYVY:
-          case DSPF_NV16:
-               while (height--) {
-                    memset( dst, 0xff, width );
-
-                    dst += dpitch;
-               }
-               break;
-          default:
-               D_ONCE( "unsupported format" );
-     }
-}
-
-void
 dfb_convert_to_a4( DFBSurfacePixelFormat  format,
                    void                  *src,
                    int                    spitch,
diff --git a/DirectFB-1.3.0/src/gfx/convert.h b/DirectFB-1.3.0/src/gfx/convert.h
index 568e8d3..d9e5300 100644
--- a/DirectFB-1.3.0/src/gfx/convert.h
+++ b/DirectFB-1.3.0/src/gfx/convert.h
@@ -286,34 +286,41 @@
 #define ARGB_TO_BGR555(pixel)  ( (((pixel) & 0x00F80000) >>  19) | \
                                    (((pixel) & 0x0000F800) >>  6) | \
                                    (((pixel) & 0x000000F8) <<  7) )
-
 /* RGB <-> YCbCr conversion */
 
-#define YCBCR_TO_RGB( y, cb, cr, r, g, b )                            \
-do {                                                                  \
-     int _y  = (y)  -  16;                                            \
-     int _cb = (cb) - 128;                                            \
-     int _cr = (cr) - 128;                                            \
-                                                                      \
-     int _r = (298 * _y             + 409 * _cr + 128) >> 8;          \
-     int _g = (298 * _y - 100 * _cb - 208 * _cr + 128) >> 8;          \
-     int _b = (298 * _y + 516 * _cb             + 128) >> 8;          \
-                                                                      \
-     (r) = CLAMP( _r, 0, 255 );                                       \
-     (g) = CLAMP( _g, 0, 255 );                                       \
-     (b) = CLAMP( _b, 0, 255 );                                       \
+extern const u16 y_for_rgb[256];
+extern const s16 cr_for_r[256];
+extern const s16 cr_for_g[256];
+extern const s16 cb_for_g[256];
+extern const s16 cb_for_b[256];
+
+#define YCBCR_TO_RGB( y, cb, cr, r, g, b ) do { \
+     u16 _y, _cb, _cr;\
+     s16 _r, _g, _b;\
+     _y  = y_for_rgb[(y)]; _cb = (cb); _cr = (cr);\
+     _r  = _y + cr_for_r[_cr]; \
+     _g  = _y + cr_for_g[_cr] + cb_for_g[_cb]; \
+     _b  = _y + cb_for_b[_cb]; \
+     (r) = CLAMP( _r, 0, 255 ); \
+     (g) = CLAMP( _g, 0, 255 ); \
+     (b) = CLAMP( _b, 0, 255 ); \
 } while (0)
 
-#define RGB_TO_YCBCR( r, g, b, y, cb, cr )                            \
-do {                                                                  \
-     int _r = (r), _g = (g), _b = (b);                                \
-                                                                      \
-     (y)  = (   66 * _r + 129 * _g +  25 * _b  +  16*256 + 128) >> 8; \
-     (cb) = ( - 38 * _r -  74 * _g + 112 * _b  + 128*256 + 128) >> 8; \
-     (cr) = (  112 * _r -  94 * _g -  18 * _b  + 128*256 + 128) >> 8; \
+extern const u16 y_from_ey[256];
+extern const u16 cb_from_bey[512];
+extern const u16 cr_from_rey[512];
+
+#define RGB_TO_YCBCR( r, g, b, y, cb, cr ) do { \
+     u32 _ey, _r, _g, _b;\
+     _r = (r); _g = (g); _b = (b);\
+     _ey = (19595 * _r + 38469 * _g + 7471 * _b) >> 16;\
+     (y)  = y_from_ey[_ey]; \
+     (cb) = cb_from_bey[_b-_ey+255]; \
+     (cr) = cr_from_rey[_r-_ey+255]; \
 } while (0)
 
 
+
 DFBSurfacePixelFormat dfb_pixelformat_for_depth( int depth );
 
 
@@ -343,9 +350,14 @@ dfb_color_to_argb( const DFBColor *color )
 static inline u32
 dfb_color_to_aycbcr( const DFBColor *color )
 {
-     u32 y  = (   66 * color->r + 129 * color->g +  25 * color->b  +  16*256 + 128) >> 8;
-     u32 cb = ( - 38 * color->r -  74 * color->g + 112 * color->b  + 128*256 + 128) >> 8;
-     u32 cr = (  112 * color->r -  94 * color->g -  18 * color->b  + 128*256 + 128) >> 8;
+     unsigned int red   = color->r;
+     unsigned int green = color->g;
+     unsigned int blue  = color->b;
+
+     u8 y  = (u8)(((66 * red + 129 * green + 25 * blue) / 256) + 16);
+
+     u8 cb = (u8)((128 * 256 -  38 * red   - 74 * green + 112 * blue) / 256);
+     u8 cr = (u8)((128 * 256 + 112 * red   - 94 * green -  18 * blue) / 256);
 
      return (color->a << 24) | (y << 16) | (cb << 8) | cr;
 }
@@ -455,24 +467,6 @@ void dfb_convert_to_rgb32( DFBSurfacePixelFormat  format,
                            int                    width,
                            int                    height );
 
-void dfb_convert_to_rgb24( DFBSurfacePixelFormat  format,
-                           void                  *src,
-                           int                    spitch,
-                           int                    surface_height,
-                           u8                    *dst,
-                           int                    dpitch,
-                           int                    width,
-                           int                    height );
-
-void dfb_convert_to_a8( DFBSurfacePixelFormat  format,
-                        void                  *src,
-                        int                    spitch,
-                        int                    surface_height,
-                        u8                    *dst,
-                        int                    dpitch,
-                        int                    width,
-                        int                    height );
-
 void dfb_convert_to_a4( DFBSurfacePixelFormat  format,
                         void                  *src,
                         int                    spitch,
diff --git a/DirectFB-1.3.0/src/gfx/generic/generic.c b/DirectFB-1.3.0/src/gfx/generic/generic.c
index 28269d4..d625158 100644
--- a/DirectFB-1.3.0/src/gfx/generic/generic.c
+++ b/DirectFB-1.3.0/src/gfx/generic/generic.c
@@ -61,6 +61,7 @@
 
 #include "generic.h"
 #include "duffs_device.h"
+#include "yuvtbl.h"
 
 
 /* lookup tables for 2/3bit to 8bit color conversion */
@@ -683,149 +684,6 @@ static GenefxFunc Bop_PFI_to_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      Bop_16_to_Aop,      /* DSPF_BGR555 */
 };
 
-/********************************* Bop_PFI_toR_Aop_PFI *************************/
-
-static void Bop_4_toR_Aop( GenefxState *gfxs )
-{
-     int w = gfxs->length>>1;
-     int Dstep = gfxs->Astep;
-     u8 * S = gfxs->Bop[0];
-     u8 * D = gfxs->Aop[0];
-     while(w--)
-     {
-          *D = *S;
-          D += Dstep;
-          S++;
-     }
-}
-
-static void Bop_8_toR_Aop( GenefxState *gfxs )
-{
-     int w = gfxs->length;
-     int Dstep = gfxs->Astep;
-     u8 * S = gfxs->Bop[0];
-     u8 * D = gfxs->Aop[0];
-     while(w--)
-     {
-          *D = *S;
-          D += Dstep;
-          S++;
-     }
-}
-
-static void Bop_16_toR_Aop( GenefxState *gfxs )
-{
-     int w = gfxs->length;
-     int Dstep = gfxs->Astep;
-     u16 * S = gfxs->Bop[0];
-     u16 * D = gfxs->Aop[0];
-     while(w--)
-     {
-          *D = *S;
-          D += Dstep;
-          S++;
-     }
-}
-
-static void Bop_24_toR_Aop( GenefxState *gfxs )
-{
-     int w = gfxs->length;
-     int Dstep = gfxs->Astep;
-     u8 * S = gfxs->Bop[0];
-     u8 * D = gfxs->Aop[0];
-     while(w--)
-     {
-          D[0] = S[0];
-          D[1] = S[1];
-          D[2] = S[2];
-
-          D += Dstep * 3;
-          S += 3;
-     }
-}
-
-static void Bop_32_toR_Aop( GenefxState *gfxs )
-{
-     int w = gfxs->length;
-     int Dstep = gfxs->Astep;
-     u32 * S = gfxs->Bop[0];
-     u32 * D = gfxs->Aop[0];
-     while(w--)
-     {
-          *D = *S;
-          D += Dstep;
-          S++;
-     }
-}
-
-static void Bop_i420_toR_Aop( GenefxState *gfxs )
-{
-     Bop_8_toR_Aop( gfxs );
-     if (gfxs->AopY & 1) {
-          int w = gfxs->length>>1;
-          int Dstep = gfxs->Astep>>1;
-          u8 * S1 = gfxs->Bop[1];
-          u8 * D1 = gfxs->Aop[1];
-          u8 * S2 = gfxs->Bop[2];
-          u8 * D2 = gfxs->Aop[2];
-          while(w--)
-          {
-               *D1 = *S1++;
-               *D2 = *S2++;
-               D1 += Dstep;
-               D2 += Dstep;
-          }
-     }
-}             
-
-static void Bop_NV_toR_Aop( GenefxState *gfxs )
-{
-     Bop_8_toR_Aop( gfxs );
-     if (gfxs->dst_format == DSPF_NV16 || gfxs->AopY & 1) {
-          int w = gfxs->length&~1;
-          int Dstep = gfxs->Astep;
-          u8 * S = gfxs->Bop[1];
-          u8 * D = gfxs->Aop[1];
-          while(w--)
-          {
-               *D = *S++;
-               D += Dstep;
-          }
-     }
-}
-
-static GenefxFunc Bop_PFI_toR_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
-     Bop_16_toR_Aop,      /* DSPF_ARGB1555 */
-     Bop_16_toR_Aop,      /* DSPF_RGB16 */
-     Bop_24_toR_Aop,      /* DSPF_RGB24 */
-     Bop_32_toR_Aop,      /* DSPF_RGB32 */
-     Bop_32_toR_Aop,      /* DSPF_ARGB */
-     Bop_8_toR_Aop,       /* DSPF_A8 */
-     Bop_16_toR_Aop,      /* DSPF_YUY2 */
-     Bop_8_toR_Aop,       /* DSPF_RGB332 */
-     Bop_16_toR_Aop,      /* DSPF_UYVY */
-     Bop_i420_toR_Aop,    /* DSPF_I420 */
-     Bop_i420_toR_Aop,    /* DSPF_YV12 */
-     Bop_8_toR_Aop,       /* DSPF_LUT8 */
-     Bop_8_toR_Aop,       /* DSPF_ALUT44 */
-     Bop_32_toR_Aop,      /* DSPF_AiRGB */
-     NULL,               /* DSPF_A1 */
-     Bop_NV_toR_Aop,      /* DSPF_NV12 */
-     Bop_NV_toR_Aop,      /* DSPF_NV16 */
-     Bop_16_toR_Aop,      /* DSPF_ARGB2554 */
-     Bop_16_toR_Aop,      /* DSPF_ARGB4444 */
-     Bop_NV_toR_Aop,      /* DSPF_NV21 */
-     Bop_32_toR_Aop,      /* DSPF_AYUV */
-     Bop_4_toR_Aop,       /* DSPF_A4 */
-     Bop_24_toR_Aop,      /* DSPF_ARGB1666 */
-     Bop_24_toR_Aop,      /* DSPF_ARGB6666 */
-     Bop_24_toR_Aop,      /* DSPF_RGB18 */
-     NULL,               /* DSPF_LUT2 */
-     Bop_16_toR_Aop,      /* DSPF_RGB444 */
-     Bop_16_toR_Aop,      /* DSPF_RGB555 */
-     Bop_16_toR_Aop,      /* DSPF_BGR555 */
-};
-
 /********************************* Bop_PFI_Kto_Aop_PFI ************************/
 
 static void Bop_rgb18_Kto_Aop( GenefxState *gfxs )
@@ -1450,10 +1308,8 @@ static GenefxFunc Bop_PFI_Sto_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      Bop_24_Sto_Aop,          /* DSPF_ARGB1666 */
      Bop_24_Sto_Aop,          /* DSPF_ARGB6666 */
      Bop_24_Sto_Aop,          /* DSPF_RGB18 */
-     NULL,                    /* DSPF_LUT2 */
      Bop_16_Sto_Aop,          /* DSPF_ARGB4444 */
      Bop_16_Sto_Aop,          /* DSPF_ARGB1555 */
-     Bop_16_Sto_Aop,          /* DSPF_ARGB1555 */
 };
 
 /********************************* Bop_PFI_SKto_Aop_PFI ***********************/
@@ -3718,20 +3574,6 @@ static void Sacc_to_Aop_nv12( GenefxState *gfxs )
                     if (cr & 0xFF00)
                          cr = 0xFF;
                          
-#ifdef WORDS_BIGENDIAN
-                    *Duv = cr | (cb << 8);
-               }
-               else if (!(S[0].YUV.a & 0xF000)) {
-                    cb = ((*Duv >> 8)   + ((S[0].YUV.u & 0xFF00) ? 0xFF : S[0].YUV.u)) >> 1;
-                    cr = ((*Duv & 0xFF) + ((S[0].YUV.v & 0xFF00) ? 0xFF : S[0].YUV.v)) >> 1;
-                    *Duv = cr | (cb << 8);
-               }
-               else if (!(S[1].YUV.a & 0xF000)) {
-                    cb = ((*Duv >> 8)   + ((S[1].YUV.u & 0xFF00) ? 0xFF : S[1].YUV.u)) >> 1;
-                    cr = ((*Duv & 0xFF) + ((S[1].YUV.v & 0xFF00) ? 0xFF : S[1].YUV.v)) >> 1;
-                    *Duv = cr | (cb << 8);
-               }
-#else
                     *Duv = cb | (cr << 8);
                }
                else if (!(S[0].YUV.a & 0xF000)) {
@@ -3744,7 +3586,6 @@ static void Sacc_to_Aop_nv12( GenefxState *gfxs )
                     cr = ((*Duv >> 8)   + ((S[1].YUV.v & 0xFF00) ? 0xFF : S[1].YUV.v)) >> 1;
                     *Duv = cb | (cr << 8);
                }
-#endif
                
                S += 2;
                Duv++;
@@ -4305,20 +4146,6 @@ static void Sacc_Sto_Aop_nv12( GenefxState *gfxs )
                     if (cr & 0xFF00)
                          cr = 0xFF;
                          
-#ifdef WORDS_BIGENDIAN
-                    *Duv = cr | (cb << 8);
-               }
-               else if (!(S0->YUV.a & 0xF000)) {
-                    cb = ((*Duv >> 8)   + ((S0->YUV.u & 0xFF00) ? 0xFF : S0->YUV.u)) >> 1;
-                    cr = ((*Duv & 0xFF) + ((S0->YUV.v & 0xFF00) ? 0xFF : S0->YUV.v)) >> 1;
-                    *Duv = cr | (cb << 8);
-               }
-               else if (!(S1->YUV.a & 0xF000)) {
-                    cb = ((*Duv >> 8)   + ((S1->YUV.u & 0xFF00) ? 0xFF : S1->YUV.u)) >> 1;
-                    cr = ((*Duv & 0xFF) + ((S1->YUV.v & 0xFF00) ? 0xFF : S1->YUV.v)) >> 1;
-                    *Duv = cr | (cb << 8);
-               }
-#else
                     *Duv = cb | (cr << 8);
                }
                else if (!(S0->YUV.a & 0xF000)) {
@@ -4331,7 +4158,6 @@ static void Sacc_Sto_Aop_nv12( GenefxState *gfxs )
                     cr = ((*Duv >> 8)   + ((S1->YUV.v & 0xFF00) ? 0xFF : S1->YUV.v)) >> 1;
                     *Duv = cb | (cr << 8);
                }
-#endif
                
                Duv++;
 
@@ -4378,20 +4204,6 @@ static void Sacc_Sto_Aop_nv21( GenefxState *gfxs )
                     if (cr & 0xFF00)
                          cr = 0xFF;
                          
-#ifdef WORDS_BIGENDIAN
-                    *Dvu = cb | (cr << 8);
-               }
-               else if (!(S0->YUV.a & 0xF000)) {
-                    cb = ((*Dvu & 0xFF) + ((S0->YUV.u & 0xFF00) ? 0xFF : S0->YUV.u)) >> 1;
-                    cr = ((*Dvu >> 8)   + ((S0->YUV.v & 0xFF00) ? 0xFF : S0->YUV.v)) >> 1;
-                    *Dvu = cb | (cr << 8);
-               }
-               else if (!(S1->YUV.a & 0xF000)) {
-                    cb = ((*Dvu & 0xFF) + ((S1->YUV.u & 0xFF00) ? 0xFF : S1->YUV.u)) >> 1;
-                    cr = ((*Dvu >> 8)   + ((S1->YUV.v & 0xFF00) ? 0xFF : S1->YUV.v)) >> 1;
-                    *Dvu = cb | (cr << 8);
-               }
-#else
                     *Dvu = cr | (cb << 8);
                }
                else if (!(S0->YUV.a & 0xF000)) {
@@ -4404,7 +4216,6 @@ static void Sacc_Sto_Aop_nv21( GenefxState *gfxs )
                     cr = ((*Dvu & 0xFF) + ((S1->YUV.v & 0xFF00) ? 0xFF : S1->YUV.v)) >> 1;
                     *Dvu = cr | (cb << 8);
                }
-#endif
                
                Dvu++;
 
@@ -5353,10 +5164,8 @@ static GenefxFunc Bop_a8_set_alphapixel_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      Bop_a8_set_alphapixel_Aop_argb1666,          /* DSPF_ARGB1666 */
      Bop_a8_set_alphapixel_Aop_argb6666,          /* DSPF_ARGB6666 */
      Bop_a8_set_alphapixel_Aop_rgb18,             /* DSPF_RGB18 */
-     NULL,                                        /* DSPF_LUT2 */
      NULL,                                        /* DSPF_ARGB4444 */
      NULL,                                        /* DSPF_ARGB1555 */
-     NULL,                                        /* DSPF_ARGB1555 */
 };
 
 /************** Bop_a1_set_alphapixel_Aop_PFI *********************************/
@@ -6246,59 +6055,68 @@ static void Sacc_add_to_Dacc_C( GenefxState *gfxs )
 
 static GenefxFunc Sacc_add_to_Dacc = Sacc_add_to_Dacc_C;
 
-/**********************************************************************************************************************/
-
-/* change the last value to adjust the size of the device (1-4) */
-#define SET_PIXEL_DUFFS_DEVICE( D, S, w ) \
-     SET_PIXEL_DUFFS_DEVICE_N( D, S, w, 3 )
-
-#define SET_PIXEL( D, S )                              \
-     if (!(S.RGB.a & 0xF000)) {                        \
-          RGB_TO_YCBCR( S.RGB.r, S.RGB.g, S.RGB.b,     \
-                        D.YUV.y, D.YUV.u, D.YUV.v );   \
-     }
 
 static void Dacc_RGB_to_YCbCr_C( GenefxState *gfxs )
 {
-     int                w = gfxs->length;
+     int                w = gfxs->length>>1;
      GenefxAccumulator *D = gfxs->Dacc;
-     GenefxAccumulator *S = gfxs->Dacc;
 
-     SET_PIXEL_DUFFS_DEVICE( D, S, w );
-}
+     while (w--) {
+          /* Actually DirectFB only supports 4:2:X formats */
+          if (!(D[0].RGB.a & 0xF000) && !(D[1].RGB.a & 0xF000)) {
+               u32 r0, g0, b0;
+               u32 r1, g1, b1;
+               u32 ey0, ey1;
 
-#undef SET_PIXEL_DUFFS_DEVICE
-#undef SET_PIXEL
+               r0 = D[0].RGB.r; g0 = D[0].RGB.g; b0 = D[0].RGB.b;
+               r1 = D[1].RGB.r; g1 = D[1].RGB.g; b1 = D[1].RGB.b;
+               ey0 = (19595 * r0 + 38469 * g0 + 7471 * b0) >> 16;
+               ey1 = (19595 * r1 + 38469 * g1 + 7471 * b1) >> 16;
 
-static GenefxFunc Dacc_RGB_to_YCbCr = Dacc_RGB_to_YCbCr_C;
+               D[0].YUV.y = y_from_ey[ey0];
+               D[1].YUV.y = y_from_ey[ey1];
+               D[0].YUV.u = D[1].YUV.u = cb_from_bey[(b0-ey0+b1-ey1)>>1];
+               D[0].YUV.v = D[1].YUV.v = cr_from_rey[(r0-ey0+r1-ey1)>>1];
+          }
+          else if (!(D[0].RGB.a & 0xF000)) {
+               u32 r, g, b, ey;
 
-/**********************************************************************************************************************/
+               r = D[0].RGB.r; g = D[0].RGB.g; b = D[0].RGB.b;
+               ey = (19595 * r + 38469 * g + 7471 * b) >> 16;
 
-/* change the last value to adjust the size of the device (1-4) */
-#define SET_PIXEL_DUFFS_DEVICE( D, S, w ) \
-     SET_PIXEL_DUFFS_DEVICE_N( D, S, w, 2 )
+               D[0].YUV.y = y_from_ey[ey];
+               D[0].YUV.u = cb_from_bey[b-ey];
+               D[0].YUV.v = cr_from_rey[r-ey];
+          }
+          else if (!(D[1].RGB.a & 0xF000)) {
+               u32 r, g, b, ey;
 
-#define SET_PIXEL( D, S )                              \
-     if (!(S.YUV.a & 0xF000)) {                        \
-          YCBCR_TO_RGB( S.YUV.y, S.YUV.u, S.YUV.v,     \
-                        D.RGB.r, D.RGB.g, D.RGB.b );   \
-     }
+               r = D[1].RGB.r; g = D[1].RGB.g; b = D[1].RGB.b;
+               ey = (19595 * r + 38469 * g + 7471 * b) >> 16;
 
-static void Dacc_YCbCr_to_RGB_C( GenefxState *gfxs )
-{
-     int                w = gfxs->length;
-     GenefxAccumulator *D = gfxs->Dacc;
-     GenefxAccumulator *S = gfxs->Dacc;
+               D[1].YUV.y = y_from_ey[ey];
+               D[1].YUV.u = cb_from_bey[b-ey];
+               D[1].YUV.v = cr_from_rey[r-ey];
+          }
 
-     SET_PIXEL_DUFFS_DEVICE( D, S, w );
-}
+          D += 2;
+     }
 
-#undef SET_PIXEL_DUFFS_DEVICE
-#undef SET_PIXEL
+     if (gfxs->length & 1) {
+          if (!(D->RGB.a & 0xF000)) {
+               u32 r, g, b, ey;
 
-static GenefxFunc Dacc_YCbCr_to_RGB = Dacc_YCbCr_to_RGB_C;
+               r = D->RGB.r; g = D->RGB.g; b = D->RGB.b;
+               ey = (19595 * r + 38469 * g + 7471 * b) >> 16;
 
-/**********************************************************************************************************************/
+               D->YUV.y = y_from_ey[ey];
+               D->YUV.u = cb_from_bey[b-ey];
+               D->YUV.v = cr_from_rey[r-ey];
+          }
+     }
+}
+
+static GenefxFunc Dacc_RGB_to_YCbCr = Dacc_RGB_to_YCbCr_C;
 
 /* change the last value to adjust the size of the device (1-4) */
 #define SET_PIXEL_DUFFS_DEVICE( D, S, w ) \
@@ -6334,7 +6152,6 @@ static void Bop_argb_blend_alphachannel_src_invsrc_Aop_rgb16( GenefxState *gfxs
 static void Bop_argb_blend_alphachannel_src_invsrc_Aop_rgb32( GenefxState *gfxs )
 {
      int  w = gfxs->length;
-     int Dstep = gfxs->Astep;
      u32 *S = gfxs->Bop[0];
      u32 *D = gfxs->Aop[0];
 
@@ -6346,9 +6163,8 @@ static void Bop_argb_blend_alphachannel_src_invsrc_Aop_rgb32( GenefxState *gfxs
 #define rb (sp32 & 0xff00ff)
 #define g  (sp32 & 0x00ff00)
 
-          *D = ((((rb-(dp32 & 0xff00ff))*salpha+((dp32 & 0xff00ff)<<7)) & 0x7f807f80) +
+          *D++ = ((((rb-(dp32 & 0xff00ff))*salpha+((dp32 & 0xff00ff)<<7)) & 0x7f807f80) +
                   ((( g-(dp32 & 0x00ff00))*salpha+((dp32 & 0x00ff00)<<7)) & 0x007f8000)) >> 7;
-          D += Dstep;
 
 #undef rb
 #undef g
@@ -6387,68 +6203,6 @@ static GenefxFunc Bop_argb_blend_alphachannel_src_invsrc_Aop_PFI[DFB_NUM_PIXELFO
      NULL,                                             /* DSPF_BGR555 */
 };
 
-/**********************************************************************************************************************/
-
-/* change the last value to adjust the size of the device (1-4) */
-#define SET_PIXEL_DUFFS_DEVICE( D, S, w ) \
-     SET_PIXEL_DUFFS_DEVICE_N( D, S, w, 3 )
-
-#define SET_PIXEL( D, S )                                   \
-do {                                                        \
-     int invsrc = 256 - (S >> 24);                          \
-                                                            \
-     u32 Drb = ((D & 0x00ff00ff) * invsrc) >> 8;            \
-     u32 Dag = ((D & 0xff00ff00) >> 8) * invsrc;            \
-                                                            \
-     D = S + (Drb & 0x00ff00ff) + (Dag & 0xff00ff00);       \
-} while (0)
-
-static void Bop_argb_blend_alphachannel_one_invsrc_Aop_argb( GenefxState *gfxs )
-{
-     int  w = gfxs->length;
-     u32 *S = gfxs->Bop[0];
-     u32 *D = gfxs->Aop[0];
-
-     SET_PIXEL_DUFFS_DEVICE( D, S, w );
-}
-
-#undef SET_PIXEL_DUFFS_DEVICE
-#undef SET_PIXEL
-
-static GenefxFunc Bop_argb_blend_alphachannel_one_invsrc_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
-     NULL,                                             /* DSPF_ARGB1555 */
-     NULL,                                             /* DSPF_RGB16 */
-     NULL,                                             /* DSPF_RGB24 */
-     Bop_argb_blend_alphachannel_one_invsrc_Aop_argb,  /* DSPF_RGB32 */
-     Bop_argb_blend_alphachannel_one_invsrc_Aop_argb,  /* DSPF_ARGB */
-     NULL,                                             /* DSPF_A8 */
-     NULL,                                             /* DSPF_YUY2 */
-     NULL,                                             /* DSPF_RGB332 */
-     NULL,                                             /* DSPF_UYVY */
-     NULL,                                             /* DSPF_I420 */
-     NULL,                                             /* DSPF_YV12 */
-     NULL,                                             /* DSPF_LUT8 */
-     NULL,                                             /* DSPF_ALUT44 */
-     NULL,                                             /* DSPF_AiRGB */
-     NULL,                                             /* DSPF_A1 */
-     NULL,                                             /* DSPF_NV12 */
-     NULL,                                             /* DSPF_NV16 */
-     NULL,                                             /* DSPF_ARGB2554 */
-     NULL,                                             /* DSPF_ARGB4444 */
-     NULL,                                             /* DSPF_NV21 */
-     NULL,                                             /* DSPF_AYUV */
-     NULL,                                             /* DSPF_A4 */
-     NULL,                                             /* DSPF_ARGB1666 */
-     NULL,                                             /* DSPF_ARGB6666 */
-     NULL,                                             /* DSPF_RGB18 */
-     NULL,                                             /* DSPF_LUT2 */
-     NULL,                                             /* DSPF_RGB444 */
-     NULL,                                             /* DSPF_RGB555 */
-     NULL,                                             /* DSPF_BGR555 */
-};
-
-/**********************************************************************************************************************/
-
 /* A8/A1 to YCbCr */
 static void Dacc_Alpha_to_YCbCr( GenefxState *gfxs )
 {
@@ -6466,10 +6220,93 @@ static void Dacc_Alpha_to_YCbCr( GenefxState *gfxs )
      }
 }
 
-/**********************************************************************************************************************/
+static void Dacc_YCbCr_to_RGB_C( GenefxState *gfxs )
+{
+     int                w = gfxs->length>>1;
+     GenefxAccumulator *D = gfxs->Dacc;
 
-static void Sop_is_Aop( GenefxState *gfxs ) { gfxs->Sop = gfxs->Aop; gfxs->Ostep = gfxs->Astep; }
-static void Sop_is_Bop( GenefxState *gfxs ) { gfxs->Sop = gfxs->Bop; gfxs->Ostep = gfxs->Bstep; }
+     while (w--) {
+          /* Actually DirectFB only supports 4:2:X formats,
+           * therefore D[0].YUV.u/v is equal to D[1].YUV.u/v */
+          if (!(D[0].YUV.a & 0xF000) && !(D[1].YUV.a & 0xF000)) {
+               s16 c0, c1, c2;
+               s16 r, g, b;
+
+               c0 = cr_for_r[D[0].YUV.v];
+               c1 = cr_for_g[D[0].YUV.v] + cb_for_g[D[0].YUV.u];
+               c2 = cb_for_b[D[0].YUV.u];
+
+               r = c0 + y_for_rgb[D[0].YUV.y];
+               g = c1 + y_for_rgb[D[0].YUV.y];
+               b = c2 + y_for_rgb[D[0].YUV.y];
+               D[0].RGB.r = (r < 0) ? 0 : r;
+               D[0].RGB.g = (g < 0) ? 0 : g;
+               D[0].RGB.b = (b < 0) ? 0 : b;
+
+               r = c0 + y_for_rgb[D[1].YUV.y];
+               g = c1 + y_for_rgb[D[1].YUV.y];
+               b = c2 + y_for_rgb[D[1].YUV.y];
+               D[1].RGB.r = (r < 0) ? 0 : r;
+               D[1].RGB.g = (g < 0) ? 0 : g;
+               D[1].RGB.b = (b < 0) ? 0 : b;
+          }
+          else if (!(D[0].YUV.a & 0xF000)) {
+               u16 y, cb, cr;
+               s16 r, g, b;
+
+               y  = y_for_rgb[D[0].YUV.y];
+               cb = D[0].YUV.u;
+               cr = D[0].YUV.v;
+               r  = y + cr_for_r[cr];
+               g  = y + cr_for_g[cr] + cb_for_g[cb];
+               b  = y                + cb_for_b[cb];
+
+               D[0].RGB.r = (r < 0) ? 0 : r;
+               D[0].RGB.g = (g < 0) ? 0 : g;
+               D[0].RGB.b = (b < 0) ? 0 : b;
+          }
+          else if (!(D[1].YUV.a & 0xF000)) {
+               u16 y, cb, cr;
+               s16 r, g, b;
+
+               y  = y_for_rgb[D[1].YUV.y];
+               cb = D[1].YUV.u;
+               cr = D[1].YUV.v;
+               r  = y + cr_for_r[cr];
+               g  = y + cr_for_g[cr] + cb_for_g[cb];
+               b  = y                + cb_for_b[cb];
+
+               D[1].RGB.r = (r < 0) ? 0 : r;
+               D[1].RGB.g = (g < 0) ? 0 : g;
+               D[1].RGB.b = (b < 0) ? 0 : b;
+          }
+
+          D += 2;
+     }
+
+     if (gfxs->length & 1) {
+          if (!(D->YUV.a & 0xF000)) {
+               u16 y, cb, cr;
+               s16 r, g, b;
+
+               y  = y_for_rgb[D->YUV.y];
+               cb = D->YUV.u;
+               cr = D->YUV.v;
+               r  = y + cr_for_r[cr];
+               g  = y + cr_for_g[cr] + cb_for_g[cb];
+               b  = y                + cb_for_b[cb];
+
+               D->RGB.r = (r < 0) ? 0 : r;
+               D->RGB.g = (g < 0) ? 0 : g;
+               D->RGB.b = (b < 0) ? 0 : b;
+          }
+     }
+}
+
+static GenefxFunc Dacc_YCbCr_to_RGB = Dacc_YCbCr_to_RGB_C;
+
+static void Sop_is_Aop( GenefxState *gfxs ) { gfxs->Sop = gfxs->Aop;}
+static void Sop_is_Bop( GenefxState *gfxs ) { gfxs->Sop = gfxs->Bop;}
 
 static void Slut_is_Alut( GenefxState *gfxs ) { gfxs->Slut = gfxs->Alut;}
 static void Slut_is_Blut( GenefxState *gfxs ) { gfxs->Slut = gfxs->Blut;}
@@ -6706,7 +6543,7 @@ bool gAcquire( CardState *state, DFBAccelerationMask accel )
      bool         src_ycbcr   = false;
      bool         dst_ycbcr   = false;
 
-     CoreSurfaceAccessFlags access = CSAF_WRITE;
+     CoreSurfaceAccessFlags access = CSAF_CPU_WRITE;
 
      if (dfb_config->hardware_only) {
           if (dfb_config->software_warn) {
@@ -6753,13 +6590,13 @@ bool gAcquire( CardState *state, DFBAccelerationMask accel )
           if (state->blittingflags & (DSBLIT_BLEND_ALPHACHANNEL |
                                       DSBLIT_BLEND_COLORALPHA   |
                                       DSBLIT_DST_COLORKEY))
-               access |= CSAF_READ;
+               access |= CSAF_CPU_READ;
      }
      else if (state->drawingflags & (DSDRAW_BLEND | DSDRAW_DST_COLORKEY))
-          access |= CSAF_READ;
+          access |= CSAF_CPU_READ;
 
      /* Lock destination */
-     ret = dfb_surface_lock_buffer( destination, state->to, CSAID_CPU, access, &state->dst );
+     ret = dfb_surface_lock_buffer( destination, state->to, access, &state->dst );
      if (ret) {
           D_DERROR( ret, "DirectFB/Genefx: Could not lock destination!\n" );
           return false;
@@ -6808,7 +6645,7 @@ bool gAcquire( CardState *state, DFBAccelerationMask accel )
 #endif
 
           /* Lock source */
-          ret = dfb_surface_lock_buffer( source, state->from, CSAID_CPU, CSAF_READ, &state->src );
+          ret = dfb_surface_lock_buffer( source, state->from, CSAF_CPU_READ, &state->src );
           if (ret) {
                D_DERROR( ret, "DirectFB/Genefx: Could not lock source!\n" );
                dfb_surface_unlock_buffer( destination, &state->dst );
@@ -7024,9 +6861,6 @@ bool gAcquire( CardState *state, DFBAccelerationMask accel )
 
      gfxs->need_accumulator = true;
 
-     /* Initialization */
-     gfxs->Astep = gfxs->Bstep = gfxs->Ostep = 1;
-
      switch (accel) {
           case DFXL_FILLRECTANGLE:
           case DFXL_DRAWRECTANGLE:
@@ -7233,17 +7067,6 @@ bool gAcquire( CardState *state, DFBAccelerationMask accel )
                          break;
                     }
                }
-               if (state->blittingflags == DSBLIT_BLEND_ALPHACHANNEL &&
-                   state->src_blend     == DSBF_ONE                  &&
-                   state->dst_blend     == DSBF_INVSRCALPHA)
-               {
-                    if (gfxs->src_format == DSPF_ARGB &&
-                        Bop_argb_blend_alphachannel_one_invsrc_Aop_PFI[dst_pfi])
-                    {
-                         *funcs++ = Bop_argb_blend_alphachannel_one_invsrc_Aop_PFI[dst_pfi];
-                         break;
-                    }
-               }
                if (((state->blittingflags == (DSBLIT_COLORIZE | DSBLIT_BLEND_ALPHACHANNEL |
                                               DSBLIT_SRC_PREMULTIPLY) &&
                      state->src_blend == DSBF_ONE)
@@ -7498,10 +7321,6 @@ bool gAcquire( CardState *state, DFBAccelerationMask accel )
                               } else if (state->blittingflags & DSBLIT_DST_COLORKEY) {
                                    gfxs->Dkey = state->dst_colorkey;
                                    *funcs++ = Bop_PFI_toK_Aop_PFI[dst_pfi];
-                              } else if (state->blittingflags & (DSBLIT_ROTATE90  |
-                                                                 DSBLIT_ROTATE180 |
-                                                                 DSBLIT_ROTATE270)) {
-                                   *funcs++ = Bop_PFI_toR_Aop_PFI[dst_pfi];
                               } else
                                    *funcs++ = Bop_PFI_to_Aop_PFI[dst_pfi];
                          }
@@ -7528,8 +7347,11 @@ bool gAcquire( CardState *state, DFBAccelerationMask accel )
                          if (scale_from_accumulator)
                               *funcs++ = Len_is_Slen;
 
-                         gfxs->Sop = gfxs->Bop;
+                         /* slow */
+                         *funcs++ = Sacc_is_Aacc;
+                         *funcs++ = Dacc_is_Aacc;
 
+                         *funcs++ = Sop_is_Bop;
                          if (DFB_PIXELFORMAT_IS_INDEXED(gfxs->src_format))
                               *funcs++ = Slut_is_Blut;
 
@@ -7603,25 +7425,10 @@ void gRelease( CardState *state )
      }
 }
 
-#define CHECK_PIPELINE()                                                             \
-     {                                                                               \
-          if (!gfxs->funcs[0])                                                       \
-               return;                                                               \
-                                                                                     \
-          if (dfb_config->software_trace) {                                          \
-               int         i;                                                        \
-               GenefxFunc *funcs = gfxs->funcs;                                      \
-                                                                                     \
-               direct_log_lock( NULL );                                              \
-               direct_log_printf( NULL, "  Software Fallback Pipeline:\n" );         \
-                                                                                     \
-               for (i=0; funcs[i]; ++i)                                              \
-                    direct_log_printf( NULL, "    [%2d] %s\n", i,                    \
-                                       direct_trace_lookup_symbol_at( funcs[i] ) );  \
-                                                                                     \
-               direct_log_printf( NULL, "\n" );                                      \
-               direct_log_unlock( NULL );                                            \
-          }                                                                          \
+#define CHECK_PIPELINE()           \
+     {                             \
+          if (!gfxs->funcs[0])     \
+               return;             \
      }
 
 #define RUN_PIPELINE()                     \
@@ -7688,12 +7495,6 @@ static inline void Aop_xy( GenefxState *gfxs, int x, int y )
      }
 }
 
-static inline void Aop_crab( GenefxState *gfxs )
-{
-     gfxs->Aop[0] += gfxs->dst_bpp;
-     gfxs->AopY++;
-}
-
 static inline void Aop_next( GenefxState *gfxs )
 {
      int pitch = gfxs->dst_pitch;
@@ -8028,8 +7829,6 @@ ABacc_prepare( GenefxState *gfxs, int width )
           gfxs->Bacc    = gfxs->Aacc + size;
      }
 
-     gfxs->Sacc = gfxs->Dacc = gfxs->Aacc;
-
      return true;
 }
 
@@ -8043,8 +7842,6 @@ ABacc_flush( GenefxState *gfxs )
           gfxs->ABstart = NULL;
           gfxs->Aacc    = NULL;
           gfxs->Bacc    = NULL;
-          gfxs->Sacc    = NULL;
-          gfxs->Dacc    = NULL;
      }
 }
 
@@ -8189,10 +7986,8 @@ void gBlit( CardState *state, DFBRectangle *rect, int dx, int dy )
 
      D_ASSERT( state->clip.x1 <= dx );
      D_ASSERT( state->clip.y1 <= dy );
-     D_ASSERT( (state->blittingflags & (DSBLIT_ROTATE90 | DSBLIT_ROTATE270)) || state->clip.x2 >= (dx + rect->w - 1) );
-     D_ASSERT( (state->blittingflags & (DSBLIT_ROTATE90 | DSBLIT_ROTATE270)) || state->clip.y2 >= (dy + rect->h - 1) );
-     D_ASSERT( !(state->blittingflags & (DSBLIT_ROTATE90 | DSBLIT_ROTATE270)) || state->clip.x2 >= (dx + rect->h - 1) );
-     D_ASSERT( !(state->blittingflags & (DSBLIT_ROTATE90 | DSBLIT_ROTATE270)) || state->clip.y2 >= (dy + rect->w - 1) );
+     D_ASSERT( state->clip.x2 >= (dx + rect->w - 1) );
+     D_ASSERT( state->clip.y2 >= (dy + rect->h - 1) );
 
      CHECK_PIPELINE();
 
@@ -8201,17 +7996,10 @@ void gBlit( CardState *state, DFBRectangle *rect, int dx, int dy )
 
      if (gfxs->src_org[0] == gfxs->dst_org[0] && dy == rect->y && dx > rect->x)
           /* we must blit from right to left */
-          gfxs->Astep = gfxs->Bstep = -1;
+          gfxs->Ostep = -1;
      else
           /* we must blit from left to right*/
-          gfxs->Astep = gfxs->Bstep = 1;
-     
-     if (state->blittingflags & DSBLIT_ROTATE90)
-          gfxs->Astep *= -gfxs->dst_pitch / gfxs->dst_bpp;
-     else if (state->blittingflags & DSBLIT_ROTATE180)
-          gfxs->Astep *= -1;
-     else if (state->blittingflags & DSBLIT_ROTATE270)
-          gfxs->Astep *= gfxs->dst_pitch / gfxs->dst_bpp;
+          gfxs->Ostep = 1;
 
      switch (gfxs->src_format) {
           case DSPF_A4:
@@ -8285,47 +8073,6 @@ void gBlit( CardState *state, DFBRectangle *rect, int dx, int dy )
           }
      }
 
-     if (state->blittingflags & DSBLIT_ROTATE180) {
-          Aop_xy( gfxs, dx + rect->w - 1, dy );
-          Bop_xy( gfxs, rect->x, rect->y + rect->h - 1 );
-          
-          for (h = rect->h; h; h--) {
-               RUN_PIPELINE();
-
-               Aop_next( gfxs );
-               Bop_prev( gfxs );
-          }
-          return;
-     }
-     else if( state->blittingflags & DSBLIT_ROTATE270 )
-     {
-          Aop_xy( gfxs, dx, dy );
-          Bop_xy( gfxs, rect->x, rect->y + rect->h - 1 );
-
-          for( h = rect->h; h; h-- )
-          {
-               RUN_PIPELINE();
-
-               Aop_crab( gfxs );
-               Bop_prev( gfxs );
-          }
-          return;
-     }
-     else if( state->blittingflags & DSBLIT_ROTATE90 )
-     {
-          Aop_xy( gfxs, dx, dy + rect->w - 1 );
-          Bop_xy( gfxs, rect->x, rect->y );
-
-          for( h = rect->h; h; h-- )
-          {
-               RUN_PIPELINE();
-
-               Aop_crab( gfxs );
-               Bop_next( gfxs );
-          }
-          return;
-     }
-
      if (gfxs->src_org[0] == gfxs->dst_org[0] && dy > rect->y &&
          !(state->blittingflags & DSBLIT_DEINTERLACE)) {
           /* we must blit from bottom to top */
@@ -8917,14 +8664,14 @@ static void gInit_MMX()
      use_mmx = 1;
 
 /********************************* Sop_PFI_Sto_Dacc ***************************/
-//     Sop_PFI_Sto_Dacc[DFB_PIXELFORMAT_INDEX(DSPF_ARGB)] = Sop_argb_Sto_Dacc_MMX;
+     Sop_PFI_Sto_Dacc[DFB_PIXELFORMAT_INDEX(DSPF_ARGB)] = Sop_argb_Sto_Dacc_MMX;
 /********************************* Sop_PFI_to_Dacc ****************************/
-//     Sop_PFI_to_Dacc[DFB_PIXELFORMAT_INDEX(DSPF_RGB16)] = Sop_rgb16_to_Dacc_MMX;
-//     Sop_PFI_to_Dacc[DFB_PIXELFORMAT_INDEX(DSPF_RGB32)] = Sop_rgb32_to_Dacc_MMX;
-//     Sop_PFI_to_Dacc[DFB_PIXELFORMAT_INDEX(DSPF_ARGB )] = Sop_argb_to_Dacc_MMX;
+     Sop_PFI_to_Dacc[DFB_PIXELFORMAT_INDEX(DSPF_RGB16)] = Sop_rgb16_to_Dacc_MMX;
+     Sop_PFI_to_Dacc[DFB_PIXELFORMAT_INDEX(DSPF_RGB32)] = Sop_rgb32_to_Dacc_MMX;
+     Sop_PFI_to_Dacc[DFB_PIXELFORMAT_INDEX(DSPF_ARGB )] = Sop_argb_to_Dacc_MMX;
 /********************************* Sacc_to_Aop_PFI ****************************/
-//     Sacc_to_Aop_PFI[DFB_PIXELFORMAT_INDEX(DSPF_RGB16)] = Sacc_to_Aop_rgb16_MMX;
-//     Sacc_to_Aop_PFI[DFB_PIXELFORMAT_INDEX(DSPF_RGB32)] = Sacc_to_Aop_rgb32_MMX;
+     Sacc_to_Aop_PFI[DFB_PIXELFORMAT_INDEX(DSPF_RGB16)] = Sacc_to_Aop_rgb16_MMX;
+     Sacc_to_Aop_PFI[DFB_PIXELFORMAT_INDEX(DSPF_RGB32)] = Sacc_to_Aop_rgb32_MMX;
 /********************************* Xacc_blend *********************************/
      Xacc_blend[DSBF_SRCALPHA-1] = Xacc_blend_srcalpha_MMX;
      Xacc_blend[DSBF_INVSRCALPHA-1] = Xacc_blend_invsrcalpha_MMX;
diff --git a/DirectFB-1.3.0/src/gfx/generic/generic.h b/DirectFB-1.3.0/src/gfx/generic/generic.h
index 6357661..06909fc 100644
--- a/DirectFB-1.3.0/src/gfx/generic/generic.h
+++ b/DirectFB-1.3.0/src/gfx/generic/generic.h
@@ -99,9 +99,6 @@ struct _GenefxState {
      void *Bop[3];
      u32   Cop;
 
-     int   Astep;
-     int   Bstep;
-
      u8 YCop;
      u8 CbCop;
      u8 CrCop;
diff --git a/DirectFB-1.3.0/src/gfx/generic/generic_dummy.c b/DirectFB-1.3.0/src/gfx/generic/generic_dummy.c
index 68ddd32..2963584 100644
--- a/DirectFB-1.3.0/src/gfx/generic/generic_dummy.c
+++ b/DirectFB-1.3.0/src/gfx/generic/generic_dummy.c
@@ -37,6 +37,9 @@
 #include <direct/messages.h>
 
 
+#include "yuvtbl.h"
+
+
 void
 gGetDriverInfo( GraphicsDriverInfo *info )
 {
diff --git a/DirectFB-1.3.0/src/gfx/generic/generic_mmx.h b/DirectFB-1.3.0/src/gfx/generic/generic_mmx.h
index fa5e0de..03606ee 100644
--- a/DirectFB-1.3.0/src/gfx/generic/generic_mmx.h
+++ b/DirectFB-1.3.0/src/gfx/generic/generic_mmx.h
@@ -526,9 +526,21 @@ static void Dacc_YCbCr_to_RGB_MMX( GenefxState *gfxs )
           : "memory" );
 
      while (w) {
-          if (!(D->YUV.a & 0xF000))
-               YCBCR_TO_RGB( D->YUV.y, D->YUV.u, D->YUV.v,
-                             D->RGB.r, D->RGB.g, D->RGB.b );
+          if (!(D->YUV.a & 0xF000)) {
+               u16 y, cb, cr;
+               s16 r, g, b;
+
+               y  = y_for_rgb[D->YUV.y];
+               cb = D->YUV.u;
+               cr = D->YUV.v;
+               r  = y + cr_for_r[cr];
+               g  = y + cr_for_g[cr] + cb_for_g[cb];
+               b  = y                + cb_for_b[cb];
+               
+               D->RGB.r = (r < 0) ? 0 : r;
+               D->RGB.g = (g < 0) ? 0 : g;
+               D->RGB.b = (b < 0) ? 0 : b;
+          }
 
           D++;
           w--;
@@ -628,9 +640,16 @@ static void Dacc_RGB_to_YCbCr_MMX( GenefxState *gfxs )
           : "memory" );
 
      while (w) {
-          if (!(D->RGB.a & 0xF000))
-               RGB_TO_YCBCR( D->RGB.r, D->RGB.g, D->RGB.b,
-                             D->YUV.y, D->YUV.u, D->YUV.v );
+          if (!(D->RGB.a & 0xF000)) {
+               u32 r, g, b, ey;
+
+               r = D->RGB.r; g = D->RGB.g; b = D->RGB.b;
+               ey = (19595 * r + 38469 * g + 7471 * b) >> 16;
+
+               D->YUV.y = y_from_ey[ey];
+               D->YUV.u = cb_from_bey[b-ey];
+               D->YUV.v = cr_from_rey[r-ey];
+          }
 
           D++;
           w--;
diff --git a/DirectFB-1.3.0/src/gfx/generic/stretch_up_down_16_indexed.h b/DirectFB-1.3.0/src/gfx/generic/stretch_up_down_16_indexed.h
new file mode 100644
index 0000000..bc7bf49
--- /dev/null
+++ b/DirectFB-1.3.0/src/gfx/generic/stretch_up_down_16_indexed.h
@@ -0,0 +1,82 @@
+#define SOURCE_LOOKUP(x) (((u16*)colors)[x])
+#define SOURCE_TYPE      u8
+
+
+#define POINT_0               hfraq
+#define LINE_0                vfraq
+#define MINUS_1               0
+#define POINT_TO_RATIO(p,ps)  ( (((((p)) & 0x3ffff) ? : 0x40000) << SHIFT_L6) / (ps) )
+#define LINE_TO_RATIO(l,ls)   ( (((((l)) & 0x3ffff) ? : 0x40000) << SHIFT_L5) / (ls) )
+
+#define POINT_L(p,ps)  ( (((p)-1) >> 18) - 1 )
+#define POINT_R(p,ps)  ( (((p)-1) >> 18) )
+
+#define LINE_T(l,ls)  ( (((l)-1) >> 18) - 1 )
+#define LINE_B(l,ls)  ( (((l)-1) >> 18) )
+
+static void FUNC_NAME(down)( void       *dst,
+                             int         dpitch,
+                             const void *src,
+                             int         spitch,
+                             int         width,
+                             int         height,
+                             int         dst_width,
+                             int         dst_height,
+                             DFBRegion  *clip,
+                             const void *colors )
+{
+#include "stretch_hvx_16.h"
+}
+
+#undef POINT_0
+#undef LINE_0
+#undef MINUS_1
+#undef POINT_TO_RATIO
+#undef LINE_TO_RATIO
+#undef POINT_L
+#undef POINT_R
+#undef LINE_T
+#undef LINE_B
+
+/**********************************************************************************************************************/
+
+#define POINT_0               0
+#define LINE_0                0
+#define MINUS_1               1
+#define POINT_TO_RATIO(p,ps)  ( ((p) & 0x3ffff) >> (18-SHIFT_L6) )
+#define LINE_TO_RATIO(l,ls)   ( ((l) & 0x3ffff) >> (18-SHIFT_L5) )
+
+#define POINT_L(p,ps)  ( (((p)) >> 18) )
+#define POINT_R(p,ps)  ( (((p)) >> 18) + 1 )
+
+#define LINE_T(l,ls)  ( (((l)) >> 18) )
+#define LINE_B(l,ls)  ( (((l)) >> 18) + 1 )
+
+static void FUNC_NAME(up)( void       *dst,
+                           int         dpitch,
+                           const void *src,
+                           int         spitch,
+                           int         width,
+                           int         height,
+                           int         dst_width,
+                           int         dst_height,
+                           DFBRegion  *clip,
+                           const void *colors )
+{
+#include "stretch_hvx_16.h"
+}
+
+#undef POINT_0
+#undef LINE_0
+#undef MINUS_1
+#undef POINT_TO_RATIO
+#undef LINE_TO_RATIO
+#undef POINT_L
+#undef POINT_R
+#undef LINE_T
+#undef LINE_B
+
+
+#undef SOURCE_LOOKUP
+#undef SOURCE_TYPE
+
diff --git a/DirectFB-1.3.0/src/gfx/generic/template_acc_16.h b/DirectFB-1.3.0/src/gfx/generic/template_acc_16.h
index a50e6d5..853217a 100644
--- a/DirectFB-1.3.0/src/gfx/generic/template_acc_16.h
+++ b/DirectFB-1.3.0/src/gfx/generic/template_acc_16.h
@@ -74,12 +74,8 @@ static void Sop_PFI_OP_Dacc(Sto)( GenefxState *gfxs )
      int                i     = gfxs->Xphase;
      int                SperD = gfxs->SperD;
      u16               *S     = gfxs->Sop[0];
-     int                Ostep = gfxs->Ostep;
      GenefxAccumulator *D     = gfxs->Dacc;
 
-     if (Ostep != 1)
-          D_UNIMPLEMENTED();
-
      while (l--) {
           u16 s = S[i>>16];
 
@@ -98,13 +94,9 @@ static void Sop_PFI_OP_Dacc(SKto)( GenefxState *gfxs )
      int                i     = gfxs->Xphase;
      int                SperD = gfxs->SperD;
      u16               *S     = gfxs->Sop[0];
-     int                Ostep = gfxs->Ostep;
      GenefxAccumulator *D     = gfxs->Dacc;
      u16                Skey  = gfxs->Skey;
 
-     if (Ostep != 1)
-          D_UNIMPLEMENTED();
-
      while (l--) {
           u16 s = S[i>>16];
 
@@ -125,10 +117,6 @@ static void Sop_PFI_OP_Dacc(to)( GenefxState *gfxs )
      int             w, l = gfxs->length;
      u16               *S = gfxs->Sop[0];
      GenefxAccumulator *D = gfxs->Dacc;
-     int                Ostep = gfxs->Ostep;
-
-     if (Ostep != 1)
-          D_UNIMPLEMENTED();
 
      if ((long)S & 2) {
           u16 s = *S++;
@@ -170,17 +158,15 @@ static void Sop_PFI_OP_Dacc(Kto)( GenefxState *gfxs )
      u16               *S    = gfxs->Sop[0];
      GenefxAccumulator *D    = gfxs->Dacc;
      u16                Skey = gfxs->Skey;
-     int                Ostep = gfxs->Ostep;
 
      while (l--) {
-          u16 s = *S;
+          u16 s = *S++;
 
           if (MASK_RGB( s ) != Skey)
                EXPAND( *D, s );
           else
                D->RGB.a = 0xF000;
 
-          S += Ostep;
           D++;
      }
 }
@@ -192,10 +178,6 @@ static void Sacc_OP_Aop_PFI(to)( GenefxState *gfxs )
      int             w, l = gfxs->length;
      GenefxAccumulator *S = gfxs->Sacc;
      u16               *D = gfxs->Aop[0];
-     int                Dstep = gfxs->Astep;
-
-     if (Dstep != 1)
-          D_UNIMPLEMENTED();
 
      if ((long)D & 2) {
           if (!(S->RGB.a & 0xF000))
@@ -242,10 +224,6 @@ static void Sacc_OP_Aop_PFI(Sto)( GenefxState *gfxs )
      int                SperD = gfxs->SperD;
      GenefxAccumulator *Sacc  = gfxs->Sacc;
      u16               *D     = gfxs->Aop[0];
-     int                Dstep = gfxs->Astep;
-
-     if (Dstep != 1)
-          D_UNIMPLEMENTED();
 
      if ((long)D & 2) {
           GenefxAccumulator *S = Sacc;
@@ -297,14 +275,13 @@ static void Sacc_OP_Aop_PFI(toK)( GenefxState *gfxs )
      GenefxAccumulator *S    = gfxs->Sacc;
      u16               *D    = gfxs->Aop[0];
      u16                Dkey = gfxs->Dkey;
-     int                Dstep = gfxs->Astep;
 
      while (l--) {
           if (!(S->RGB.a & 0xF000) && MASK_RGB( *D ) == Dkey)
                *D = PIXEL( *S );
 
           S++;
-          D += Dstep;
+          D++;
      }
 }
 
@@ -318,7 +295,6 @@ static void Sacc_OP_Aop_PFI(StoK)( GenefxState *gfxs )
      GenefxAccumulator *Sacc  = gfxs->Sacc;
      u16               *D     = gfxs->Aop[0];
      u16                Dkey  = gfxs->Dkey;
-     int                Dstep = gfxs->Astep;
 
      while (l--) {
           GenefxAccumulator *S = &Sacc[i>>16];
@@ -326,7 +302,7 @@ static void Sacc_OP_Aop_PFI(StoK)( GenefxState *gfxs )
           if (!(S->RGB.a & 0xF000) && MASK_RGB( *D ) == Dkey)
                *D = PIXEL( *S );
 
-          D += Dstep;
+          D++;
           i += SperD;
      }
 }
diff --git a/DirectFB-1.3.0/src/gfx/generic/template_acc_32.h b/DirectFB-1.3.0/src/gfx/generic/template_acc_32.h
index f0894ca..569a135 100644
--- a/DirectFB-1.3.0/src/gfx/generic/template_acc_32.h
+++ b/DirectFB-1.3.0/src/gfx/generic/template_acc_32.h
@@ -69,12 +69,8 @@ static void Sop_PFI_OP_Dacc(Sto)( GenefxState *gfxs )
      int                i     = gfxs->Xphase;
      int                SperD = gfxs->SperD;
      u32               *S     = gfxs->Sop[0];
-     int                Ostep = gfxs->Ostep;
      GenefxAccumulator *D     = gfxs->Dacc;
 
-     if (Ostep != 1)
-          D_UNIMPLEMENTED();
-          
      while (l--) {
           u32 s = S[i>>16];
 
@@ -93,13 +89,9 @@ static void Sop_PFI_OP_Dacc(SKto)( GenefxState *gfxs )
      int                i     = gfxs->Xphase;
      int                SperD = gfxs->SperD;
      u32               *S     = gfxs->Sop[0];
-     int                Ostep = gfxs->Ostep;
      GenefxAccumulator *D     = gfxs->Dacc;
      u32                Skey  = gfxs->Skey;
 
-     if (Ostep != 1)
-          D_UNIMPLEMENTED();
-
      while (l--) {
           u32 s = S[i>>16];
 
@@ -120,15 +112,12 @@ static void Sop_PFI_OP_Dacc(to)( GenefxState *gfxs )
      int                l = gfxs->length;
      u32               *S = gfxs->Sop[0];
      GenefxAccumulator *D = gfxs->Dacc;
-     int                Ostep = gfxs->Ostep;
 
      while (l--) {
-          u32 s = *S;
+          u32 s = *S++;
 
           EXPAND( *D, s );
 
-          S += Ostep;
-
           D++;
      }
 }
@@ -141,17 +130,15 @@ static void Sop_PFI_OP_Dacc(Kto)( GenefxState *gfxs )
      u32               *S    = gfxs->Sop[0];
      GenefxAccumulator *D    = gfxs->Dacc;
      u32                Skey = gfxs->Skey;
-     int                Ostep = gfxs->Ostep;
 
      while (l--) {
-          u32 s = *S;
+          u32 s = *S++;
 
           if ((s & RGB_MASK) != Skey)
                EXPAND( *D, s );
           else
                D->RGB.a = 0xF000;
 
-          S += Ostep;
           D++;
      }
 }
@@ -163,14 +150,13 @@ static void Sacc_OP_Aop_PFI(to)( GenefxState *gfxs )
      int                l = gfxs->length;
      GenefxAccumulator *S = gfxs->Sacc;
      u32               *D = gfxs->Aop[0];
-     int                Dstep = gfxs->Astep;
 
      while (l--) {
           if (!(S->RGB.a & 0xF000))
                *D = PIXEL( *S );
 
           S++;
-          D += Dstep;
+          D++;
      }
 }
 
@@ -183,7 +169,6 @@ static void Sacc_OP_Aop_PFI(Sto)( GenefxState *gfxs )
      int                SperD = gfxs->SperD;
      GenefxAccumulator *Sacc  = gfxs->Sacc;
      u32               *D     = gfxs->Aop[0];
-     int                Dstep = gfxs->Astep;
 
      while (l--) {
           GenefxAccumulator *S = &Sacc[i>>16];
@@ -191,7 +176,7 @@ static void Sacc_OP_Aop_PFI(Sto)( GenefxState *gfxs )
           if (!(S->RGB.a & 0xF000))
                *D = PIXEL( *S );
 
-          D += Dstep;
+          D++;
           i += SperD;
      }
 }
@@ -203,7 +188,6 @@ static void Sacc_OP_Aop_PFI(toK)( GenefxState *gfxs )
      int                l    = gfxs->length;
      GenefxAccumulator *S    = gfxs->Sacc;
      u32               *D    = gfxs->Aop[0];
-     int                Dstep = gfxs->Astep;
      u32                Dkey = gfxs->Dkey;
 
      while (l--) {
@@ -211,7 +195,7 @@ static void Sacc_OP_Aop_PFI(toK)( GenefxState *gfxs )
                *D = PIXEL( *S );
 
           S++;
-          D += Dstep;
+          D++;
      }
 }
 
@@ -224,7 +208,6 @@ static void Sacc_OP_Aop_PFI(StoK)( GenefxState *gfxs )
      int                SperD = gfxs->SperD;
      GenefxAccumulator *Sacc  = gfxs->Sacc;
      u32               *D     = gfxs->Aop[0];
-     int                Dstep = gfxs->Astep;
      u32                Dkey  = gfxs->Dkey;
 
      while (l--) {
@@ -233,7 +216,7 @@ static void Sacc_OP_Aop_PFI(StoK)( GenefxState *gfxs )
           if (!(S->RGB.a & 0xF000) && (*D & RGB_MASK) == Dkey)
                *D = PIXEL( *S );
 
-          D += Dstep;
+          D++;
           i += SperD;
      }
 }
diff --git a/DirectFB-1.3.0/src/gfx/generic/template_colorkey_32.h b/DirectFB-1.3.0/src/gfx/generic/template_colorkey_32.h
index 52227af..a4d69a1 100644
--- a/DirectFB-1.3.0/src/gfx/generic/template_colorkey_32.h
+++ b/DirectFB-1.3.0/src/gfx/generic/template_colorkey_32.h
@@ -56,15 +56,14 @@ static void Cop_OP_Aop_PFI(toK)( GenefxState *gfxs )
 static void Bop_PFI_OP_Aop_PFI(Kto)( GenefxState *gfxs )
 {
      int  l     = gfxs->length;
-     int  Sstep = gfxs->Bstep;
-     int  Dstep = gfxs->Astep;
+     int  Ostep = gfxs->Ostep;
      u32 *S     = gfxs->Bop[0];
      u32 *D     = gfxs->Aop[0];
      u32  Skey  = gfxs->Skey;
 
-     if (Sstep < 0) {
+     if (Ostep < 0) {
           S += gfxs->length - 1;
-          D += (gfxs->length - 1) * gfxs->Astep;
+          D += gfxs->length - 1;
      }
 
      while (l--) {
@@ -73,8 +72,8 @@ static void Bop_PFI_OP_Aop_PFI(Kto)( GenefxState *gfxs )
           if ((s & RGB_MASK) != Skey)
                *D = s;
 
-          S += Sstep;
-          D += Dstep;
+          S += Ostep;
+          D += Ostep;
      }
 }
 
@@ -83,23 +82,22 @@ static void Bop_PFI_OP_Aop_PFI(Kto)( GenefxState *gfxs )
 static void Bop_PFI_OP_Aop_PFI(toK)( GenefxState *gfxs )
 {
      int  l     = gfxs->length;
-     int  Sstep = gfxs->Bstep;
-     int  Dstep = gfxs->Astep;
+     int  Ostep = gfxs->Ostep;
      u32 *S     = gfxs->Bop[0];
      u32 *D     = gfxs->Aop[0];
      u32  Dkey  = gfxs->Dkey;
 
-     if (Sstep < 0) {
+     if (Ostep < 0) {
           S += gfxs->length - 1;
-          D += (gfxs->length - 1) * gfxs->Astep;
+          D += gfxs->length - 1;
      }
 
      while (l--) {
           if ((*D & RGB_MASK) == Dkey)
                *D = *S;
 
-          S += Sstep;
-          D += Dstep;
+          S += Ostep;
+          D += Ostep;
      }
 }
 
@@ -108,16 +106,15 @@ static void Bop_PFI_OP_Aop_PFI(toK)( GenefxState *gfxs )
 static void Bop_PFI_OP_Aop_PFI(KtoK)( GenefxState *gfxs )
 {
      int  l     = gfxs->length;
-     int  Sstep = gfxs->Bstep;
-     int  Dstep = gfxs->Astep;
+     int  Ostep = gfxs->Ostep;
      u32 *S     = gfxs->Bop[0];
      u32 *D     = gfxs->Aop[0];
      u32  Skey  = gfxs->Skey;
      u32  Dkey  = gfxs->Dkey;
 
-     if (Sstep < 0) {
+     if (Ostep < 0) {
           S += gfxs->length - 1;
-          D += (gfxs->length - 1) * gfxs->Astep;
+          D += gfxs->length - 1;
      }
 
      while (l--) {
@@ -126,8 +123,8 @@ static void Bop_PFI_OP_Aop_PFI(KtoK)( GenefxState *gfxs )
           if ((s & RGB_MASK) != Skey && (*D & RGB_MASK) == Dkey)
                *D = s;
 
-          S += Sstep;
-          D += Dstep;
+          S += Ostep;
+          D += Ostep;
      }
 }
 
@@ -140,7 +137,6 @@ static void Bop_PFI_OP_Aop_PFI(SKto)( GenefxState *gfxs )
      int  SperD = gfxs->SperD;
      u32 *S     = gfxs->Bop[0];
      u32 *D     = gfxs->Aop[0];
-     int  Dstep = gfxs->Astep;
      u32  Skey  = gfxs->Skey;
 
      while (l--) {
@@ -149,7 +145,7 @@ static void Bop_PFI_OP_Aop_PFI(SKto)( GenefxState *gfxs )
           if ((s & RGB_MASK) != Skey)
                *D = s;
 
-          D += Dstep;
+          D++;
           i += SperD;
      }
 }
@@ -164,13 +160,12 @@ static void Bop_PFI_OP_Aop_PFI(StoK)( GenefxState *gfxs )
      u32 *S     = gfxs->Bop[0];
      u32 *D     = gfxs->Aop[0];
      u32  Dkey  = gfxs->Dkey;
-     int  Dstep = gfxs->Astep;
 
      while (l--) {
           if ((*D & RGB_MASK) != Dkey)
                *D = S[i>>16];
 
-          D += Dstep;
+          D++;
           i += SperD;
      }
 }
@@ -186,7 +181,6 @@ static void Bop_PFI_OP_Aop_PFI(SKtoK)( GenefxState *gfxs )
      u32 *D     = gfxs->Aop[0];
      u32  Skey  = gfxs->Skey;
      u32  Dkey  = gfxs->Dkey;
-     int  Dstep = gfxs->Astep;
 
      while (l--) {
           u32 s = S[i>>16];
@@ -194,7 +188,7 @@ static void Bop_PFI_OP_Aop_PFI(SKtoK)( GenefxState *gfxs )
           if ((s & RGB_MASK) != Skey && (*D & RGB_MASK) == Dkey)
                *D = s;
 
-          D += Dstep;
+          D++;
           i += SperD;
      }
 }
diff --git a/DirectFB-1.3.0/src/gfx/util.c b/DirectFB-1.3.0/src/gfx/util.c
index bf4b71a..4e6cd29 100644
--- a/DirectFB-1.3.0/src/gfx/util.c
+++ b/DirectFB-1.3.0/src/gfx/util.c
@@ -104,10 +104,9 @@ dfb_gfx_copy_to( CoreSurface *source, CoreSurface *destination, const DFBRectang
 }
 
 static void
-back_to_front_copy( CoreSurface *surface, const DFBRegion *region, DFBSurfaceBlittingFlags flags, int rotation)
+back_to_front_copy( CoreSurface *surface, const DFBRegion *region, DFBSurfaceBlittingFlags flags )
 {
      DFBRectangle rect;
-     int          dx, dy;
 
      if (region) {
           rect.x = region->x1;
@@ -122,9 +121,6 @@ back_to_front_copy( CoreSurface *surface, const DFBRegion *region, DFBSurfaceBli
           rect.h = surface->config.size.h;
      }
 
-     dx = rect.x;
-     dy = rect.y;
-
      pthread_mutex_lock( &btf_lock );
 
      if (!btf_state_inited) {
@@ -143,30 +139,9 @@ back_to_front_copy( CoreSurface *surface, const DFBRegion *region, DFBSurfaceBli
      btf_state.source        = surface;
      btf_state.destination   = surface;
 
-
-     if (rotation == 90) {
-          dx = rect.y;
-          dy = surface->config.size.w - rect.w - rect.x;
-
-          flags |= DSBLIT_ROTATE90;
-     }
-     else if (rotation == 180) {
-          dx = surface->config.size.w - rect.w - rect.x;
-          dy = surface->config.size.h - rect.h - rect.y;
-
-          flags |= DSBLIT_ROTATE180;
-     }
-     else if (rotation == 270) {
-          dx = surface->config.size.h - rect.h - rect.y;
-          dy = rect.x;
-
-          flags |= DSBLIT_ROTATE270;
-     }
-
-
      dfb_state_set_blitting_flags( &btf_state, flags );
 
-     dfb_gfxcard_blit( &rect, dx, dy, &btf_state );
+     dfb_gfxcard_blit( &rect, rect.x, rect.y, &btf_state );
 
      /* Signal end of sequence. */
      dfb_state_stop_drawing( &btf_state );
@@ -177,13 +152,13 @@ back_to_front_copy( CoreSurface *surface, const DFBRegion *region, DFBSurfaceBli
 void
 dfb_back_to_front_copy( CoreSurface *surface, const DFBRegion *region )
 {
-     back_to_front_copy( surface, region, DSBLIT_NOFX, 0);
+     back_to_front_copy( surface, region, DSBLIT_NOFX );
 }
 
 void
-dfb_back_to_front_copy_rotation( CoreSurface *surface, const DFBRegion *region, int rotation )
+dfb_back_to_front_copy_180( CoreSurface *surface, const DFBRegion *region )
 {
-     back_to_front_copy( surface, region, DSBLIT_NOFX, rotation );
+     back_to_front_copy( surface, region, DSBLIT_ROTATE180 );
 }
 
 void
diff --git a/DirectFB-1.3.0/src/gfx/util.h b/DirectFB-1.3.0/src/gfx/util.h
index b2c0bed..7159760 100644
--- a/DirectFB-1.3.0/src/gfx/util.h
+++ b/DirectFB-1.3.0/src/gfx/util.h
@@ -34,7 +34,7 @@
 void dfb_gfx_copy( CoreSurface *source, CoreSurface *destination, const DFBRectangle *rect );
 void dfb_gfx_copy_to( CoreSurface *source, CoreSurface *destination, const DFBRectangle *rect, int x, int y, bool from_back );
 void dfb_back_to_front_copy( CoreSurface *surface, const DFBRegion *region );
-void dfb_back_to_front_copy_rotation( CoreSurface *surface, const DFBRegion *region, int rotation );
+void dfb_back_to_front_copy_180( CoreSurface *surface, const DFBRegion *region );
 void dfb_clear_depth( CoreSurface *surface, const DFBRegion *region );
 
 void dfb_sort_triangle( DFBTriangle *tri );
diff --git a/DirectFB-1.3.0/src/idirectfb.c b/DirectFB-1.3.0/src/idirectfb.c
index 59cbf4e..c2eef28 100644
--- a/DirectFB-1.3.0/src/idirectfb.c
+++ b/DirectFB-1.3.0/src/idirectfb.c
@@ -431,9 +431,9 @@ IDirectFB_CreateSurface( IDirectFB                    *thiz,
      int height = 256;
      DFBSurfacePixelFormat format;
      DFBSurfaceCapabilities caps = DSCAPS_NONE;
+     DFBDisplayLayerConfig  config;
      CoreSurface *surface = NULL;
      unsigned long resource_id = 0;
-     DFBDisplayLayerConfig  config;
 
      DIRECT_INTERFACE_GET_DATA(IDirectFB)
 
@@ -444,14 +444,7 @@ IDirectFB_CreateSurface( IDirectFB                    *thiz,
      else
           dfb_layer_context_get_configuration( data->context, &config );
 
-     if (desc->flags & DSDESC_HINTS && desc->hints & DSHF_FONT) {
-          format = dfb_config->font_format;
-
-          if (dfb_config->font_premult)
-               caps = DSCAPS_PREMULTIPLIED;
-     }
-     else
-          format = config.pixelformat;
+     format = config.pixelformat;
 
      if (!desc || !interface)
           return DFB_INVARG;
diff --git a/DirectFB-1.3.0/src/misc/conf.c b/DirectFB-1.3.0/src/misc/conf.c
index 16bc701..9d75f0b 100644
--- a/DirectFB-1.3.0/src/misc/conf.c
+++ b/DirectFB-1.3.0/src/misc/conf.c
@@ -34,7 +34,6 @@
 #include <string.h>
 
 #include <directfb.h>
-#include <directfb_util.h>
 
 #include <direct/conf.h>
 #include <direct/log.h>
@@ -84,7 +83,6 @@ static const char *config_usage =
      "  [no-]hardware                  Enable/disable hardware acceleration\n"
      "  [no-]software                  Enable/disable software fallbacks\n"
      "  [no-]software-warn             Show warnings when doing/dropping software operations\n"
-     "  [no-]software-trace            Show every stage of the software rendering pipeline\n"
      "  [no-]dma                       Enable DMA acceleration\n"
      "  [no-]sync                      Do `sync()' (default=no)\n"
 #ifdef USE_MMX
@@ -124,7 +122,7 @@ static const char *config_usage =
      "  layer-bg-tile=<filename>       Use tiled background image\n"
      "  layer-src-key=AARRGGBB         Enable color keying (hex)\n"
      "  layer-palette-<index>=AARRGGBB Set palette entry at index (hex)\n"
-     "  layer-rotate=<degree>          Set the layer rotation for double buffer mode (0,90,180,270)\n"
+     "  layer-rotate=<degree>          Set the layer rotation for double buffer mode (0/180)\n"
      "  [no-]smooth-upscale            Enable/disable smooth upscaling per default\n"
      "  [no-]smooth-downscale          Enable/disable smooth downscaling per default\n"
      "  [no-]translucent-windows       Allow translucent windows\n"
@@ -178,34 +176,100 @@ static const char *config_usage =
      "  vsync-none:    disable polling for vertical retrace.\n"
      "\n";
 
-/**********************************************************************************************************************/
+typedef struct {
+     const char            *string;
+     DFBSurfacePixelFormat  format;
+} FormatString;
+
+static const FormatString format_strings[] = {
+     { "A1",       DSPF_A1       },
+     { "A4",       DSPF_A4       },
+     { "A8",       DSPF_A8       },
+     { "ALUT44",   DSPF_ALUT44   },
+     { "ARGB",     DSPF_ARGB     },
+     { "ARGB1555", DSPF_ARGB1555 },
+     { "ARGB1666", DSPF_ARGB1666 },
+     { "ARGB2554", DSPF_ARGB2554 },
+     { "ARGB4444", DSPF_ARGB4444 },
+     { "ARGB6666", DSPF_ARGB6666 },
+     { "AYUV",     DSPF_AYUV     },
+     { "AiRGB",    DSPF_AiRGB    },
+     { "BGR555",   DSPF_BGR555   },
+     { "I420",     DSPF_I420     },
+     { "LUT2",     DSPF_LUT2     },
+     { "LUT8",     DSPF_LUT8     },
+     { "NV12",     DSPF_NV12     },
+     { "NV16",     DSPF_NV16     },
+     { "NV21",     DSPF_NV21     },
+     { "RGB16",    DSPF_RGB16    },
+     { "RGB18",    DSPF_RGB18    },
+     { "RGB24",    DSPF_RGB24    },
+     { "RGB32",    DSPF_RGB32    },
+     { "RGB332",   DSPF_RGB332   },
+     { "RGB444",   DSPF_RGB444   },
+     { "RGB555",   DSPF_RGB555   },
+     { "UYVY",     DSPF_UYVY     },
+     { "YUY2",     DSPF_YUY2     },
+     { "YV12",     DSPF_YV12     },
+};
+
+#define NUM_FORMAT_STRINGS D_ARRAY_SIZE(format_strings)
+
+static const FormatString font_format_strings[] = {
+     { "A1",       DSPF_A1       },
+     { "A4",       DSPF_A4       },
+     { "A8",       DSPF_A8       },
+     { "ARGB",     DSPF_ARGB     },
+     { "ARGB1555", DSPF_ARGB1555 },
+     { "ARGB2554", DSPF_ARGB2554 },
+     { "ARGB4444", DSPF_ARGB4444 },
+     { "AiRGB",    DSPF_AiRGB    },
+     { "LUT2",     DSPF_LUT2     }
+};
+
+#define NUM_FONT_FORMAT_STRINGS D_ARRAY_SIZE(font_format_strings)
 
 /* serial mouse device names */
 #define DEV_NAME     "/dev/mouse"
 #define DEV_NAME_GPM "/dev/gpmdata"
 
-/**********************************************************************************************************************/
+static const u8 lookup3to8[] = { 0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff };
+static const u8 lookup2to8[] = { 0x00, 0x55, 0xaa, 0xff };
+
+static int
+format_string_compare (const void *key,
+                       const void *base)
+{
+     return strcmp ((const char *) key, ((const FormatString *) base)->string);
+}
 
 DFBSurfacePixelFormat
 dfb_config_parse_pixelformat( const char *format )
 {
-     int    i;
-     size_t length = strlen(format);
+     FormatString *format_string;
 
-     for (i=0; dfb_pixelformat_names[i].format != DSPF_UNKNOWN; i++) {
-          if (!strcasecmp( format, dfb_pixelformat_names[i].name ))
-               return dfb_pixelformat_names[i].format;
-     }
+     format_string = bsearch( format, format_strings,
+                              NUM_FORMAT_STRINGS, sizeof(FormatString),
+                              format_string_compare );
+     if (!format_string)
+          return DSPF_UNKNOWN;
 
-     for (i=0; dfb_pixelformat_names[i].format != DSPF_UNKNOWN; i++) {
-          if (!strncasecmp( format, dfb_pixelformat_names[i].name, length ))
-               return dfb_pixelformat_names[i].format;
-     }
-
-     return DSPF_UNKNOWN;
+     return format_string->format;
 }
 
-/**********************************************************************************************************************/
+static DFBSurfacePixelFormat
+parse_font_format( const char *format )
+{
+     FormatString *format_string;
+
+     format_string = bsearch( format, font_format_strings,
+                              NUM_FONT_FORMAT_STRINGS, sizeof(FormatString),
+                              format_string_compare );
+     if (!format_string)
+          return DSPF_UNKNOWN;
+
+     return format_string->format;
+}
 
 static void
 print_config_usage( void )
@@ -383,7 +447,6 @@ static void config_allocate()
      dfb_config->i8xx_overlay_pipe_b      = false;
      dfb_config->surface_shmpool_size     = 64 * 1024 * 1024;
      dfb_config->keep_accumulators        = 1024;
-     dfb_config->font_format              = DSPF_A8;
 
      /* default to fbdev */
      dfb_config->system = D_STRDUP( "FBDev" );
@@ -501,7 +564,7 @@ DFBResult dfb_config_set( const char *name, const char *value )
           if (value) {
                DFBSurfacePixelFormat format;
 
-               format = dfb_config_parse_pixelformat( value );
+               format = parse_font_format( value );
                if (format == DSPF_UNKNOWN) {
                     D_ERROR("DirectFB/Config 'font-format': Could not parse format!\n");
                     return DFB_INVARG;
@@ -645,12 +708,6 @@ DFBResult dfb_config_set( const char *name, const char *value )
      if (strcmp (name, "no-software-warn" ) == 0) {
           dfb_config->software_warn = false;
      } else
-     if (strcmp (name, "software-trace" ) == 0) {
-          dfb_config->software_trace = true;
-     } else
-     if (strcmp (name, "no-software-trace" ) == 0) {
-          dfb_config->software_trace = false;
-     } else
      if (strcmp (name, "warn" ) == 0 || strcmp (name, "no-warn" ) == 0) {
           /* Enable/disable all at once by default. */
           DFBConfigWarnFlags flags = DMT_ALL;
@@ -1296,8 +1353,8 @@ DFBResult dfb_config_set( const char *name, const char *value )
                     return DFB_INVARG;
                }
 
-               if (rotate != 0 && rotate != 90 && rotate != 180 && rotate != 270) {
-                    D_ERROR("DirectFB/Config '%s': Only 0, 90, 180 or 270 supported!\n", name);
+               if (rotate != 0 && rotate != 180) {
+                    D_ERROR("DirectFB/Config '%s': Only 0 and 180 supported yet!\n", name);
                     return DFB_UNSUPPORTED;
                }
 
diff --git a/DirectFB-1.3.0/src/misc/conf.h b/DirectFB-1.3.0/src/misc/conf.h
index a46919b..506e6f2 100644
--- a/DirectFB-1.3.0/src/misc/conf.h
+++ b/DirectFB-1.3.0/src/misc/conf.h
@@ -237,8 +237,6 @@ typedef struct
      } warn;
 
      int           keep_accumulators;             /* Free accumulators above this limit */
-
-     bool          software_trace;
 } DFBConfig;
 
 extern DFBConfig *dfb_config;
diff --git a/DirectFB-1.3.0/src/misc/gfx_util.c b/DirectFB-1.3.0/src/misc/gfx_util.c
index 20aa028..ce0e38e 100644
--- a/DirectFB-1.3.0/src/misc/gfx_util.c
+++ b/DirectFB-1.3.0/src/misc/gfx_util.c
@@ -379,13 +379,8 @@ static void write_argb_span (u32 *src, u8 *dst[], int len,
                     d[i+1] = y1;
                                   
                     if (dst_surface->config.format == DSPF_NV16 || dy & 1) {
-#ifdef WORDS_BIGENDIAN
-                         ((u16*)d1)[i>>1] =    ((v0 + v1) >> 1)     |
-                                              (((u0 + u1) >> 1) << 8);
-#else
                          ((u16*)d1)[i>>1] =    ((u0 + u1) >> 1)     |
                                               (((v0 + v1) >> 1) << 8);
-#endif
                     }
                }
                if (len & 1) {
@@ -399,11 +394,7 @@ static void write_argb_span (u32 *src, u8 *dst[], int len,
                                   
                     d[i] = y;
                     if (dst_surface->config.format == DSPF_NV16 || dy & 1)
-#ifdef WORDS_BIGENDIAN
-                         ((u16*)d1)[i>>1] = v | (u << 8);
-#else
                          ((u16*)d1)[i>>1] = u | (v << 8);
-#endif
                }
                break;
                
@@ -424,13 +415,8 @@ static void write_argb_span (u32 *src, u8 *dst[], int len,
                     d[i+1] = y1;
                                   
                     if (dy & 1) {
-#ifdef WORDS_BIGENDIAN
-                         ((u16*)d1)[i>>1] =    ((u0 + u1) >> 1)     |
-                                              (((v0 + v1) >> 1) << 8);
-#else
                          ((u16*)d1)[i>>1] =    ((v0 + v1) >> 1)     |
                                               (((u0 + u1) >> 1) << 8);
-#endif
                     }
                }
                if (len & 1) {
@@ -444,11 +430,7 @@ static void write_argb_span (u32 *src, u8 *dst[], int len,
                                   
                     d[i] = y;
                     if (dy & 1)
-#ifdef WORDS_BIGENDIAN
-                         ((u16*)d1)[i>>1] = u | (v << 8);
-#else
                          ((u16*)d1)[i>>1] = v | (u << 8);
-#endif
                }  
                break;
 
diff --git a/DirectFB-1.3.0/src/misc/util.c b/DirectFB-1.3.0/src/misc/util.c
index 7e03331..010f9fe 100644
--- a/DirectFB-1.3.0/src/misc/util.c
+++ b/DirectFB-1.3.0/src/misc/util.c
@@ -47,12 +47,6 @@
 
 D_DEBUG_DOMAIN( DFB_Updates, "DirectFB/Updates", "DirectFB Updates" );
 
-/**********************************************************************************************************************/
-
-const DirectFBPixelFormatNames( dfb_pixelformat_names );
-
-/**********************************************************************************************************************/
-
 bool
 dfb_region_intersect( DFBRegion *region,
                       int x1, int y1, int x2, int y2 )
@@ -428,44 +422,3 @@ dfb_updates_stat( DFBUpdates *updates,
                           (updates->bounding.y2 - updates->bounding.y1 + 1);
 }
 
-void
-dfb_updates_get_rectangles( DFBUpdates   *updates,
-                            DFBRectangle *ret_rects,
-                            int          *ret_num )
-{
-     D_MAGIC_ASSERT( updates, DFBUpdates );
-     D_ASSERT( updates->regions != NULL );
-     D_ASSERT( updates->num_regions >= 0 );
-     D_ASSERT( updates->num_regions <= updates->max_regions );
-
-     switch (updates->num_regions) {
-          case 0:
-               *ret_num = 0;
-               break;
-
-          default: {
-               int n, d, total, bounding;
-
-               dfb_updates_stat( updates, &total, &bounding );
-
-               n = updates->max_regions - updates->num_regions + 1;
-               d = n + 1;
-
-               /* Try to optimize updates. Use individual regions only if not too much overhead. */
-               if (total < bounding * n / d) {
-                    *ret_num = updates->num_regions;
-
-                    for (n=0; n<updates->num_regions; n++)
-                         ret_rects[n] = DFB_RECTANGLE_INIT_FROM_REGION( &updates->regions[n] );
-
-                    break;
-               }
-          }
-          /* fall through */
-
-          case 1:
-               *ret_num   = 1;
-               *ret_rects = DFB_RECTANGLE_INIT_FROM_REGION( &updates->bounding );
-               break;
-     }
-}
diff --git a/DirectFB-1.3.0/src/windows/idirectfbwindow.c b/DirectFB-1.3.0/src/windows/idirectfbwindow.c
index 203ba44..3a14bde 100644
--- a/DirectFB-1.3.0/src/windows/idirectfbwindow.c
+++ b/DirectFB-1.3.0/src/windows/idirectfbwindow.c
@@ -1199,16 +1199,6 @@ IDirectFBWindow_SetDstGeometry( IDirectFBWindow         *thiz,
 }
 
 DFBResult
-IDirectFBWindow_SetRotation(IDirectFBWindow *thiz,
-                          int rotation)
-{
-
-     DIRECT_INTERFACE_GET_DATA(IDirectFBWindow)
-
-     return dfb_window_set_rotation( data->window, rotation % 360 );     
- }
-
-DFBResult
 IDirectFBWindow_Construct( IDirectFBWindow *thiz,
                            CoreWindow      *window,
                            CoreLayer       *layer,
@@ -1276,7 +1266,6 @@ IDirectFBWindow_Construct( IDirectFBWindow *thiz,
      thiz->UngrabUnselectedKeys = IDirectFBWindow_UngrabUnselectedKeys;
      thiz->SetSrcGeometry = IDirectFBWindow_SetSrcGeometry;
      thiz->SetDstGeometry = IDirectFBWindow_SetDstGeometry;
-     thiz->SetRotation = IDirectFBWindow_SetRotation;
 
      return DFB_OK;
 }
diff --git a/DirectFB-1.3.0/systems/devmem/devmem_surface_pool.c b/DirectFB-1.3.0/systems/devmem/devmem_surface_pool.c
index 0c54404..67ca610 100644
--- a/DirectFB-1.3.0/systems/devmem/devmem_surface_pool.c
+++ b/DirectFB-1.3.0/systems/devmem/devmem_surface_pool.c
@@ -115,21 +115,10 @@ devmemInitPool( CoreDFB                    *core,
      if (ret)
           return ret;
 
-     ret_desc->caps              = CSPCAPS_PHYSICAL | CSPCAPS_VIRTUAL;
-     ret_desc->access[CSAID_CPU] = CSAF_READ | CSAF_WRITE | CSAF_SHARED;
-     ret_desc->access[CSAID_GPU] = CSAF_READ | CSAF_WRITE | CSAF_SHARED;
-     ret_desc->types             = CSTF_LAYER | CSTF_WINDOW | CSTF_CURSOR | CSTF_FONT | CSTF_SHARED | CSTF_EXTERNAL;
-     ret_desc->priority          = CSPP_DEFAULT;
-
-     /* For hardware layers */
-     ret_desc->access[CSAID_LAYER0] = CSAF_READ;
-     ret_desc->access[CSAID_LAYER1] = CSAF_READ;
-     ret_desc->access[CSAID_LAYER2] = CSAF_READ;
-     ret_desc->access[CSAID_LAYER3] = CSAF_READ;
-     ret_desc->access[CSAID_LAYER4] = CSAF_READ;
-     ret_desc->access[CSAID_LAYER5] = CSAF_READ;
-     ret_desc->access[CSAID_LAYER6] = CSAF_READ;
-     ret_desc->access[CSAID_LAYER7] = CSAF_READ;
+     ret_desc->caps     = CSPCAPS_NONE;
+     ret_desc->access   = CSAF_CPU_READ | CSAF_CPU_WRITE | CSAF_GPU_READ | CSAF_GPU_WRITE | CSAF_SHARED;
+     ret_desc->types    = CSTF_LAYER | CSTF_WINDOW | CSTF_CURSOR | CSTF_FONT | CSTF_SHARED | CSTF_EXTERNAL;
+     ret_desc->priority = CSPP_DEFAULT;
 
      snprintf( ret_desc->name, DFB_SURFACE_POOL_DESC_NAME_LENGTH, "/dev/mem" );
 
diff --git a/DirectFB-1.3.0/systems/fbdev/fb.h b/DirectFB-1.3.0/systems/fbdev/fb.h
index 6cc1399..0d492dd 100644
--- a/DirectFB-1.3.0/systems/fbdev/fb.h
+++ b/DirectFB-1.3.0/systems/fbdev/fb.h
@@ -132,6 +132,8 @@
 #define FB_ACCEL_PROSAVAGE_DDR  0x8d	/* S3 ProSavage DDR             */
 #define FB_ACCEL_PROSAVAGE_DDRK 0x8e	/* S3 ProSavage DDR-K           */
 
+#define FB_ACCEL_CX2450X	0x90	/* Conexant CX2450X		*/
+
 struct fb_fix_screeninfo {
 	char id[16];			/* identification string eg "TT Builtin" */
 	unsigned long smem_start;	/* Start of frame buffer mem */
diff --git a/DirectFB-1.3.0/systems/fbdev/fbdev.c b/DirectFB-1.3.0/systems/fbdev/fbdev.c
index d709cb3..0f3144b 100644
--- a/DirectFB-1.3.0/systems/fbdev/fbdev.c
+++ b/DirectFB-1.3.0/systems/fbdev/fbdev.c
@@ -825,6 +825,11 @@ system_get_accelerator()
 	  return FB_ACCEL_EP9X;
 #endif
 
+#ifdef FB_ACCEL_CX2450X
+     if (!strcmp( dfb_fbdev->shared->fix.id, "CX2450X" ))
+	  return FB_ACCEL_CX2450X;
+#endif
+
      if (dfb_fbdev->shared->fix.mmio_len > 0)
           return dfb_fbdev->shared->fix.accel;
      return -1;
diff --git a/DirectFB-1.3.0/systems/fbdev/fbdev_surface_pool.c b/DirectFB-1.3.0/systems/fbdev/fbdev_surface_pool.c
index 3e91eab..089bcfa 100644
--- a/DirectFB-1.3.0/systems/fbdev/fbdev_surface_pool.c
+++ b/DirectFB-1.3.0/systems/fbdev/fbdev_surface_pool.c
@@ -113,21 +113,10 @@ fbdevInitPool( CoreDFB                    *core,
      if (ret)
           return ret;
 
-     ret_desc->caps              = CSPCAPS_PHYSICAL | CSPCAPS_VIRTUAL;
-     ret_desc->access[CSAID_CPU] = CSAF_READ | CSAF_WRITE | CSAF_SHARED;
-     ret_desc->access[CSAID_GPU] = CSAF_READ | CSAF_WRITE | CSAF_SHARED;
-     ret_desc->types             = CSTF_LAYER | CSTF_WINDOW | CSTF_CURSOR | CSTF_FONT | CSTF_SHARED | CSTF_EXTERNAL;
-     ret_desc->priority          = CSPP_DEFAULT;
-
-     /* For hardware layers */
-     ret_desc->access[CSAID_LAYER0] = CSAF_READ;
-     ret_desc->access[CSAID_LAYER1] = CSAF_READ;
-     ret_desc->access[CSAID_LAYER2] = CSAF_READ;
-     ret_desc->access[CSAID_LAYER3] = CSAF_READ;
-     ret_desc->access[CSAID_LAYER4] = CSAF_READ;
-     ret_desc->access[CSAID_LAYER5] = CSAF_READ;
-     ret_desc->access[CSAID_LAYER6] = CSAF_READ;
-     ret_desc->access[CSAID_LAYER7] = CSAF_READ;
+     ret_desc->caps     = CSPCAPS_NONE;
+     ret_desc->access   = CSAF_CPU_READ | CSAF_CPU_WRITE | CSAF_GPU_READ | CSAF_GPU_WRITE | CSAF_SHARED;
+     ret_desc->types    = CSTF_LAYER | CSTF_WINDOW | CSTF_CURSOR | CSTF_FONT | CSTF_SHARED | CSTF_EXTERNAL;
+     ret_desc->priority = CSPP_DEFAULT;
 
      snprintf( ret_desc->name, DFB_SURFACE_POOL_DESC_NAME_LENGTH, "Frame Buffer Memory" );
 
diff --git a/DirectFB-1.3.0/systems/sdl/primary.c b/DirectFB-1.3.0/systems/sdl/primary.c
index bf8bf96..3c60760 100644
--- a/DirectFB-1.3.0/systems/sdl/primary.c
+++ b/DirectFB-1.3.0/systems/sdl/primary.c
@@ -389,15 +389,47 @@ update_screen( int x, int y, int w, int h )
 
      D_DEBUG_AT( SDL_Updates, "  -> copying pixels...\n" );
 
-     switch (screen->format->BitsPerPixel) {
-          case 16:
-               dfb_convert_to_rgb16( surface->config.format,
-                                     src, lock.pitch, surface->config.size.h,
-                                     dst, screen->pitch, w, h );
-               break;
+     for (i=0; i<h; ++i) {
+          switch (screen->format->BitsPerPixel) {
+               case 16:
+                    switch (surface->config.format) {
+                         case DSPF_RGB16:
+                              direct_memcpy( dst, src, DFB_BYTES_PER_LINE( surface->config.format, w ) );
+                              break;
+
+                         case DSPF_NV16:
+                              src8  = src;
+                              src16 = src + surface->config.size.h * lock.pitch;
+                              dst16 = dst;
+
+                              for (n=0; n<w; n++) {
+                                   int r, g, b;
+
+                                   YCBCR_TO_RGB( src8[n], src16[n>>1] & 0xff, src16[n>>1] >> 8, r, g, b );
+
+                                   dst16[n] = PIXEL_RGB16( r, g, b );
+                              }
+                              break;
+
+                         case DSPF_RGB444:
+                         case DSPF_ARGB4444:
+                              src16 = src;
+                              dst16 = dst;
+
+                              for (n=0; n<w; n++)
+                                   dst16[n] = PIXEL_RGB16( ((src16[n] & 0x0F00) >> 4) | ((src16[n] & 0x0F00) >> 8),
+                                                           ((src16[n] & 0x00F0)     ) | ((src16[n] & 0x00F0) >> 4),
+                                                           ((src16[n] & 0x000F) << 4) | ((src16[n] & 0x000F)     ) );
+                              break;
+                    }
+                    break;
+
+               default:
+                    direct_memcpy( dst, src, DFB_BYTES_PER_LINE( surface->config.format, w ) );
+          }
 
-          default:
-               direct_memcpy( dst, src, DFB_BYTES_PER_LINE( surface->config.format, w ) );
+          src += lock.pitch;
+          dst += screen->pitch;
      }
 
      D_DEBUG_AT( SDL_Updates, "  -> unlocking dfb surface...\n" );
diff --git a/DirectFB-1.3.0/systems/sdl/sdl_surface_pool.c b/DirectFB-1.3.0/systems/sdl/sdl_surface_pool.c
index c2d753d..8b0be23 100644
--- a/DirectFB-1.3.0/systems/sdl/sdl_surface_pool.c
+++ b/DirectFB-1.3.0/systems/sdl/sdl_surface_pool.c
@@ -81,11 +81,10 @@ sdlInitPool( CoreDFB                    *core,
      D_MAGIC_ASSERT( pool, CoreSurfacePool );
      D_ASSERT( ret_desc != NULL );
 
-     ret_desc->caps              = CSPCAPS_NONE;
-     ret_desc->access[CSAID_CPU] = CSAF_READ | CSAF_WRITE;
-     ret_desc->access[CSAID_GPU] = CSAF_READ | CSAF_WRITE;
-     ret_desc->types             = CSTF_LAYER | CSTF_WINDOW | CSTF_CURSOR | CSTF_FONT | CSTF_SHARED | CSTF_EXTERNAL;
-     ret_desc->priority          = CSPP_PREFERED;
+     ret_desc->caps     = CSPCAPS_NONE;
+     ret_desc->access   = CSAF_CPU_READ | CSAF_CPU_WRITE | CSAF_GPU_READ | CSAF_GPU_WRITE;
+     ret_desc->types    = CSTF_LAYER | CSTF_WINDOW | CSTF_CURSOR | CSTF_FONT | CSTF_SHARED | CSTF_EXTERNAL;
+     ret_desc->priority = CSPP_PREFERED;
 
      snprintf( ret_desc->name, DFB_SURFACE_POOL_DESC_NAME_LENGTH, "SDL" );
 
diff --git a/DirectFB-1.3.0/systems/vnc/primary.c b/DirectFB-1.3.0/systems/vnc/primary.c
index 81ce874..c819d2f 100644
--- a/DirectFB-1.3.0/systems/vnc/primary.c
+++ b/DirectFB-1.3.0/systems/vnc/primary.c
@@ -416,7 +416,7 @@ update_screen( CoreSurface *surface, int x, int y, int w, int h )
      D_ASSERT( rfb_screen != NULL );
      D_ASSERT( rfb_screen->frameBuffer != NULL );
 
-     ret = dfb_surface_lock_buffer( surface, CSBR_FRONT, CSAID_CPU, CSAF_READ, &lock );
+     ret = dfb_surface_lock_buffer( surface, CSBR_FRONT, CSAF_CPU_READ, &lock );
      if (ret) {
           D_DERROR( ret, "DirectFB/VNC: Couldn't lock layer surface!\n" );
           return ret;
diff --git a/DirectFB-1.3.0/systems/x11/Makefile.am b/DirectFB-1.3.0/systems/x11/Makefile.am
index 23c0b88..6582c24 100644
--- a/DirectFB-1.3.0/systems/x11/Makefile.am
+++ b/DirectFB-1.3.0/systems/x11/Makefile.am
@@ -6,7 +6,6 @@ INCLUDES = \
 	-I$(top_builddir)/lib		\
 	-I$(top_srcdir)/lib		\
 	-I$(top_srcdir)/src		\
-	-I$(top_srcdir)/gfxdrivers	\
 	$(X11_CFLAGS)
 
 
@@ -18,15 +17,12 @@ endif
 
 systems_LTLIBRARIES = libdirectfb_x11.la
 
+
 libdirectfb_x11_la_LDFLAGS = \
 	$(X11_LIBS)	\
 	-avoid-version	\
 	-module
 
-if GFX_GLX
-libdirectfb_x11_la_LDFLAGS += -lGL
-endif
-
 libdirectfb_x11_la_SOURCES = \
 	primary.c		\
 	primary.h		\
@@ -41,18 +37,9 @@ libdirectfb_x11_la_SOURCES = \
 	x11input.c		\
 	x11_surface_pool.c	\
 	x11_surface_pool.h	\
-	x11types.h		\
 	xwindow.h		\
 	xwindow.c
 
-if GFX_GLX
-libdirectfb_x11_la_SOURCES += \
-	glx_surface_pool.c	\
-	glx_surface_pool.h	\
-	x11_surface_pool_bridge.c	\
-	x11_surface_pool_bridge.h
-endif
-
 libdirectfb_x11_la_LIBADD = \
 	$(top_builddir)/lib/direct/libdirect.la \
 	$(top_builddir)/lib/fusion/libfusion.la \
diff --git a/DirectFB-1.3.0/systems/x11/primary.c b/DirectFB-1.3.0/systems/x11/primary.c
index 629bb61..139c01d 100644
--- a/DirectFB-1.3.0/systems/x11/primary.c
+++ b/DirectFB-1.3.0/systems/x11/primary.c
@@ -56,14 +56,10 @@
 #include <direct/memcpy.h>
 #include <direct/messages.h>
 
+
 #include <string.h>
 #include <stdlib.h>
 
-#ifdef USE_GLX
-#include <GL/glx.h>
-#include "glx_surface_pool.h"
-#endif
-
 #include "xwindow.h"
 #include "x11.h"
 #include "primary.h"
@@ -75,64 +71,56 @@ D_DEBUG_DOMAIN( X11_Update, "X11/Update", "X11 Update" );
 /**********************************************************************************************************************/
 
 static DFBResult
-dfb_x11_create_window( DFBX11 *x11, const CoreLayerRegionConfig *config )
+dfb_x11_create_window( const CoreLayerRegionConfig *config )
 {
-     int           ret;
-     DFBX11Shared *shared = x11->shared;
+     int ret;
 
      D_ASSERT( config != NULL );
 
-     shared->setmode.config = *config;
+     dfb_x11->setmode.config = *config;
 
-     if (fusion_call_execute( &shared->call, FCEF_NONE, X11_CREATE_WINDOW, &shared->setmode, &ret ))
+     if (fusion_call_execute( &dfb_x11->call, FCEF_NONE, X11_CREATE_WINDOW, &dfb_x11->setmode, &ret ))
           return DFB_FUSION;
 
      return ret;
 }
 
 static DFBResult
-dfb_x11_destroy_window( DFBX11 *x11 )
+dfb_x11_destroy_window()
 {
-     int           ret;
-     DFBX11Shared *shared = x11->shared;
+     int ret;
 
-     if (fusion_call_execute( &shared->call, FCEF_NONE, X11_DESTROY_WINDOW, NULL, &ret ))
+     if (fusion_call_execute( &dfb_x11->call, FCEF_NONE, X11_DESTROY_WINDOW, NULL, &ret ))
           return DFB_FUSION;
 
      return ret;
 }
 
 static DFBResult
-dfb_x11_update_screen( DFBX11 *x11, const DFBRegion *region, CoreSurfaceBufferLock *lock )
+dfb_x11_update_screen( const DFBRegion *region, CoreSurfaceBufferLock *lock )
 {
-     int           ret;
-     DFBX11Shared *shared = x11->shared;
+     int ret;
 
      DFB_REGION_ASSERT( region );
      D_ASSERT( lock != NULL );
 
-     /* FIXME: Just a hot fix! */
-     while (shared->update.lock)
-          usleep( 10000 );
-
-     shared->update.region = *region;
-     shared->update.lock   = lock;
+     dfb_x11->update.region = *region;
+     dfb_x11->update.lock   = lock;
 
-     if (fusion_call_execute( &shared->call, FCEF_NONE, X11_UPDATE_SCREEN, &shared->update, &ret ))
+     if (fusion_call_execute( &dfb_x11->call, FCEF_NONE, X11_UPDATE_SCREEN, &dfb_x11->update, &ret ))
           return DFB_FUSION;
 
      return ret;
 }
 
 static DFBResult
-dfb_x11_set_palette( DFBX11 *x11, CorePalette *palette )
+dfb_x11_set_palette( CorePalette *palette )
 {
-     int           ret;
-     DFBX11Shared *shared = x11->shared;
+     int ret;
 
      D_ASSERT( palette != NULL );
 
-     if (fusion_call_execute( &shared->call, FCEF_NONE, X11_SET_PALETTE, palette, &ret ))
+     if (fusion_call_execute( &dfb_x11->call, FCEF_NONE, X11_SET_PALETTE, palette, &ret ))
           return DFB_FUSION;
 
      return ret;
@@ -164,11 +152,23 @@ primaryGetScreenSize( CoreScreen *screen,
                       int        *ret_width,
                       int        *ret_height )
 {
-     DFBX11       *x11    = driver_data;
-     DFBX11Shared *shared = x11->shared;
+     D_ASSERT( dfb_x11 != NULL );
 
-     *ret_width  = shared->screen_size.w;
-     *ret_height = shared->screen_size.h;
+     if (dfb_x11->primary) {
+          *ret_width  = dfb_x11->primary->config.size.w;
+          *ret_height = dfb_x11->primary->config.size.h;
+     }
+     else {
+          if (dfb_config->mode.width)
+               *ret_width  = dfb_config->mode.width;
+          else
+               *ret_width  = 640;
+
+          if (dfb_config->mode.height)
+               *ret_height = dfb_config->mode.height;
+          else
+               *ret_height = 480;
+     }
 
      return DFB_OK;
 }
@@ -200,9 +200,6 @@ primaryInitLayer( CoreLayer                  *layer,
                   DFBDisplayLayerConfig      *config,
                   DFBColorAdjustment         *adjustment )
 {
-     DFBX11       *x11    = driver_data;
-     DFBX11Shared *shared = x11->shared;
-
      /* set capabilities and type */
      description->caps = DLCAPS_SURFACE;
      description->type = DLTF_GRAPHICS;
@@ -219,19 +216,19 @@ primaryInitLayer( CoreLayer                  *layer,
      if (dfb_config->mode.width)
           config->width  = dfb_config->mode.width;
      else
-          config->width  = shared->screen_size.w;
+          config->width  = 640;
 
      if (dfb_config->mode.height)
           config->height = dfb_config->mode.height;
      else
-          config->height = shared->screen_size.h;
+          config->height = 480;
 
      if (dfb_config->mode.format != DSPF_UNKNOWN)
           config->pixelformat = dfb_config->mode.format;
      else if (dfb_config->mode.depth > 0)
           config->pixelformat = dfb_pixelformat_for_depth( dfb_config->mode.depth );
      else {
-          int depth = DefaultDepthOfScreen( x11->screenptr );
+          int depth = DefaultDepth( dfb_x11->display, DefaultScreen(dfb_x11->display) );
 
           switch (depth) {
                case 15:
@@ -248,7 +245,8 @@ primaryInitLayer( CoreLayer                  *layer,
                     break;
                default:
                     printf(" Unsupported X11 screen depth %d \n",depth);
-                    return DFB_UNSUPPORTED;
+                    exit(-1);
+                    break;
           }
      }
 
@@ -327,15 +325,17 @@ primarySetRegion( CoreLayer                  *layer,
                   CorePalette                *palette,
                   CoreSurfaceBufferLock      *lock )
 {
-     DFBResult  ret;
-     DFBX11    *x11 = driver_data;
+     DFBResult ret;
 
-     ret = dfb_x11_create_window( x11, config );
+     ret = dfb_x11_create_window( config );
      if (ret)
           return ret;
 
+     if (surface)
+          dfb_x11->primary = surface;
+
      if (palette)
-          dfb_x11_set_palette( x11, palette );
+          dfb_x11_set_palette( palette );
 
      return DFB_OK;
 }
@@ -346,9 +346,9 @@ primaryRemoveRegion( CoreLayer             *layer,
                      void                  *layer_data,
                      void                  *region_data )
 {
-     DFBX11 *x11 = driver_data;
+     dfb_x11_destroy_window();
 
-     dfb_x11_destroy_window( x11 );
+     dfb_x11->primary = NULL;
 
      return DFB_OK;
 }
@@ -362,12 +362,11 @@ primaryFlipRegion( CoreLayer             *layer,
                    DFBSurfaceFlipFlags    flags,
                    CoreSurfaceBufferLock *lock )
 {
-     DFBX11    *x11    = driver_data;
-     DFBRegion  region = DFB_REGION_INIT_FROM_DIMENSION( &surface->config.size );
+     DFBRegion region = DFB_REGION_INIT_FROM_DIMENSION( &surface->config.size );
 
      dfb_surface_flip( surface, false );
 
-     return dfb_x11_update_screen( x11, &region, lock );
+     return dfb_x11_update_screen( &region, lock );
 }
 
 static DFBResult
@@ -379,13 +378,9 @@ primaryUpdateRegion( CoreLayer             *layer,
                      const DFBRegion       *update,
                      CoreSurfaceBufferLock *lock )
 {
-     DFBX11    *x11    = driver_data;
-     DFBRegion  region = DFB_REGION_INIT_FROM_DIMENSION( &surface->config.size );
-
-     if (update && !dfb_region_region_intersect( &region, update ))
-          return DFB_OK;
+     DFBRegion region = DFB_REGION_INIT_FROM_DIMENSION( &surface->config.size );
 
-     return dfb_x11_update_screen( x11, &region, lock );
+     return dfb_x11_update_screen( update ? : &region, lock );
 }
 
 DisplayLayerFuncs x11PrimaryLayerFuncs = {
@@ -404,92 +399,48 @@ DisplayLayerFuncs x11PrimaryLayerFuncs = {
 /******************************************************************************/
 
 static DFBResult
-update_screen( DFBX11 *x11, const DFBRectangle *clip, CoreSurfaceBufferLock *lock )
+update_screen( CoreSurface *surface, const DFBRectangle *clip, CoreSurfaceBufferLock *lock )
 {
      void                  *dst;
      void                  *src;
      unsigned int           offset = 0;
-     XWindow               *xw;
+     XWindow               *xw     = dfb_x11->xw;
      XImage                *ximage;
-     CoreSurface           *surface;
      CoreSurfaceAllocation *allocation;
-     DFBX11Shared          *shared;
      DFBRectangle           rect;
-     bool                   direct = false;
 
-     D_ASSERT( x11 != NULL );
-     DFB_RECTANGLE_ASSERT( clip );
+     D_ASSERT( clip != NULL );
+     D_ASSERT( xw != NULL );
 
      D_DEBUG_AT( X11_Update, "%s( %4d,%4d-%4dx%4d )\n", __FUNCTION__, DFB_RECTANGLE_VALS( clip ) );
 
+     D_ASSERT( surface != NULL );
      CORE_SURFACE_BUFFER_LOCK_ASSERT( lock );
 
-     shared = x11->shared;
-     D_ASSERT( shared != NULL );
-
-     XLockDisplay( x11->display );
-
-     xw = shared->xw;
-     if (!xw) {
-          XUnlockDisplay( x11->display );
-          return DFB_OK;
-     }
-
      allocation = lock->allocation;
      CORE_SURFACE_ALLOCATION_ASSERT( allocation );
 
-     surface = allocation->surface;
-     D_ASSERT( surface != NULL );
-
+     XLockDisplay( dfb_x11->display );
 
      rect.x = rect.y = 0;
      rect.w = xw->width;
      rect.h = xw->height;
 
      if (!dfb_rectangle_intersect( &rect, clip )) {
-          XUnlockDisplay( x11->display );
+          XUnlockDisplay( dfb_x11->display );
           return DFB_OK;
      }
 
      D_DEBUG_AT( X11_Update, "  -> %4d,%4d-%4dx%4d\n", DFB_RECTANGLE_VALS( &rect ) );
 
-#ifdef USE_GLX
-     /* Check for GLX allocation... */
-     if (allocation->pool == shared->glx_pool && lock->handle) {
-          LocalPixmap *pixmap = lock->handle;
-
-          D_MAGIC_ASSERT( pixmap, LocalPixmap );
-
-          /* ...and just call SwapBuffers... */
-          //D_DEBUG_AT( X11_Update, "  -> Calling glXSwapBuffers( 0x%lx )...\n", alloc->drawable );
-          //glXSwapBuffers( x11->display, alloc->drawable );
-
-
-          D_DEBUG_AT( X11_Update, "  -> Copying from GLXPixmap...\n" );
-
-          glXWaitGL();
-
-          XCopyArea( x11->display, pixmap->pixmap, xw->window, xw->gc,
-                     rect.x, rect.y, rect.w, rect.h, rect.x, rect.y );
-
-          glXWaitX();
-
-          XUnlockDisplay( x11->display );
-
-          return DFB_OK;
-     }
-#endif
-
      /* Check for our special native allocation... */
-     if (allocation->pool == shared->x11image_pool && lock->handle) {
+     if (allocation->pool == dfb_x11->x11image_pool && lock->handle) {
           x11Image *image = lock->handle;
 
           D_MAGIC_ASSERT( image, x11Image );
 
           /* ...and directly XShmPutImage from that. */
           ximage = image->ximage;
-
-          direct = true;
      }
      else {
           /* ...or copy or convert into XShmImage or XImage allocated with the XWindow. */
@@ -531,27 +482,23 @@ update_screen( DFBX11 *x11, const DFBRectangle *clip, CoreSurfaceBufferLock *loc
 
 
      /* Wait for previous data to be processed... */
-     XSync( x11->display, False );
+     XSync( dfb_x11->display, False );
 
      /* ...and immediately queue or send the next! */
-     if (x11->use_shm) {
+     if (dfb_x11->use_shm) {
           /* Just queue the command, it's XShm :) */
           XShmPutImage( xw->display, xw->window, xw->gc, ximage,
                         rect.x, rect.y + offset, rect.x, rect.y, rect.w, rect.h, False );
 
           /* Make sure the queue has really happened! */
-          XFlush( x11->display );
+          XFlush( dfb_x11->display );
      }
      else
           /* Initiate transfer of buffer... */
           XPutImage( xw->display, xw->window, xw->gc, ximage,
                      rect.x, rect.y + offset, rect.x, rect.y, rect.w, rect.h );
 
-     /* Wait for display if single buffered and not converted... */
-     if (direct && !(surface->config.caps & DSCAPS_FLIPPING))
-          XSync( x11->display, False );
-
-     XUnlockDisplay( x11->display );
+     XUnlockDisplay( dfb_x11->display );
 
      return DFB_OK;
 }
@@ -559,70 +506,65 @@ update_screen( DFBX11 *x11, const DFBRectangle *clip, CoreSurfaceBufferLock *loc
 /******************************************************************************/
 
 DFBResult
-dfb_x11_create_window_handler( DFBX11 *x11, CoreLayerRegionConfig *config )
+dfb_x11_create_window_handler( CoreLayerRegionConfig *config )
 {
-     XWindow      *xw;
-     DFBX11Shared *shared = x11->shared;
+     XWindow *xw;
 
      D_DEBUG_AT( X11_Window, "%s( %p )\n", __FUNCTION__, config );
 
      D_DEBUG_AT( X11_Window, "  -> %4dx%4d %s\n", config->width, config->height, dfb_pixelformat_name(config->format) );
 
-     XLockDisplay( x11->display );
+     XLockDisplay( dfb_x11->display );
 
-     xw = shared->xw;
+     xw = dfb_x11->xw;
      if (xw != NULL) {
           if (xw->width == config->width && xw->height == config->height) {
-               XUnlockDisplay( x11->display );
+               XUnlockDisplay( dfb_x11->display );
                return DFB_OK;
           }
 
-          shared->xw = NULL;
-          dfb_x11_close_window( x11, xw );
+          dfb_x11_close_window( xw );
+          dfb_x11->xw = NULL;
      }
 
-     bool bSucces = dfb_x11_open_window( x11, &xw, 0, 0, config->width, config->height, config->format );
+     bool bSucces = dfb_x11_open_window(&xw, 0, 0, config->width, config->height);
 
      /* Set video mode */
      if ( !bSucces ) {
-          D_ERROR( "DirectFB/X11: Couldn't open %dx%d window!\n", config->width, config->height );
+          D_ERROR( "ML: DirectFB/X11: Couldn't open %dx%d window: %s\n",
+                   config->width, config->height, "X11 error!");
 
-          XUnlockDisplay( x11->display );
+          XUnlockDisplay( dfb_x11->display );
           return DFB_FAILURE;
      }
      else
-          shared->xw = xw;
+          dfb_x11->xw = xw;
 
-     XUnlockDisplay( x11->display );
+     XUnlockDisplay( dfb_x11->display );
      return DFB_OK;
 }
 
 DFBResult
-dfb_x11_destroy_window_handler( DFBX11 *x11 )
+dfb_x11_destroy_window_handler()
 {
-     DFBX11Shared *shared = x11->shared;
-
      D_DEBUG_AT( X11_Window, "%s()\n", __FUNCTION__ );
 
-     XLockDisplay( x11->display );
-
-     if (shared->xw) {
-          XWindow *xw = shared->xw;
+     XLockDisplay( dfb_x11->display );
 
-          shared->xw = NULL;
-
-          dfb_x11_close_window( x11, xw );
+     if (dfb_x11->xw) {
+          dfb_x11_close_window( dfb_x11->xw );
+          dfb_x11->xw = NULL;
      }
 
-     XSync( x11->display, False );
+     XSync( dfb_x11->display, False );
 
-     XUnlockDisplay( x11->display );
+     XUnlockDisplay( dfb_x11->display );
 
      return DFB_OK;
 }
 
 DFBResult
-dfb_x11_update_screen_handler( DFBX11 *x11, UpdateScreenData *data )
+dfb_x11_update_screen_handler( UpdateScreenData *data )
 {
      DFBRectangle rect;
 
@@ -630,16 +572,11 @@ dfb_x11_update_screen_handler( DFBX11 *x11, UpdateScreenData *data )
 
      rect = DFB_RECTANGLE_INIT_FROM_REGION( &data->region );
 
-     if (data->lock)
-          update_screen( x11, &rect, data->lock );
-
-     data->lock = NULL;
-
-     return DFB_OK;
+     return update_screen( dfb_x11->primary, &rect, data->lock );
 }
 
 DFBResult
-dfb_x11_set_palette_handler( DFBX11 *x11, CorePalette *palette )
+dfb_x11_set_palette_handler( CorePalette *palette )
 {
      return DFB_OK;
 }
diff --git a/DirectFB-1.3.0/systems/x11/vpsmem_surface_pool.c b/DirectFB-1.3.0/systems/x11/vpsmem_surface_pool.c
index e1ea33d..5b10578 100644
--- a/DirectFB-1.3.0/systems/x11/vpsmem_surface_pool.c
+++ b/DirectFB-1.3.0/systems/x11/vpsmem_surface_pool.c
@@ -102,10 +102,8 @@ vpsmemInitPool( CoreDFB                    *core,
                 CoreSurfacePoolDescription *ret_desc )
 {
      DFBResult            ret;
-     VPSMemPoolData      *data   = pool_data;
-     VPSMemPoolLocalData *local  = pool_local;
-     DFBX11              *x11    = system_data;
-     DFBX11Shared        *shared = x11->shared;
+     VPSMemPoolData      *data  = pool_data;
+     VPSMemPoolLocalData *local = pool_local;
 
      D_DEBUG_AT( VPSMem_Surfaces, "%s()\n", __FUNCTION__ );
 
@@ -115,29 +113,23 @@ vpsmemInitPool( CoreDFB                    *core,
      D_ASSERT( local != NULL );
      D_ASSERT( ret_desc != NULL );
 
-     data->mem = SHMALLOC( shared->data_shmpool, shared->vpsmem_length );
+     data->mem = SHMALLOC( dfb_x11->data_shmpool, dfb_x11->vpsmem_length );
      if (!data->mem) {
-          shared->vpsmem_length = 0;
+          dfb_x11->vpsmem_length = 0;
           return D_OOSHM();
      }
 
-     data->length = shared->vpsmem_length;
+     data->length = dfb_x11->vpsmem_length;
 
      ret = dfb_surfacemanager_create( core, data->length, &data->manager );
      if (ret)
           return ret;
 
-     ret_desc->caps              = CSPCAPS_PHYSICAL | CSPCAPS_VIRTUAL;
-     ret_desc->access[CSAID_CPU] = CSAF_READ | CSAF_WRITE | CSAF_SHARED;
-     ret_desc->types             = CSTF_LAYER | CSTF_WINDOW | CSTF_CURSOR | CSTF_FONT | CSTF_SHARED | CSTF_EXTERNAL;
-     ret_desc->priority          = CSPP_DEFAULT;
-     ret_desc->size              = data->length;
-
-     /* For testing... */
-     ret_desc->access[CSAID_ACCEL1] = CSAF_READ | CSAF_WRITE | CSAF_SHARED;
-     ret_desc->access[CSAID_ACCEL2] = CSAF_READ | CSAF_WRITE | CSAF_SHARED;
-     ret_desc->access[CSAID_ACCEL3] = CSAF_READ | CSAF_WRITE | CSAF_SHARED;
-     ret_desc->access[CSAID_ACCEL4] = CSAF_READ | CSAF_WRITE | CSAF_SHARED;
+     ret_desc->caps     = CSPCAPS_NONE;
+     ret_desc->access   = CSAF_CPU_READ | CSAF_CPU_WRITE | CSAF_GPU_READ | CSAF_GPU_WRITE | CSAF_SHARED;
+     ret_desc->types    = CSTF_LAYER | CSTF_WINDOW | CSTF_CURSOR | CSTF_FONT | CSTF_SHARED | CSTF_EXTERNAL;
+     ret_desc->priority = CSPP_DEFAULT;
+     ret_desc->size     = data->length;
 
      snprintf( ret_desc->name, DFB_SURFACE_POOL_DESC_NAME_LENGTH, "Virtual Physical" );
 
diff --git a/DirectFB-1.3.0/systems/x11/x11.c b/DirectFB-1.3.0/systems/x11/x11.c
index c836723..baaa571 100644
--- a/DirectFB-1.3.0/systems/x11/x11.c
+++ b/DirectFB-1.3.0/systems/x11/x11.c
@@ -59,11 +59,6 @@
 #include "xwindow.h"
 #include "x11.h"
 #include "x11_surface_pool.h"
-#include "x11_surface_pool_bridge.h"
-
-#ifdef USE_GLX
-#include "glx_surface_pool.h"
-#endif
 
 #include "vpsmem_surface_pool.h"
 
@@ -72,6 +67,8 @@
 
 DFB_CORE_SYSTEM( x11 )
 
+DFBX11*   dfb_x11      = NULL;
+CoreDFB*  dfb_x11_core = NULL;
 
 static VideoMode modes[] = {
      {  320,  200 },
@@ -111,33 +108,54 @@ static FusionCallHandlerResult call_handler( int           caller,
 
 /**********************************************************************************************************************/
 
+static void
+system_get_info( CoreSystemInfo *info )
+{
+     info->type = CORE_X11;   
+     info->caps = CSCAPS_ACCELERATION;
+
+     snprintf( info->name, DFB_CORE_SYSTEM_INFO_NAME_LENGTH, "X11" );
+}
+
 static DFBResult
-InitLocal( DFBX11 *x11, DFBX11Shared *shared, CoreDFB *core )
+system_initialize( CoreDFB *core, void **data )
 {
-     int i, n;
+     int         i, n;
+     CoreScreen *screen;
 
-     XInitThreads();
+     D_ASSERT( dfb_x11 == NULL );
+
+     dfb_x11 = (DFBX11*) SHCALLOC( dfb_core_shmpool(core), 1, sizeof(DFBX11) );
+     if (!dfb_x11) {
+          D_ERROR( "DirectFB/X11: Couldn't allocate shared memory!\n" );
+          return D_OOSHM();
+     }
+
+     dfb_x11->data_shmpool = dfb_core_shmpool_data( core );
 
-     x11->shared = shared;
-     x11->core   = core;
+     dfb_x11_core = core;
 
-     x11->display = XOpenDisplay(getenv("DISPLAY"));
-     if (!x11->display) {
+
+
+     XInitThreads();
+
+     dfb_x11->display = XOpenDisplay(getenv("DISPLAY"));
+     if (!dfb_x11->display) {
           D_ERROR("X11: Error in XOpenDisplay for '%s'\n", getenv("DISPLAY"));
           return DFB_INIT;
      }
 
-     x11->screenptr = DefaultScreenOfDisplay(x11->display);
-     x11->screennum = DefaultScreen(x11->display);
+     dfb_x11->screenptr = DefaultScreenOfDisplay(dfb_x11->display);
+     dfb_x11->screennum = DefaultScreen(dfb_x11->display);
 
-     for (i=0; i<x11->screenptr->ndepths; i++) {
-          const Depth *depth = &x11->screenptr->depths[i];
+     for (i=0; i<dfb_x11->screenptr->ndepths; i++) {
+          const Depth *depth = &dfb_x11->screenptr->depths[i];
 
           for (n=0; n<depth->nvisuals; n++) {
                Visual *visual = &depth->visuals[n];
 
-               D_DEBUG( "X11/Visual: [%2d] ID 0x%02lx, depth %d, red 0x%06lx, green 0x%06lx, blue 0x%06lx, %d bits/rgb, %d entries\n",
-                        n, visual->visualid, depth->depth,
+               D_DEBUG( "X11/Visual: ID %02lu, depth %d, red 0x%06lx, green 0x%06lx, blue 0x%06lx, %d bits/rgb, %d entries\n",
+                        visual->visualid, depth->depth,
                         visual->red_mask, visual->green_mask, visual->blue_mask,
                         visual->bits_per_rgb, visual->map_entries );
 
@@ -146,127 +164,64 @@ InitLocal( DFBX11 *x11, DFBX11Shared *shared, CoreDFB *core )
                          if (visual->red_mask   == 0xff0000 &&
                              visual->green_mask == 0x00ff00 &&
                              visual->blue_mask  == 0x0000ff &&
-                             !x11->visuals[DFB_PIXELFORMAT_INDEX(DSPF_ARGB)])
-                              x11->visuals[DFB_PIXELFORMAT_INDEX(DSPF_ARGB)] = visual;
+                             !dfb_x11->visuals[DFB_PIXELFORMAT_INDEX(DSPF_ARGB)])
+                              dfb_x11->visuals[DFB_PIXELFORMAT_INDEX(DSPF_ARGB)] = visual;
                          break;
 
                     case 24:
                          if (visual->red_mask   == 0xff0000 &&
                              visual->green_mask == 0x00ff00 &&
                              visual->blue_mask  == 0x0000ff &&
-                             !x11->visuals[DFB_PIXELFORMAT_INDEX(DSPF_RGB32)])
-                              x11->visuals[DFB_PIXELFORMAT_INDEX(DSPF_RGB32)] = visual;
+                             !dfb_x11->visuals[DFB_PIXELFORMAT_INDEX(DSPF_RGB32)])
+                              dfb_x11->visuals[DFB_PIXELFORMAT_INDEX(DSPF_RGB32)] = visual;
                          break;
 
                     case 16:
                          if (visual->red_mask   == 0xf800 &&
                              visual->green_mask == 0x07e0 &&
                              visual->blue_mask  == 0x001f &&
-                             !x11->visuals[DFB_PIXELFORMAT_INDEX(DSPF_RGB16)])
-                              x11->visuals[DFB_PIXELFORMAT_INDEX(DSPF_RGB16)] = visual;
+                             !dfb_x11->visuals[DFB_PIXELFORMAT_INDEX(DSPF_RGB16)])
+                              dfb_x11->visuals[DFB_PIXELFORMAT_INDEX(DSPF_RGB16)] = visual;
                          break;
 
                     case 15:
                          if (visual->red_mask   == 0x7c00 &&
                              visual->green_mask == 0x03e0 &&
                              visual->blue_mask  == 0x001f &&
-                             !x11->visuals[DFB_PIXELFORMAT_INDEX(DSPF_RGB555)])
-                              x11->visuals[DFB_PIXELFORMAT_INDEX(DSPF_RGB555)] = visual;
+                             !dfb_x11->visuals[DFB_PIXELFORMAT_INDEX(DSPF_RGB555)])
+                              dfb_x11->visuals[DFB_PIXELFORMAT_INDEX(DSPF_RGB555)] = visual;
                          break;
                }
           }
      }
 
-     if (XShmQueryExtension( x11->display ))
-          XShmQueryVersion( x11->display, &x11->xshm_major, &x11->xshm_minor, &x11->use_shm );
-
-
-     x11->screen = dfb_screens_register( NULL, x11, &x11PrimaryScreenFuncs );
-
-     dfb_layers_register( x11->screen, x11, &x11PrimaryLayerFuncs );
-
-     return DFB_OK;
-}
-
-/**********************************************************************************************************************/
+     if (XShmQueryExtension( dfb_x11->display ))
+          XShmQueryVersion( dfb_x11->display, &dfb_x11->xshm_major, &dfb_x11->xshm_minor, &dfb_x11->use_shm );
 
-static void
-system_get_info( CoreSystemInfo *info )
-{
-     info->type = CORE_X11;   
-     info->caps = CSCAPS_ACCELERATION;
 
-     snprintf( info->name, DFB_CORE_SYSTEM_INFO_NAME_LENGTH, "X11" );
-}
 
-static DFBResult
-system_initialize( CoreDFB *core, void **data )
-{
-     DFBResult     ret;
-     DFBX11       *x11;
-     DFBX11Shared *shared;
+     fusion_skirmish_init( &dfb_x11->lock, "X11 System", dfb_core_world(core) );
 
-     x11 = D_CALLOC( 1, sizeof(DFBX11) );
-     if (!x11)
-          return D_OOM();
+     fusion_call_init( &dfb_x11->call, call_handler, NULL, dfb_core_world(core) );
 
-     shared = SHCALLOC( dfb_core_shmpool( core ), 1, sizeof(DFBX11Shared) );
-     if (!shared) {
-          D_FREE( x11 );
-          return D_OOSHM();
-     }
 
+     if (dfb_config->video_length) {
+          dfb_x11->vpsmem_length = dfb_config->video_length;
 
-     /*
-      * Local init (master and slave)
-      */
-     ret = InitLocal( x11, shared, core );
-     if (ret) {
-          SHFREE( dfb_core_shmpool( core ), shared );
-          D_FREE( x11 );
-          return ret;
+          dfb_surface_pool_initialize( core, &vpsmemSurfacePoolFuncs, &dfb_x11->vpsmem_pool );
      }
 
+     dfb_surface_pool_initialize( core, &x11SurfacePoolFuncs, &dfb_x11->x11image_pool );
 
-     /*
-      * Shared init (master only)
-      */
-     shared->data_shmpool = dfb_core_shmpool_data( core );
-
-     shared->screen_size.w = x11->screenptr->width;
-     shared->screen_size.h = x11->screenptr->height;
-
-     fusion_skirmish_init( &shared->lock, "X11 System", dfb_core_world(core) );
-
-     fusion_call_init( &shared->call, call_handler, x11, dfb_core_world(core) );
-
-
-     /*
-      * Must be set before initializing the pools!
-      */
-     *data = x11;
-
-
-     /*
-      * Master init
-      */
-     dfb_surface_pool_initialize( core, &x11SurfacePoolFuncs, &shared->x11image_pool );
 
-#ifdef USE_GLX
-     dfb_surface_pool_initialize( core, &glxSurfacePoolFuncs, &shared->glx_pool );
-#endif
+     screen = dfb_screens_register( NULL, NULL, &x11PrimaryScreenFuncs );
 
-     if (dfb_config->video_length) {
-          shared->vpsmem_length = dfb_config->video_length;
+     dfb_layers_register( screen, NULL, &x11PrimaryLayerFuncs );
 
-          dfb_surface_pool_initialize( core, &vpsmemSurfacePoolFuncs, &shared->vpsmem_pool );
-     }
 
-#ifdef USE_GLX
-     dfb_surface_pool_bridge_initialize( core, &x11SurfacePoolBridgeFuncs, x11, &shared->x11_pool_bridge );
-#endif
+     fusion_arena_add_shared_field( dfb_core_arena( core ), "x11", dfb_x11 );
 
-     fusion_arena_add_shared_field( dfb_core_arena( core ), "x11", shared );
+     *data = dfb_x11;
 
      return DFB_OK;
 }
@@ -274,53 +229,27 @@ system_initialize( CoreDFB *core, void **data )
 static DFBResult
 system_join( CoreDFB *core, void **data )
 {
-     DFBResult     ret;
-     void         *ptr;
-     DFBX11       *x11;
-     DFBX11Shared *shared;
-
-     x11 = D_CALLOC( 1, sizeof(DFBX11) );
-     if (!x11)
-          return D_OOM();
-
-     fusion_arena_get_shared_field( dfb_core_arena( core ), "x11", &ptr );
-     shared = ptr;
-
-
-     /*
-      * Local init (master and slave)
-      */
-     ret = InitLocal( x11, shared, core );
-     if (ret) {
-          D_FREE( x11 );
-          return ret;
-     }
+     void       *ret;
+     CoreScreen *screen;
+
+     D_ASSERT( dfb_x11 == NULL );
 
+     fusion_arena_get_shared_field( dfb_core_arena( core ), "x11", &ret );
 
-     /*
-      * Must be set before joining the pools!
-      */
-     *data = x11;
+     dfb_x11 = ret;
+     dfb_x11_core = core;
 
+     if (dfb_x11->vpsmem_pool)
+          dfb_surface_pool_join( core, dfb_x11->vpsmem_pool, &vpsmemSurfacePoolFuncs );
 
-     /*
-      * Slave init
-      */
-     if (shared->x11image_pool)
-          dfb_surface_pool_join( core, shared->x11image_pool, &x11SurfacePoolFuncs );
+     if (dfb_x11->x11image_pool)
+          dfb_surface_pool_join( core, dfb_x11->x11image_pool, &x11SurfacePoolFuncs );
 
-#ifdef USE_GLX
-     if (shared->glx_pool)
-          dfb_surface_pool_join( core, shared->glx_pool, &glxSurfacePoolFuncs );
-#endif
+     screen = dfb_screens_register( NULL, NULL, &x11PrimaryScreenFuncs );
 
-     if (shared->vpsmem_pool)
-          dfb_surface_pool_join( core, shared->vpsmem_pool, &vpsmemSurfacePoolFuncs );
+     dfb_layers_register( screen, NULL, &x11PrimaryLayerFuncs );
 
-#ifdef USE_GLX
-     if (shared->x11_pool_bridge)
-          dfb_surface_pool_bridge_join( core, shared->x11_pool_bridge, &x11SurfacePoolBridgeFuncs, x11 );
-#endif
+     *data = dfb_x11;
 
      return DFB_OK;
 }
@@ -328,48 +257,28 @@ system_join( CoreDFB *core, void **data )
 static DFBResult
 system_shutdown( bool emergency )
 {
-     DFBX11       *x11    = dfb_system_data();
-     DFBX11Shared *shared = x11->shared;
-
-     /*
-      * Master deinit
-      */
-     if (shared->x11_pool_bridge)
-          dfb_surface_pool_bridge_destroy( shared->x11_pool_bridge );
-
-     if (shared->vpsmem_pool)
-          dfb_surface_pool_destroy( shared->vpsmem_pool );
-
-     if (shared->glx_pool)
-          dfb_surface_pool_destroy( shared->glx_pool );
-
-     if (shared->x11image_pool)
-          dfb_surface_pool_destroy( shared->x11image_pool );
+     D_ASSERT( dfb_x11 != NULL );
 
+     if (dfb_x11->x11image_pool)
+          dfb_surface_pool_destroy( dfb_x11->x11image_pool );
 
-     /*
-      * Shared deinit (master only)
-      */
-     fusion_call_destroy( &shared->call );
+     if (dfb_x11->vpsmem_pool)
+          dfb_surface_pool_destroy( dfb_x11->vpsmem_pool );
 
-     fusion_skirmish_prevail( &shared->lock );
+     fusion_call_destroy( &dfb_x11->call );
 
-     if (shared->xw)
-         dfb_x11_close_window( x11, shared->xw );
+     fusion_skirmish_prevail( &dfb_x11->lock );
+     if (dfb_x11->xw)
+         dfb_x11_close_window( dfb_x11->xw );
 
-     fusion_skirmish_destroy( &shared->lock );
+     if (dfb_x11->display)
+         XCloseDisplay( dfb_x11->display );
 
+     fusion_skirmish_destroy( &dfb_x11->lock );
 
-     SHFREE( dfb_core_shmpool( x11->core ), shared );
-
-
-     /*
-      * Local deinit (master and slave)
-      */
-     if (x11->display)
-         XCloseDisplay( x11->display );
-
-     D_FREE( x11 );
+     SHFREE( dfb_core_shmpool(dfb_x11_core), dfb_x11 );
+     dfb_x11 = NULL;
+     dfb_x11_core = NULL;
 
      return DFB_OK;
 }
@@ -377,32 +286,16 @@ system_shutdown( bool emergency )
 static DFBResult
 system_leave( bool emergency )
 {
-     DFBX11       *x11    = dfb_system_data();
-     DFBX11Shared *shared = x11->shared;
-
-     /*
-      * Slave deinit
-      */
-     if (shared->x11_pool_bridge)
-          dfb_surface_pool_bridge_leave( shared->x11_pool_bridge );
+     D_ASSERT( dfb_x11 != NULL );
 
-     if (shared->vpsmem_pool)
-          dfb_surface_pool_leave( shared->vpsmem_pool );
+     if (dfb_x11->x11image_pool)
+          dfb_surface_pool_leave( dfb_x11->x11image_pool );
 
-     if (shared->glx_pool)
-          dfb_surface_pool_leave( shared->glx_pool );
+     if (dfb_x11->vpsmem_pool)
+          dfb_surface_pool_leave( dfb_x11->vpsmem_pool );
 
-     if (shared->x11image_pool)
-          dfb_surface_pool_leave( shared->x11image_pool );
-
-
-     /*
-      * Local deinit (master and slave)
-      */
-     if (x11->display)
-         XCloseDisplay( x11->display );
-
-     D_FREE( x11 );
+     dfb_x11 = NULL;
+     dfb_x11_core = NULL;
 
      return DFB_OK;
 }
@@ -502,12 +395,14 @@ system_auxram_length()
 static void
 system_get_busid( int *ret_bus, int *ret_dev, int *ret_func )
 {
+     return;
 }
 
 static void
 system_get_deviceid( unsigned int *ret_vendor_id,
                      unsigned int *ret_device_id )
 {
+     return;
 }
 
 static FusionCallHandlerResult
@@ -518,31 +413,29 @@ call_handler( int           caller,
               unsigned int  serial,
               int          *ret_val )
 {
-     DFBX11 *x11 = ctx;
-
      switch (call_arg) {
           case X11_CREATE_WINDOW:
-               *ret_val = dfb_x11_create_window_handler( x11, call_ptr );
+               *ret_val = dfb_x11_create_window_handler( call_ptr );
                break;
 
           case X11_DESTROY_WINDOW:
-               *ret_val = dfb_x11_destroy_window_handler( x11 );
+               *ret_val = dfb_x11_destroy_window_handler();
                break;
 
           case X11_UPDATE_SCREEN:
-               *ret_val = dfb_x11_update_screen_handler( x11, call_ptr );
+               *ret_val = dfb_x11_update_screen_handler( call_ptr );
                break;
 
           case X11_SET_PALETTE:
-               *ret_val = dfb_x11_set_palette_handler( x11, call_ptr );
+               *ret_val = dfb_x11_set_palette_handler( call_ptr );
                break;
 
           case X11_IMAGE_INIT:
-               *ret_val = dfb_x11_image_init_handler( x11, call_ptr );
+               *ret_val = dfb_x11_image_init_handler( call_ptr );
                break;
 
           case X11_IMAGE_DESTROY:
-               *ret_val = dfb_x11_image_destroy_handler( x11, call_ptr );
+               *ret_val = dfb_x11_image_destroy_handler( call_ptr );
                break;
 
           default:
diff --git a/DirectFB-1.3.0/systems/x11/x11.h b/DirectFB-1.3.0/systems/x11/x11.h
index 203f998..ca8b8bc 100644
--- a/DirectFB-1.3.0/systems/x11/x11.h
+++ b/DirectFB-1.3.0/systems/x11/x11.h
@@ -54,42 +54,27 @@ typedef struct {
      UpdateScreenData     update;
      SetModeData          setmode;
                          
+     Bool                 use_shm;
+     int                  xshm_major;
+     int                  xshm_minor;
+                         
      FusionSkirmish       lock;
      FusionCall           call;
 
      FusionSHMPoolShared *data_shmpool;
  
      CoreSurfacePool     *x11image_pool;
-
-     CoreSurfacePool     *glx_pool; /* only used for GL */
-
      CoreSurfacePool     *vpsmem_pool;
      unsigned int         vpsmem_length;
  
-     CoreSurfacePoolBridge *x11_pool_bridge;
-
-//     CoreSurface         *primary;
-     DFBDimension         screen_size;
-
+     CoreSurface         *primary;
      XWindow             *xw;
-} DFBX11Shared;
-
-struct __DFB_X11 {
-     DFBX11Shared        *shared;
-
-     CoreDFB             *core;
-     CoreScreen          *screen;
-
-     Bool                 use_shm;
-     int                  xshm_major;
-     int                  xshm_minor;
-                         
      Display             *display;
-     Screen              *screenptr;
+     Screen*              screenptr;
      int                  screennum;
                      
      Visual              *visuals[DFB_NUM_PIXELFORMATS];
-};
+} DFBX11;
 
 typedef enum {
      X11_CREATE_WINDOW,
@@ -102,14 +87,18 @@ typedef enum {
 
 
 
-DFBResult dfb_x11_create_window_handler ( DFBX11 *x11, CoreLayerRegionConfig *config );
-DFBResult dfb_x11_destroy_window_handler( DFBX11 *x11 );
+DFBResult dfb_x11_create_window_handler ( CoreLayerRegionConfig *config );
+DFBResult dfb_x11_destroy_window_handler( void );
+
+DFBResult dfb_x11_update_screen_handler ( UpdateScreenData *data );
+DFBResult dfb_x11_set_palette_handler   ( CorePalette *palette );
+
+DFBResult dfb_x11_image_init_handler    ( x11Image *image );
+DFBResult dfb_x11_image_destroy_handler ( x11Image *image );
 
-DFBResult dfb_x11_update_screen_handler ( DFBX11 *x11, UpdateScreenData *data );
-DFBResult dfb_x11_set_palette_handler   ( DFBX11 *x11, CorePalette *palette );
 
-DFBResult dfb_x11_image_init_handler    ( DFBX11 *x11, x11Image *image );
-DFBResult dfb_x11_image_destroy_handler ( DFBX11 *x11, x11Image *image );
+extern DFBX11  *dfb_x11;
+extern CoreDFB *dfb_x11_core;
 
 
 #endif //__X11SYSTEM__X11_H__
diff --git a/DirectFB-1.3.0/systems/x11/x11_surface_pool.c b/DirectFB-1.3.0/systems/x11/x11_surface_pool.c
index 8e3cb9e..637b383 100644
--- a/DirectFB-1.3.0/systems/x11/x11_surface_pool.c
+++ b/DirectFB-1.3.0/systems/x11/x11_surface_pool.c
@@ -52,8 +52,6 @@ typedef struct {
 typedef struct {
      pthread_mutex_t  lock;
      DirectHash      *hash;
-
-     DFBX11          *x11;
 } x11PoolLocalData;
 
 /**********************************************************************************************************************/
@@ -86,22 +84,16 @@ x11InitPool( CoreDFB                    *core,
 {
      DFBResult         ret;
      x11PoolLocalData *local = pool_local;
-     DFBX11           *x11   = system_data;
 
      D_DEBUG_AT( X11_Surfaces, "%s()\n", __FUNCTION__ );
 
      D_MAGIC_ASSERT( pool, CoreSurfacePool );
      D_ASSERT( ret_desc != NULL );
 
-     local->x11 = x11;
-
-     ret_desc->caps              = CSPCAPS_VIRTUAL;
-     ret_desc->access[CSAID_CPU] = CSAF_READ | CSAF_WRITE | CSAF_SHARED;
-     ret_desc->types             = CSTF_LAYER | CSTF_WINDOW | CSTF_CURSOR | CSTF_FONT | CSTF_SHARED | CSTF_EXTERNAL;
-     ret_desc->priority          = CSPP_ULTIMATE;
-
-     /* For showing our X11 window */
-     ret_desc->access[CSAID_LAYER0] = CSAF_READ;
+     ret_desc->caps     = CSPCAPS_NONE;
+     ret_desc->access   = CSAF_CPU_READ | CSAF_CPU_WRITE | CSAF_GPU_READ | CSAF_GPU_WRITE | CSAF_SHARED;
+     ret_desc->types    = CSTF_LAYER | CSTF_WINDOW | CSTF_CURSOR | CSTF_FONT | CSTF_SHARED | CSTF_EXTERNAL;
+     ret_desc->priority = CSPP_PREFERED;
 
      snprintf( ret_desc->name, DFB_SURFACE_POOL_DESC_NAME_LENGTH, "X11 Shm Images" );
 
@@ -125,14 +117,11 @@ x11JoinPool( CoreDFB                    *core,
 {
      DFBResult         ret;
      x11PoolLocalData *local = pool_local;
-     DFBX11           *x11   = system_data;
 
      D_DEBUG_AT( X11_Surfaces, "%s()\n", __FUNCTION__ );
 
      D_MAGIC_ASSERT( pool, CoreSurfacePool );
 
-     local->x11 = x11;
-
      ret = direct_hash_create( 7, &local->hash );
      if (ret) {
           D_DERROR( ret, "X11/Surfaces: Could not create local hash table!\n" );
@@ -187,16 +176,11 @@ x11TestConfig( CoreSurfacePool         *pool,
                CoreSurfaceBuffer       *buffer,
                const CoreSurfaceConfig *config )
 {
-     x11PoolLocalData *local  = pool_local;
-     DFBX11           *x11    = local->x11;
-     DFBX11Shared     *shared = x11->shared;
-
-     /* Provide a fallback only if no virtual physical pool is allocated... */
-     if (!shared->vpsmem_length)
+     if (!dfb_x11->vpsmem_length)
           return DFB_OK;
           
      /* Pass NULL image for probing */
-     return x11ImageInit( x11, NULL, config->size.w, config->size.h, config->format );
+     return x11ImageInit( NULL, config->size.w, config->size.h, config->format );
 }
 
 static DFBResult
@@ -209,8 +193,6 @@ x11AllocateBuffer( CoreSurfacePool       *pool,
 {
      CoreSurface       *surface;
      x11AllocationData *alloc = alloc_data;
-     x11PoolLocalData  *local = pool_local;
-     DFBX11            *x11   = local->x11;
 
      D_DEBUG_AT( X11_Surfaces, "%s()\n", __FUNCTION__ );
 
@@ -220,7 +202,7 @@ x11AllocateBuffer( CoreSurfacePool       *pool,
      surface = buffer->surface;
      D_MAGIC_ASSERT( surface, CoreSurface );
 
-     if (x11ImageInit( x11, &alloc->image, surface->config.size.w, surface->config.size.h, surface->config.format ) == DFB_OK) {
+     if (x11ImageInit( &alloc->image, surface->config.size.w, surface->config.size.h, surface->config.format ) == DFB_OK) {
           alloc->real  = true;
           alloc->pitch = alloc->image.pitch;
 
@@ -240,10 +222,7 @@ x11DeallocateBuffer( CoreSurfacePool       *pool,
                      CoreSurfaceAllocation *allocation,
                      void                  *alloc_data )
 {
-     x11AllocationData *alloc  = alloc_data;
-     x11PoolLocalData  *local  = pool_local;
-     DFBX11            *x11    = local->x11;
-     DFBX11Shared      *shared = x11->shared;
+     x11AllocationData *alloc = alloc_data;
 
      D_DEBUG_AT( X11_Surfaces, "%s()\n", __FUNCTION__ );
 
@@ -253,10 +232,10 @@ x11DeallocateBuffer( CoreSurfacePool       *pool,
      CORE_SURFACE_ALLOCATION_ASSERT( allocation );
 
      if (alloc->real)
-          return x11ImageDestroy( x11, &alloc->image );
+          return x11ImageDestroy( &alloc->image );
 
      if (alloc->ptr)
-          SHFREE( shared->data_shmpool, alloc->ptr );
+          SHFREE( dfb_x11->data_shmpool, alloc->ptr );
 
      return DFB_OK;
 }
@@ -270,10 +249,8 @@ x11Lock( CoreSurfacePool       *pool,
          CoreSurfaceBufferLock *lock )
 {
      DFBResult          ret;
-     x11PoolLocalData  *local  = pool_local;
-     x11AllocationData *alloc  = alloc_data;
-     DFBX11            *x11    = local->x11;
-     DFBX11Shared      *shared = x11->shared;
+     x11PoolLocalData  *local = pool_local;
+     x11AllocationData *alloc = alloc_data;
      CoreSurfaceBuffer *buffer;
      CoreSurface       *surface;
 
@@ -314,12 +291,13 @@ x11Lock( CoreSurfacePool       *pool,
      }
      else {
           if (!alloc->ptr) {
-               alloc->ptr = SHCALLOC( shared->data_shmpool, 1, allocation->size );
+               alloc->ptr = SHCALLOC( dfb_x11->data_shmpool, 1, allocation->size );
                if (!alloc->ptr)
                     return D_OOSHM();
           }
 
-          lock->addr = alloc->ptr;
+          lock->addr   = alloc->ptr;
+          lock->offset = 0;
      }
 
      lock->pitch = alloc->pitch;
diff --git a/DirectFB-1.3.0/systems/x11/x11image.c b/DirectFB-1.3.0/systems/x11/x11image.c
index bfef7b7..933f044 100644
--- a/DirectFB-1.3.0/systems/x11/x11image.c
+++ b/DirectFB-1.3.0/systems/x11/x11image.c
@@ -37,21 +37,19 @@
 
 /**********************************************************************************************************************/
 
-DFBResult x11ImageInit( DFBX11                *x11,
-                        x11Image              *image,
+DFBResult x11ImageInit( x11Image              *image,
                         int                    width,
                         int                    height,
                         DFBSurfacePixelFormat  format )
 {
-     int           ret;
-     Visual       *visual;
-     DFBX11Shared *shared = x11->shared;
+     int     ret;
+     Visual *visual;
 
-     if (!x11->use_shm)
+     if (!dfb_x11->use_shm)
           return DFB_UNSUPPORTED;
 
      /* Lookup visual. */
-     visual = x11->visuals[DFB_PIXELFORMAT_INDEX(format)];
+     visual = dfb_x11->visuals[DFB_PIXELFORMAT_INDEX(format)];
      if (!visual)
           return DFB_UNSUPPORTED;
 
@@ -63,10 +61,11 @@ DFBResult x11ImageInit( DFBX11                *x11,
      image->height = height;
      image->format = format;
      image->depth  = DFB_COLOR_BITS_PER_PIXEL( format );
+     image->visual = visual;
 
      D_MAGIC_SET( image, x11Image );
 
-     if (fusion_call_execute( &shared->call, FCEF_NONE, X11_IMAGE_INIT, image, &ret )) {
+     if (fusion_call_execute( &dfb_x11->call, FCEF_NONE, X11_IMAGE_INIT, image, &ret )) {
           D_MAGIC_CLEAR( image );
           return DFB_FUSION;
      }
@@ -81,15 +80,13 @@ DFBResult x11ImageInit( DFBX11                *x11,
 }
 
 DFBResult
-x11ImageDestroy( DFBX11   *x11,
-                 x11Image *image )
+x11ImageDestroy( x11Image *image )
 {
-     int           ret;
-     DFBX11Shared *shared = x11->shared;
+     int ret;
 
      D_MAGIC_ASSERT( image, x11Image );
 
-     if (fusion_call_execute( &shared->call, FCEF_NONE, X11_IMAGE_DESTROY, image, &ret ))
+     if (fusion_call_execute( &dfb_x11->call, FCEF_NONE, X11_IMAGE_DESTROY, image, &ret ))
           return DFB_FUSION;
 
      if (ret) {
@@ -130,30 +127,19 @@ x11ImageAttach( x11Image  *image,
 /**********************************************************************************************************************/
 
 DFBResult
-dfb_x11_image_init_handler( DFBX11 *x11, x11Image *image )
+dfb_x11_image_init_handler( x11Image *image )
 {
-     Visual *visual;
      XImage *ximage;
 
      D_MAGIC_ASSERT( image, x11Image );
 
-     if (!x11->use_shm)
-          return DFB_UNSUPPORTED;
-
-     /* Lookup visual. */
-     visual = x11->visuals[DFB_PIXELFORMAT_INDEX(image->format)];
-     if (!visual)
-          return DFB_UNSUPPORTED;
-
-     image->visual = visual;
-
-     XLockDisplay( x11->display );
+     XLockDisplay( dfb_x11->display );
 
-     ximage = XShmCreateImage( x11->display, image->visual, image->depth,
+     ximage = XShmCreateImage( dfb_x11->display, image->visual, image->depth,
                                ZPixmap, NULL, &image->seginfo, image->width, image->height );
      if (!ximage) {
           D_ERROR( "X11/ShmImage: Error creating shared image (XShmCreateImage)!\n");
-          XUnlockDisplay( x11->display );
+          XUnlockDisplay( dfb_x11->display );
           return DFB_FAILURE;
      }
 
@@ -176,18 +162,13 @@ dfb_x11_image_init_handler( DFBX11 *x11, x11Image *image )
      /* We set the buffer in Read and Write mode */
      image->seginfo.readOnly = False;
 
-     if (!XShmAttach( x11->display, &image->seginfo ))
+     if (!XShmAttach( dfb_x11->display, &image->seginfo ))
           goto error_xshmattach;
 
      image->ximage = ximage;
      image->pitch  = ximage->bytes_per_line;
 
-     image->pixmap = XShmCreatePixmap( x11->display, DefaultRootWindow(x11->display), ximage->data,
-                                       &image->seginfo, image->width, image->height, image->depth );
-
-     image->gc = XCreateGC( x11->display, image->pixmap, 0, NULL );
-
-     XUnlockDisplay( x11->display );
+     XUnlockDisplay( dfb_x11->display );
 
      return DFB_OK;
 
@@ -201,26 +182,23 @@ error_shmat:
 error:
      XDestroyImage( ximage );
 
-     XUnlockDisplay( x11->display );
+     XUnlockDisplay( dfb_x11->display );
 
      return DFB_FAILURE;
 }
 
 DFBResult
-dfb_x11_image_destroy_handler( DFBX11 *x11, x11Image *image )
+dfb_x11_image_destroy_handler( x11Image *image )
 {
      D_MAGIC_ASSERT( image, x11Image );
 
-     XLockDisplay( x11->display );
-
-     XFreeGC( x11->display, image->gc );
-     XFreePixmap( x11->display, image->pixmap );
+     XLockDisplay( dfb_x11->display );
 
-     XShmDetach( x11->display, &image->seginfo );
+     XShmDetach( dfb_x11->display, &image->seginfo );
 
      XDestroyImage( image->ximage );
 
-     XUnlockDisplay( x11->display );
+     XUnlockDisplay( dfb_x11->display );
 
      shmdt( image->seginfo.shmaddr );
 
diff --git a/DirectFB-1.3.0/systems/x11/x11image.h b/DirectFB-1.3.0/systems/x11/x11image.h
index 8d69548..9b5fa35 100644
--- a/DirectFB-1.3.0/systems/x11/x11image.h
+++ b/DirectFB-1.3.0/systems/x11/x11image.h
@@ -36,8 +36,7 @@
 #include <X11/extensions/XShm.h>
 #include <sys/ipc.h>
 #include <sys/shm.h>
-
-#include "x11types.h"
+ 
 
 
 typedef struct {
@@ -54,20 +53,15 @@ typedef struct {
      int                   pitch;
 
      XShmSegmentInfo       seginfo;
-
-     Pixmap                pixmap;
-     GC                    gc;
 } x11Image;
 
 
-DFBResult x11ImageInit   ( DFBX11                *x11,
-                           x11Image              *image,
+DFBResult x11ImageInit   ( x11Image              *image,
                            int                    width,
                            int                    height,
                            DFBSurfacePixelFormat  format );
 
-DFBResult x11ImageDestroy( DFBX11                *x11,
-                           x11Image              *image );
+DFBResult x11ImageDestroy( x11Image              *image );
 
 DFBResult x11ImageAttach ( x11Image              *image,
                            void                 **ret_addr );
diff --git a/DirectFB-1.3.0/systems/x11/x11input.c b/DirectFB-1.3.0/systems/x11/x11input.c
index 6534182..fb4d447 100644
--- a/DirectFB-1.3.0/systems/x11/x11input.c
+++ b/DirectFB-1.3.0/systems/x11/x11input.c
@@ -59,6 +59,8 @@
 
 #include <core/input_driver.h>
 
+extern DFBX11  *dfb_x11;
+extern CoreDFB *dfb_x11_core;
 
 DFB_INPUT_DRIVER( x11input )
 
@@ -69,7 +71,7 @@ DFB_INPUT_DRIVER( x11input )
 typedef struct {
      CoreInputDevice*    device;
      DirectThread*       thread;
-     DFBX11*             x11;
+     DFBX11*             dfb_x11;
      bool                stop;
 } X11InputData;
 
@@ -500,32 +502,30 @@ handle_expose( const XExposeEvent *expose )
 static void*
 x11EventThread( DirectThread *thread, void *driver_data )
 {
-     X11InputData *data   = driver_data;
-     DFBX11       *x11    = data->x11;
-     DFBX11Shared *shared = x11->shared;
+     X11InputData *data    = driver_data;
+     DFBX11       *dfb_x11 = data->dfb_x11;
 
      while (!data->stop) {
-          unsigned int  pull = 23;
+          unsigned int  pull = 100;
           XEvent        xEvent; 
           DFBInputEvent dfbEvent;
 
           /* FIXME: Detect key repeats, we're receiving KeyPress, KeyRelease, KeyPress, KeyRelease... !!?? */
 
-          if (!shared->xw || !shared->xw->window) {
+#if 1
+          if (data->thread)
+               direct_thread_testcancel( data->thread );
+
+          if (!dfb_x11->xw || !dfb_x11->xw->window) {
                /* no window, so no event */
-               usleep( 50000 );
+               usleep( 20000 );
                continue;
           }
 
-          usleep( 10000 );
-
-          XLockDisplay( x11->display );
 
-          while (!data->stop && pull-- && XPending( x11->display )) {
-               XNextEvent( x11->display, &xEvent );
-
-               XUnlockDisplay( x11->display );
+          XNextEvent( dfb_x11->display, &xEvent );
 
+          while (pull-- && !data->stop) {
                switch (xEvent.type) {
                     case ButtonPress:
                     case ButtonRelease:
@@ -552,7 +552,7 @@ x11EventThread( DirectThread *thread, void *driver_data )
                     case Expose:
                          handle_expose( &xEvent.xexpose );
                          break;
-
+				
                     case DestroyNotify:
                          /* this event is mainly to unblock XNextEvent. */
                          break;
@@ -561,13 +561,62 @@ x11EventThread( DirectThread *thread, void *driver_data )
                          break;
                }
 
-               XLockDisplay( x11->display );
+               if (pull && !data->stop) {
+                    XLockDisplay( dfb_x11->display );
+
+                    if (!XCheckMaskEvent( dfb_x11->display, ~0, &xEvent ))
+                         pull = 0;
+
+                    XUnlockDisplay( dfb_x11->display );
+               }
           }
+#else
+          usleep(10000);
 
-          XUnlockDisplay( x11->display );
+          XLockDisplay( dfb_x11->display );
 
-          if (!data->stop)
-               motion_realize( data );
+          while (XCheckMaskEvent( dfb_x11->display, ~0, &xEvent )) {
+               XUnlockDisplay( dfb_x11->display );
+
+               switch (xEvent.type) {
+                    case ButtonPress:
+                    case ButtonRelease:
+                         motion_realize( data );
+                    case MotionNotify:
+                         handleMouseEvent( &xEvent, data ); // crash ???
+                         break;
+
+                    case KeyPress:
+                    case KeyRelease: {
+                         motion_realize( data );
+
+                         dfbEvent.type     = (xEvent.type == KeyPress) ? DIET_KEYPRESS : DIET_KEYRELEASE;
+                         dfbEvent.flags    = DIEF_KEYCODE | DIEF_TIMESTAMP;
+                         dfbEvent.key_code = xEvent.xkey.keycode;
+
+                         dfbEvent.timestamp.tv_sec  =  xEvent.xkey.time / 1000;
+                         dfbEvent.timestamp.tv_usec = (xEvent.xkey.time % 1000) * 1000;
+
+                         dfb_input_dispatch( data->device, &dfbEvent );
+                         break;
+                    }
+
+                    case Expose:
+                         handle_expose( &xEvent.xexpose );
+                         break;
+
+                    default:
+                         break;
+               }
+
+               XLockDisplay( dfb_x11->display );
+          }
+
+          XUnlockDisplay( dfb_x11->display );
+#endif
+          motion_realize( data );
+
+          direct_thread_testcancel( thread );
      }
 
      return NULL;
@@ -612,12 +661,11 @@ driver_open_device( CoreInputDevice  *device,
                     void            **driver_data )
 {
      X11InputData *data;
-     DFBX11       *x11    = dfb_system_data();
-     DFBX11Shared *shared = x11->shared;
+     DFBX11       *dfb_x11 = dfb_system_data();
 
-     fusion_skirmish_prevail( &shared->lock );
+     fusion_skirmish_prevail( &dfb_x11->lock );
 
-     fusion_skirmish_dismiss( &shared->lock );
+     fusion_skirmish_dismiss( &dfb_x11->lock );
 
      /* set device vendor and name */
      snprintf( info->desc.vendor, DFB_INPUT_DEVICE_DESC_VENDOR_LENGTH, "XServer" );
@@ -640,8 +688,8 @@ driver_open_device( CoreInputDevice  *device,
      /* allocate and fill private data */
      data = D_CALLOC( 1, sizeof(X11InputData) );
 
-     data->device = device;
-     data->x11    = x11;
+     data->device  = device;
+     data->dfb_x11 = dfb_x11;
 
      /* start input thread */
      data->thread = direct_thread_create( DTT_INPUT, x11EventThread, data, "X11 Input" );
@@ -662,13 +710,13 @@ driver_get_keymap_entry( CoreInputDevice           *device,
                          DFBInputDeviceKeymapEntry *entry )
 {
      int           i;
-     X11InputData *data = driver_data;
-     DFBX11       *x11  = data->x11;
+     X11InputData *data    = driver_data;
+     DFBX11       *dfb_x11 = data->dfb_x11;
 
-     XLockDisplay( x11->display );
+     XLockDisplay( dfb_x11->display );
 
      for (i=0; i<4; i++) {
-          KeySym xSymbol = XKeycodeToKeysym( x11->display, entry->code, i );
+          KeySym xSymbol = XKeycodeToKeysym( dfb_x11->display, entry->code, i );
 
           if (i == 0)
                entry->identifier = xsymbol_to_id( xSymbol );
@@ -676,7 +724,7 @@ driver_get_keymap_entry( CoreInputDevice           *device,
           entry->symbols[i] = xsymbol_to_symbol( xSymbol );
      }
 
-     XUnlockDisplay( x11->display );
+     XUnlockDisplay( dfb_x11->display );
 
      /* is CapsLock effective? */
      if (entry->identifier >= DIKI_A && entry->identifier <= DIKI_Z)
@@ -695,36 +743,24 @@ driver_get_keymap_entry( CoreInputDevice           *device,
 static void
 driver_close_device( void *driver_data )
 {
-     X11InputData *data   = driver_data;
-     DFBX11       *x11    = data->x11;
-     DFBX11Shared *shared = x11->shared;
+     X11InputData *data    = driver_data;
+     DFBX11       *dfb_x11 = data->dfb_x11;
 
      /* stop input thread */
      data->stop = true;
 
-     XLockDisplay( x11->display );
-
-     if (shared->xw) {
-          XWindow *xw = shared->xw;
-
-          shared->xw = NULL;
-
+     XLockDisplay( dfb_x11->display );
+     if( dfb_x11->xw ) {
           /* the window must generate an event, otherwise the input thread will not end */
-          dfb_x11_close_window( x11, xw );
-     }
 
-     XSync( x11->display, False );
-
-     XUnlockDisplay( x11->display );
-
-     /* it is possible that this "close" function is called from the same
-      * thread that the input device is actually running on.
-      * This happens when you e.g. click the close box with your mouse.
-      * As a fix, we check if we are this thread. */
-     if (data->thread != direct_thread_self()) {
-          direct_thread_join( data->thread );
-          direct_thread_destroy( data->thread );
+          XWindow* xw = dfb_x11->xw;
+          dfb_x11->xw = NULL;
+          dfb_x11_close_window( xw );
      }
+     XUnlockDisplay( dfb_x11->display );
+
+     direct_thread_join( data->thread );
+     direct_thread_destroy( data->thread );
 
      /* free private data */
      D_FREE ( data );
diff --git a/DirectFB-1.3.0/systems/x11/xwindow.c b/DirectFB-1.3.0/systems/x11/xwindow.c
index 2e8a72e..663a9be 100644
--- a/DirectFB-1.3.0/systems/x11/xwindow.c
+++ b/DirectFB-1.3.0/systems/x11/xwindow.c
@@ -32,65 +32,42 @@
 #include <stdlib.h>
 #include <stdio.h>
 
-#include <directfb_util.h>
-
 #include <direct/mem.h>
 
 #include "x11.h"
 
+extern DFBX11  *dfb_x11;
+extern CoreDFB *dfb_x11_core;
 
-static bool use_shm = true;
 
 static int
-error_handler_shm( Display *display, XErrorEvent *event )
+error_handler( Display *display, XErrorEvent *event )
 {
-     if (use_shm) {
+     if (dfb_x11->use_shm) {
           D_INFO( "X11/Display: Error! Disabling XShm.\n" );
 
-          use_shm = false;
+          dfb_x11->use_shm = false;
      }
 
      return 0;
 }
 
-
-static int error_code = 0;
-
-static int
-error_handler( Display *display, XErrorEvent *event )
-{
-     char buf[512];
-
-     XGetErrorText( display, event->error_code, buf, sizeof(buf) );
-
-     D_ERROR( "X11/Display: Error! %s\n", buf );
-
-     error_code = event->error_code;
-
-     return 0;
-}
-
 Bool
-dfb_x11_open_window( DFBX11 *x11, XWindow** ppXW, int iXPos, int iYPos, int iWidth, int iHeight, DFBSurfacePixelFormat format )
+dfb_x11_open_window(XWindow** ppXW, int iXPos, int iYPos, int iWidth, int iHeight)
 {
-     XWindow              *xw;
-     XSetWindowAttributes  attr = { 0 };
+     XWindow* xw = (XWindow *)D_CALLOC(1, sizeof(XWindow));
 
-     D_INFO( "X11/Window: Creating %4dx%4d %s window...\n", iWidth, iHeight, dfb_pixelformat_name(format) );
-
-     xw = D_CALLOC( 1, sizeof(XWindow) );
-     if (!xw)
-          return D_OOM();
+     XSetWindowAttributes attr = { 0 };
 
      /* We set the structure as needed for our window */
      xw->width   = iWidth;
      xw->height  = iHeight;
-     xw->display = x11->display;
+     xw->display = dfb_x11->display;
 
      xw->screenptr = DefaultScreenOfDisplay(xw->display);
      xw->screennum = DefaultScreen(xw->display);
-     xw->depth     = DFB_COLOR_BITS_PER_PIXEL(format) + DFB_ALPHA_BITS_PER_PIXEL(format);
-     xw->visual    = x11->visuals[DFB_PIXELFORMAT_INDEX(format)] ?: DefaultVisualOfScreen(xw->screenptr);
+     xw->visual    = DefaultVisualOfScreen(xw->screenptr);
+     xw->depth     = DefaultDepth( xw->display, xw->screennum );
 
      attr.event_mask = 
             ButtonPressMask
@@ -101,20 +78,16 @@ dfb_x11_open_window( DFBX11 *x11, XWindow** ppXW, int iXPos, int iYPos, int iWid
           | ExposureMask
           | StructureNotifyMask;
 
-     XLockDisplay( x11->display );
-
-     XSetErrorHandler( error_handler );
-
-     error_code = 0;
+     XLockDisplay( dfb_x11->display );
 
      xw->window = XCreateWindow( xw->display,
                                  RootWindowOfScreen(xw->screenptr),
                                  iXPos, iYPos, iWidth, iHeight, 0, xw->depth, InputOutput,
                                  xw->visual, CWEventMask, &attr );
-     XSync( xw->display, False );
-     if (!xw->window || error_code) {
+
+     if (!xw->window) {
           D_FREE( xw );
-          XUnlockDisplay( x11->display );
+          XUnlockDisplay( dfb_x11->display );
           return False;
      }
 
@@ -161,22 +134,20 @@ dfb_x11_open_window( DFBX11 *x11, XWindow** ppXW, int iXPos, int iYPos, int iWid
      XMapRaised( xw->display, xw->window );
 
 
-     if (x11->use_shm) {
+     if (dfb_x11->use_shm) {
           // Shared memory 	
           xw->shmseginfo=(XShmSegmentInfo *)D_CALLOC(1, sizeof(XShmSegmentInfo));
           if (!xw->shmseginfo) {
-               x11->use_shm = false;
+               dfb_x11->use_shm = false;
                goto no_shm;
           }
 
           xw->ximage=XShmCreateImage(xw->display, xw->visual, xw->depth, ZPixmap,
                                      NULL,xw->shmseginfo, xw->width, xw->height * 2);
-          XSync( xw->display, False );
-          if (!xw->ximage || error_code) {
+          if (!xw->ximage) {
                D_ERROR("X11: Error creating shared image (XShmCreateImage) \n");
-               x11->use_shm = false;
+               dfb_x11->use_shm = false;
                D_FREE(xw->shmseginfo);
-               error_code = 0;
                goto no_shm;
           }
 
@@ -189,7 +160,7 @@ dfb_x11_open_window( DFBX11 *x11, XWindow** ppXW, int iXPos, int iYPos, int iWid
                                        IPC_CREAT|0777);
 
           if (xw->shmseginfo->shmid<0) {
-               x11->use_shm = false;
+               dfb_x11->use_shm = false;
                XDestroyImage(xw->ximage);
                D_FREE(xw->shmseginfo);
                goto no_shm;
@@ -199,7 +170,7 @@ dfb_x11_open_window( DFBX11 *x11, XWindow** ppXW, int iXPos, int iYPos, int iWid
           function search the correct memory place --> NULL. It's safest ! */
           xw->shmseginfo->shmaddr = shmat( xw->shmseginfo->shmid, NULL, 0 );
           if (!xw->shmseginfo->shmaddr) {
-               x11->use_shm = false;
+               dfb_x11->use_shm = false;
                shmctl(xw->shmseginfo->shmid,IPC_RMID,NULL);
                XDestroyImage(xw->ximage);
                D_FREE(xw->shmseginfo);
@@ -212,18 +183,18 @@ dfb_x11_open_window( DFBX11 *x11, XWindow** ppXW, int iXPos, int iYPos, int iWid
           xw->virtualscreen= xw->ximage->data = xw->shmseginfo->shmaddr;
 
 
-          XSetErrorHandler( error_handler_shm );
+          XSetErrorHandler( error_handler );
 
-          XShmAttach(x11->display,xw->shmseginfo);
+          XShmAttach(dfb_x11->display,xw->shmseginfo);
 
-          XShmPutImage(x11->display, xw->window, xw->gc, xw->ximage,
+          XShmPutImage(dfb_x11->display, xw->window, xw->gc, xw->ximage,
                        0, 0, 0, 0, 1, 1, False);
 
-          XSync(x11->display, False);
+          XSync(dfb_x11->display, False);
 
-          XSetErrorHandler( error_handler );
+          XSetErrorHandler( NULL );
 
-          if (!x11->use_shm) {
+          if (!dfb_x11->use_shm) {
                shmdt(xw->shmseginfo->shmaddr);
                shmctl(xw->shmseginfo->shmid,IPC_RMID,NULL);
                XDestroyImage(xw->ximage);
@@ -232,7 +203,7 @@ dfb_x11_open_window( DFBX11 *x11, XWindow** ppXW, int iXPos, int iYPos, int iWid
      }
 
 no_shm:
-     if (!x11->use_shm) {
+     if (!dfb_x11->use_shm) {
           int pitch;
 
           xw->bpp = (xw->depth > 16) ? 4 :
@@ -244,24 +215,20 @@ no_shm:
 
           xw->ximage = XCreateImage( xw->display, xw->visual, xw->depth, ZPixmap, 0,
                                      xw->virtualscreen, xw->width, xw->height * 2, 32, pitch );
-          XSync( xw->display, False );
-          if (!xw->ximage || error_code) {
+          if (!xw->ximage) {
                D_ERROR( "X11/Window: XCreateImage( Visual %02lu, depth %d, size %dx%d, buffer %p [%d] ) failed!\n",
                         xw->visual->visualid, xw->depth, xw->width, xw->height * 2, xw->virtualscreen, pitch );
                XFreeGC(xw->display,xw->gc);
                XDestroyWindow(xw->display,xw->window);
-               XSetErrorHandler( NULL );
-               XUnlockDisplay( x11->display );
+               XUnlockDisplay( dfb_x11->display );
                D_FREE( xw );
                return False;
           }
      }
 
-     XSetErrorHandler( NULL );
-
-     XUnlockDisplay( x11->display );
+     XUnlockDisplay( dfb_x11->display );
 
-     D_INFO( "X11/Display: %ssing XShm.\n", x11->use_shm ? "U" : "Not u" );
+     D_INFO( "X11/Display: %ssing XShm.\n", dfb_x11->use_shm ? "U" : "Not u" );
 
      (*ppXW) = xw;
 
@@ -269,9 +236,9 @@ no_shm:
 }
 
 void
-dfb_x11_close_window( DFBX11 *x11, XWindow* xw )
+dfb_x11_close_window( XWindow* xw )
 {
-     if (x11->use_shm) {
+     if (dfb_x11->use_shm) {
           XShmDetach(xw->display, xw->shmseginfo);
           shmdt(xw->shmseginfo->shmaddr);
           shmctl(xw->shmseginfo->shmid,IPC_RMID,NULL);
diff --git a/DirectFB-1.3.0/systems/x11/xwindow.h b/DirectFB-1.3.0/systems/x11/xwindow.h
index cd65cf9..fe8c502 100644
--- a/DirectFB-1.3.0/systems/x11/xwindow.h
+++ b/DirectFB-1.3.0/systems/x11/xwindow.h
@@ -36,40 +36,40 @@
 #include <X11/extensions/XShm.h>
 #include <sys/ipc.h>
 #include <sys/shm.h>
-
-#include "x11types.h"
-
-
-typedef struct {
-     Display*            display;
-     Window              window;
-     Screen*             screenptr;
-     int                 screennum;
-     Visual*             visual;
-     GC                  gc;
-     XImage*             ximage;
-     int                 ximage_offset;
-     Colormap            colormap;
-
-     XShmSegmentInfo*    shmseginfo;
-     unsigned char*      videomemory;
-
-     char*               virtualscreen;
-     int                 videoaccesstype;
-
-     int                 width;
-     int                 height;
-     int                 depth;
-     int                 bpp;
-
-     /* (Null) cursor stuff*/
-     Pixmap              pixmp1;
-     Pixmap              pixmp2;
-     Cursor              NullCursor;
+ 
+
+
+typedef struct 
+{
+	Display*			display;
+	Window 				window;
+	Screen*				screenptr;
+	int 				screennum;
+	Visual*				visual;
+	GC 					gc;
+	XImage*				ximage;
+    int                 ximage_offset;
+	Colormap 			colormap;
+
+	XShmSegmentInfo*	shmseginfo;
+	unsigned char*		videomemory;
+
+	char*		        virtualscreen;
+	int 				videoaccesstype;
+
+	int 				width;
+	int 				height;
+	int 				depth;
+    int 				bpp;
+
+    /* (Null) cursor stuff*/
+	Pixmap  			pixmp1;
+	Pixmap  			pixmp2;
+	Cursor 				NullCursor;
 } XWindow;
 
-Bool dfb_x11_open_window ( DFBX11 *x11, XWindow** ppXW, int iXPos, int iYPos, int iWidth, int iHeight, DFBSurfacePixelFormat format );
-void dfb_x11_close_window( DFBX11 *x11, XWindow* pXW );
+Bool dfb_x11_open_window(XWindow** ppXW, int iXPos, int iYPos, int iWidth, int iHeight);
+void dfb_x11_close_window(XWindow* pXW);
 
 
 
diff --git a/DirectFB-1.3.0/tests/Makefile.am b/DirectFB-1.3.0/tests/Makefile.am
index 6d75909..9e989ff 100644
--- a/DirectFB-1.3.0/tests/Makefile.am
+++ b/DirectFB-1.3.0/tests/Makefile.am
@@ -10,7 +10,6 @@ INCLUDES = \
 
 
 noinst_PROGRAMS = \
-	dfbtest_blit	\
 	dfbtest_reinit	\
 	dfbtest_scale	\
 	dfbtest_window	\
@@ -22,9 +21,6 @@ noinst_PROGRAMS = \
 	fusion_stream
 
 
-dfbtest_blit_SOURCES = dfbtest_blit.c
-dfbtest_blit_LDADD   = ../src/libdirectfb.la ../lib/fusion/libfusion.la ../lib/direct/libdirect.la
-
 dfbtest_reinit_SOURCES = dfbtest_reinit.c
 dfbtest_reinit_LDADD   = ../src/libdirectfb.la ../lib/fusion/libfusion.la ../lib/direct/libdirect.la
 
diff --git a/DirectFB-1.3.0/tools/dfbdump.c b/DirectFB-1.3.0/tools/dfbdump.c
index 139760d..06b0de2 100644
--- a/DirectFB-1.3.0/tools/dfbdump.c
+++ b/DirectFB-1.3.0/tools/dfbdump.c
@@ -102,10 +102,10 @@ buffer_size( CoreSurface *surface, CoreSurfaceBuffer *buffer, bool video )
 
      fusion_vector_foreach (allocation, i, buffer->allocs) {
           if (video) {
-               if (allocation->access[CSAID_GPU])
+               if (allocation->access & (CSAF_GPU_READ | CSAF_GPU_WRITE))
                     mem += allocation->size;
           }
-          else if (!allocation->access[CSAID_GPU])
+          else if (!(allocation->access & (CSAF_GPU_READ | CSAF_GPU_WRITE)))
                mem += allocation->size;
      }
 
@@ -397,58 +397,44 @@ surface_pool_info_callback( CoreSurfacePool *pool,
                break;
      }
 
-     printf( "%6lu/%6luk  ", total / 1024, pool->desc.size / 1024 );
+     printf( "  %c %c  %c %c  %c ",
+             (pool->desc.access & CSAF_CPU_READ)  ? '*' : ' ',
+             (pool->desc.access & CSAF_CPU_WRITE) ? '*' : ' ',
+             (pool->desc.access & CSAF_GPU_READ)  ? '*' : ' ',
+             (pool->desc.access & CSAF_GPU_WRITE) ? '*' : ' ',
+             (pool->desc.access & CSAF_SHARED)    ? '*' : ' ' );
+
+
+     printf( "%6lu/%6luk   ", total / 1024, pool->desc.size / 1024 );
+
 
      if (pool->desc.types & CSTF_SHARED)
-          printf( "* " );
+          printf( "SHARED   " );
      else
-          printf( "  " );
+          printf( "         " );
 
 
      if (pool->desc.types & CSTF_INTERNAL)
-          printf( "INT " );
+          printf( "INTERNAL  " );
 
      if (pool->desc.types & CSTF_EXTERNAL)
-          printf( "EXT " );
+          printf( "EXTERNAL  " );
 
      if (!(pool->desc.types & (CSTF_INTERNAL | CSTF_EXTERNAL)))
-          printf( "    " );
+          printf( "          " );
 
 
      if (pool->desc.types & CSTF_LAYER)
           printf( "LAYER " );
-     else
-          printf( "      " );
 
      if (pool->desc.types & CSTF_WINDOW)
           printf( "WINDOW " );
-     else
-          printf( "       " );
 
      if (pool->desc.types & CSTF_CURSOR)
           printf( "CURSOR " );
-     else
-          printf( "       " );
 
      if (pool->desc.types & CSTF_FONT)
           printf( "FONT " );
-     else
-          printf( "     " );
-
-
-     for (i=CSAID_CPU; i<=CSAID_GPU; i++) {
-          printf( " %c%c%c",
-                  (pool->desc.access[i] & CSAF_READ)   ? 'r' : '-',
-                  (pool->desc.access[i] & CSAF_WRITE)  ? 'w' : '-',
-                  (pool->desc.access[i] & CSAF_SHARED) ? 's' : '-' );
-     }
-
-     for (i=CSAID_LAYER0; i<=CSAID_LAYER2; i++) {
-          printf( " %c%c%c",
-                  (pool->desc.access[i] & CSAF_READ)   ? 'r' : '-',
-                  (pool->desc.access[i] & CSAF_WRITE)  ? 'w' : '-',
-                  (pool->desc.access[i] & CSAF_SHARED) ? 's' : '-' );
-     }
 
      printf( "\n" );
 
@@ -460,7 +446,7 @@ dump_surface_pool_info()
 {
      printf( "\n" );
      printf( "-------------------------------------[ Surface Buffer Pools ]------------------------------------\n" );
-     printf( "Name                 Priority   Used/Capacity S I/E Resource Type Support     CPU GPU Layer 0 - 2\n" );
+     printf( "Name                 Priority  CrCw GrGw Sh   Used/Capacity  Usage    Storage   Resource Types\n" );
      printf( "-------------------------------------------------------------------------------------------------\n" );
 
      dfb_surface_pools_enumerate( surface_pool_info_callback, NULL );
@@ -544,9 +530,6 @@ context_callback( FusionObjectPool *pool,
      else
           printf( "PRIVATE  " );
 
-     if (context->rotation)
-          printf( "ROTATED %d ", context->rotation);
-
      if (dfb_layer_get_level( layer, &level ))
           printf( "N/A" );
      else
@@ -635,9 +618,6 @@ window_callback( CoreWindow *window,
      if (DFB_WINDOW_DESTROYED( window ))
           printf( "DESTROYED      " );
 
-     if (window->config.rotation)
-          printf( "ROTATED %d     ", window->config.rotation);
-
      printf( "\n" );
 
      return DFENUM_OK;
@@ -820,29 +800,23 @@ main( int argc, char *argv[] )
      }
 
      dump_surfaces();
-     fflush( stdout );
-
      dump_layers();
-     fflush( stdout );
 
 #if FUSION_BUILD_MULTI
      if (show_shm) {
           printf( "\n" );
           dump_shmpools();
-          fflush( stdout );
      }
 #endif
 
      if (show_pools) {
           printf( "\n" );
           dump_surface_pool_info();
-          fflush( stdout );
      }
 
      if (show_allocs) {
           printf( "\n" );
           dump_surface_pools();
-          fflush( stdout );
      }
 
      printf( "\n" );
diff --git a/DirectFB-1.3.0/tools/dfbpenmount.c b/DirectFB-1.3.0/tools/dfbpenmount.c
old mode 100755
new mode 100644
diff --git a/DirectFB-1.3.0/tools/dfbsummon.c b/DirectFB-1.3.0/tools/dfbsummon.c
new file mode 100644
index 0000000..57cfa9c
--- /dev/null
+++ b/DirectFB-1.3.0/tools/dfbsummon.c
@@ -0,0 +1,241 @@
+/*
+   (c) Copyright 2001-2008  The world wide DirectFB Open Source Community (directfb.org)
+   (c) Copyright 2000-2004  Convergence (integrated media) GmbH
+
+   All rights reserved.
+
+   Written by Denis Oliver Kropp <dok@directfb.org>,
+              Andreas Hundt <andi@fischlustig.de>,
+              Sven Neumann <neo@directfb.org>,
+              Ville Syrjl <syrjala@sci.fi> and
+              Claudio Ciccani <klan@users.sf.net>.
+
+   This file is subject to the terms and conditions of the MIT License:
+
+   Permission is hereby granted, free of charge, to any person
+   obtaining a copy of this software and associated documentation
+   files (the "Software"), to deal in the Software without restriction,
+   including without limitation the rights to use, copy, modify, merge,
+   publish, distribute, sublicense, and/or sell copies of the Software,
+   and to permit persons to whom the Software is furnished to do so,
+   subject to the following conditions:
+
+   The above copyright notice and this permission notice shall be
+   included in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*/
+
+#include <config.h>
+
+#include <time.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+
+#include <directfb.h>
+
+#include <core/gfxcard.h>
+#include <core/surface.h>
+#include <core/surfacemanager.h>
+
+#include <direct/util.h>
+
+/******************************************************************************/
+
+static IDirectFB            *dfb     = NULL;
+static IDirectFBSurface     *primary = NULL;
+static IDirectFBEventBuffer *events  = NULL;
+
+static int screen_width, screen_height;
+static unsigned int video_total, screen_total;
+
+/******************************************************************************/
+
+static void init_application( int *argc, char **argv[] );
+static void exit_application( int status );
+
+static void update_display();
+
+/******************************************************************************/
+
+int
+main( int argc, char *argv[] )
+{
+     /* Initialize application. */
+     init_application( &argc, &argv );
+
+     /* Main loop. */
+     while (1) {
+          DFBInputEvent event;
+
+          update_display();
+
+          events->WaitForEventWithTimeout( events, 0, 100 );
+
+          /* Check for new events. */
+          while (events->GetEvent( events, DFB_EVENT(&event) ) == DFB_OK) {
+
+               /* Handle key press events. */
+               if (event.type == DIET_KEYPRESS) {
+                    switch (event.key_symbol) {
+                         case DIKS_ESCAPE:
+                         case DIKS_POWER:
+                         case DIKS_BACK:
+                         case DIKS_SMALL_Q:
+                         case DIKS_CAPITAL_Q:
+                              exit_application( 0 );
+                              break;
+
+                         default:
+                              break;
+                    }
+               }
+          }
+     }
+
+     /* Shouldn't reach this. */
+     return 0;
+}
+
+/******************************************************************************/
+
+static void
+init_application( int *argc, char **argv[] )
+{
+     DFBResult                    ret;
+     DFBSurfaceDescription        desc;
+     DFBGraphicsDeviceDescription dev_desc;
+
+     /* Initialize DirectFB including command line parsing. */
+     ret = DirectFBInit( argc, argv );
+     if (ret) {
+          DirectFBError( "DirectFBInit() failed", ret );
+          exit_application( 1 );
+     }
+
+     /* Create the super interface. */
+     ret = DirectFBCreate( &dfb );
+     if (ret) {
+          DirectFBError( "DirectFBCreate() failed", ret );
+          exit_application( 2 );
+     }
+
+     dfb->GetDeviceDescription( dfb, &dev_desc );
+
+     video_total = dev_desc.video_memory ? : 1;
+
+     /* Request fullscreen mode. */
+     //dfb->SetCooperativeLevel( dfb, DFSCL_FULLSCREEN );
+
+     /* Fill the surface description. */
+     desc.flags = DSDESC_CAPS;
+     desc.caps  = DSCAPS_PRIMARY | DSCAPS_DOUBLE;
+
+     /* Create the primary surface. */
+     ret = dfb->CreateSurface( dfb, &desc, &primary );
+     if (ret) {
+          DirectFBError( "IDirectFB::CreateSurface() failed", ret );
+          exit_application( 3 );
+     }
+
+     /* Create an event buffer with key capable devices attached. */
+     ret = dfb->CreateInputEventBuffer( dfb, DICAPS_KEYS, DFB_FALSE, &events );
+     if (ret) {
+          DirectFBError( "IDirectFB::CreateEventBuffer() failed", ret );
+          exit_application( 4 );
+     }
+}
+
+static void
+exit_application( int status )
+{
+     /* Release the event buffer. */
+     if (events)
+          events->Release( events );
+
+     /* Release the primary surface. */
+     if (primary)
+          primary->Release( primary );
+
+     /* Release the super interface. */
+     if (dfb)
+          dfb->Release( dfb );
+
+     /* Terminate application. */
+     exit( status );
+}
+
+static DFBEnumerationResult
+chunk_callback( SurfaceBuffer *buffer,
+                int            offset,
+                int            length,
+                int            tolerations,
+                void          *ctx )
+{
+     u8           r = 0, g = 0, b = 0;
+     unsigned int screen_length, screen_offset;
+
+     if (buffer) {
+          switch (buffer->policy) {
+               case CSP_VIDEOLOW:
+                    g = 0x80;
+                    break;
+               case CSP_VIDEOHIGH:
+                    g = 0xa0;
+                    break;
+               case CSP_VIDEOONLY:
+                    b = 0xa0;
+                    break;
+               default:
+                    break;
+          }
+
+          r = tolerations*2/3;
+     }
+
+     primary->SetColor( primary, r, g, b, 0xff );
+
+     screen_length = (unsigned int)( (long long)length *
+                                     (long long)screen_total /
+                                     (long long)video_total );
+     screen_offset = (unsigned int)( (long long)offset *
+                                     (long long)screen_total /
+                                     (long long)video_total );
+
+     while (screen_length > 0) {
+          int x = screen_offset % screen_width;
+          int y = screen_offset / screen_width;
+
+          int w = MIN( screen_length, screen_width - x );
+
+          primary->FillRectangle( primary, x, y, w, 1 );
+
+          screen_length -= w;
+          screen_offset += w;
+     }
+
+     return DFENUM_OK;
+}
+
+static void
+update_display( void )
+{
+     primary->GetSize( primary, &screen_width, &screen_height );
+
+     screen_total = screen_width * screen_height;
+
+     primary->Clear( primary, 0x30, 0x30, 0x30, 0x80 );
+
+     dfb_surfacemanager_enumerate_chunks( dfb_gfxcard_surface_manager(),
+                                          chunk_callback, NULL );
+
+     primary->Flip( primary, NULL, 0 );
+}
diff --git a/DirectFB-1.3.0/tools/mknames.sh b/DirectFB-1.3.0/tools/mknames.sh
index 8e4ca2f..9eaffea 100755
--- a/DirectFB-1.3.0/tools/mknames.sh
+++ b/DirectFB-1.3.0/tools/mknames.sh
@@ -16,13 +16,10 @@ HEADER=$6
 
 cat << EOF
 
-
-struct DFB${NAME}Name {
-     ${ENUM} ${VALUE};
-     const char *name;
-};
-
-#define DirectFB${NAME}Names(Identifier) struct DFB${NAME}Name Identifier[] = { \\
+#define DirectFB${NAME}Names(Identifier) struct DFB${NAME}Name { \\
+     ${ENUM} ${VALUE}; \\
+     const char *name; \\
+} Identifier[] = { \\
 EOF
 
 egrep "^ +${PREFIX}_[0-9A-Za-z_]+[ ,]" $HEADER | grep -v ${PREFIX}_${NULL} | perl -p -e "s/^\\s*(${PREFIX}_)([\\w_]+)[ ,].*/     \\{ \\1\\2, \\\"\\2\\\" \\}, \\\\/"
diff --git a/DirectFB-1.3.0/wm/default/default.c b/DirectFB-1.3.0/wm/default/default.c
index dcf2479..81af480 100644
--- a/DirectFB-1.3.0/wm/default/default.c
+++ b/DirectFB-1.3.0/wm/default/default.c
@@ -176,36 +176,6 @@ static int keys_compare( const void *key1,
 
 /**************************************************************************************************/
 
-static inline void
-transform_point_in_window( CoreWindow *window,
-                           int        *x,
-                           int        *y )
-{
-     int _x = *x, _y = *y;
-
-     switch (window->config.rotation) {
-          default:
-               D_BUG( "invalid rotation %d", window->config.rotation );
-          case 0:
-               break;
-
-          case 90:
-               *x = window->config.bounds.w - _y - 1;
-               *y = _x;
-               break;
-
-          case 180:
-               *x = window->config.bounds.w - _x - 1;
-               *y = window->config.bounds.h - _y - 1;
-               break;
-
-          case 270:
-               *x = _y;
-               *y = window->config.bounds.h - _x - 1;
-               break;
-     }
-}
-
 static void
 post_event( CoreWindow     *window,
             StackData      *data,
@@ -258,40 +228,11 @@ send_button_event( CoreWindow          *window,
      we.y      = window->stack->cursor.y - window->config.bounds.y;
      we.button = (data->wm_level & 2) ? (event->button + 2) : event->button;
 
-     transform_point_in_window( window, &we.x, &we.y );
-
      post_event( window, data, &we );
 }
 
 /**************************************************************************************************/
 
-static inline void
-transform_window_to_stack( CoreWindow         *window,
-                           const DFBRectangle *rect,
-                           DFBRectangle       *ret_rect )
-{
-     DFB_RECTANGLE_ASSERT( rect );
-
-     ret_rect->x = rect->x;
-     ret_rect->y = rect->y;
-
-     switch (window->config.rotation) {
-          default:
-               D_BUG( "invalid rotation %d", window->config.rotation );
-          case 0:
-          case 180:
-               ret_rect->w = rect->w;
-               ret_rect->h = rect->h;
-               break;
-
-          case 90:
-          case 270:
-               ret_rect->w = rect->h;
-               ret_rect->h = rect->w;
-               break;
-     }
-}
-
 static inline int
 get_priority( const CoreWindow *window )
 {
@@ -456,11 +397,8 @@ window_at_pointer( CoreWindowStack *stack,
 
      fusion_vector_foreach_reverse (window, i, data->windows) {
           CoreWindowConfig *config  = &window->config;
+          DFBRectangle     *bounds  = &config->bounds;
           DFBWindowOptions  options = config->options;
-          DFBRectangle      rotated;
-          DFBRectangle     *bounds  = &rotated;
-
-          transform_window_to_stack( window, &config->bounds, &rotated );
 
           if (!(options & DWOP_GHOST) && config->opacity &&
               x >= bounds->x  &&  x < bounds->x + bounds->w &&
@@ -479,12 +417,14 @@ window_at_pointer( CoreWindowStack *stack,
                     return window;
                }
                else {
-                    u8                     buf[8];
                     CoreSurface           *surface = window->surface;
                     DFBSurfacePixelFormat  format  = surface->config.format;
-                    DFBRectangle           rect    = { wx, wy, 1, 1 };
+                    CoreSurfaceBufferLock  lock;
+
+                    if (dfb_surface_lock_buffer( surface, CSBR_FRONT, CSAF_CPU_READ, &lock ) == DFB_OK) {
+                         void *data  = lock.addr;
+                         int   pitch = lock.pitch;
 
-                    if (dfb_surface_read_buffer( surface, CSBR_FRONT, buf, 8, &rect ) == DFB_OK) {
                          if (options & DWOP_ALPHACHANNEL) {
                               int alpha = -1;
 
@@ -492,26 +432,26 @@ window_at_pointer( CoreWindowStack *stack,
 
                               switch (format) {
                                    case DSPF_AiRGB:
-                                        alpha = 0xff - (*(u32*)(buf) >> 24);
+                                        alpha = 0xff - (*(u32*)(data + 4 * wx + pitch * wy) >> 24);
                                         break;
                                    case DSPF_ARGB:
                                    case DSPF_AYUV:
-                                        alpha = *(u32*)(buf) >> 24;
+                                        alpha = *(u32*)(data + 4 * wx + pitch * wy) >> 24;
                                         break;
                                    case DSPF_ARGB1555:
                                    case DSPF_ARGB2554:
                                    case DSPF_ARGB4444:
-                                        alpha = *(u16*)(buf) & 0x8000;
+                                        alpha = *(u16*)(data + 2 * wx + pitch * wy) & 0x8000;
                                         alpha = alpha ? 0xff : 0x00;
                                         break;
                                    case DSPF_ALUT44:
-                                        alpha = *(u8*)(buf) & 0xf0;
+                                        alpha = *(u8*)(data + wx + pitch * wy) & 0xf0;
                                         alpha |= alpha >> 4;
                                         break;
                                    case DSPF_LUT2:
                                    case DSPF_LUT8: {
                                         CorePalette *palette = surface->palette;
-                                        u8           pix     = *((u8*) buf);
+                                        u8           pix     = *((u8*) data + wx + pitch * wy);
 
                                         if (palette && pix < palette->num_entries) {
                                              alpha = palette->entries[pix].a;
@@ -527,8 +467,11 @@ window_at_pointer( CoreWindowStack *stack,
                                         break;
                               }
 
-                              if (alpha) /* alpha == -1 on error */
+                              if (alpha) { /* alpha == -1 on error */
+                                   dfb_surface_unlock_buffer( surface, &lock );
                                    return window;
+                              }
+
                          }
                          if (options & DWOP_COLORKEYING) {
                               int pixel = 0;
@@ -537,11 +480,13 @@ window_at_pointer( CoreWindowStack *stack,
                                    case DSPF_ARGB:
                                    case DSPF_AiRGB:
                                    case DSPF_RGB32:
-                                        pixel = *(u32*)(buf) & 0x00ffffff;
+                                        pixel = *(u32*)(data +
+                                                        4 * wx + pitch * wy)
+                                                & 0x00ffffff;
                                         break;
 
                                    case DSPF_RGB24:
-                                        p = (buf);
+                                        p = (data + 3 * wx + pitch * wy);
 #ifdef WORDS_BIGENDIAN
                                         pixel = (p[0] << 16) | (p[1] << 8) | p[2];
 #else
@@ -550,29 +495,34 @@ window_at_pointer( CoreWindowStack *stack,
                                         break;
 
                                    case DSPF_RGB16:
-                                        pixel = *(u16*)(buf);
+                                        pixel = *(u16*)(data + 2 * wx +
+                                                        pitch * wy);
                                         break;
 
                                    case DSPF_ARGB4444:
                                    case DSPF_RGB444:
-                                        pixel = *(u16*)(buf)
+                                        pixel = *(u16*)(data + 2 * wx +
+                                                        pitch * wy)
                                                 & 0xfff;
                                         break;
 
                                    case DSPF_ARGB1555:
                                    case DSPF_RGB555:
                                    case DSPF_BGR555:
-                                        pixel = *(u16*)(buf)
+                                        pixel = *(u16*)(data + 2 * wx +
+                                                        pitch * wy)
                                                 & 0x7fff;
                                         break;
 
                                    case DSPF_RGB332:
                                    case DSPF_LUT8:
-                                        pixel = *(u8*)(buf);
+                                        pixel = *(u8*)(data +
+                                                       wx + pitch * wy);
                                         break;
 
                                    case DSPF_ALUT44:
-                                        pixel = *(u8*)(buf)
+                                        pixel = *(u8*)(data +
+                                                       wx + pitch * wy)
                                                 & 0x0f;
                                         break;
 
@@ -581,9 +531,14 @@ window_at_pointer( CoreWindowStack *stack,
                                         break;
                               }
 
-                              if (pixel != config->color_key)
+                              if ( pixel != config->color_key ) {
+                                   dfb_surface_unlock_buffer( surface, &lock );
                                    return window;
+                              }
+
                          }
+
+                         dfb_surface_unlock_buffer( surface, &lock );
                     }
                }
           }
@@ -662,8 +617,6 @@ update_focus( CoreWindowStack *stack,
                     we.x    = stack->cursor.x - before->config.bounds.x;
                     we.y    = stack->cursor.y - before->config.bounds.y;
 
-                    transform_point_in_window( before, &we.x, &we.y );
-
                     post_event( before, data, &we );
                }
 
@@ -675,8 +628,6 @@ update_focus( CoreWindowStack *stack,
                     we.x    = stack->cursor.x - after->config.bounds.x;
                     we.y    = stack->cursor.y - after->config.bounds.y;
 
-                    transform_point_in_window( after, &we.x, &we.y );
-
                     post_event( after, data, &we );
                }
 
@@ -711,23 +662,11 @@ ensure_focus( CoreWindowStack *stack,
 /**************************************************************************************************/
 /**************************************************************************************************/
 
-static inline void
-transform_stack_to_dest( CoreWindowStack *stack,
-                         const DFBRegion *region,
-                         DFBRegion       *ret_dest )
-{
-     DFBDimension size = { stack->width, stack->height };
-
-     DFB_REGION_ASSERT( region );
-
-     dfb_region_from_rotated( ret_dest, region, &size, stack->rotation );
-}
-
 static void
-draw_cursor( CoreWindowStack *stack, StackData *data, CardState *state, const DFBRegion *region )
+draw_cursor( CoreWindowStack *stack, StackData *data, CardState *state, DFBRegion *region )
 {
      DFBRectangle            src;
-     DFBRegion               dest;
+     DFBRectangle            clip;
      DFBSurfaceBlittingFlags flags = DSBLIT_BLEND_ALPHACHANNEL;
 
      D_ASSERT( stack != NULL );
@@ -737,14 +676,18 @@ draw_cursor( CoreWindowStack *stack, StackData *data, CardState *state, const DF
 
      D_ASSUME( stack->cursor.opacity > 0 );
 
-     /* Initialize destination region. */
-     transform_stack_to_dest( stack, region, &dest );
-
      /* Initialize source rectangle. */
      src.x = region->x1 - stack->cursor.x + stack->cursor.hot.x;
      src.y = region->y1 - stack->cursor.y + stack->cursor.hot.y;
      src.w = region->x2 - region->x1 + 1;
      src.h = region->y2 - region->y1 + 1;
+     /* Initialize source clipping rectangle */
+     clip.x = clip.y = 0;
+     clip.w = stack->cursor.surface->config.size.w;
+     clip.h = stack->cursor.surface->config.size.h;
+     /* Intersect rectangles */
+     if (!dfb_rectangle_intersect( &src, &clip ))
+          return;
 
      /* Use global alpha blending. */
      if (stack->cursor.opacity != 0xFF) {
@@ -821,14 +764,14 @@ draw_cursor( CoreWindowStack *stack, StackData *data, CardState *state, const DF
      }
 
      /* Set blitting flags. */
-     dfb_state_set_blitting_flags( state, flags | stack->rotated_blit );
+     dfb_state_set_blitting_flags( state, flags );
 
      /* Set blitting source. */
      state->source    = stack->cursor.surface;
      state->modified |= SMF_SOURCE;
 
      /* Blit from the window to the region being updated. */
-     dfb_gfxcard_blit( &src, dest.x1, dest.y1, state );
+     dfb_gfxcard_blit( &src, region->x1, region->y1, state );
 
      /* Reset blitting source. */
      state->source    = NULL;
@@ -837,29 +780,24 @@ draw_cursor( CoreWindowStack *stack, StackData *data, CardState *state, const DF
 
 static void
 draw_window( CoreWindow *window, CardState *state,
-             const DFBRegion *region, bool alpha_channel )
+             DFBRegion *region, bool alpha_channel )
 {
-     DFBRegion                dest;
+     DFBRectangle             src;
      DFBSurfaceBlittingFlags  flags = DSBLIT_NOFX;
-     CoreWindowStack         *stack;
      CoreWindowConfig        *config;
-     CoreSurface             *surface;
-     int                      rotation;
 
      D_ASSERT( window != NULL );
      D_MAGIC_ASSERT( state, CardState );
      DFB_REGION_ASSERT( region );
 
-     stack = window->stack;
-     D_MAGIC_ASSERT( stack, CoreWindowStack );
-
-     surface = window->surface;
-     D_MAGIC_ASSERT( surface, CoreSurface );
-
      config = &window->config;
 
-     /* Initialize destination region. */
-     transform_stack_to_dest( stack, region, &dest );
+     /* Initialize source rectangle. */
+     dfb_rectangle_from_region( &src, region );
+
+     /* Subtract window offset. */
+     src.x -= config->bounds.x;
+     src.y -= config->bounds.y;
 
      /* Use per pixel alpha blending. */
      if (alpha_channel && (config->options & DWOP_ALPHACHANNEL))
@@ -885,7 +823,7 @@ draw_window( CoreWindow *window, CardState *state,
      }
 
      /* Use automatic deinterlacing. */
-     if (surface->config.caps & DSCAPS_INTERLACED)
+     if (window->surface->config.caps & DSCAPS_INTERLACED)
           flags |= DSBLIT_DEINTERLACE;
 
      /* Different compositing methods depending on destination format. */
@@ -914,7 +852,7 @@ draw_window( CoreWindow *window, CardState *state,
                dfb_state_set_src_blend( state, DSBF_ONE );
 
                /* Need to premultiply source with As*Ac or only with Ac? */
-               if (! (surface->config.caps & DSCAPS_PREMULTIPLIED))
+               if (! (window->surface->config.caps & DSCAPS_PREMULTIPLIED))
                     flags |= DSBLIT_SRC_PREMULTIPLY;
                else if (flags & DSBLIT_BLEND_COLORALPHA)
                     flags |= DSBLIT_SRC_PREMULTCOLOR;
@@ -939,7 +877,7 @@ draw_window( CoreWindow *window, CardState *state,
                 * cx = Cd * (1-As*Ac) + Cs*As * Ac  (still same effect as above)
                 * ax = Ad * (1-As*Ac) + As*As * Ac  (wrong, but discarded anyways)
                 */
-               if (surface->config.caps & DSCAPS_PREMULTIPLIED) {
+               if (window->surface->config.caps & DSCAPS_PREMULTIPLIED) {
                     /* Need to premultiply source with Ac? */
                     if (flags & DSBLIT_BLEND_COLORALPHA)
                          flags |= DSBLIT_SRC_PREMULTCOLOR;
@@ -951,46 +889,20 @@ draw_window( CoreWindow *window, CardState *state,
           }
      }
 
-     rotation = (window->config.rotation + stack->rotation) % 360;
-     switch (rotation) {
-          default:
-               D_BUG( "invalid rotation %d", rotation );
-          case 0:
-               break;
-
-          case 90:
-               flags |= DSBLIT_ROTATE90;
-               break;
-
-          case 180:
-               flags |= DSBLIT_ROTATE180;
-               break;
-
-          case 270:
-               flags |= DSBLIT_ROTATE270;
-               break;
-     }
-
      /* Set blitting flags. */
      dfb_state_set_blitting_flags( state, flags );
 
      /* Set blitting source. */
-     state->source    = surface;
+     state->source    = window->surface;
      state->modified |= SMF_SOURCE;
 
      if (window->config.options & DWOP_SCALE) {
-          DFBDimension size = { stack->width, stack->height };
           DFBRegion    clip = state->clip;
-          DFBRectangle src  = { 0, 0, surface->config.size.w, surface->config.size.h };
-          DFBRectangle dst;
-          DFBRectangle bounds;
-
-          transform_window_to_stack( window, &window->config.bounds, &bounds );
-
-          dfb_rectangle_from_rotated( &dst, &bounds, &size, stack->rotation );
+          DFBRectangle dst  = window->config.bounds;
+          DFBRectangle src  = { 0, 0, window->surface->config.size.w, window->surface->config.size.h };
 
           /* Change clipping region. */
-          dfb_state_set_clip( state, &dest );
+          dfb_state_set_clip( state, region );
 
           /* Scale window to the screen clipped by the region being updated. */
           dfb_gfxcard_stretchblit( &src, &dst, state );
@@ -999,27 +911,11 @@ draw_window( CoreWindow *window, CardState *state,
           dfb_state_set_clip( state, &clip );
      }
      else {
-          DFBDimension size = { config->bounds.w, config->bounds.h };
-          DFBRectangle rect, src;
-
-          D_ASSERT( surface->config.size.w == config->bounds.w );
-          D_ASSERT( surface->config.size.h == config->bounds.h );
-
-          /* Initialize source rectangle. */
-          dfb_rectangle_from_region( &rect, region );
-
-          /* Subtract window offset. */
-          rect.x -= config->bounds.x;
-          rect.y -= config->bounds.y;
-
-          /* Rotate back to window surface. */
-          if (window->config.rotation == 90 || window->config.rotation == 270)
-               D_UTIL_SWAP( size.w, size.h );
-
-          dfb_rectangle_from_rotated( &src, &rect, &size, (360 - window->config.rotation) % 360 );
+          D_ASSERT( window->surface->config.size.w  == window->config.bounds.w );
+          D_ASSERT( window->surface->config.size.h == window->config.bounds.h );
 
           /* Blit from the window to the region being updated. */
-          dfb_gfxcard_blit( &src, dest.x1, dest.y1, state );
+          dfb_gfxcard_blit( &src, region->x1, region->y1, state );
      }
 
      /* Reset blitting source. */
@@ -1028,9 +924,9 @@ draw_window( CoreWindow *window, CardState *state,
 }
 
 static void
-draw_background( CoreWindowStack *stack, CardState *state, const DFBRegion *region )
+draw_background( CoreWindowStack *stack, CardState *state, DFBRegion *region )
 {
-     DFBRegion dest;
+     DFBRectangle dst;
 
      D_ASSERT( stack != NULL );
      D_MAGIC_ASSERT( state, CardState );
@@ -1039,57 +935,67 @@ draw_background( CoreWindowStack *stack, CardState *state, const DFBRegion *regi
      D_ASSERT( stack->bg.image != NULL || (stack->bg.mode != DLBM_IMAGE &&
                                            stack->bg.mode != DLBM_TILE) );
 
-     /* Initialize destination region. */
-     transform_stack_to_dest( stack, region, &dest );
-
-     if (!dfb_region_intersect( &dest, 0, 0,
-                                state->destination->config.size.w - 1, state->destination->config.size.h - 1 ))
-         return;
+     /* Initialize destination rectangle. */
+     dfb_rectangle_from_region( &dst, region );
 
      switch (stack->bg.mode) {
           case DLBM_COLOR: {
-               DFBRectangle  rect  = DFB_RECTANGLE_INIT_FROM_REGION( &dest );
-               CoreSurface  *dst   = state->destination;
-               DFBColor     *color = &stack->bg.color;
-
-               D_MAGIC_ASSERT( dst, CoreSurface );
+               CoreSurface *dest  = state->destination;
+               DFBColor    *color = &stack->bg.color;
 
                /* Set the background color. */
-               if (DFB_PIXELFORMAT_IS_INDEXED( dst->config.format ))
+               if (DFB_PIXELFORMAT_IS_INDEXED( dest->config.format ))
                     dfb_state_set_color_index( state,  /* FIXME: don't search every time */
-                                               dfb_palette_search( dst->palette, color->r,
+                                               dfb_palette_search( dest->palette, color->r,
                                                                    color->g, color->b, color->a ) );
                else
                     dfb_state_set_color( state, color );
 
                /* Simply fill the background. */
-               dfb_gfxcard_fillrectangles( &rect, 1, state );
+               dfb_gfxcard_fillrectangles( &dst, 1, state );
+
                break;
           }
 
           case DLBM_IMAGE: {
-               CoreSurface  *bg   = stack->bg.image;
-               DFBRegion     clip = state->clip;
-               DFBRectangle  src  = { 0, 0, bg->config.size.w, bg->config.size.h };
-               DFBRectangle  dst  = { 0, 0, stack->rotated_width, stack->rotated_height };
-
-               D_MAGIC_ASSERT( bg, CoreSurface );
+               CoreSurface *bg = stack->bg.image;
 
                /* Set blitting source. */
                state->source    = bg;
                state->modified |= SMF_SOURCE;
 
                /* Set blitting flags. */
-               dfb_state_set_blitting_flags( state, stack->rotated_blit );
-
-               /* Set clipping region. */
-               dfb_state_set_clip( state, &dest );
+               dfb_state_set_blitting_flags( state, DSBLIT_NOFX );
 
-               /* Blit background image. */
-               dfb_gfxcard_stretchblit( &src, &dst, state );
-
-               /* Restore clipping region. */
-               dfb_state_set_clip( state, &clip );
+               /* Check the size of the background image. */
+               if (bg->config.size.w == stack->width && bg->config.size.h == stack->height) {
+                    /* Simple blit for 100% fitting background image. */
+                    dfb_gfxcard_blit( &dst, dst.x, dst.y, state );
+               }
+               else {
+                    DFBRegion    clip = state->clip;
+                    DFBRectangle src  = { 0, 0,
+                                          bg->config.size.w,
+                                          bg->config.size.h };
+
+                    /* Change clipping region. */
+                    dfb_state_set_clip( state, region );
+
+                    /*
+                     * Scale image to fill the whole screen
+                     * clipped to the region being updated.
+                     */
+                    dst.x = 0;
+                    dst.y = 0;
+                    dst.w = stack->width;
+                    dst.h = stack->height;
+
+                    /* Stretch blit for non fitting background images. */
+                    dfb_gfxcard_stretchblit( &src, &dst, state );
+
+                    /* Restore clipping region. */
+                    dfb_state_set_clip( state, &clip );
+               }
 
                /* Reset blitting source. */
                state->source    = NULL;
@@ -1103,17 +1009,15 @@ draw_background( CoreWindowStack *stack, CardState *state, const DFBRegion *regi
                DFBRegion     clip = state->clip;
                DFBRectangle  src  = { 0, 0, bg->config.size.w, bg->config.size.h };
 
-               D_MAGIC_ASSERT( bg, CoreSurface );
-
                /* Set blitting source. */
                state->source    = bg;
                state->modified |= SMF_SOURCE;
 
                /* Set blitting flags. */
-               dfb_state_set_blitting_flags( state, stack->rotated_blit );
+               dfb_state_set_blitting_flags( state, DSBLIT_NOFX );
 
                /* Change clipping region. */
-               dfb_state_set_clip( state, &clip );
+               dfb_state_set_clip( state, region );
 
                /* Tiled blit (aligned). */
                dfb_gfxcard_tileblit( &src,
@@ -1167,12 +1071,8 @@ update_region( CoreWindowStack *stack,
           CoreWindow *window = fusion_vector_at( &data->windows, i );
 
           if (VISIBLE_WINDOW( window )) {
-               DFBRectangle rotated;
-
-               transform_window_to_stack( window, &window->config.bounds, &rotated );
-
                if (dfb_region_intersect( &region,
-                                         DFB_REGION_VALS_FROM_RECTANGLE( &rotated )))
+                                         DFB_REGION_VALS_FROM_RECTANGLE( &window->config.bounds )))
                     break;
           }
 
@@ -1290,8 +1190,7 @@ repaint_stack( CoreWindowStack     *stack,
      CoreLayer   *layer;
      CardState   *state;
      CoreSurface *surface;
-     DFBRegion    flips[num_updates];
-     int          num_flips = 0;
+     DFBRegion    cursor_inter;
 
      D_ASSERT( stack != NULL );
      D_ASSERT( stack->context != NULL );
@@ -1313,7 +1212,6 @@ repaint_stack( CoreWindowStack     *stack,
      state->modified    |= SMF_DESTINATION;
 
      for (i=0; i<num_updates; i++) {
-          DFBRegion        dest;
           const DFBRegion *update = &updates[i];
 
           DFB_REGION_ASSERT( update );
@@ -1321,38 +1219,26 @@ repaint_stack( CoreWindowStack     *stack,
           D_DEBUG_AT( WM_Default, "  -> %d, %d - %dx%d  (%d)\n",
                       DFB_RECTANGLE_VALS_FROM_REGION( update ), i );
 
-          transform_stack_to_dest( stack, update, &dest );
-
-          if (!dfb_region_intersect( &dest, 0, 0, surface->config.size.w - 1, surface->config.size.h - 1 ))
-               continue;
-
           /* Set clipping region. */
-          dfb_state_set_clip( state, &dest );
+          dfb_state_set_clip( state, update );
 
           /* Compose updated region. */
           update_region( stack, data, state,
                          fusion_vector_size( &data->windows ) - 1,
-                         DFB_REGION_VALS( update ) );
-
-          flips[num_flips++] = dest;
+                         update->x1, update->y1, update->x2, update->y2 );
 
           /* Update cursor? */
-          if (data->cursor_drawn) {
-               DFBRegion cursor_rotated;
+          cursor_inter = data->cursor_region;
+          if (data->cursor_drawn && dfb_region_region_intersect( &cursor_inter, update )) {
+               DFBRectangle rect = DFB_RECTANGLE_INIT_FROM_REGION( &cursor_inter );
 
                D_ASSUME( data->cursor_bs_valid );
 
-               transform_stack_to_dest( stack, &data->cursor_region, &cursor_rotated );
-
-               if (dfb_region_region_intersect( &dest, &cursor_rotated )) {
-                    DFBRectangle rect = DFB_RECTANGLE_INIT_FROM_REGION( &dest );
-
-                    dfb_gfx_copy_to( surface, data->cursor_bs, &rect,
-                                     rect.x - cursor_rotated.x1,
-                                     rect.y - cursor_rotated.y1, true );
+               dfb_gfx_copy_to( surface, data->cursor_bs, &rect,
+                                rect.x - data->cursor_region.x1,
+                                rect.y - data->cursor_region.y1, true );
 
-                    draw_cursor( stack, data, state, &data->cursor_region );
-               }
+               draw_cursor( stack, data, state, &cursor_inter );
           }
      }
 
@@ -1364,13 +1250,13 @@ repaint_stack( CoreWindowStack     *stack,
      if (stack->cursor.enabled)
           flags |= DSFLIP_BLIT;
 
-     for (i=0; i<num_flips; i++) {
-          const DFBRegion *flip = &flips[i];
+     for (i=0; i<num_updates; i++) {
+          const DFBRegion *update = &updates[i];
 
-          DFB_REGION_ASSERT( flip );
+          DFB_REGION_ASSERT( update );
 
           /* Flip the updated region .*/
-          dfb_layer_region_flip_update( region, flip, flags );
+          dfb_layer_region_flip_update( region, update, flags );
      }
 }
 
@@ -1418,9 +1304,6 @@ process_updates( StackData           *data,
 //          direct_log_printf( NULL, "%s() <- %d regions, total %d, bounding %d (%d/%d: %d), FULL UPDATE\n",
 //                             __FUNCTION__, data->updates.num_regions, total, bounding, n, d, bounding*n/d );
 
-//          if (context->config.buffermode == DLBM_FRONTONLY)
-//               dfb_region_transpose(&region, context->rotation);
-
           repaint_stack( stack, data, primary, &region, 1, flags );
      }
      else if (data->updates.num_regions < 2 || total < bounding * n / d)
@@ -1465,9 +1348,8 @@ wind_of_change( CoreWindowStack     *stack,
      for (; current > changed; current--) {
           CoreWindow       *window;
           CoreWindowConfig *config;
+          DFBRectangle     *bounds;
           DFBRegion         opaque;
-          DFBRectangle      rotated;
-          DFBRectangle     *bounds = &rotated;
           DFBWindowOptions  options;
 
           D_ASSERT( changed >= 0 );
@@ -1476,10 +1358,9 @@ wind_of_change( CoreWindowStack     *stack,
 
           window  = fusion_vector_at( &data->windows, current );
           config  = &window->config;
+          bounds  = &config->bounds;
           options = config->options;
 
-          transform_window_to_stack( window, &config->bounds, &rotated );
-
           /*
                can skip opaque region
           */
@@ -1570,11 +1451,9 @@ update_window( CoreWindow          *window,
                bool                 scale_region )
 {
      DFBRegion        area;
-     DFBRegion        update;
      StackData       *data;
      CoreWindowStack *stack;
      DFBRectangle    *bounds;
-     DFBDimension     size;
 
      D_ASSERT( window != NULL );
      D_ASSERT( window_data != NULL );
@@ -1593,8 +1472,6 @@ update_window( CoreWindow          *window,
           return DFB_OK;
 
      bounds = &window->config.bounds;
-     size.w = bounds->w;
-     size.h = bounds->h;
 
      if (region) {
           if (scale_region && (window->config.options & DWOP_SCALE)) {
@@ -1627,29 +1504,24 @@ update_window( CoreWindow          *window,
 
                /* limit to window area */
                dfb_region_clip( &area, 0, 0, bounds->w - 1, bounds->h - 1 );
+
+               /* screen offset */
+               dfb_region_translate( &area, bounds->x, bounds->y );
           }
           else
-               area = *region;
+               area = DFB_REGION_INIT_TRANSLATED( region, bounds->x, bounds->y );
      }
-     else {
-          area.x1 = area.y1 = 0;
-          area.x2 = bounds->w - 1;
-          area.y2 = bounds->h - 1;
-     }
-
-     dfb_region_from_rotated( &update, &area, &size, window->config.rotation );
-
-     /* screen offset */
-     dfb_region_translate( &update, bounds->x, bounds->y );
+     else
+          area = DFB_REGION_INIT_FROM_RECTANGLE( bounds );
 
-     if (!dfb_unsafe_region_intersect( &update, 0, 0, stack->width - 1, stack->height - 1 ))
+     if (!dfb_unsafe_region_intersect( &area, 0, 0, stack->width - 1, stack->height - 1 ))
           return DFB_OK;
 
      if (force_complete)
-          dfb_updates_add( &data->updates, &update );
+          dfb_updates_add( &data->updates, &area );
      else
           repaint_stack_for_window( stack, data, window->primary_region,
-                                    &update, flags, get_index( data, window ) );
+                                    &area, flags, get_index( data, window ) );
 
      return DFB_OK;
 }
@@ -1791,28 +1663,32 @@ move_window( CoreWindow *window,
      DFBWindowEvent  evt;
      DFBRectangle   *bounds = &window->config.bounds;
 
+     bounds->x += dx;
+     bounds->y += dy;
+
      if (window->region) {
           data->config.dest.x += dx;
           data->config.dest.y += dy;
 
           ret = dfb_layer_region_set_configuration( window->region, &data->config, CLRCF_DEST );
           if (ret) {
+               bounds->x -= dx;
+               bounds->y -= dy;
+
                data->config.dest.x -= dx;
                data->config.dest.y -= dy;
 
                return ret;
           }
-
-          bounds->x += dx;
-          bounds->y += dy;
      }
      else if (VISIBLE_WINDOW(window)) {
-          update_window( window, data, NULL, 0, false, false, false );
+          DFBRegion region = { 0, 0, bounds->w - 1, bounds->h - 1 };
 
-          bounds->x += dx;
-          bounds->y += dy;
+          update_window( window, data, &region, 0, false, false, false );
 
-          update_window( window, data, NULL, 0, false, false, false );
+          dfb_region_translate( &region, -dx, -dy );
+
+          update_window( window, data, &region, 0, false, false, false );
      }
 
      /* Send new position */
@@ -1863,6 +1739,9 @@ resize_window( CoreWindow *window,
                return ret;
      }
 
+     bounds->w = width;
+     bounds->h = height;
+
      if (window->region) {
           data->config.dest.w = data->config.source.w = data->config.width  = width;
           data->config.dest.h = data->config.source.h = data->config.height = height;
@@ -1881,23 +1760,20 @@ resize_window( CoreWindow *window,
           dfb_region_intersect( &window->config.opaque, 0, 0, width - 1, height - 1 );
 
           if (VISIBLE_WINDOW (window)) {
-               if (ow > width) {
-                    DFBRegion region = { width, 0, ow - 1, MIN(height, oh) - 1 };
+               if (ow > bounds->w) {
+                    DFBRegion region = { bounds->w, 0, ow - 1, MIN(bounds->h, oh) - 1 };
 
                     update_window( window, data, &region, 0, false, false, false );
                }
 
-               if (oh > height) {
-                    DFBRegion region = { 0, height, MAX(width, ow) - 1, oh - 1 };
+               if (oh > bounds->h) {
+                    DFBRegion region = { 0, bounds->h, MAX(bounds->w, ow) - 1, oh - 1 };
 
                     update_window( window, data, &region, 0, false, false, false );
                }
           }
      }
 
-     bounds->w = width;
-     bounds->h = height;
-
      /* Send new size */
      evt.type = DWET_SIZE;
      evt.w    = bounds->w;
@@ -2352,8 +2228,6 @@ request_focus( CoreWindow *window,
           we.x    = stack->cursor.x - entered->config.bounds.x;
           we.y    = stack->cursor.y - entered->config.bounds.y;
 
-          transform_point_in_window( entered, &we.x, &we.y );
-
           post_event( entered, data, &we );
 
           data->entered_window = NULL;
@@ -2768,8 +2642,6 @@ perform_motion( CoreWindowStack *stack,
                     we.x    = stack->cursor.x - window->config.bounds.x;
                     we.y    = stack->cursor.y - window->config.bounds.y;
 
-                    transform_point_in_window( window, &we.x, &we.y );
-
                     post_event( window, data, &we );
                }
                else if (!update_focus( stack, data, wmdata ) && data->entered_window) {
@@ -2779,8 +2651,6 @@ perform_motion( CoreWindowStack *stack,
                     we.x    = stack->cursor.x - window->config.bounds.x;
                     we.y    = stack->cursor.y - window->config.bounds.y;
 
-                    transform_point_in_window( window, &we.x, &we.y );
-
                     post_event( window, data, &we );
                }
 
@@ -2841,8 +2711,6 @@ handle_wheel( CoreWindowStack *stack,
                we.y    = stack->cursor.y - window->config.bounds.y;
                we.step = dz;
 
-               transform_point_in_window( window, &we.x, &we.y );
-
                post_event( window, data, &we );
           }
      }
@@ -2854,76 +2722,11 @@ handle_axis_motion( CoreWindowStack     *stack,
                     WMData              *wmdata,
                     const DFBInputEvent *event )
 {
-     CoreLayerContext *context;
-     DFBInputEvent     rotated_event;
-
      D_ASSERT( stack != NULL );
      D_ASSERT( data != NULL );
      D_ASSERT( event != NULL );
      D_ASSERT( event->type == DIET_AXISMOTION );
 
-     context = stack->context;
-     D_MAGIC_ASSERT( context, CoreLayerContext );
-
-     if (event->flags & DIEF_AXISREL) {
-          rotated_event = *event;
-          event = &rotated_event;
-
-          if (event->axis == DIAI_X) {
-               if (context->rotation == 90) {
-                    rotated_event.axis = DIAI_Y;
-               }
-               else if (context->rotation == 180) {
-                    rotated_event.axisrel = -rotated_event.axisrel;
-               }
-               else if (context->rotation == 270) {
-                    rotated_event.axis = DIAI_Y;
-                    rotated_event.axisrel = -rotated_event.axisrel;
-               }
-          }
-          else if (event->axis == DIAI_Y) {
-               if (context->rotation == 90) {
-                    rotated_event.axis = DIAI_X;
-                    rotated_event.axisrel = -rotated_event.axisrel;
-               }
-               else if (context->rotation == 180) {
-                    rotated_event.axisrel = -rotated_event.axisrel;
-               }
-               else if (context->rotation == 270) {
-                    rotated_event.axis = DIAI_X;
-               }
-          }
-     }
-     else if (event->flags & DIEF_AXISABS) {
-          rotated_event = *event;
-          event = &rotated_event;
-
-          if (event->axis == DIAI_X) {
-               if (context->rotation == 90) {
-                    rotated_event.axis = DIAI_Y;
-               }
-               else if (context->rotation == 180) {
-                    rotated_event.axisabs = stack->rotated_width - rotated_event.axisabs;
-               }
-               else if (context->rotation == 270) {
-                    rotated_event.axis = DIAI_Y;
-                    rotated_event.axisabs = stack->rotated_width - rotated_event.axisabs;
-               }
-          }
-          else if (event->axis == DIAI_Y) {
-               if (context->rotation == 90) {
-                    rotated_event.axis = DIAI_X;
-                    rotated_event.axisabs = stack->rotated_height - rotated_event.axisabs;
-               }
-               else if (context->rotation == 180) {
-                    rotated_event.axisabs = stack->rotated_height - rotated_event.axisabs;
-               }
-               else if (context->rotation == 270) {
-                    rotated_event.axis = DIAI_X;
-               }
-          }
-     }
-
      if (event->flags & DIEF_AXISREL) {
           int rel = event->axisrel;
 
@@ -3585,14 +3388,6 @@ wm_set_window_config( CoreWindow             *window,
           }
      }
 
-     if (flags & CWCF_ROTATION) {
-          update_window( window, window_data, NULL, DSFLIP_NONE, false, false, false );
-
-          window->config.rotation = config->rotation;
-
-          update_window( window, window_data, NULL, DSFLIP_NONE, false, false, false );
-     }
-
      if (flags & CWCF_STACKING)
           restack_window( window, window_data, window, window_data, 0, config->stacking );
 
@@ -3779,7 +3574,7 @@ static DFBResult
 wm_update_stack( CoreWindowStack     *stack,
                  void                *wm_data,
                  void                *stack_data,
-                 const DFBRegion     *region,     /* stack coordinates */
+                 const DFBRegion     *region,
                  DFBSurfaceFlipFlags  flags )
 {
      StackData *data = stack_data;
@@ -3830,7 +3625,6 @@ wm_update_cursor( CoreWindowStack       *stack,
                   CoreCursorUpdateFlags  flags )
 {
      DFBResult         ret;
-     DFBRegion         old_dest;
      DFBRegion         old_region;
      WMData           *wmdata   = wm_data;
      StackData        *data     = stack_data;
@@ -3847,8 +3641,6 @@ wm_update_cursor( CoreWindowStack       *stack,
 
      old_region = data->cursor_region;
 
-     transform_stack_to_dest( stack, &old_region, &old_dest );
-
      if (flags & (CCUF_ENABLE | CCUF_POSITION | CCUF_SIZE)) {
           data->cursor_bs_valid  = false;
 
@@ -3871,19 +3663,15 @@ wm_update_cursor( CoreWindowStack       *stack,
      D_ASSERT( context != NULL );
 
      if (!data->cursor_bs) {
-          CoreSurface            *cursor_bs;
-          DFBSurfaceCapabilities  caps = DSCAPS_NONE;
-          DFBDimension            size = stack->cursor.size;
+          CoreSurface *cursor_bs;
+          DFBSurfaceCapabilities caps = DSCAPS_NONE;
 
           D_ASSUME( flags & CCUF_ENABLE );
 
           dfb_surface_caps_apply_policy( stack->cursor.policy, &caps );
 
-          if (stack->rotation == 90 || stack->rotation == 270)
-               D_UTIL_SWAP( size.w, size.h );
-
           /* Create the cursor backing store surface. */
-          ret = dfb_surface_create_simple( wmdata->core, size.w, size.h,
+          ret = dfb_surface_create_simple( wmdata->core, stack->cursor.size.w, stack->cursor.size.h,
                                            context->config.pixelformat, caps, CSTF_SHARED | CSTF_CURSOR,
                                            0, /* FIXME: no shared cursor objects, no cursor id */
                                            NULL, &cursor_bs );
@@ -3906,7 +3694,8 @@ wm_update_cursor( CoreWindowStack       *stack,
           return ret;
 
      surface = primary->surface;
-     D_MAGIC_ASSERT( surface, CoreSurface );
+
+     D_ASSERT( surface != NULL );
 
      if (flags & CCUF_ENABLE) {
          /* Ensure valid back buffer. From now on swapping is prevented until cursor is disabled.
@@ -3924,16 +3713,14 @@ wm_update_cursor( CoreWindowStack       *stack,
      }
 
      /* restore region under cursor */
-     if (data->cursor_drawn && dfb_region_intersect( &old_dest, 0, 0,
-                                                     surface->config.size.w - 1, surface->config.size.h - 1 ))
-     {
+     if (data->cursor_drawn) {
           DFBRectangle rect = { 0, 0,
-                                old_dest.x2 - old_dest.x1 + 1,
-                                old_dest.y2 - old_dest.y1 + 1 };
+                                old_region.x2 - old_region.x1 + 1,
+                                old_region.y2 - old_region.y1 + 1 };
 
           D_ASSERT( stack->cursor.opacity || (flags & CCUF_OPACITY) );
 
-          dfb_gfx_copy_to( data->cursor_bs, surface, &rect, old_dest.x1, old_dest.y1, false );
+          dfb_gfx_copy_to( data->cursor_bs, surface, &rect, old_region.x1, old_region.y1, false );
 
           data->cursor_drawn = false;
 
@@ -3941,12 +3728,9 @@ wm_update_cursor( CoreWindowStack       *stack,
      }
 
      if (flags & CCUF_SIZE) {
-          DFBDimension size = stack->cursor.size;
-
-          if (stack->rotation == 90 || stack->rotation == 270)
-               D_UTIL_SWAP( size.w, size.h );
-
-          ret = dfb_surface_reformat( data->cursor_bs, size.w, size.h, data->cursor_bs->config.format );
+          ret = dfb_surface_reformat( data->cursor_bs,
+                                      stack->cursor.size.w, stack->cursor.size.h,
+                                      data->cursor_bs->config.format );
           if (ret)
                D_DERROR( ret, "WM/Default: Failed resizing backing store for cursor from %dx%d to %dx%d!\n",
                          data->cursor_bs->config.size.w, data->cursor_bs->config.size.h,
@@ -3957,22 +3741,13 @@ wm_update_cursor( CoreWindowStack       *stack,
           dfb_surface_unlink( &data->cursor_bs );
      }
      else if (stack->cursor.opacity) {
-          DFBRegion  dest;
           CoreLayer *layer = dfb_layer_at( context->layer_id );
           CardState *state = &layer->state;
-
-          transform_stack_to_dest( stack, &data->cursor_region, &dest );
-
-          if (!dfb_region_intersect( &dest, 0, 0, surface->config.size.w - 1, surface->config.size.h - 1 )) {
-               if (restored)
-                    dfb_layer_region_flip_update( primary, &old_dest, DSFLIP_BLIT );
-               dfb_layer_region_unref( primary );
-               return DFB_OK;
-          }
+          DFBRectangle source = primary->config.source;
 
           /* backup region under cursor */
           if (!data->cursor_bs_valid) {
-               DFBRectangle rect = DFB_RECTANGLE_INIT_FROM_REGION( &dest );
+               DFBRectangle rect = DFB_RECTANGLE_INIT_FROM_REGION( &data->cursor_region );
 
                D_ASSERT( !data->cursor_drawn );
 
@@ -3989,7 +3764,7 @@ wm_update_cursor( CoreWindowStack       *stack,
           state->modified    |= SMF_DESTINATION;
 
           /* Set clipping region. */
-          dfb_state_set_clip( state, &dest );
+          dfb_state_set_clip( state, &data->cursor_region );
 
           /* draw cursor */
           draw_cursor( stack, data, state, &data->cursor_region );
@@ -4001,38 +3776,31 @@ wm_update_cursor( CoreWindowStack       *stack,
           data->cursor_drawn = true;
 
           if (restored) {
-               if (dfb_region_region_intersects( &old_dest, &dest ))
-                    dfb_region_region_union( &old_dest, &dest );
+               if (dfb_region_region_intersects( &old_region, &data->cursor_region ))
+                    dfb_region_region_union( &old_region, &data->cursor_region );
                else
-                    dfb_layer_region_flip_update( primary, &dest, DSFLIP_BLIT );
+                    dfb_layer_region_flip_update( primary, &data->cursor_region, DSFLIP_BLIT );
 
-               dfb_layer_region_flip_update( primary, &old_dest, DSFLIP_BLIT );
+               dfb_layer_region_flip_update( primary, &old_region, DSFLIP_BLIT );
           }
           else
-               dfb_layer_region_flip_update( primary, &dest, DSFLIP_BLIT );
-
-          /* Pan to follow the cursor? */
-          if (primary->config.source.w < surface->config.size.w || primary->config.source.h < surface->config.size.h) {
-               DFBRectangle source = primary->config.source;
+               dfb_layer_region_flip_update( primary, &data->cursor_region, DSFLIP_BLIT );
 
-               if (stack->rotation)
-                    D_UNIMPLEMENTED();
+          /* Pan to follow the cursor. */
+          if (source.x > stack->cursor.x)
+               source.x = stack->cursor.x;
+          else if (source.x + source.w - 1 < stack->cursor.x)
+               source.x = stack->cursor.x - source.w + 1;
 
-               if (source.x > stack->cursor.x)
-                    source.x = stack->cursor.x;
-               else if (source.x + source.w - 1 < stack->cursor.x)
-                    source.x = stack->cursor.x - source.w + 1;
+          if (source.y > stack->cursor.y)
+               source.y = stack->cursor.y;
+          else if (source.y + source.h - 1 < stack->cursor.y)
+               source.y = stack->cursor.y - source.h + 1;
 
-               if (source.y > stack->cursor.y)
-                    source.y = stack->cursor.y;
-               else if (source.y + source.h - 1 < stack->cursor.y)
-                    source.y = stack->cursor.y - source.h + 1;
-
-               dfb_layer_context_set_sourcerectangle( context, &source );
-          }
+          dfb_layer_context_set_sourcerectangle( context, &source );
      }
      else if (restored)
-          dfb_layer_region_flip_update( primary, &old_dest, DSFLIP_BLIT );
+          dfb_layer_region_flip_update( primary, &old_region, DSFLIP_BLIT );
 
      /* Unref primary region. */
      dfb_layer_region_unref( primary );
diff --git a/DirectFB-1.3.0/wm/unique/FLOW b/DirectFB-1.3.0/wm/unique/FLOW
new file mode 100644
index 0000000..f9c8611
--- /dev/null
+++ b/DirectFB-1.3.0/wm/unique/FLOW
@@ -0,0 +1,15 @@
+
+
+Input event handling
+---------------------
+
+                                   UniqueCursor
+                                        |
+                                        |
+CoreInputDevice  )---  UniquePointer  )-')-.
+                                           |
+                                   UniqueInputSwitch  -->  UniqueInputChannel  )---  UniqueWindow  -->  CoreWindow
+                                           |
+CoreInputDevice  )-.-  UniqueKeyboard  )---'
+                   |
+CoreInputDevice  )-'
diff --git a/DirectFB-1.3.0/wm/unique/IDEAS b/DirectFB-1.3.0/wm/unique/IDEAS
new file mode 100644
index 0000000..17c099f
--- /dev/null
+++ b/DirectFB-1.3.0/wm/unique/IDEAS
@@ -0,0 +1,71 @@
+UniqueContext object
+- core stack functionality
+- manage parts like dnd, input event and cursor handling
+  without knowing any detail about the different parts
+- reactor for unique context events
+
+UniqueWindow object
+- core window functionality
+- decorations (window borders, overlays)
+- properties (title, type, icon)
+- constraints (min/max size, resize step)
+- options (keep position, size, stacking)
+- state (iconified, maximized, minimized, shaded)
+- window groups and relationships
+- has an UniqueInputChannel for input events
+- reactor for unique window events
+
+
+UniqueDevice
+- listents to input events
+- dispatches events to one or more UniqueInputSwitch
++ currently there's one instance for each these device classes
+  - pointer     motion and button events, cursor acceleration
+  - wheel       wheel events
+  - keyboard    key events
+
+
+UniqueInputSwitch
+- bundles devices into a logical group, listening to them
+- dispatches events to the selected UniqueInputChannel
+- each device class has its own channel selection
+- automatic channel selection by pre-processing events (focus follows mouse etc.)
+- fixed channel selection (grabbing) for whole device or selected events
+- implicit grabbing for keyboard and pointer
+
+
+UniqueInputChannel
+- each UniqueWindow has one channel to receive input events
+- window decorations can have additional channels
+- StReT regions can be assigned a channel for each device class
+- automatic channel selection is based on these assignments
+- reactor for dispatching input events received from UniqueInputSwitch
+
+
+UniqueCursor part
+- switches or updates shapes
+- manages the StReT region
+- listens to pointer devices to update the cursor position
+
+UniqueCursorShape object
+- one global fallback shape
+- optionally one shape per window
+- builtin cursor animation
+
+
+UniqueDND part
+- dnd context manager
+
+UniqueDNDContext object
+- created by application starting the drag
+
+
+UniqueDecoration object
+- created for each decoration added to a window
+- manages stret region(s) attached to the frame
++ there can be several uses of this object
+  - border
+  - shadow
+  - glass ?
+  - flames :->
+
diff --git a/DirectFB-1.3.0/wm/unique/STRET b/DirectFB-1.3.0/wm/unique/STRET
new file mode 100644
index 0000000..8638bf5
--- /dev/null
+++ b/DirectFB-1.3.0/wm/unique/STRET
@@ -0,0 +1,34 @@
+=  Container region
+\  Container region level
++  Specific region
+
+
+= Root
+   \ Desktop
+      + Icons
+      + Fullscreen Apps redirected
+    
+   \ User
+      = Frame
+         \ Background
+         \ Content
+            + Normal
+               + Opaque
+         \ Foreground
+            + Decoration
+
+  \ System
+     + Expos
+     + Dock/Panel
+     + Glass
+     + Clipboard Manager
+     + Virtual Keyboard
+     + Input Methods
+
+  \ Cursor
+     + Drag'n'Drop
+     + Shape
+
+  \ Screen
+     + Saver
+     + Lock
diff --git a/DirectFB-1.3.0/wm/unique/classes/foo.c b/DirectFB-1.3.0/wm/unique/classes/foo.c
index 2f15d8a..3efd3d5 100644
--- a/DirectFB-1.3.0/wm/unique/classes/foo.c
+++ b/DirectFB-1.3.0/wm/unique/classes/foo.c
@@ -78,8 +78,8 @@ foo_get_input( StretRegion         *region,
                break;
 
           case UDCI_POINTER:
-//               *ret_channel = window->channel;
-               *ret_channel = context->foo_channel;
+               *ret_channel = window->channel;
+//               *ret_channel = context->foo_channel;
                break;
 
           default:
diff --git a/DirectFB-1.3.0/wm/unique/internal.h b/DirectFB-1.3.0/wm/unique/internal.h
index 7b7c95e..0f9d105 100644
--- a/DirectFB-1.3.0/wm/unique/internal.h
+++ b/DirectFB-1.3.0/wm/unique/internal.h
@@ -213,7 +213,6 @@ struct __UniQuE_UniqueWindow {
      StretRegion             *frame;
      StretRegion             *region;
      StretRegion             *foos[8];
-     DFBPoint                 foo_motion;
 
      DFBInsets                insets;
 
diff --git a/DirectFB-1.3.0/wm/unique/test_foo.c b/DirectFB-1.3.0/wm/unique/test_foo.c
index 7ffd1b1..ab8eb47 100644
--- a/DirectFB-1.3.0/wm/unique/test_foo.c
+++ b/DirectFB-1.3.0/wm/unique/test_foo.c
@@ -43,9 +43,6 @@
 
 #include <direct/debug.h>
 
-#include <core/layer_context.h>
-#include <core/layers_internal.h>
-
 #include <unique/context.h>
 #include <unique/input_channel.h>
 #include <unique/internal.h>
@@ -82,49 +79,12 @@ context_callback( FusionObjectPool *pool,
      return false;
 }
 
-static void
-dispatch_motion( UniqueWindow                  *window,
-                 const UniqueInputPointerEvent *event )
-{
-     D_MAGIC_ASSERT( window, UniqueWindow );
-     D_ASSERT( event != NULL );
-
-     if (event->buttons) {
-          CoreWindowConfig config;
-
-          unique_window_get_config( window, &config );
-
-          config.bounds.x -= window->foo_motion.x - event->x;
-          config.bounds.y -= window->foo_motion.y - event->y;
-
-          unique_window_set_config( window, &config, CWCF_POSITION );
-     }
-
-     window->foo_motion.x = event->x;
-     window->foo_motion.y = event->y;
-}
-
-static void
-dispatch_button( UniqueWindow                  *window,
-                 const UniqueInputPointerEvent *event )
-{
-     D_MAGIC_ASSERT( window, UniqueWindow );
-     D_ASSERT( event != NULL );
-
-     if (event->press)
-          unique_window_restack( window, NULL, 1 );
-}
-
 static ReactionResult
 foo_channel_listener( const void *msg_data,
                       void       *ctx )
 {
      const UniqueInputEvent *event   = msg_data;
      UniqueContext          *context = ctx;
-     CoreLayerRegion        *region;
-     StretRegion            *stret;
-     WMShared               *shared;
-     static UniqueWindow    *window;
 
      (void) context;
 
@@ -134,43 +94,25 @@ foo_channel_listener( const void *msg_data,
 
      D_DEBUG_AT( UniQuE_TestFoo, "foo_channel_listener( %p, %p )\n", event, context );
 
-     region = context->region;
-     D_ASSERT( region != NULL );
-     D_ASSERT( region->context != NULL );
-
-     shared = context->shared;
-     D_MAGIC_ASSERT( shared, WMShared );
-
-     dfb_layer_context_lock( region->context );
-
      switch (event->type) {
           case UIET_MOTION:
+               //dispatch_motion( window, event );
+               break;
+
           case UIET_BUTTON:
-               /* FIXME: This is a workaround because of the global input channel used for all windows. */
-               stret = stret_region_at( context->root, event->pointer.x, event->pointer.y,
-                                        SRF_INPUT, shared->region_classes[URCI_FOO] );
-               if (stret)
-                    window = stret->data;
-               else if (event->type == UIET_BUTTON && !event->pointer.buttons)
-                    window = NULL;
-
-               if (window) {
-                    D_MAGIC_ASSERT( window, UniqueWindow );
-
-                    if (event->type == UIET_MOTION)
-                         dispatch_motion( window, &event->pointer );
-                    else
-                         dispatch_button( window, &event->pointer );
-               }
+               //dispatch_button( window, event );
                break;
 
           case UIET_WHEEL:
+               //dispatch_wheel( window, event );
                break;
 
           case UIET_KEY:
+               //dispatch_key( window, event );
                break;
 
           case UIET_CHANNEL:
+               //dispatch_channel( window, event );
                break;
 
           default:
@@ -178,8 +120,6 @@ foo_channel_listener( const void *msg_data,
                break;
      }
 
-     dfb_layer_context_unlock( region->context );
-
      return RS_OK;
 }
 
diff --git a/DirectFB-1.3.0/wm/unique/unique.c b/DirectFB-1.3.0/wm/unique/unique.c
index dbdaf06..9ef52f3 100644
--- a/DirectFB-1.3.0/wm/unique/unique.c
+++ b/DirectFB-1.3.0/wm/unique/unique.c
@@ -128,8 +128,7 @@ context_notify( WMData                          *data,
      if (notification->flags & UCNF_DESTROYED) {
           D_DEBUG_AT( WM_Unique, "  -> context destroyed.\n" );
 
-          if (notification->context == stack_data->context)
-               stack_data->context = NULL;
+          stack_data->context = NULL;
 
           return RS_REMOVE;
      }
@@ -386,9 +385,6 @@ wm_set_active( CoreWindowStack *stack,
 
      D_MAGIC_ASSERT( data, StackData );
 
-     D_DEBUG_AT( WM_Unique, "%s( stack %p, wm_data %p, stack_data %p, %sactive )\n",
-                 __FUNCTION__, stack, wm_data, stack_data, active ? "" : "in" );
-
      if (!data->context) {
           D_ASSERT( !active );
           return DFB_OK;
diff --git a/DirectFB-1.3.0/wm/unique/uniquewm.c b/DirectFB-1.3.0/wm/unique/uniquewm.c
index 4113320..8e3600a 100644
--- a/DirectFB-1.3.0/wm/unique/uniquewm.c
+++ b/DirectFB-1.3.0/wm/unique/uniquewm.c
@@ -86,7 +86,9 @@ static DFBResult unregister_device_classes( WMShared *shared );
 static DFBResult
 load_foo( CoreDFB *core, WMShared *shared )
 {
-     DFBResult ret;
+     int                   i;
+     DFBResult             ret;
+     CoreSurfaceBufferLock lock;
 
      D_ASSERT( core != NULL );
 
@@ -100,11 +102,20 @@ load_foo( CoreDFB *core, WMShared *shared )
           return ret;
      }
 
-     ret = dfb_surface_write_buffer( shared->foo_surface, CSBR_BACK,
-                                     foo_desc.preallocated[0].data, foo_desc.preallocated[0].pitch, NULL );
-     if (ret)
-          D_DERROR( ret, "UniQuE/WM: Could not write to %dx%d surface for border tiles!\n",
-                    foo_desc.width, foo_desc.height );
+     ret = dfb_surface_lock_buffer( shared->foo_surface, CSBR_BACK, CSAF_CPU_WRITE, &lock );
+     if (ret) {
+          D_DERROR( ret, "UniQuE/WM: Could not lock surface for border tiles!\n" );
+          dfb_surface_unref( shared->foo_surface );
+          return ret;
+     }
+
+     for (i=0; i<foo_desc.height; i++) {
+          direct_memcpy( dfb_surface_data_offset( shared->foo_surface, lock.addr, lock.pitch, 0, i ),
+                         foo_data + i * foo_desc.preallocated[0].pitch,
+                         DFB_BYTES_PER_LINE( foo_desc.pixelformat, foo_desc.width ) );
+     }
+
+     dfb_surface_unlock_buffer( shared->foo_surface, &lock );
 
      dfb_surface_globalize( shared->foo_surface );
 
@@ -221,8 +232,7 @@ unique_wm_module_deinit( WMData *data, WMShared *shared, bool master, bool emerg
      unregister_device_classes( shared );
      unregister_region_classes( shared );
 
-     if (master)
-          unload_foo( wm_shared );
+//FIXME     unload_foo( wm_shared );
 
      dfb_core  = NULL;
      wm_data   = NULL;
