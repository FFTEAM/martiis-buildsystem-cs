From f95f9b6772c8897c535cf2cf29e86ce73c1a833d Mon Sep 17 00:00:00 2001
From: "[CST] Focus" <focus.cst@gmail.com>
Date: Wed, 5 Sep 2012 15:40:08 +0400
Subject: [PATCH 01/16] Coolstream patches for linux kernel 2.6.34.13

---
 Makefile                                       |    7 +-
 arch/arm/Kconfig                               |   15 +
 arch/arm/Makefile                              |   14 +-
 arch/arm/include/asm/mach/serial_cnxt.h        |   97 ++
 arch/arm/include/asm/memory.h                  |    8 +-
 arch/arm/include/asm/setup.h                   |   26 +
 arch/arm/kernel/armksyms.c                     |   12 +
 arch/arm/kernel/init_task.c                    |    1 +
 arch/arm/kernel/module.c                       |    2 +-
 arch/arm/lib/Makefile                          |    2 +
 arch/arm/lib/cnxtlongjmp.S                     |   39 +
 arch/arm/lib/cnxtsetjmp.S                      |   39 +
 arch/arm/lib/lib1funcs.S                       |  229 ++++
 arch/arm/mach-nevis/Kconfig                    |  224 +++
 arch/arm/mach-nevis/Makefile                   |   15 +
 arch/arm/mach-nevis/Makefile.boot              |    4 +
 arch/arm/mach-nevis/clock.c                    |   64 +
 arch/arm/mach-nevis/clock.h                    |   15 +
 arch/arm/mach-nevis/devices.c                  |  234 ++++
 arch/arm/mach-nevis/devices.h                  |   51 +
 arch/arm/mach-nevis/dma.c                      |   43 +
 arch/arm/mach-nevis/gpio.c                     |  238 ++++
 arch/arm/mach-nevis/include/mach/clkdev.h      |    7 +
 arch/arm/mach-nevis/include/mach/cx2450x.h     |  159 +++
 arch/arm/mach-nevis/include/mach/debug-macro.S |   51 +
 arch/arm/mach-nevis/include/mach/dma.h         |   27 +
 arch/arm/mach-nevis/include/mach/entry-macro.S |  109 ++
 arch/arm/mach-nevis/include/mach/gpio.h        |   83 ++
 arch/arm/mach-nevis/include/mach/hardware.h    |   41 +
 arch/arm/mach-nevis/include/mach/ide.h         |   30 +
 arch/arm/mach-nevis/include/mach/io.h          |   53 +
 arch/arm/mach-nevis/include/mach/irq.h         |   37 +
 arch/arm/mach-nevis/include/mach/irqs.h        |   55 +
 arch/arm/mach-nevis/include/mach/memmap.h      |   60 +
 arch/arm/mach-nevis/include/mach/memory.h      |   30 +
 arch/arm/mach-nevis/include/mach/param.h       |   31 +
 arch/arm/mach-nevis/include/mach/platform.h    |   43 +
 arch/arm/mach-nevis/include/mach/startup.h     |   84 ++
 arch/arm/mach-nevis/include/mach/system.h      |   49 +
 arch/arm/mach-nevis/include/mach/time.h        |   37 +
 arch/arm/mach-nevis/include/mach/timex.h       |   24 +
 arch/arm/mach-nevis/include/mach/uncompress.h  |  186 +++
 arch/arm/mach-nevis/include/mach/vmalloc.h     |   25 +
 arch/arm/mach-nevis/irq.c                      |  359 +++++
 arch/arm/mach-nevis/mach.c                     |  477 +++++++
 arch/arm/mach-nevis/mipidle.c                  |  127 ++
 arch/arm/mach-nevis/pci.c                      |  310 +++++
 arch/arm/mach-nevis/pllc.c                     |  377 +++++
 arch/arm/mach-nevis/pm.c                       |  149 ++
 arch/arm/mach-nevis/time.c                     |  228 +++
 arch/arm/mm/ioremap.c                          |    8 +
 arch/arm/mm/mmu.c                              |    5 +
 build.sh                                       |    4 +
 config-2.6.34.13                               | 1752 ++++++++++++++++++++++++
 drivers/mtd/maps/Kconfig                       |    4 +
 drivers/mtd/maps/Makefile                      |    1 +
 drivers/mtd/maps/cx2450x-flash.c               |  336 +++++
 drivers/net/Kconfig                            |   10 +
 drivers/net/Makefile                           |    1 +
 drivers/net/arcvmac.c                          | 1478 ++++++++++++++++++++
 drivers/net/arcvmac.h                          |  265 ++++
 drivers/serial/Kconfig                         |   57 +
 drivers/serial/Makefile                        |    1 +
 drivers/serial/cx2450x_uart.c                  |  918 +++++++++++++
 drivers/staging/rtl8192u/Kconfig               |    3 +-
 drivers/usb/Kconfig                            |    1 +
 drivers/usb/host/Kconfig                       |   25 +
 drivers/usb/host/ehci-cx2450x.c                |  247 ++++
 drivers/usb/host/ehci-hcd.c                    |    5 +
 fs/proc/Makefile                               |    1 +
 fs/proc/mipidle.c                              |   27 +
 include/linux/kernel.h                         |    4 +
 include/linux/semaphore.h                      |    1 +
 include/linux/serial_core.h                    |    3 +
 kernel/semaphore.c                             |   32 +
 mm/init-mm.c                                   |    1 +
 net/core/filter.c                              |    2 +
 77 files changed, 9810 insertions(+), 9 deletions(-)
 create mode 100644 arch/arm/include/asm/mach/serial_cnxt.h
 create mode 100644 arch/arm/lib/cnxtlongjmp.S
 create mode 100644 arch/arm/lib/cnxtsetjmp.S
 create mode 100644 arch/arm/mach-nevis/Kconfig
 create mode 100644 arch/arm/mach-nevis/Makefile
 create mode 100644 arch/arm/mach-nevis/Makefile.boot
 create mode 100644 arch/arm/mach-nevis/clock.c
 create mode 100644 arch/arm/mach-nevis/clock.h
 create mode 100644 arch/arm/mach-nevis/devices.c
 create mode 100644 arch/arm/mach-nevis/devices.h
 create mode 100644 arch/arm/mach-nevis/dma.c
 create mode 100644 arch/arm/mach-nevis/gpio.c
 create mode 100644 arch/arm/mach-nevis/include/mach/clkdev.h
 create mode 100644 arch/arm/mach-nevis/include/mach/cx2450x.h
 create mode 100644 arch/arm/mach-nevis/include/mach/debug-macro.S
 create mode 100644 arch/arm/mach-nevis/include/mach/dma.h
 create mode 100644 arch/arm/mach-nevis/include/mach/entry-macro.S
 create mode 100644 arch/arm/mach-nevis/include/mach/gpio.h
 create mode 100644 arch/arm/mach-nevis/include/mach/hardware.h
 create mode 100644 arch/arm/mach-nevis/include/mach/ide.h
 create mode 100644 arch/arm/mach-nevis/include/mach/io.h
 create mode 100644 arch/arm/mach-nevis/include/mach/irq.h
 create mode 100644 arch/arm/mach-nevis/include/mach/irqs.h
 create mode 100644 arch/arm/mach-nevis/include/mach/memmap.h
 create mode 100644 arch/arm/mach-nevis/include/mach/memory.h
 create mode 100644 arch/arm/mach-nevis/include/mach/param.h
 create mode 100644 arch/arm/mach-nevis/include/mach/platform.h
 create mode 100644 arch/arm/mach-nevis/include/mach/startup.h
 create mode 100644 arch/arm/mach-nevis/include/mach/system.h
 create mode 100644 arch/arm/mach-nevis/include/mach/time.h
 create mode 100644 arch/arm/mach-nevis/include/mach/timex.h
 create mode 100644 arch/arm/mach-nevis/include/mach/uncompress.h
 create mode 100644 arch/arm/mach-nevis/include/mach/vmalloc.h
 create mode 100644 arch/arm/mach-nevis/irq.c
 create mode 100644 arch/arm/mach-nevis/mach.c
 create mode 100644 arch/arm/mach-nevis/mipidle.c
 create mode 100644 arch/arm/mach-nevis/pci.c
 create mode 100644 arch/arm/mach-nevis/pllc.c
 create mode 100644 arch/arm/mach-nevis/pm.c
 create mode 100644 arch/arm/mach-nevis/time.c
 create mode 100755 build.sh
 create mode 100644 config-2.6.34.13
 create mode 100644 drivers/mtd/maps/cx2450x-flash.c
 create mode 100644 drivers/net/arcvmac.c
 create mode 100644 drivers/net/arcvmac.h
 create mode 100644 drivers/serial/cx2450x_uart.c
 create mode 100644 drivers/usb/host/ehci-cx2450x.c
 create mode 100644 fs/proc/mipidle.c

diff --git a/Makefile b/Makefile
index 697375f..e2a7530 100644
--- a/Makefile
+++ b/Makefile
@@ -536,6 +536,10 @@ else
 KBUILD_CFLAGS	+= -O2
 endif
 
+# conserve stack if available
+# do this early so that an architecture can override it.
+#KBUILD_CFLAGS   += $(call cc-option,-fconserve-stack)
+
 include $(srctree)/arch/$(SRCARCH)/Makefile
 
 ifneq ($(CONFIG_FRAME_WARN),0)
@@ -587,9 +591,6 @@ KBUILD_CFLAGS	+= $(call cc-option,-fno-strict-overflow)
 # revert to pre-gcc-4.4 behaviour of .eh_frame
 KBUILD_CFLAGS	+= $(call cc-option,-fno-dwarf2-cfi-asm)
 
-# conserve stack if available
-KBUILD_CFLAGS   += $(call cc-option,-fconserve-stack)
-
 # Add user supplied CPPFLAGS, AFLAGS and CFLAGS as the last assignments
 # But warn user when we do so
 warn-assign = \
diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 811dedc..b0ffca0 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -369,6 +369,19 @@ config ARCH_NETX
 	help
 	  This enables support for systems based on the Hilscher NetX Soc
 
+config ARCH_NEVIS
+	bool "NXP CX2450x (Nevis)"
+	depends on MMU
+	select CPU_V6
+	select GENERIC_GPIO
+	select ARCH_REQUIRE_GPIOLIB
+	select VMSPLIT_2G
+	select ARCH_USES_GETTIMEOFFSET
+	select ARCH_HAS_HOLES_MEMORYMODEL
+	select CLKDEV_LOOKUP
+	help
+	  Support for NXP CX2450x SoC.
+
 config ARCH_H720X
 	bool "Hynix HMS720x-based"
 	select CPU_ARM720T
@@ -922,6 +935,8 @@ source "arch/arm/mach-versatile/Kconfig"
 
 source "arch/arm/mach-w90x900/Kconfig"
 
+source "arch/arm/mach-nevis/Kconfig"
+
 # Definitions to make life easier
 config ARCH_ACORN
 	bool
diff --git a/arch/arm/Makefile b/arch/arm/Makefile
index ed820e7..3ed36c0 100644
--- a/arch/arm/Makefile
+++ b/arch/arm/Makefile
@@ -34,6 +34,14 @@ ifeq ($(CONFIG_FRAME_POINTER),y)
 KBUILD_CFLAGS	+=-fno-omit-frame-pointer -mapcs -mno-sched-prolog
 endif
 
+ifeq ($(CONFIG_CC_STACKPROTECTOR),y)
+KBUILD_CFLAGS	+=-fstack-protector
+endif
+
+# ARM gcc developers unfortunately broke -fconserve-stack. It misaligns
+# variables on the stack
+KBUILD_CFLAGS += $(call cc-option,-fno-conserve-stack)
+
 ifeq ($(CONFIG_CPU_BIG_ENDIAN),y)
 KBUILD_CPPFLAGS	+= -mbig-endian
 AS		+= -EB
@@ -81,7 +89,9 @@ tune-$(CONFIG_CPU_SA1100)	:=-mtune=strongarm1100
 tune-$(CONFIG_CPU_XSCALE)	:=$(call cc-option,-mtune=xscale,-mtune=strongarm110) -Wa,-mcpu=xscale
 tune-$(CONFIG_CPU_XSC3)		:=$(call cc-option,-mtune=xscale,-mtune=strongarm110) -Wa,-mcpu=xscale
 tune-$(CONFIG_CPU_FEROCEON)	:=$(call cc-option,-mtune=marvell-f,-mtune=xscale)
-tune-$(CONFIG_CPU_V6)		:=$(call cc-option,-mtune=arm1136j-s,-mtune=strongarm)
+#tune-$(CONFIG_CPU_V6)		:=$(call cc-option,-mtune=arm1136j-s,-mtune=strongarm)
+tune-$(CONFIG_CPU_V6)		:=$(call cc-option,-mtune=arm1176jz-s,-mtune=strongarm)
+tune-$(CONFIG_CPU_V6K)		:=$(call cc-option,-mtune=arm1136j-s,-mtune=strongarm)
 
 ifeq ($(CONFIG_AEABI),y)
 CFLAGS_ABI	:=-mabi=aapcs-linux -mno-thumb-interwork
@@ -178,6 +188,8 @@ machine-$(CONFIG_ARCH_VERSATILE)	:= versatile
 machine-$(CONFIG_ARCH_W90X900)		:= w90x900
 machine-$(CONFIG_ARCH_NUC93X)		:= nuc93x
 machine-$(CONFIG_FOOTBRIDGE)		:= footbridge
+machine-$(CONFIG_ARCH_NEVIS)		:= nevis
+textofs-$(CONFIG_ARCH_NEVIS)		:= 0x00048000
 
 # Platform directory name.  This list is sorted alphanumerically
 # by CONFIG_* macro name.
diff --git a/arch/arm/include/asm/mach/serial_cnxt.h b/arch/arm/include/asm/mach/serial_cnxt.h
new file mode 100644
index 0000000..6a23d3c
--- /dev/null
+++ b/arch/arm/include/asm/mach/serial_cnxt.h
@@ -0,0 +1,97 @@
+/*
+ *  linux/include/asm-arm/hardware/serial_rio.h
+ *
+ *  Internal header file for CNXT  serial ports
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef ASM_ARM_HARDWARE_SERIAL_CNXT_H
+#define ASM_ARM_HARDWARE_SERIAL_CNXT_H
+
+/*
+ *  UART Register Offsets.
+ */
+#define CNXT_BRDL                       0x0   /* lower byte of baud rate  divisor */
+#define CNXT_BRDH                       0x4   /* lower byte of baud rate  divisor */
+#define CNXT_FIFO                       0x0
+#define CNXT_IRQE                       0x4
+#define CNXT_FIFC                       0x8
+#define CNXT_FRMC                       0xc
+#define CNXT_STAT                       0x14
+#define CNXT_IRLVL                      0x18
+#define CNXT_TXSTA                      0x28
+#define CNXT_RXSTA                      0x2c
+
+#define CNXT_EXP                        0x30  /* Fractional Baud Rate Divisor */
+                                              /* 2-bit for regular UART */
+                                              /* 6-bit for HS UART */
+
+#define CNXT_EXCTL                      0x3C  /* Expanded Control Register */
+                                              /* HS UART */
+
+#define CNXT_IRQE_ERFE   0x80
+#define CNXT_IRQE_TIDE   0x40
+#define CNXT_IRQE_TSRE   0x20
+#define CNXT_IRQE_RBKE   0x10
+#define CNXT_IRQE_FREE   0x08
+#define CNXT_IRQE_PAEE   0x04
+#define CNXT_IRQE_RFOE   0x02
+#define CNXT_IRQE_RSRE   0x01
+
+#define CNXT_FIFC_RFT_ONE  0x00
+#define CNXT_FIFC_RFT_FOUR 0x40
+#define CNXT_FIFC_RFT_EIGHT 0x80
+#define CNXT_FIFC_RFT_TWLV  0xc0
+#define CNXT_FIFC_TFT_FOUR  0x00
+#define CNXT_FIFC_TFT_EIGHT 0x10
+#define CNXT_FIFC_TFT_TWLV  0x20
+#define CNXT_FIFC_TFT_SXTN  0x30
+#define CNXT_FIFC_TFC       0x04
+#define CNXT_FIFC_RFC       0x02
+
+#define CNXT_FRMC_BDS    0x80
+#define CNXT_FRMC_TBK    0x40
+#define CNXT_FRMC_POR    0x20
+#define CNXT_FRMC_EOP    0x10
+#define CNXT_FRMC_PEN    0x08
+#define CNXT_FRMC_SBS    0x04
+#define CNXT_FRMC_LBM    0x02
+#define CNXT_FRMC_FRS    0x01
+
+#define CNXT_STAT_ERF    0x80
+#define CNXT_STAT_TID    0x40
+#define CNXT_STAT_TSR    0x20
+#define CNXT_STAT_RBK    0x10
+#define CNXT_STAT_FRE    0x08
+#define CNXT_STAT_PAE    0x04
+#define CNXT_STAT_RFO    0x02
+#define CNXT_STAT_RSR    0x01
+
+#define CNXT_EXCTL_HSM   0x80
+#define CNXT_EXCTL_OSP   0x40
+#define CNXT_EXCTL_RTS   0x20
+#define CNXT_EXCTL_DMATX 0x10
+#define CNXT_EXCTL_DMARX 0x08
+#define CNXT_EXCTL_FCEN  0x04
+#define CNXT_EXCTL_RXFC_ONE   0x00
+#define CNXT_EXCTL_RXFC_FOUR  0x01
+#define CNXT_EXCTL_RXFC_EIGHT 0x02
+#define CNXT_EXCTL_RXFC_FRTN  0x03
+
+#define CNXT_STAT_ANY    (CNXT_STAT_RBK | CNXT_STAT_FRE | \
+                         CNXT_STAT_PAE | CNXT_STAT_RFO)
+
+
+#endif
diff --git a/arch/arm/include/asm/memory.h b/arch/arm/include/asm/memory.h
index 4312ee5..b3a22dc 100644
--- a/arch/arm/include/asm/memory.h
+++ b/arch/arm/include/asm/memory.h
@@ -32,8 +32,8 @@
  * TASK_UNMAPPED_BASE - the lower boundary of the mmap VM area
  */
 #define PAGE_OFFSET		UL(CONFIG_PAGE_OFFSET)
-#define TASK_SIZE		(UL(CONFIG_PAGE_OFFSET) - UL(0x01000000))
-#define TASK_UNMAPPED_BASE	(UL(CONFIG_PAGE_OFFSET) / 3)
+#define TASK_SIZE		(UL(CONFIG_PAGE_OFFSET) - UL(0x01800000))
+#define TASK_UNMAPPED_BASE	((UL(CONFIG_PAGE_OFFSET) + UL(0x10000000))/ 3)
 
 /*
  * The maximum size of a 26-bit user space task.
@@ -45,7 +45,7 @@
  * and PAGE_OFFSET - it must be within 32MB of the kernel text.
  */
 #ifndef CONFIG_THUMB2_KERNEL
-#define MODULES_VADDR		(PAGE_OFFSET - 16*1024*1024)
+#define MODULES_VADDR		(PAGE_OFFSET - 24*1024*1024)
 #else
 /* smaller range for Thumb-2 symbols relocation (2^24)*/
 #define MODULES_VADDR		(PAGE_OFFSET - 8*1024*1024)
@@ -87,6 +87,8 @@
 #define CONSISTENT_END		(0xffe00000UL)
 #define CONSISTENT_BASE		(CONSISTENT_END - CONSISTENT_DMA_SIZE)
 
+#define PHYS_OFFSET UL(0x00000000)
+
 #else /* CONFIG_MMU */
 
 /*
diff --git a/arch/arm/include/asm/setup.h b/arch/arm/include/asm/setup.h
index f392fb4..c987efc 100644
--- a/arch/arm/include/asm/setup.h
+++ b/arch/arm/include/asm/setup.h
@@ -136,6 +136,26 @@ struct tag_acorn {
 	__u8 adfsdrives;
 };
 
+/* conexant pecos/nevis specific for reading the MAC address */
+#define	ATAG_MAC	0x5441000A
+
+struct tag_mac {
+          __u8 mac_addr[6];
+};
+
+/* conexant pecos/nevis specific for specifying the reserved memory
+ * locations.
+ * see arch/arm/mach-nevis/mach.c
+ */
+#define	ATAG_DECARM	0x5441000B
+
+struct tag_decarm {
+	__u32 uSize;
+	__u32 uStart;
+	__u32 uSharedRAMSize;
+	__u32 uSharedRAMStart;
+};
+
 /* footbridge memory clock, see arch/arm/mach-footbridge/arch.c */
 #define ATAG_MEMCLK	0x41000402
 
@@ -162,6 +182,12 @@ struct tag {
 		struct tag_acorn	acorn;
 
 		/*
+		 * Conexant Nevis / Pecos specific
+		 */
+		struct tag_mac mac;
+		struct tag_decarm decarm;
+
+		/*
 		 * DC21285 specific
 		 */
 		struct tag_memclk	memclk;
diff --git a/arch/arm/kernel/armksyms.c b/arch/arm/kernel/armksyms.c
index 8214bfe..9054db3 100644
--- a/arch/arm/kernel/armksyms.c
+++ b/arch/arm/kernel/armksyms.c
@@ -46,6 +46,7 @@ extern void __aeabi_lmul(void);
 extern void __aeabi_uidiv(void);
 extern void __aeabi_uidivmod(void);
 extern void __aeabi_ulcmp(void);
+extern void __aeabi_uldivmod(void);
 
 extern void fpundefinstr(void);
 
@@ -137,6 +138,7 @@ EXPORT_SYMBOL(__aeabi_lmul);
 EXPORT_SYMBOL(__aeabi_uidiv);
 EXPORT_SYMBOL(__aeabi_uidivmod);
 EXPORT_SYMBOL(__aeabi_ulcmp);
+EXPORT_SYMBOL(__aeabi_uldivmod);
 #endif
 
 	/* bitops */
@@ -168,3 +170,13 @@ EXPORT_SYMBOL(_find_next_bit_be);
 EXPORT_SYMBOL(mcount);
 EXPORT_SYMBOL(__gnu_mcount_nc);
 #endif
+
+#ifdef CONFIG_ARM_PATCH_PHYS_VIRT
+EXPORT_SYMBOL(__pv_phys_offset);
+#endif
+
+#ifdef CONFIG_SETJMP_INCLUDED
+#include <asm/cnxtsetjmp.h>
+EXPORT_SYMBOL(_setjmp);
+EXPORT_SYMBOL(longjmp);
+#endif
diff --git a/arch/arm/kernel/init_task.c b/arch/arm/kernel/init_task.c
index e7cbb50..825974e 100644
--- a/arch/arm/kernel/init_task.c
+++ b/arch/arm/kernel/init_task.c
@@ -35,3 +35,4 @@ union thread_union init_thread_union __init_task_data =
 struct task_struct init_task = INIT_TASK(init_task);
 
 EXPORT_SYMBOL(init_task);
+EXPORT_SYMBOL(init_mm);
diff --git a/arch/arm/kernel/module.c b/arch/arm/kernel/module.c
index c628bdf..560a459 100644
--- a/arch/arm/kernel/module.c
+++ b/arch/arm/kernel/module.c
@@ -142,7 +142,7 @@ apply_relocate(Elf32_Shdr *sechdrs, const char *strtab, unsigned int symindex,
 			offset += sym->st_value - loc;
 			if (offset & 3 ||
 			    offset <= (s32)0xfe000000 ||
-			    offset >= (s32)0x02000000) {
+			    offset >= (s32)0x03000000) {
 				printk(KERN_ERR
 				       "%s: relocation out of range, section "
 				       "%d reloc %d sym '%s'\n", module->name,
diff --git a/arch/arm/lib/Makefile b/arch/arm/lib/Makefile
index 030ba72..87045fc 100644
--- a/arch/arm/lib/Makefile
+++ b/arch/arm/lib/Makefile
@@ -15,6 +15,8 @@ lib-y		:= backtrace.o changebit.o csumipv6.o csumpartial.o   \
 		   ucmpdi2.o lib1funcs.o div64.o sha1.o               \
 		   io-readsb.o io-writesb.o io-readsl.o io-writesl.o
 
+lib-$(CONFIG_SETJUMP_INCLUDED)		+= cnxtlongjmp.o cnxtsetjmp.o
+
 mmu-y	:= clear_user.o copy_page.o getuser.o putuser.o
 
 # the code in uaccess.S is not preemption safe and
diff --git a/arch/arm/lib/cnxtlongjmp.S b/arch/arm/lib/cnxtlongjmp.S
new file mode 100644
index 0000000..efadc3e
--- /dev/null
+++ b/arch/arm/lib/cnxtlongjmp.S
@@ -0,0 +1,39 @@
+/******************************************************************************/
+/*                   CONEXANT PROPRIETARY AND CONFIDENTIAL                    */
+/*                        SOFTWARE FILE/MODULE HEADER                         */
+/*                 Copyright Conexant Systems Inc. 2007                       */
+/*                                 Hyderabad                                  */
+/*                            All Rights Reserved                             */
+/******************************************************************************/
+/*
+ * Filename:        cnxtlongjmp.S
+ *
+ *
+ * Description:     ARM Assembly file for longjmp.
+ *
+ *
+ * Author:          Kaushik Bar
+ *
+ ******************************************************************************/
+/* $Id$
+ ******************************************************************************/
+.global longjmp
+.align 2
+
+longjmp:
+     mov       ip, r0       /* save jmp_buf pointer */
+     movs      r0, r1       /* get the return value in place */
+     moveq     r0, #1       /* can't let longjmp return zero! */
+     ldmia     ip!,  {v1-v6, sl, fp, sp, lr}
+     #ifdef CONFIG_FRAME_POINTER
+        bx     lr
+     #else
+        mov    pc, lr
+     #endif
+
+/*******************************************************************************
+ * Modifications:
+ * $Log:
+ *
+ ******************************************************************************/
+ 
diff --git a/arch/arm/lib/cnxtsetjmp.S b/arch/arm/lib/cnxtsetjmp.S
new file mode 100644
index 0000000..5b595d0
--- /dev/null
+++ b/arch/arm/lib/cnxtsetjmp.S
@@ -0,0 +1,39 @@
+/******************************************************************************/
+/*                   CONEXANT PROPRIETARY AND CONFIDENTIAL                    */
+/*                        SOFTWARE FILE/MODULE HEADER                         */
+/*                 Copyright Conexant Systems Inc. 2007                       */
+/*                                 Hyderabad                                  */
+/*                            All Rights Reserved                             */
+/******************************************************************************/
+/*
+ * Filename:        cnxtsetjmp.S
+ *
+ *
+ * Description:     ARM Assembly file for setjmp.
+ *
+ *
+ * Author:          Kaushik Bar
+ *
+ ******************************************************************************/
+/* $Id$
+ ******************************************************************************/
+.global _setjmp
+.align 2
+
+_setjmp:
+     mov     ip, r0
+     /* Save registers */
+     stmia   ip!, {v1-v6, sl, fp, sp, lr}
+     mov     r0, #0                        /* make setjmp return zero */
+     #ifdef CONFIG_FRAME_POINTER
+        bx   lr
+     #else
+        mov  pc, lr
+     #endif
+
+/*******************************************************************************
+ * Modifications:
+ * $Log:
+ *
+ ******************************************************************************/
+
diff --git a/arch/arm/lib/lib1funcs.S b/arch/arm/lib/lib1funcs.S
index 6dc0648..1ea9208 100644
--- a/arch/arm/lib/lib1funcs.S
+++ b/arch/arm/lib/lib1funcs.S
@@ -338,6 +338,44 @@ ENDPROC(__aeabi_idivmod)
 
 #endif
 
+#ifdef CONFIG_AEABI
+
+/* Patch added by Trident for 64-bit division in kernel
+	Due to a bug in GCC, it replaces the 64-bit by 64-bit/32-bit division and modulus function with __aeabi_uldivmod
+    Inputs:-    r0, r1   -   divisor
+                r2, r3   -   divident  ( the higher bit is ignored in current implementation as we call __do_div64
+    Outputs:-   r0, r1   -   quotient
+                r2, r3   -   remainder
+*/
+
+ENTRY(__aeabi_uldivmod)
+    stmfd    sp!, {r4, lr}
+
+#ifdef __ARMEB__  	          /* If we have big-endian then move r3 to r4, because __do_div64 has 32-bit divisor */
+    mov      r4, r3
+#else
+    mov      r4, r2
+#endif
+    bl       __do_my_div64    /* The result is in r2 and r3 . and this is also written in assembly */
+
+    mov      r4, r0
+    mov      r0, r2
+    mov      r2, r4
+
+    mov      r4, r1
+    mov      r1, r3
+    mov      r3, r4
+
+#ifndef __ARMEB__
+    mov      r4, r2
+    mov      r2, r3
+    mov      r3, r4
+#endif
+
+    ldmfd    sp!, {r4, lr}
+    mov      pc, lr
+#endif
+
 Ldiv0:
 
 	str	lr, [sp, #-8]!
@@ -345,4 +383,195 @@ Ldiv0:
 	mov	r0, #0			@ About as wrong as it could be.
 	ldr	pc, [sp], #8
 
+ENDPROC(__aeabi_uldivmod)
+
+
+#ifdef __ARMEB__
+#define xh r0
+#define xl r1
+#define yh r2
+#define yl r3
+#else
+#define xl r0
+#define xh r1
+#define yl r2
+#define yh r3
+#endif
+
+/*
+ * This is a copy of __do_div64 from div64.S, Copy is needed otherwise bzImage does not work
+ * __do_my_div64: perform a division with 64-bit dividend and 32-bit divisor.
+ *
+ * Note: Calling convention is totally non standard for optimal code.
+ *       This is meant to be used by do_div() from include/asm/div64.h only.
+ *
+ * Input parameters:
+ * 	xh-xl	= dividend (clobbered)
+ * 	r4	= divisor (preserved)
+ *
+ * Output values:
+ * 	yh-yl	= result
+ * 	xh	= remainder
+ *
+ * Clobbered regs: xl, ip
+ */
+
+ENTRY(__do_my_div64)
+
+	@ Test for easy paths first.
+	subs	ip, r4, #1
+	bls	9f			@ divisor is 0 or 1
+	tst	ip, r4
+	beq	8f			@ divisor is power of 2
+
+	@ See if we need to handle upper 32-bit result.
+	cmp	xh, r4
+	mov	yh, #0
+	blo	3f
+
+	@ Align divisor with upper part of dividend.
+	@ The aligned divisor is stored in yl preserving the original.
+	@ The bit position is stored in ip.
+
+#if __LINUX_ARM_ARCH__ >= 5
+
+	clz	yl, r4
+	clz	ip, xh
+	sub	yl, yl, ip
+	mov	ip, #1
+	mov	ip, ip, lsl yl
+	mov	yl, r4, lsl yl
+
+#else
+
+	mov	yl, r4
+	mov	ip, #1
+1:	cmp	yl, #0x80000000
+	cmpcc	yl, xh
+	movcc	yl, yl, lsl #1
+	movcc	ip, ip, lsl #1
+	bcc	1b
+
+#endif
+
+	@ The division loop for needed upper bit positions.
+ 	@ Break out early if dividend reaches 0.
+2:	cmp	xh, yl
+	orrcs	yh, yh, ip
+	subcss	xh, xh, yl
+	movnes	ip, ip, lsr #1
+	mov	yl, yl, lsr #1
+	bne	2b
+
+	@ See if we need to handle lower 32-bit result.
+3:	cmp	xh, #0
+	mov	yl, #0
+	cmpeq	xl, r4
+	movlo	xh, xl
+	movlo	pc, lr
+
+	@ The division loop for lower bit positions.
+	@ Here we shift remainer bits leftwards rather than moving the
+	@ divisor for comparisons, considering the carry-out bit as well.
+	mov	ip, #0x80000000
+4:	movs	xl, xl, lsl #1
+	adcs	xh, xh, xh
+	beq	6f
+	cmpcc	xh, r4
+5:	orrcs	yl, yl, ip
+	subcs	xh, xh, r4
+	movs	ip, ip, lsr #1
+	bne	4b
+	mov	pc, lr
+
+	@ The top part of remainder became zero.  If carry is set
+	@ (the 33th bit) this is a false positive so resume the loop.
+	@ Otherwise, if lower part is also null then we are done.
+6:	bcs	5b
+	cmp	xl, #0
+	moveq	pc, lr
+
+	@ We still have remainer bits in the low part.  Bring them up.
+
+#if __LINUX_ARM_ARCH__ >= 5
+
+	clz	xh, xl			@ we know xh is zero here so...
+	add	xh, xh, #1
+	mov	xl, xl, lsl xh
+	mov	ip, ip, lsr xh
+
+#else
+
+7:	movs	xl, xl, lsl #1
+	mov	ip, ip, lsr #1
+	bcc	7b
+
+#endif
+
+	@ Current remainder is now 1.  It is worthless to compare with
+	@ divisor at this point since divisor can not be smaller than 3 here.
+	@ If possible, branch for another shift in the division loop.
+	@ If no bit position left then we are done.
+	movs	ip, ip, lsr #1
+	mov	xh, #1
+	bne	4b
+	mov	pc, lr
+
+8:	@ Division by a power of 2: determine what that divisor order is
+	@ then simply shift values around
+
+#if __LINUX_ARM_ARCH__ >= 5
+
+	clz	ip, r4
+	rsb	ip, ip, #31
+
+#else
+
+	mov	yl, r4
+	cmp	r4, #(1 << 16)
+	mov	ip, #0
+	movhs	yl, yl, lsr #16
+	movhs	ip, #16
+
+	cmp	yl, #(1 << 8)
+	movhs	yl, yl, lsr #8
+	addhs	ip, ip, #8
+
+	cmp	yl, #(1 << 4)
+	movhs	yl, yl, lsr #4
+	addhs	ip, ip, #4
+
+	cmp	yl, #(1 << 2)
+	addhi	ip, ip, #3
+	addls	ip, ip, yl, lsr #1
+
+#endif
+
+	mov	yh, xh, lsr ip
+	mov	yl, xl, lsr ip
+	rsb	ip, ip, #32
+ ARM(	orr	yl, yl, xh, lsl ip	)
+ THUMB(	lsl	xh, xh, ip		)
+ THUMB(	orr	yl, yl, xh		)
+	mov	xh, xl, lsl ip
+	mov	xh, xh, lsr ip
+	mov	pc, lr
+
+	@ eq -> division by 1: obvious enough...
+9:	moveq	yl, xl
+	moveq	yh, xh
+	moveq	xh, #0
+	moveq	pc, lr
+
+	@ Division by 0:
+	str	lr, [sp, #-8]!
+	bl	__div0
+
+	@ as wrong as it could be...
+	mov	yl, #0
+	mov	yh, #0
+	mov	xh, #0
+	ldr	pc, [sp], #8
+
+ENDPROC(__do_my_div64)
 
diff --git a/arch/arm/mach-nevis/Kconfig b/arch/arm/mach-nevis/Kconfig
new file mode 100644
index 0000000..5b6a817
--- /dev/null
+++ b/arch/arm/mach-nevis/Kconfig
@@ -0,0 +1,224 @@
+if ARCH_NEVIS
+
+menu "NXP CX2450X (Nevis) SoC support"
+	depends on ARCH_NEVIS
+
+config	MACH_NEVIS
+	bool "Nevis IRD board support"
+	help
+	 Enables NXP CX2450X based IRDs
+
+config  ED_COOLSTREAM_HD1
+	depends on MACH_NEVIS
+	bool  "CoolStream HD1 IRD"
+	default y
+
+config  ARCH_CNXT_EDWARDS
+	bool "Conexant Edwards API"
+	default y
+	help
+	 Enables the use of Conexant Edwards API.
+
+config  CNXT_PHYS_OFFSET
+	depends on ARCH_CNXT_EDWARDS
+	hex "PHYS Offset"
+	default 0x0
+	help
+	 PHYS_OFFSET is the address at which the kernel thinks
+	 RAM begins.  If there is an address hole/alias at
+	 physical address 0, then PHYS_OFFSET would probably
+	 NOT be 0.
+
+config  CNXT_TEXT_OFFSET
+	depends on ARCH_CNXT_EDWARDS
+	hex "Kernel Text Offset"
+	default 0x17048000
+	help
+	 TEXT_OFFSET tells the kernel where to begin its
+	 text section relative to where it thinks the beginning
+	 of RAM is.  ie.  The kernel is loaded at
+	 TEXT_OFFSET + PHYS_OFFSET.  The kernel requires that
+	 this address end in 0xYYYZ8000.  Conexant requires that
+	 Z be greater than 0.
+
+config  CNXT_MODULE_START_OFFSET
+	depends on ARCH_CNXT_EDWARDS
+	hex "Module address space start offset"
+	default 0x00FB8000
+
+config  CNXT_MODULE_ADDRESS_SPACE_SIZE
+	depends on ARCH_CNXT_EDWARDS
+	hex "Module address space size"
+	default 0x1000000
+
+config  CNXT_VMALLOC_SIZE
+	depends on ARCH_CNXT_EDWARDS
+	hex "VMALLOC size"
+	default 0x40000000
+
+config  CNXT_DECARM_PHY_ADDRESS
+	depends on ARCH_CNXT_EDWARDS
+	hex "DECARM Physical Start Address"
+	default 0x17800000
+	help
+	 This is the physical address at which the kernel
+	 will reserve memory for use by the DECARM slave CPU.
+	 Be sure to avoid any overlapping memory regions with
+	 the KAL memory.
+
+config  CNXT_DECARM_CODE_MEM_SIZE
+	depends on ARCH_CNXT_EDWARDS
+	hex "Conexant DECARM Code Memory Size"
+	default 0x00300000
+	help
+	 This tells the kernel how much memory is being
+	 reserved for MALONE. The default is 3MB.
+
+config  CNXT_DECARM_SHARED_MEM_SIZE
+	depends on ARCH_CNXT_EDWARDS
+	hex "Conexant DECARM Shared Memory Size"
+	default 0x00100000
+	help
+	 This tells the kernel how much memory is being
+	 reserved for MALONE shared memory. This memory is
+	 is shared between the host CPU and the slave. The
+	 default is 1MB.
+
+menu "GPIO MUX defaults"
+depends on ARCH_CNXT_EDWARDS
+config PLL_CONFIG0_REG_DEFAULT
+	hex "PLL CONFIG 0 register"
+	default 0xFFFFEFFE
+
+config PLL_ALT_FUNC_REG_DEFAULT
+	hex "PLL PIN ALT FUNC register"
+	default 0x60000020
+
+config PLL_PRI_GPIO_MUX0_REG_DEFAULT
+	hex "PLL PIN GPIO MUX0 REG"
+	default 0x0100D000
+
+config PLL_PRI_GPIO_MUX1_REG_DEFAULT
+	hex "PLL PIN GPIO MUX1 REG"
+	default 0x00000080
+
+config PLL_PRI_GPIO_MUX2_REG_DEFAULT
+	hex "PLL PIN GPIO MUX2 REG"
+	default 0x00000040
+
+config PLL_PRI_GPIO_MUX3_REG_DEFAULT
+	hex "PLL PIN GPIO MUX3 REG"
+	default 0xFFBFC380
+
+config PLL_PRI_GPIO_MUX4_REG_DEFAULT
+	hex "PLL PIN GPIO MUX4 REG"
+	default 0xFFFC0006
+
+config PLL_PRI_GPIO_MUX5_REG_DEFAULT
+	hex "PLL PIN GPIO MUX5 REG"
+	default 0x0006F209
+
+config PLL_PRI_GPIO_MUX6_REG_DEFAULT
+	hex "PLL PIN GPIO MUX6 REG"
+	default 0x00000000
+
+config PLL_SEC_GPIO_MUX0_REG_DEFAULT
+	hex "PLL SEC PIN MUX0 REG"
+	default 0x00000000
+
+config PLL_SEC_GPIO_MUX1_REG_DEFAULT
+	hex "PLL SEC PIN MUX1 REG"
+	default 0x000030000
+
+config PLL_SEC_GPIO_MUX2_REG_DEFAULT
+	hex "PLL SEC PIN MUX2 REG"
+	default 0x3F7C0000
+
+config PLL_SEC_GPIO_MUX3_REG_DEFAULT
+	hex "PLL SEC PIN MUX3 REG"
+	default 0x20000000
+
+config PLL_SEC_GPIO_MUX4_REG_DEFAULT
+	hex "PLL SEC PIN MUX4 REG"
+	default 0x00000000
+
+config PLL_SEC_GPIO_MUX5_REG_DEFAULT
+	hex "PLL SEC PIN MUX5 REG"
+	default 0x00000000
+
+config PLL_SEC_GPIO_MUX6_REG_DEFAULT
+	hex "PLL SEC PIN MUX6 REG"
+	default 0x00000000
+
+endmenu
+
+menu "GPIO options"
+	depends on MACH_NEVIS
+config	PIO_INIT_ON_BOOT
+	bool "Initialize GPIO's on boot"
+	default y
+	help
+	 If enabled, all exisiting GPIO pins will be 
+	 initialized to be inputs in the early boot.
+
+config	PIO_EXCL_MASK_PIO_031_000
+	depends on PIO_INIT_ON_BOOT
+	hex "Exclude mask for PIO  31 to   0"
+	default 0x00000000
+	help
+	 GPIO's marked with 1 here are excluded from
+	 the initialization.
+
+config	PIO_EXCL_MASK_PIO_063_032
+	depends on PIO_INIT_ON_BOOT
+	hex "Exclude mask for PIO  63 to  32"
+	default 0x00000000
+	help
+	 GPIO's marked with 1 here are excluded from
+	 the initialization.
+
+config	PIO_EXCL_MASK_PIO_095_064
+	depends on PIO_INIT_ON_BOOT
+	hex "Exclude mask for PIO  95 to  64"
+	default 0x00000000
+	help
+	 GPIO's marked with 1 here are excluded from
+	 the initialization.
+
+config	PIO_EXCL_MASK_PIO_127_096
+	depends on PIO_INIT_ON_BOOT
+	hex "Exclude mask for PIO 127 to  96"
+	default 0x00000000
+	help
+	 GPIO's marked with 1 here are excluded from
+	 the initialization.
+
+config	PIO_EXCL_MASK_PIO_159_128
+	depends on PIO_INIT_ON_BOOT
+	hex "Exclude mask for PIO 159 to 128"
+	default 0x00000000
+	help
+	 GPIO's marked with 1 here are excluded from
+	 the initialization.
+
+config	PIO_EXCL_MASK_PIO_191_160
+	depends on PIO_INIT_ON_BOOT
+	hex "Exclude mask for PIO 191 to 160"
+	default 0x00000000
+	help
+	 GPIO's marked with 1 here are excluded from
+	 the initialization.
+
+config	PIO_EXCL_MASK_PIO_223_192
+	depends on PIO_INIT_ON_BOOT
+	hex "Exclude mask for PIO 223 to 192"
+	default 0x00000000
+	help
+	 GPIO's marked with 1 here are excluded from
+	 the initialization.
+
+endmenu
+
+endmenu
+
+endif
diff --git a/arch/arm/mach-nevis/Makefile b/arch/arm/mach-nevis/Makefile
new file mode 100644
index 0000000..904f70e
--- /dev/null
+++ b/arch/arm/mach-nevis/Makefile
@@ -0,0 +1,15 @@
+#
+# Makefile for the linux kernel.
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+
+USE_STANDARD_AS_RULE := true
+
+# Object file lists.
+
+obj-y			:= irq.o dma.o mach.o mipidle.o devices.o gpio.o time.o clock.o
+#obj-y			:= pllc.o
+obj-$(CONFIG_PCI)	+= pci.o
+#obj-$(CONFIG_PM)	+= pm.o
diff --git a/arch/arm/mach-nevis/Makefile.boot b/arch/arm/mach-nevis/Makefile.boot
new file mode 100644
index 0000000..57a8298
--- /dev/null
+++ b/arch/arm/mach-nevis/Makefile.boot
@@ -0,0 +1,4 @@
+   zreladdr-y	:= 0x00048000
+params_phys-y	:= 0x00000100
+initrd_phys-y	:= 0x00800000
+
diff --git a/arch/arm/mach-nevis/clock.c b/arch/arm/mach-nevis/clock.c
new file mode 100644
index 0000000..7ae09be
--- /dev/null
+++ b/arch/arm/mach-nevis/clock.c
@@ -0,0 +1,64 @@
+/*
+ * arch/arm/mach-nevis/clock.c
+ * CX2450x Clock Management
+ *
+ * Copyright (C) 2009 CoolStream International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/sysfs.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/clk.h>
+#include <asm/clkdev.h>
+#include "clock.h"
+
+unsigned long clk_get_rate(struct clk *clk)
+{
+	return clk->rate;
+}
+EXPORT_SYMBOL(clk_get_rate);
+
+/* enable and disable do nothing */
+int clk_enable(struct clk *clk)
+{
+	return 0;
+}
+EXPORT_SYMBOL(clk_enable);
+
+void clk_disable(struct clk *clk)
+{
+}
+EXPORT_SYMBOL(clk_disable);
+
+static struct clk clk_25M = {
+	.rate = 25 * 1000 * 1000,
+};
+
+/*
+ * Catch-all default clock to satisfy drivers using the clk API.  We don't
+ * model the actual hardware clocks yet.
+ */
+static struct clk clk_default;
+
+#define CLK(_clk, dev)				\
+	{					\
+		.clk		= _clk,		\
+		.dev_id		= dev,		\
+	}
+
+static struct clk_lookup lookups[] = {
+	CLK(&clk_25M, "arcvmac"),
+};
+
+int __init cx2450x_clk_init(void)
+{
+	//clkdev_add_table(lookups, ARRAY_SIZE(lookups));
+
+	return 0;
+}
diff --git a/arch/arm/mach-nevis/clock.h b/arch/arm/mach-nevis/clock.h
new file mode 100644
index 0000000..aa9ad53
--- /dev/null
+++ b/arch/arm/mach-nevis/clock.h
@@ -0,0 +1,15 @@
+
+/*
+ *  arch/arm/mach-nevis/clock.h
+ *
+ *  Copyright (C) 2011 CoolStream International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+struct clk {
+	unsigned long		rate;
+};
+
+int __init cx2450x_clk_init(void);
diff --git a/arch/arm/mach-nevis/devices.c b/arch/arm/mach-nevis/devices.c
new file mode 100644
index 0000000..f355b16
--- /dev/null
+++ b/arch/arm/mach-nevis/devices.c
@@ -0,0 +1,234 @@
+/* linux/arch/arm/mach-trinity/devices.c
+ *
+ * Platform device definitions and helper functions for systems based
+ * on the Conexant CX2450x (Nevis) SoC
+ *
+ * Copyright (C) 2008 CoolStream International Limited.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/list.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/irq.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+
+#include <mach/memory.h>
+#include <mach/hardware.h>
+#include <mach/cx2450x.h>
+#include "devices.h"
+
+static u64 cx2450x_device_dmamask = DMA_BIT_MASK (32);
+
+/* 
+ * USB Host Controllers
+ */
+#ifdef CONFIG_CX2450X_USB0
+static struct resource cx2450x_usb_res0[] = {
+	[0] = {
+	       .start = 0xE8000100,
+	       .end = 0xE80001FB,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = IRQ_USB0,
+	       .end = IRQ_USB0,
+	       .flags = IORESOURCE_IRQ,
+	       }
+};
+#endif
+
+#ifdef CONFIG_CX2450X_USB1
+static struct resource cx2450x_usb_res1[] = {
+	[0] = {
+	       .start = 0xE8001100,
+	       .end = 0xE80011FB,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = IRQ_USB1,
+	       .end = IRQ_USB1,
+	       .flags = IORESOURCE_IRQ,
+	       }
+};
+#endif
+
+#ifdef CONFIG_SERIAL_CNXT_UART
+#if CONFIG_SERIAL_CNXT_UART >= 1
+
+/*
+ * Serial port #0, by default we use Conexant UART #3 for console etc.
+ * Resources from 0xE041x00 - 0xE041x3C, where x is 0, 0x1000, 0x2000, 0x3000
+ * Note: we reversed the mappings because the serial console is hooked up at UART #3.
+ *	 This simplifies the mapping. So ttyRI0 will be the real console.
+ *	 WARNING: Do not change the id because the driver depends on this.
+ */
+static struct resource cx2450x_ser0_res[] = {
+	[0] = {
+	       .start = 0xE0412000,
+	       .end   = 0xE041203F,
+	       .flags = IORESOURCE_MEM,
+	      },
+	[1] = {
+	       .start = IRQ_UART3,
+	       .end   = IRQ_UART3,
+	       .flags = IORESOURCE_IRQ,
+	      }
+};
+
+/*******************************************************************************/
+
+struct platform_device cx2450x_device_ser0 = {
+	.name = "cnxt_uart",
+	.id = 0,
+	.num_resources = ARRAY_SIZE (cx2450x_ser0_res),
+	.resource = cx2450x_ser0_res,
+	.dev = {
+		.dma_mask = &cx2450x_device_dmamask,
+		.coherent_dma_mask = DMA_BIT_MASK (32),
+		}
+};
+EXPORT_SYMBOL (cx2450x_device_ser0);
+#endif
+
+/*******************************************************************************/
+
+#if CONFIG_SERIAL_CNXT_UART >= 2
+static struct resource cx2450x_ser1_res[] = {
+	[0] = {
+	       .start = 0xE0411000,
+	       .end   = 0xE041103F,
+	       .flags = IORESOURCE_MEM,
+	      },
+	[1] = {
+	       .start = IRQ_UART2,
+	       .end   = IRQ_UART2,
+	       .flags = IORESOURCE_IRQ,
+	      }
+};
+
+/*******************************************************************************/
+
+struct platform_device cx2450x_device_ser1 = {
+	.name = "cnxt_uart",
+	.id = 1,
+	.num_resources = ARRAY_SIZE (cx2450x_ser1_res),
+	.resource = cx2450x_ser1_res,
+	.dev = {
+		.dma_mask = &cx2450x_device_dmamask,
+		.coherent_dma_mask = DMA_BIT_MASK (32),
+	       }
+};
+EXPORT_SYMBOL (cx2450x_device_ser1);
+#endif
+
+/*******************************************************************************/
+
+#if CONFIG_SERIAL_CNXT_UART >= 3
+static struct resource cx2450x_ser2_res[] = {
+	[0] = {
+	       .start = 0xE0410000,
+	       .end   = 0xE041003B,
+	       .flags = IORESOURCE_MEM,
+	      },
+	[1] = {
+	       .start = IRQ_UART1,
+	       .end   = IRQ_UART1,
+	       .flags = IORESOURCE_IRQ,
+	      }
+};
+ 
+/*******************************************************************************/
+
+struct platform_device cx2450x_device_ser2 = {
+	.name = "cnxt_uart",
+	.id = 2,
+	.num_resources = ARRAY_SIZE (cx2450x_ser2_res),
+	.resource = cx2450x_ser2_res,
+	.dev = {
+		.dma_mask = &cx2450x_device_dmamask,
+		.coherent_dma_mask = DMA_BIT_MASK (32),
+		}
+
+};
+EXPORT_SYMBOL (cx2450x_device_ser2);
+#endif
+#endif
+
+/*******************************************************************************/
+
+#ifdef CONFIG_CX2450X_USB0
+struct platform_device cx2450x_device_usb0 = {
+	.name = "cx2450x-ehci",
+	.id = 0,
+	.num_resources = ARRAY_SIZE (cx2450x_usb_res0),
+	.resource = cx2450x_usb_res0,
+	.dev = {
+		.dma_mask = &cx2450x_device_dmamask,
+		.coherent_dma_mask = 0xFFFFFFFFUL}
+};
+EXPORT_SYMBOL (cx2450x_device_usb0);
+#endif
+
+#ifdef CONFIG_CX2450X_USB1
+struct platform_device cx2450x_device_usb1 = {
+	.name = "cx2450x-ehci",
+	.id = 1,
+	.num_resources = ARRAY_SIZE (cx2450x_usb_res1),
+	.resource = cx2450x_usb_res1,
+	.dev = {
+		.dma_mask = &cx2450x_device_dmamask,
+		.coherent_dma_mask = 0xFFFFFFFFUL
+	}
+};
+EXPORT_SYMBOL (cx2450x_device_usb1);
+
+#endif
+
+#ifdef CONFIG_ARCVMAC
+static struct resource cx2450x_vmac_res[] = {
+	[0] = {
+		.start	= 0xE8003000,
+		.end	= 0xE8003043,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_EMAC0,
+		.end	= IRQ_EMAC0,
+		.flags	= IORESOURCE_IRQ,
+	}
+};
+
+struct platform_device cx2450x_device_vmac = {
+	.name = "arcvmac",
+	.id = -1,
+	.num_resources = ARRAY_SIZE (cx2450x_vmac_res),
+	.resource = cx2450x_vmac_res,
+	.dev = {
+		.dma_mask = &cx2450x_device_dmamask,
+		.coherent_dma_mask = 0xFFFFFFFFUL
+	}
+};
+
+EXPORT_SYMBOL(cx2450x_device_vmac);
+#endif
diff --git a/arch/arm/mach-nevis/devices.h b/arch/arm/mach-nevis/devices.h
new file mode 100644
index 0000000..255af01
--- /dev/null
+++ b/arch/arm/mach-nevis/devices.h
@@ -0,0 +1,51 @@
+/* arch/arm/mach-cx2450x/devs.h
+ *
+ * Header file for cx2450x platform devices
+ *
+ * Copyright (C) 2008 Coolstream International Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Modifications:
+*/
+#ifndef __DEVICES_H
+#define __DEVICES_H
+
+#include <generated/autoconf.h>
+#include <linux/platform_device.h>
+
+#ifdef CONFIG_CX2450X_USB0
+extern struct platform_device cx2450x_device_usb0;	/* USB EHCI Controller #0 */
+#endif
+#ifdef CONFIG_CX2450X_USB1
+extern struct platform_device cx2450x_device_usb1;	/* USB EHCI Controller #1 */
+#endif
+
+#ifdef CONFIG_ARCVMAC
+extern struct platform_device cx2450x_device_vmac;
+#endif
+
+#ifdef CONFIG_SERIAL_CNXT_UART
+#if CONFIG_SERIAL_CNXT_UART >= 1
+extern struct platform_device cx2450x_device_ser0;	/* UART #2 */
+#endif
+#if CONFIG_SERIAL_CNXT_UART >= 2
+extern struct platform_device cx2450x_device_ser1;	/* UART #1 */
+#endif
+#if CONFIG_SERIAL_CNXT_UART >= 3
+extern struct platform_device cx2450x_device_ser2;	/* UART #0 */
+#endif
+#endif
+
+#endif /* __DEVICES_H */
diff --git a/arch/arm/mach-nevis/dma.c b/arch/arm/mach-nevis/dma.c
new file mode 100644
index 0000000..e449ed8
--- /dev/null
+++ b/arch/arm/mach-nevis/dma.c
@@ -0,0 +1,43 @@
+/*****************************************************************************
+ *  linux/arch/arm/mach-nevis/dma.c
+ * 
+ *  Copyright (C) 2007 Conexant Systems Inc, USA.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License Version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02111-1307  USA
+ *****************************************************************************/
+/*$Id$
+ ******************************************************************************/
+
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/mman.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/scatterlist.h>
+
+#include <asm/page.h>
+#include <asm/pgtable.h>
+#include <asm/dma.h>
+#include <mach/hardware.h>
+#include <asm/irq.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/map.h>
+#include <mach/irqs.h>
+
+#include <asm/mach/dma.h>
+
+void __init arch_dma_init(dma_t * dma)
+{
+}
diff --git a/arch/arm/mach-nevis/gpio.c b/arch/arm/mach-nevis/gpio.c
new file mode 100644
index 0000000..7e712ce
--- /dev/null
+++ b/arch/arm/mach-nevis/gpio.c
@@ -0,0 +1,238 @@
+/*
+ * (C) Copyright 2008
+ * Coolstream Internation Limited
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/init.h>
+#include <linux/input.h>	/* for EXPORT_SYMBOL */
+#include <linux/module.h>
+#include <linux/irq.h>
+#include <linux/sysdev.h>
+#include <linux/spinlock.h>
+
+#include <asm/gpio.h>
+#include <asm/io.h>
+#include <mach/hardware.h>
+#include <mach/cx2450x.h>
+
+struct cx2450x_gpio_chip {
+	struct gpio_chip chip;
+	void __iomem *regbase;
+};
+
+DEFINE_SPINLOCK(gpio_lock);
+
+/* some helpers for the GPIO controller */
+/*******************************************************************************/
+/* switch the pio number to the given state (PIO_HIGH, PIO_LOW, PIO_OFF)       */
+
+void gpio_drive(u32 pio, u32 state)
+{
+	unsigned long flags;
+	volatile u32 *reg, val;
+	/* decode the requested PIO to the assigned bank/bit */
+	u32 bank = pio / 32;
+	u32 bit = pio % 32;
+
+	val = state + (bank * 0x40);
+
+	if (bank < 7) {
+		spin_lock_irqsave(&gpio_lock, flags);
+		reg = (volatile u32 *) val;
+		*reg = (1 << bit);
+		spin_unlock_irqrestore(&gpio_lock, flags);
+	}
+}
+
+/*******************************************************************************/
+/* read the state of one GPIO pin (if configured as input before)              */
+
+u32 gpio_read(u32 pio)
+{
+	unsigned long flags;
+	volatile u32 *reg;
+	u32 bank = pio / 32;
+	u32 bit = pio % 32;
+	u32 ret = 0;
+
+	if (bank < 7) {
+		spin_lock_irqsave(&gpio_lock, flags);
+		reg = (volatile u32 *) (PIO_READ_REG + (bank * 0x40));
+		if ((*reg) & (1 << bit))
+			ret = 1;
+		spin_unlock_irqrestore(&gpio_lock, flags);
+	}
+
+	return ret;
+}
+
+/*******************************************************************************/
+
+EXPORT_SYMBOL(gpio_drive);
+EXPORT_SYMBOL(gpio_read);
+
+#define PIO_BASE		0xE0470000
+#define PIO_BANKS		0x07
+#define PIO_BANK_SIZE		0x40
+#define PIO_READ_OFFSET		0x00
+#define PIO_HIGH_OFFSET		0x04
+#define PIO_LOW_OFFSET		0x08
+#define PIO_OFF_OFFSET		0x0C
+
+static int cx2450x_gpio_direction_input(struct gpio_chip *chip, unsigned offset)
+{
+	u32 mask = 1 << offset;
+	u32 value;
+	unsigned long flags;
+	struct cx2450x_gpio_chip *cx;
+	void __iomem *pio_off;
+
+	cx = container_of(chip, struct cx2450x_gpio_chip, chip);
+	pio_off = cx->regbase + PIO_OFF_OFFSET;
+
+	spin_lock_irqsave(&gpio_lock, flags);
+	value = readl(pio_off);
+	value |= mask;
+	writel(value, pio_off);
+	spin_unlock_irqrestore(&gpio_lock, flags);
+
+	return 0;
+}
+
+static int cx2450x_gpio_direction_output(struct gpio_chip *chip, unsigned offset, int value)
+{
+	u32 mask = 1 << offset;
+	unsigned long flags;
+	struct cx2450x_gpio_chip *cx;
+	void __iomem *pio_off;
+
+	cx = container_of(chip, struct cx2450x_gpio_chip, chip);
+	pio_off = cx->regbase + (value ? PIO_HIGH_OFFSET : PIO_LOW_OFFSET);
+
+	spin_lock_irqsave(&gpio_lock, flags);
+	writel(mask, pio_off);
+	spin_unlock_irqrestore(&gpio_lock, flags);
+
+	return 0;
+}
+
+/*
+ * Return GPIO level
+ */
+static int cx2450x_gpio_get(struct gpio_chip *chip, unsigned offset)
+{
+	u32 mask = 1 << offset;
+	struct cx2450x_gpio_chip *cx;
+
+	cx = container_of(chip, struct cx2450x_gpio_chip, chip);
+	return !!readl(cx->regbase + PIO_READ_OFFSET) & mask;
+}
+
+/*
+ * Set output GPIO level
+ */
+static void cx2450x_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
+{
+	u32 mask = 1 << offset;
+	struct cx2450x_gpio_chip *cx;
+
+	cx = container_of(chip, struct cx2450x_gpio_chip, chip);
+
+	if (value)
+		writel(mask, cx->regbase + PIO_HIGH_OFFSET);
+	else
+		writel(mask, cx->regbase + PIO_LOW_OFFSET);
+}
+
+#define GPIO_CHIP(_n)									\
+	[_n] = {									\
+		.regbase = (void __iomem *)(PIO_BASE + ((_n) * PIO_BANK_SIZE)),		\
+		.chip = {								\
+			.label			= "gpio-" #_n,				\
+			.direction_input	= cx2450x_gpio_direction_input,		\
+			.direction_output	= cx2450x_gpio_direction_output,	\
+			.get			= cx2450x_gpio_get,			\
+			.set			= cx2450x_gpio_set,			\
+			.base			= (_n) * 32,				\
+			.ngpio			= 32,					\
+		},									\
+	}
+
+static struct cx2450x_gpio_chip cx2450x_gpio_chip[] = {
+	GPIO_CHIP(0),
+	GPIO_CHIP(1),
+	GPIO_CHIP(2),
+	GPIO_CHIP(3),
+	GPIO_CHIP(4),
+	GPIO_CHIP(5),
+	GPIO_CHIP(6),
+};
+
+static const u32 pio_excl_mask[] = {
+	CONFIG_PIO_EXCL_MASK_PIO_031_000,
+	CONFIG_PIO_EXCL_MASK_PIO_063_032,
+	CONFIG_PIO_EXCL_MASK_PIO_095_064,
+	CONFIG_PIO_EXCL_MASK_PIO_127_096,
+	CONFIG_PIO_EXCL_MASK_PIO_159_128,
+	CONFIG_PIO_EXCL_MASK_PIO_191_160,
+	CONFIG_PIO_EXCL_MASK_PIO_223_192
+};
+
+int __init cx2450x_init_gpio(void)
+{
+	u32 i;
+#ifdef CONFIG_PIO_INIT_ON_BOOT
+	volatile u32 *reg;
+
+	if (ARRAY_SIZE(pio_excl_mask) != PIO_BANKS)
+		printk(KERN_ERR "banks are not matching the masks\n");
+
+	/* Clear out GPIO registers. */
+	for (i = 0; i < ARRAY_SIZE(pio_excl_mask); i++) {
+		/* Init all GPIO interrupt sources to known inactive state */
+		reg = (volatile u32 *) GPIO_POS_EDGE_REG_BASE(i);
+		*reg = 0;
+		reg = (volatile u32 *) GPIO_NEG_EDGE_REG_BASE(i);
+		*reg = 0;
+
+		/* Make sure all GPIOs are inactive and in high impedance state */
+		reg = (volatile u32 *) GPIO_DRIVE_OFF_REG_BASE(i);
+		*reg = (0xFFFFFFFF ^ pio_excl_mask[i]);
+	}
+#endif				/* CONFIG_PIO_INIT_ON_BOOT */
+
+	for (i = 0; i < PIO_BANKS; i++)
+		gpiochip_add(&cx2450x_gpio_chip[i].chip);
+
+	return 0;
+}
+
+
+static struct sysdev_class cx2450x_gpio_sysclass = {
+	.name		= "gpio",
+	.suspend	= NULL, /*_gpio_suspend,*/
+	.resume		= NULL, /* _gpio_resume,*/
+};
+
+static int __init cx2450x_gpio_init_sys(void)
+{
+	return sysdev_class_register(&cx2450x_gpio_sysclass);
+}
+
+core_initcall(cx2450x_gpio_init_sys);
+arch_initcall(cx2450x_init_gpio);
diff --git a/arch/arm/mach-nevis/include/mach/clkdev.h b/arch/arm/mach-nevis/include/mach/clkdev.h
new file mode 100644
index 0000000..04b37a8
--- /dev/null
+++ b/arch/arm/mach-nevis/include/mach/clkdev.h
@@ -0,0 +1,7 @@
+#ifndef __ASM_MACH_CLKDEV_H
+#define __ASM_MACH_CLKDEV_H
+
+#define __clk_get(clk) ({ 1; })
+#define __clk_put(clk) do { } while (0)
+
+#endif
diff --git a/arch/arm/mach-nevis/include/mach/cx2450x.h b/arch/arm/mach-nevis/include/mach/cx2450x.h
new file mode 100644
index 0000000..50438fc8
--- /dev/null
+++ b/arch/arm/mach-nevis/include/mach/cx2450x.h
@@ -0,0 +1,159 @@
+/************************************************************************************
+ * linux/include/asm-arm/arch-nevis/cx2450x.h
+ *
+ * global register definitions
+ *
+ *  Copyright (C) 2008 Coolstream International Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License Version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02111-1307  USA
+ *************************************************************************************/
+
+#ifndef __CX2450X_H
+#define __CX2450X_H
+
+/* CX2450X Base clock frequency */
+#define NEVIS_XTAL_FREQUENCY		UL(60000000)
+
+//#define HSX_BASE                	(0xE0000000)
+#define HSX_PIT_GENERAL_REG		(0xE0000100)
+#define HSX_PIT_DATA_REG		(0xE0000104)
+#define HSX_PIT_INSTR_REG		(0xE0000108)
+
+/* ISA Aperture */
+#define ISA_IO_BASE_ADDR		(0xE1000000)
+#define ISA_IO_BANK_SIZE		(0x00100000)
+
+/* ROM/ISA Mapping */
+#define ROM_DESC_REG_BASE(x)		(0xE0010000 + ((x) * 4))	/* ROM descriptor base (x = 0 ... 7) */
+#define ROM_MAP_REG_BASE(x)		(0xE0010020 + ((x) * 4))	/* ROM mapping register base (x = 0 ... 7) */
+#define ROM_EXT_DESC_REG_BASE(x)	(0xE0010080 + ((x) * 4))	/* ROM ext. descriptor base (x = 0 ... 7) */
+/* PCI Interface */
+//#define PCI_BASE			(0xE0010000)
+#define PCI_ROM_DESC0_REG		(0xE0010000)
+#define PCI_ISAROM_DESC1_REG		(0xE0010004)
+#define PCI_ROM_DESC0_REG2		(0xE0010080)
+#define PCI_CFG_ADDR_REG		(0xE0010040)
+#define PCI_CFG_DATA_REG		(0xE0010044)
+#define PCI_INTSTAT_REG			(0xE0010054)			/* PCI Controller Interrupt Status Register */
+/* System controller */
+#define SYS_SOFTRESET_REG		(0xE040001C)			/* writing anything causes a reset */
+
+/* UART's 
+   (16550 compatible except: FIFOs allways on, no DMA mode select, 
+   no support for 5 and 6 bit data frames, no scratch register) */
+#define	UART_FIFO_BRDL_REG(x)		(0xE0410000 + ((x) * 0x1000))	/* FIFO (BDS=0) or lower baud rate divisor (BDS=1) register (x = 0 ... 3) */
+#define	UART_IRQE_BRDU_REG(x)		(0xE0410004 + ((x) * 0x1000))	/* Interrupt enable (BDS=0) or upper baud rate divisor (BDS=1) register (x = 0 ... 3) */
+#define	UART_FIFC_REG(x)		(0xE0410008 + ((x) * 0x1000))	/* FIFO control register (x = 0 ... 3) */
+#define	UART_FRMC_REG(x)		(0xE041000C + ((x) * 0x1000))	/* Frame control register (x = 0 ... 3) */
+#define	UART_STAT_REG(x)		(0xE0410014 + ((x) * 0x1000))	/* Status register (x = 0 ... 3) */
+#define	UART_IRLVL_REG(x)		(0xE0410018 + ((x) * 0x1000))	/* Interrupt level register (x = 0 ... 3) */
+#define	UART_IRDC_REG(x)		(0xE0410020 + ((x) * 0x1000))	/* IrDA control register (x = 0 ... 3) */
+#define	UART_TXSTA_REG(x)		(0xE0410028 + ((x) * 0x1000))	/* Transmit FIFO status register (x = 0 ... 3) */
+#define	UART_RXSTA_REG(x)		(0xE041002C + ((x) * 0x1000))	/* Receive FIFO status register (x = 0 ... 3) */
+#define	UART_EXP_REG(x)			(0xE0410030 + ((x) * 0x1000))	/* Expansion register (x = 0 ... 3) */
+
+/* General Purpos Timers */
+#define TIMER_VALUE_REG_BASE(x)		(0xE0430000 + ((x) * 0x10))	/* the current timer value (x = 0 ... 15) */
+#define TIMER_LIMIT_REG_BASE(x)		(0xE0430004 + ((x) * 0x10))	/* the timer limit value (x = 0 ... 15) */
+#define TIMER_MODE_REG_BASE(x)		(0xE0430008 + ((x) * 0x10))	/* the mode bits (x = 0 ... 15) */
+#define TIMER_BASE_REG_BASE(x)		(0xE043000C + ((x) * 0x10))	/* the clock base (x = 0 ... 15) */
+#define TIMER_INT_STAT_REG		(0xE0430100)			/* the interrupt status */
+
+/* PLL */
+#define PLL_BASE			(0xE0440000)
+#define PLL_MPG0_INTFRAC_REG		(0xE0440000)
+#define PLL_MPG0_CTRL_REG		(0xE0440004)
+#define PLL_FENRUS_CTRL_REG		(0xE0440048)
+#define PLL_DIV_MUX_CTRL1_REG		(0xE0440054)
+#define PLL_DIV_MUX_CTRL10_REG		(0xE0440078)
+
+#define PLL_CONFIG0_REG			(0xE0440100)
+
+/* System Registers */
+#define SREG_ALT_PIN_FUNC_REG		(0xE0440110)			/* alternate pin function register */
+#define	SREG_USB_ENABLE_REG		(0xE0440138)
+#define SREG_PRI_MUX_REG_BASE(x)	(0xE0440180 + ((x) * 4))	/* Primary PIO multiplex select register (x = 0 ... 6) */
+#define SREG_SEC_MUX_REG_BASE(x)	(0xE04401C0 + ((x) * 4))	/* Secondary PIO multiplex select register (x = 0 ... 6) */
+
+/* Interrupt Controller */
+#define ITC_DEST_REG_BASE(x)		(0xE0450000 + ((x) * 0x20))	/* Interrupt Destination Registers (x = 0 ... 3) */
+#define ITC_ENABLE_REG_BASE(x)		(0xE0450004 + ((x) * 0x20))	/* Interrupt Enable Registers (x = 0 ... 3) */
+#define ITC_IRQREQ_REG_BASE(x)		(0xE0450008 + ((x) * 0x20))	/* Interrupt Enable Registers (x = 0 ... 3) */
+#define ITC_STATCLR_REG_BASE(x)		(0xE0450010 + ((x) * 0x20))	/* Interrupt Status/Clear Registers (x = 0 ... 3) */
+#define ITC_STATSET_REG_BASE(x)		(0xE0450014 + ((x) * 0x20))	/* Interrupt Status/Set Registers (x = 0 ... 3) */
+
+/* Infrared Remote Controllers */
+#define IR_CTRL_REG_BASE(x)		(0xE0460000 + ((x) * 0x1000))	/* Control register (x = 0 ... 1) */
+#define IR_TXCLK_REG_BASE(x)		(0xE0460004 + ((x) * 0x1000))	/* TX-clock divider register (x = 0 ... 1) */
+#define IR_RXCLK_REG_BASE(x)		(0xE0460008 + ((x) * 0x1000))	/* RX-clock divider register (x = 0 ... 1) */
+#define IR_CDUTY_REG_BASE(x)		(0xE046000C + ((x) * 0x1000))	/* TX-carrier duty cycle register (x = 0 ... 1) */
+#define IR_STAT_REG_BASE(x)		(0xE0460010 + ((x) * 0x1000))	/* Status register (x = 0 ... 1) */
+#define IR_IRQEN_REG_BASE(x)		(0xE0460014 + ((x) * 0x1000))	/* Interrupt enable register (x = 0 ... 1) */
+#define IR_FILTER_REG_BASE(x)		(0xE0460018 + ((x) * 0x1000))	/* Low pass filter register (x = 0 ... 1) */
+#define IR_FIFO_REG_BASE(x)		(0xE0460040 + ((x) * 0x1000))	/* FIFO register (x = 0 ... 1) */
+
+/* General Purpose I/O Controller */
+#define GPIO_READ_REG_BASE(x)		(0xE0470000 + ((x) * 0x40))	/* Read registers (x = 0 ... 6) */
+#define GPIO_DRIVE_HIGH_REG_BASE(x)	(0xE0470004 + ((x) * 0x40))	/* Drive high registers (x = 0 ... 6) */
+#define GPIO_DRIVE_LOW_REG_BASE(x)	(0xE0470008 + ((x) * 0x40))	/* Drive low registers (x = 0 ... 6) */
+#define GPIO_DRIVE_OFF_REG_BASE(x)	(0xE047000C + ((x) * 0x40))	/* Drive off registers (x = 0 ... 6) */
+#define GPIO_INTSTAT_REG_BASE(x)	(0xE0470010 + ((x) * 0x40))	/* Interrupt Status Registers (x = 0 ... 6) */
+#define GPIO_INTENA_REG_BASE(x)		(0xE0470014 + ((x) * 0x40))	/* Interrupt Enable Registers (x = 0 ... 6 ) */
+#define GPIO_POS_EDGE_REG_BASE(x)	(0xE0470018 + ((x) * 0x40))	/* positive edge trigger register (x = 0 ... 6) */
+#define GPIO_NEG_EDGE_REG_BASE(x)	(0xE047001C + ((x) * 0x40))	/* negative trigger registers (x = 0 ... 6) */
+#define GPIO_LEVEL_REG_BASE(x)		(0xE0470020 + ((x) * 0x40))	/* level trigger registers (x = 0 ... 6) */
+
+/* memory controller */
+//#define MEM_PLL_CTRL0_REG		0xE0500800
+#define MEM_PLL_CTRL1_REG		0xE0500804
+#define MEM_PLL_CTRL2_REG		0xE0500808
+//#define MEM_PLL_CTRL3_REG		0xE050080C
+
+/* Network controller(s) */
+#define EMAC0_BASE			(0xE8003000)
+#define EMAC1_BASE			(0xE8004000)
+
+#define EMAC_ID_REG(x)			(0xE8003000 + ((x) * 0x1000))
+#define EMAC_STAT_REG(x)		(0xE8003004 + ((x) * 0x1000))
+#define EMAC_ENABLE_REG(x)		(0xE8003008 + ((x) * 0x1000))
+#define EMAC_CONTROL_REG(x)		(0xE800300C + ((x) * 0x1000))
+#define EMAC_POLLRATE_REG(x)		(0xE8003010 + ((x) * 0x1000))
+#define EMAC_RXERR_REG(x)		(0xE8003014 + ((x) * 0x1000))
+#define EMAC_MISS_REG(x)		(0xE8003018 + ((x) * 0x1000))
+#define EMAC_TXRINGPTR_REG(x)		(0xE800301C + ((x) * 0x1000))
+#define EMAC_RXRINGPTR_REG(x)		(0xE8003020 + ((x) * 0x1000))
+#define EMAC_ADDRL_REG(x)		(0xE8003024 + ((x) * 0x1000))
+#define EMAC_ADDRH_REG(x)		(0xE8003028 + ((x) * 0x1000))
+#define EMAC_LAFL_REG(x)		(0xE800302C + ((x) * 0x1000))
+#define EMAC_LAFH_REG(x)		(0xE8003030 + ((x) * 0x1000))
+#define EMAC_MDIO_REG(x)		(0xE8003034 + ((x) * 0x1000))
+#define EMAC_TXPTRREAD_REG(x)		(0xE8003038 + ((x) * 0x1000))
+#define EMAC_RXPTRREAD_REG(x)		(0xE800303C + ((x) * 0x1000))
+#define EMAC_XTRACTRL_REG(x)		(0xE8003040 + ((x) * 0x1000))
+
+/* vaious definitions */
+#define CHIP_CRYSTAL_FREQUENCY		60000000			/* SoC is clocked by a 60.000 MHz crystal */
+#define XTAL_PRESCALE_FACTOR		1
+
+#define MPG0PLL				0x00
+#define MPG1PLL				0x01
+#define HDPLL				0x02
+#define AUDPLL				0x03
+//#define MEMPLL				0x04
+#define PLL0				0x05
+#define PLL1				0x06
+#define PLL2				0x07
+#define FENRUSPLL			0x08
+
+#endif /* __CX2450X_H */
diff --git a/arch/arm/mach-nevis/include/mach/debug-macro.S b/arch/arm/mach-nevis/include/mach/debug-macro.S
new file mode 100644
index 0000000..a201c31e
--- /dev/null
+++ b/arch/arm/mach-nevis/include/mach/debug-macro.S
@@ -0,0 +1,51 @@
+/****************************************************************************
+ *
+ *  include/asm-arm/arch-pecos/debug-macro.S
+ *
+ *  Copyright (C) 2007 Conexant Systems Inc, USA.
+ *  Copyright (C) 2008 CoolStream International Limited.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License Version 2 as published by
+ *  the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02111-1307  USA
+ *
+ ****************************************************************************/
+		/* .equ	io_virt, ASX_VADDR_BASE @ 0xFD00.0000 */
+		/* .equ	io_phys, ASX_PHYS_BASE  @ 0xE000.0000 */
+		.equ	io_virt, 0xE0000000 @ 0xFD00.0000  
+		.equ	io_phys, 0xE0000000 @ 0xE000.0000
+
+		.macro	addruart,rp, rv
+		mov     \rp, #0x2000
+		orr	\rp, #0x410000
+		orr	\rp, \rp, #io_phys	@ ASX physical base address
+		mov     \rv, #0x2000
+		orr	\rv, #0x410000
+		orr	\rv, \rv, #io_virt	@ ASX virtual base address
+		.endm
+
+		.macro	senduart,rd,rx
+		strb	\rd, [\rx]		@ SER_DATA_REG
+		.endm
+
+		.macro	waituart,rd,rx
+1001:		ldrb	\rd,    [\rx, #0x14]    @ SER_STATUS_REG
+		tst     \rd, #(1 << 6)            @ SER_STATUS_TXIDLE
+		beq     1001b
+		.endm
+
+		.macro	busyuart,rd,rx
+1002:           ldrb     \rd,[\rx, #0x14]	@ SER_STATUS_REG
+                tst     \rd, #(1 << 6)		@ SER_STATUS_TXIDLE
+		bne	1002b
+		.endm
+
diff --git a/arch/arm/mach-nevis/include/mach/dma.h b/arch/arm/mach-nevis/include/mach/dma.h
new file mode 100644
index 0000000..16bb898
--- /dev/null
+++ b/arch/arm/mach-nevis/include/mach/dma.h
@@ -0,0 +1,27 @@
+/***********************************************************************************
+ *  linux/include/asm-arm/arch-nevis/dma.h
+ *
+ *  Copyright 2007 Conexant Systems Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License Version 2 as published by
+ *  the Free Software Foundation.
+ * 
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ * 
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02111-1307  USA
+ *
+ **************************************************************************************/
+
+#ifndef __ASM_ARCH_DMA_H
+#define __ASM_ARCH_DMA_H
+
+#define MAX_DMA_ADDRESS		0xffffffff
+#define MAX_DMA_CHANNELS	0
+
+#endif /* _ASM_ARCH_DMA_H */
diff --git a/arch/arm/mach-nevis/include/mach/entry-macro.S b/arch/arm/mach-nevis/include/mach/entry-macro.S
new file mode 100644
index 0000000..01fc42b
--- /dev/null
+++ b/arch/arm/mach-nevis/include/mach/entry-macro.S
@@ -0,0 +1,109 @@
+/******************************************************************************
+ * include/asm-arm/arch-nevis/entry-macro.S
+ *
+ *  Copyright (C) 2007 Conexant Systems Inc, USA.
+ *  Copyright (C) 2010 CoolStream Int Ltd.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License Version 2 as published by
+ *  the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02111-1307  USA
+ *
+ ****************************************************************************/
+
+#include <mach/cx2450x.h>
+#define MAXIRQNUM 32
+
+		.equ itc_intstatset_1   , ITC_STATSET_REG_BASE(0)
+		.equ itc_intstatenable_1, ITC_ENABLE_REG_BASE(0)
+		.equ itc_intstatset_2   , ITC_STATSET_REG_BASE(1)
+		.equ itc_intstatenable_2, ITC_ENABLE_REG_BASE(1)
+		.equ itc_intstatset_3   , ITC_STATSET_REG_BASE(2)
+		.equ itc_intstatenable_3, ITC_ENABLE_REG_BASE(2)
+		.equ itc_intstatset_4   , ITC_STATSET_REG_BASE(3)
+		.equ itc_intstatenable_4, ITC_ENABLE_REG_BASE(3)
+
+		.macro  disable_fiq
+		.endm
+
+		.macro  get_irqnr_preamble, base, tmp
+		.endm
+
+		.macro  arch_ret_to_user, tmp1, tmp2
+		.endm
+
+		.macro  get_irqnr_and_base, irqnr, irqstat, base, tmp
+		/* Check IRQ controller #0 */
+		ldr	\tmp, =itc_intstatset_1
+		ldr	\irqstat, [\tmp]
+		ldr	\tmp, =itc_intstatenable_1
+		ldr	\tmp, [\tmp]
+		ands	\irqstat, \irqstat, \tmp	@ Any IRQ set ?
+		beq	1001f				@ No IRQ set, check IRQ block 1
+
+		mov	\irqnr, #0			@ IRQ nr = 0
+1100:		movs	\irqstat, \irqstat, lsr #1	@ Shift bit into carry
+		bcs	1004f				@ IRQ found, get out of here.
+		add	\irqnr, \irqnr, #1		@ Increase irqnr
+		bne	1100b				@ Check next IRQ
+		b	1005f				@ Uhhh...
+
+1001:		/* Check IRQ controller #1 */
+		ldr	\tmp, =itc_intstatset_2
+		ldr	\irqstat, [\tmp]
+		ldr	\tmp, =itc_intstatenable_2
+		ldr	\tmp, [\tmp]
+		ands	\irqstat, \irqstat, \tmp	@ Any IRQ set ?
+		beq	1002f				@ No IRQ set, check IRQ block 2
+
+		mov	\irqnr, #32			@ IRQ nr = 32
+1200:		movs	\irqstat, \irqstat, lsr #1	@ Shift bit into carry
+		bcs	1004f				@ IRQ found, get out of here.
+		add	\irqnr, \irqnr, #1		@ Increase irqnr
+		bne	1200b				@ Check next IRQ
+		b	1005f				@ Uhhh...
+
+1002:		/* Check IRQ controller #2 */
+		ldr	\tmp, =itc_intstatset_3	
+		ldr	\irqstat, [\tmp]
+		ldr	\tmp, =itc_intstatenable_3
+		ldr	\tmp, [\tmp]
+		ands	\irqstat, \irqstat, \tmp	@ Any IRQ set ?
+		beq	1003f				@ No IRQ set, check IRQ block 3
+		mov	\irqnr, #64			@ IRQ nr = 64
+
+1300:		movs	\irqstat,\irqstat,lsr #1	@ Shift bit into carry
+		bcs	1004f				@ IRQ found, get out of here.
+		add	\irqnr, \irqnr, #1		@ Increase irqnr
+		bne	1300b				@ Check next IRQ
+		b	1005f				@ Uhhh...
+
+1003:		/* Check IRQ controller #3 */
+		ldr	\tmp, =itc_intstatset_4
+		ldr	\irqstat, [\tmp]
+		ldr	\tmp, =itc_intstatenable_4
+		ldr	\tmp, [\tmp]
+		ands	\irqstat, \irqstat, \tmp	@ Any IRQ set ?
+		beq	1005f				@ No IRQ set, get out of here
+		mov	\irqnr, #96			@ IRQ nr = 96
+
+1400:		movs	\irqstat, \irqstat, lsr #1	@ Shift bit into carry
+		bcs	1004f				@ IRQ found, get out of here.
+		add	\irqnr, \irqnr, #1		@ Increase irqnr
+		bne	1400b				@ Check next IRQ
+		b	1005f				@ No IRQs set, hmm
+		/* IRQ found */
+1004:		movs	\irqstat, #1			@ Force !Z 
+1005:		/* If No IRQ are set */
+		.endm
+
+		.macro  irq_prio_table
+		.endm
diff --git a/arch/arm/mach-nevis/include/mach/gpio.h b/arch/arm/mach-nevis/include/mach/gpio.h
new file mode 100644
index 0000000..35495e9
--- /dev/null
+++ b/arch/arm/mach-nevis/include/mach/gpio.h
@@ -0,0 +1,83 @@
+/*
+ * (C) Copyright 2008
+ * Coolstream Internation Limited
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __ASM_ARCH_NEVIS_GPIO_H__
+#define __ASM_ARCH_NEVIS_GPIO_H__
+
+#ifdef __KERNEL__
+
+#include <linux/types.h>
+#include <asm/irq.h>
+#include <asm-generic/gpio.h>
+#include <mach/hardware.h>
+
+#define PIO_READ_REG		0xE0470000
+#define PIO_DRIVE_HIGH_REG	0xE0470004
+#define PIO_DRIVE_LOW_REG	0xE0470008
+#define PIO_DRIVE_OFF_REG	0xE047000C
+
+#define PIO_HIGH		PIO_DRIVE_HIGH_REG	/* drive PIO HIGH */
+#define PIO_LOW			PIO_DRIVE_LOW_REG	/* drive PIO LOW */
+#define PIO_OFF			PIO_DRIVE_OFF_REG	/* switch PIO into input mode */
+
+#define GPIO_MAX		224
+#define GPIO_bit(_n)		(1 << ((_n) & 0x1F))
+#define GPLR(_n)		(*((u32*)(PIO_READ_REG       + ((_n) * 0x40))))
+#define GPSR(_n)		(*((u32*)(PIO_DRIVE_HIGH_REG + ((_n) * 0x40))))
+#define GPCR(_n)		(*((u32*)(PIO_DRIVE_LOW_REG  + ((_n) * 0x40))))
+
+void gpio_drive(u32 pio, u32 state);
+u32 gpio_read(u32 pio);
+
+static inline int gpio_get_value(unsigned gpio)
+{
+        if (__builtin_constant_p(gpio) && (gpio < GPIO_MAX))
+                return GPLR(gpio) & GPIO_bit(gpio);
+        else
+                return __gpio_get_value(gpio);
+}
+
+static inline void gpio_set_value(unsigned gpio, int value)
+{
+        if (__builtin_constant_p(gpio) && (gpio < GPIO_MAX))
+                if (value)
+                        GPSR(gpio) = GPIO_bit(gpio);
+                else
+                        GPCR(gpio) = GPIO_bit(gpio);
+        else
+                __gpio_set_value(gpio, value);
+}
+
+#define gpio_cansleep   __gpio_cansleep
+
+static inline unsigned gpio_to_irq(unsigned gpio)
+{
+        return gpio + 128;
+}
+
+static inline unsigned irq_to_gpio(unsigned irq)
+{
+	return irq - 128;
+}
+
+
+#endif /* __KERNEL__ */
+
+#endif /* __ASM_ARCH_NEVIS_GPIO_H__ */
diff --git a/arch/arm/mach-nevis/include/mach/hardware.h b/arch/arm/mach-nevis/include/mach/hardware.h
new file mode 100644
index 0000000..30a55a1
--- /dev/null
+++ b/arch/arm/mach-nevis/include/mach/hardware.h
@@ -0,0 +1,41 @@
+/************************************************************************************
+ *  include/asm-arm/arch-nevis/hardware.h
+ *
+ * Copyright (C) 2007 Conexant Systems Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License Version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02111-1307  USA
+ *************************************************************************************/
+#ifndef __ASM_ARCH_NEVIS_HARDWARE_H
+#define __ASM_ARCH_NEVIS_HARDWARE_H
+
+#include <asm/sizes.h>
+#include <mach/platform.h>
+#include <mach/memmap.h>
+
+/*
+ * Conversion from Phys to Virt
+ */
+#define ASX_TO_VIRT(x)		(((unsigned int)(x) - (unsigned int)ASX_PHYS_BASE ) + (unsigned int)ASX_VADDR_BASE)
+#define EXT_IO_TO_VIRT(x)	(((unsigned int)(x) - (unsigned int)EXT_IO_PHYS_BASE ) + (unsigned int)EXT_IO_VADDR_BASE )
+//#define PCI_MEM_TO_VIRT(x)	(unsigned int)(x)
+#define PCIBIOS_MIN_IO		0x6000
+#define PCIBIOS_MIN_MEM		0x10000
+
+/*
+ * Override the logic in pci_scan_bus
+ * for skipping already-configured bus numbers.
+ */
+#define pcibios_assign_all_busses() 1
+
+#endif /* __ASM_ARCH_HARDWARE_H */
diff --git a/arch/arm/mach-nevis/include/mach/ide.h b/arch/arm/mach-nevis/include/mach/ide.h
new file mode 100644
index 0000000..d95c70a
--- /dev/null
+++ b/arch/arm/mach-nevis/include/mach/ide.h
@@ -0,0 +1,30 @@
+/*
+ * linux/include/asm-arm/arch-shark/ide.h
+ *
+ * derived from:
+ * linux/include/asm-arm/arch-ebsa285/ide.h
+ * Copyright (c) 1998 Russell King
+ */
+
+#include <asm/irq.h>
+
+
+static __inline__ int ide_default_irq(ide_ioreg_t base)
+{
+	return 0;
+}
+
+static __inline__ ide_ioreg_t ide_default_io_base(int index)
+{
+	return 0;
+}
+
+
+static __inline__ void
+ide_init_hwif_ports(hw_regs_t * hw, int data_port, int ctrl_port, int *irq)
+{
+}
+
+static __inline__ void ide_init_default_hwifs(void)
+{
+}
diff --git a/arch/arm/mach-nevis/include/mach/io.h b/arch/arm/mach-nevis/include/mach/io.h
new file mode 100644
index 0000000..e729a44
--- /dev/null
+++ b/arch/arm/mach-nevis/include/mach/io.h
@@ -0,0 +1,53 @@
+/*******************************************************************************
+ *  linux/include/asm-arm/arch-bronco/io.h
+ *
+ *  Copyright (C) 2004 Conexant Systems Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License Version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02111-1307  USA
+ ********************************************************************************/
+
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+/*
+ * Generic virtual read/write
+ */
+#define IO_SPACE_LIMIT		0xffffffff
+
+/*
+ * Generic function to handle IO addresses. In case
+ * we have special handling we could add this here.
+ */
+static inline void __iomem *__io(unsigned long addr)
+{
+	return (void __iomem *) addr;
+}
+
+#define __io(a)                 __io((a))
+#define __mem_pci(a)		(a)
+#define __mem_isa(a)		(a)
+
+/*
+ * Validate the pci memory address for ioremap.
+ * WARNING: address are now always assumed correct.
+ */
+#define iomem_valid_addr(iomem,size)	(1)
+
+/*
+ * Convert PCI memory space to a CPU physical address
+ * WARNING: this is only true if we have a 1:1 mapping.
+ */
+#define iomem_to_phys(iomem)		(iomem)
+
+#endif /* __ASM_ARM_ARCH_IO_H */
diff --git a/arch/arm/mach-nevis/include/mach/irq.h b/arch/arm/mach-nevis/include/mach/irq.h
new file mode 100644
index 0000000..5b904f8
--- /dev/null
+++ b/arch/arm/mach-nevis/include/mach/irq.h
@@ -0,0 +1,37 @@
+/*********************************************************************************
+ *  linux/include/asm-arm/arch-nevis/irq.h
+ *
+ *  Copyright (C) 2007 Conexant Systems Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License Version 2  as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02111-1307  USA
+ ***********************************************************************************/
+/* $Id$
+ ***********************************************************************************/
+#ifndef __ASM_ARCH_NEVIS_IRQ_H
+#define __ASM_ARCH_NEVIS_IRQ_H
+
+#define LATENCY_COUNT	1000
+
+struct s_latency {
+	unsigned int delta[LATENCY_COUNT];
+	unsigned int duration[LATENCY_COUNT];
+	unsigned int count;
+	unsigned int dur_count;
+};
+
+extern void __init cx2450x_init_irq(void);
+
+/* #define fixup_irq(i)  (edwards_cascade_irq(i)) */
+
+#endif /* __ASM_ARCH_IRQ_H */
diff --git a/arch/arm/mach-nevis/include/mach/irqs.h b/arch/arm/mach-nevis/include/mach/irqs.h
new file mode 100644
index 0000000..6af2e86
--- /dev/null
+++ b/arch/arm/mach-nevis/include/mach/irqs.h
@@ -0,0 +1,55 @@
+/************************************************************************************
+ *  linux/include/asm-arm/arch-nevis/irqs.h
+ *
+ *  Copyright (C) 2007 Conexant Systems Inc.
+ *  Copyright (C) 2008 Coolstream International Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License Version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02111-1307  USA
+ *************************************************************************************/
+
+#ifndef __MACH_ARCH_NEVIS_IRQS_H
+#define __MACH_ARCH_NEVIS_IRQS_H
+
+/* Use the architecture-specific definitions */
+#include <mach/platform.h>
+
+/* Misc. interrupt definitions */
+#define NR_IRQS			352
+#define VALID_PRI_INT_SRC	0x0000FFFF	/* non-reserved bits in primary pic */
+#define VALID_SEC_INT_SRC	0xFFFFC3FF	/* non-reserved bits in secondary pic */
+
+#define IRQ_UART1		 0		/* first UART */
+#define IRQ_UART2		 1		/* second UART */
+#define IRQ_UART3		 2		/* third UART */
+#define IRQ_I2C0		 6		/* first I2C bus */
+#define IRQ_I2C1		 7		/* second I2C bus */
+#define IRQ_IR0			 9		/* first Infrared receiver */
+#define IRQ_IR1			10		/* second Infrared receiver */
+#define IRQ_USB0		13		/* first USB interface */
+#define IRQ_GPIOC		14		/* GPIO controller (global interrupt for chained handler) */
+#define IRQ_USB1		17		/* second USB interface */
+#define IRQ_I2C2		19		/* third I2C bus */
+#define IRQ_USB2		20		/* third USB interface */
+#define IRQ_EMAC0		24		/* first Media Access Controller */
+#define IRQ_EMAC1		25		/* second Media Access Controller */
+#define IRQ_I2C3		27		/* fourth I2C bus */
+#define IRQ_SATA1		35		/* second SATA controller */
+#define IRQ_PCI			37		/* PCI controller */
+#define IRQ_SATA0		42		/* first SATA controller */
+#define IRQ_SC(x)		(  3 + (x))	/* first of the two smardcard interface controllers */
+#define IRQ_IR(x)		(  9 + (x))	/* first of the two Infrared remote controllers */
+#define IRQ_TIMER(x)		( 64 + (x))	/* first of the 16 hardware timer starts at IRQ 64 (count 0 to 15) */
+#define IRQ_GPIO(x)		(128 + (x))	/* first of the 224 GPIO's starts at IRQ 128 (count 0 to 223) */
+
+#endif /* __MACH_ARCH_NEVIS_IRQS_H */
diff --git a/arch/arm/mach-nevis/include/mach/memmap.h b/arch/arm/mach-nevis/include/mach/memmap.h
new file mode 100644
index 0000000..ad93730
--- /dev/null
+++ b/arch/arm/mach-nevis/include/mach/memmap.h
@@ -0,0 +1,60 @@
+/************************************************************************************
+ * linux/include/asm-arm/arch-nevis/cx2450x.h
+ *
+ * global memory map
+ *
+ *  Copyright (C) 2008 Coolstream International Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License Version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02111-1307  USA
+ *************************************************************************************/
+
+#ifndef __MEMMAP_H
+#define __MEMMAP_H
+
+#include <asm/sizes.h>
+
+/*
+ * Fixed Mappings
+ */
+
+/* Virtual Addresses */
+/* #define PCI_MEM_VADDR_BASE	0x80000000  8000.0000 - 9FFF.FFFF */
+#define ASX_VADDR_BASE		0xE0000000 /* E000.0000 - E07F.FFFF */
+#define EXT_IO_VADDR_BASE	0xE1000000 /* E100.0000 - E17F.FFFF */
+#define TEMPEST_VADDR_BASE	0xE4000000 /* E400.0000 - E407.FFFF */
+#define APP_VADDR_BASE		0xE8000000 /* 8000.0000 - 9FFF.FFFF */
+/* #define FLASH_VADDR_BASE	0xF0000000  FC00.0000 - FCFF.FFFF */
+
+/* MFB: TODO: remove me */
+#define IO_BASE			(ASX_VADDR_BASE)
+#define IO_ADDRESS(x)		(((x) & 0x00ffffff) | IO_BASE)
+
+/* Mapping Range */
+#define PCI_MEM_SIZE		0x20000000
+#define PCI_IO_SIZE		0x00100000
+#define ASX_IO_SIZE		0x01000000
+#define EXT_IO_SIZE     	0x01000000	/* EXT IO ecompases PCI IO and ISA IO */
+#define TEMPEST_IO_SIZE		0x01000000
+#define APP_IO_SIZE		0x00040000 // SZ_64K
+#define FLASH_IO_SIZE		SZ_32M
+
+/* Physical Addresses */
+#define FLASH_PHYS_BASE		0xF0000000
+#define ASX_PHYS_BASE		0xE0000000
+#define EXT_IO_PHYS_BASE	0xE1000000	/* Include PCI IO and ISA IO */
+#define TEMPEST_PHYS_BASE	0xE4000000
+#define PCI_MEM_PHYS_BASE	0x80000000
+#define APP_PHYS_BASE		0xE8000000
+
+#endif /*__MEMMAP_H */
diff --git a/arch/arm/mach-nevis/include/mach/memory.h b/arch/arm/mach-nevis/include/mach/memory.h
new file mode 100644
index 0000000..716be53
--- /dev/null
+++ b/arch/arm/mach-nevis/include/mach/memory.h
@@ -0,0 +1,30 @@
+/********************************************************************************
+ *  linux/include/asm-arm/arch-nevis/memory.h
+ *
+ *  Copyright (C) 2007 Conexant Systems Inc.
+ *  Copyright (C) 2008 Coolstream International Limited.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License Version 2 as published by
+ *  the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02111-1307  USA
+ *
+ *********************************************************************************/
+
+#ifndef __ARCH_MEMORY_H
+#define __ARCH_MEMORY_H
+
+/*
+ * Physical start address of the RAM
+ */
+#define PLAT_PHYS_OFFSET     UL(0x00000000)
+
+#endif /* __ARCH_MEMORY_H */
diff --git a/arch/arm/mach-nevis/include/mach/param.h b/arch/arm/mach-nevis/include/mach/param.h
new file mode 100644
index 0000000..2d77c41
--- /dev/null
+++ b/arch/arm/mach-nevis/include/mach/param.h
@@ -0,0 +1,31 @@
+/**************************************************************************************
+ *  linux/include/asm-arm/arch-nevis/param.h
+ *
+ *  Copyright (C) 2007 Conexant Systems Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License Version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02111-1307  USA
+ ***************************************************************************************/
+
+/* FIXME: can we get rid of this file ? */
+#include <asm/param.h>
+
+#if HZ != 100
+#error Please fix the HZ setup
+#endif
+
+/**************************************************************************************
+ * Modifications:
+ * $Log$
+ *
+ ***************************************************************************************/
diff --git a/arch/arm/mach-nevis/include/mach/platform.h b/arch/arm/mach-nevis/include/mach/platform.h
new file mode 100644
index 0000000..ca4f5b6
--- /dev/null
+++ b/arch/arm/mach-nevis/include/mach/platform.h
@@ -0,0 +1,43 @@
+/************************************************************************************
+ * include/asm-arm/arch-nevis/platform.h
+ *
+ * Copyright (C) 2008 CoolStream International Limited.
+ * Copyright (C) 2007 Conexant Systems Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License Version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02111-1307  USA
+ **************************************************************************************/
+
+#ifndef __PLATFORM_H
+#define __PLATFORM_H
+
+#include <mach/hardware.h>
+#include <asm/types.h>
+
+//#include "hwopts.h"
+//#include "nevis.h"
+
+typedef enum _PLL_SOURCE {
+        ARM_PLL_SOURCE = 0,
+        MEM_PLL_SOURCE,
+        MPG0_PLL_SOURCE,
+        FENRUS_PLL_SOURCE
+} PLL_SOURCE;
+
+extern void CalcClkFreqAndPeriod(unsigned int *frequency,
+                                 unsigned int *period,
+                                 unsigned int pll_source,
+                                 unsigned int xtal_freq);
+
+
+#endif /* __PLATFORM_H */
diff --git a/arch/arm/mach-nevis/include/mach/startup.h b/arch/arm/mach-nevis/include/mach/startup.h
new file mode 100644
index 0000000..e421b41
--- /dev/null
+++ b/arch/arm/mach-nevis/include/mach/startup.h
@@ -0,0 +1,84 @@
+/****************************************************************************
+ * include/asm-arm/arch-nevis/startup.h
+ *
+ * Copyright (C) 2007 Conexant Systems Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License Version 2as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02111-1307  USA
+
+ ****************************************************************************/
+/* $Id $
+ ****************************************************************************/
+
+
+/* GET RID OFF */
+
+#ifndef _STARTUP_H
+#define _STARTUP_H
+
+/*****************/
+/* Include Files */
+/*****************/
+#include <mach/hardware.h>
+
+/****************************************************************************/
+/*                                                                          */
+/* Hardware register access macros                                          */
+/*                                                                          */
+/****************************************************************************/
+
+#define RMO(y)                   ( ((y) & 0x00000001) ?  0 : \
+                                   ( ((y) & 0x00000002) ?  1 : \
+                                     ( ((y) & 0x00000004) ?  2 : \
+                                       ( ((y) & 0x00000008) ?  3 : \
+                                         ( ((y) & 0x00000010) ?  4 : \
+                                           ( ((y) & 0x00000020) ?  5 : \
+                                             ( ((y) & 0x00000040) ?  6 : \
+                                               ( ((y) & 0x00000080) ?  7 : \
+                                                 ( ((y) & 0x00000100) ?  8 : \
+                                                   ( ((y) & 0x00000200) ?  9 : \
+                                                     ( ((y) & 0x00000400) ? 10 : \
+                                                       ( ((y) & 0x00000800) ? 11 : \
+                                                         ( ((y) & 0x00001000) ? 12 : \
+                                                           ( ((y) & 0x00002000) ? 13 : \
+                                                             ( ((y) & 0x00004000) ? 14 : \
+                                                               ( ((y) & 0x00008000) ? 15 : \
+                                                                 ( ((y) & 0x00010000) ? 16 : \
+                                                                   ( ((y) & 0x00020000) ? 17 : \
+                                                                     ( ((y) & 0x00040000) ? 18 : \
+                                                                       ( ((y) & 0x00080000) ? 19 : \
+                                                                         ( ((y) & 0x00100000) ? 20 : \
+                                                                           ( ((y) & 0x00200000) ? 21 : \
+                                                                             ( ((y) & 0x00400000) ? 22 : \
+                                                                               ( ((y) & 0x00800000) ? 23 : \
+                                                                                 ( ((y) & 0x01000000) ? 24 : \
+                                                                                   ( ((y) & 0x02000000) ? 25 : \
+                                                                                     ( ((y) & 0x04000000) ? 26 : \
+                                                                                       ( ((y) & 0x08000000) ? 27 : \
+                                                                                         ( ((y) & 0x10000000) ? 28 : \
+                                                                                           ( ((y) & 0x20000000) ? 29 : \
+                                                                                             ( ((y) & 0x40000000) ? 30 : \
+                                                                                               ( ((y) & 0x80000000) ? 31 : 0 ))))))))))))))))))))))))))))))))
+
+#endif
+
+/****************************************************************************
+ * Modifications:
+ * $Log:
+ *  3    Linux_SDK 1.2         6/14/07 6:25:34 PM IST Debashish Rath  Header
+ *       file include which was not needed is removed
+ *  2    Linux_SDK 1.1         3/27/07 5:43:24 PM IST Satpal Parmar   GPL
+ *       header and Starteam footer addition.
+ *  1    Linux_SDK 1.0         3/1/07 11:47:20 PM IST Vineet Seth     
+ * $
+ ****************************************************************************/
diff --git a/arch/arm/mach-nevis/include/mach/system.h b/arch/arm/mach-nevis/include/mach/system.h
new file mode 100644
index 0000000..8414685
--- /dev/null
+++ b/arch/arm/mach-nevis/include/mach/system.h
@@ -0,0 +1,49 @@
+/***********************************************************************************
+ *  linux/include/asm-arm/arch-nevis/system.h
+ *
+ *  Copyright (C) 2007 Conexant Systems Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02111-1307  USA
+ *************************************************************************************/
+
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+#include <asm/io.h>
+#include <mach/hardware.h>
+#include <mach/cx2450x.h>
+
+void cnxt_mip_idle(void);
+
+static inline void arch_idle(void)
+{
+	/* The 'normal' thing is to call cpu_do_idle();     */
+	/* which puts the cpu in 'wait for interrupt' mode. */
+
+	/* FIXME! Implement mipidle stuff from here - DAVEM */
+	/* cpu_do_idle(); */
+	cnxt_mip_idle();	/* noida  neeraj */
+
+}
+
+static inline void arch_reset(char mode, const char *cmd)
+{
+	/* Any write to this register resets the IRD! */
+	writel(0x0, (void __iomem*) ASX_TO_VIRT(SYS_SOFTRESET_REG));
+
+	while (1)
+		; /* not-reached */
+}
+
+#endif /* __ASM_ARCH_SYSTEM_H */
diff --git a/arch/arm/mach-nevis/include/mach/time.h b/arch/arm/mach-nevis/include/mach/time.h
new file mode 100644
index 0000000..81a74ce
--- /dev/null
+++ b/arch/arm/mach-nevis/include/mach/time.h
@@ -0,0 +1,37 @@
+/***********************************************************************************
+ *  linux/include/asm-arm/arch-nevis/time.h
+ *
+ *  Copyright (C) 2007 Conexant Systems Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License Version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02111-1307  USA
+ ************************************************************************************/
+
+#ifndef __LINUX_ARCH_TIME_H__
+#define __LINUX_ARCH_TIME_H__
+
+#include <asm/system.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <linux/interrupt.h>
+
+
+/* Clock ticks at 54 Mhz, giving maximum 79.5sec count */
+#define uSEC_1 54
+#define TIMER_INTERVAL	((uSEC_1 * 1000000) / HZ)
+
+void cx2450x_unlock_timer(u32 timer_number);
+s32 cx2450x_lock_timer(u32 timer_number);
+s32 cx2450x_softlock_timer(u32 timer_number);
+
+#endif	/* __LINUX_ARCH_TIME_H__ */
diff --git a/arch/arm/mach-nevis/include/mach/timex.h b/arch/arm/mach-nevis/include/mach/timex.h
new file mode 100644
index 0000000..f7b5348
--- /dev/null
+++ b/arch/arm/mach-nevis/include/mach/timex.h
@@ -0,0 +1,24 @@
+/**************************************************************************************
+ *  linux/include/asm-arm/arch-nevis/timex.h
+ *  
+ *  Copyright (C) 2007 Conexant Systems Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License Version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,51 Franklin St, Fifth Floor, Boston, MA  02111-1307  USA
+ ***************************************************************************************/
+#ifndef __ARCH_TIMEX_H
+#define __ARCH_TIMEX_H
+
+#define CLOCK_TICK_RATE		1000000
+
+#endif /* __ARCH_TIMEX_H */
diff --git a/arch/arm/mach-nevis/include/mach/uncompress.h b/arch/arm/mach-nevis/include/mach/uncompress.h
new file mode 100644
index 0000000..a65cb4c
--- /dev/null
+++ b/arch/arm/mach-nevis/include/mach/uncompress.h
@@ -0,0 +1,186 @@
+/* linux/include/asm-arm/arch-nevis/uncompress.h
+ *
+ *  Copyright (C) 2008 Coolstream International Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ *(at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ARCH_UNCOMPRESS_H
+#define __ARCH_UNCOMPRESS_H
+
+/* This code is only necessary if:
+ *  - you use a zImage 
+ *  - your architecture can only talk to you via serial ports
+ *  - you wanna see the "Uncompressing Linux..." on the serial port
+ */
+
+#include <generated/autoconf.h>
+#include <mach/cx2450x.h>
+
+#ifdef CONFIG_SERIAL_CX2450X_BOOTMSG
+
+#ifdef CONFIG_SERIAL_CX2450X_BAUDRATE_230400
+#define BAUDRATE	230400
+#else
+#ifdef CONFIG_SERIAL_CX2450X_BAUDRATE_115200
+#define BAUDRATE	115200
+#else
+#ifdef	CONFIG_SERIAL_CX2450X_BAUDRATE_57600
+#define BAUDRATE	57600
+#else
+#ifdef	CONFIG_SERIAL_CX2450X_BAUDRATE_38400
+#define BAUDRATE	38400
+#else
+#ifdef	CONFIG_SERIAL_CX2450X_BAUDRATE_19200
+#define BAUDRATE	19200
+#else
+#ifdef	CONFIG_SERIAL_CX2450X_BAUDRATE_9600
+#define BAUDRATE	9600
+#else
+#error BAUDRATE not configured
+#endif				/* CONFIG_SERIAL_CX2450X_BOOTMSG_9600 */
+#endif				/* CONFIG_SERIAL_CX2450X_BOOTMSG_19200 */
+#endif				/* CONFIG_SERIAL_CX2450X_BOOTMSG_38400 */
+#endif				/* CONFIG_SERIAL_CX2450X_BOOTMSG_57600 */
+#endif				/* CONFIG_SERIAL_CX2450X_BOOTMSG_115200 */
+#endif				/* CONFIG_SERIAL_CX2450X_BOOTMSG_230400 */
+
+static int have_uart[3];
+
+#endif				/* CONFIG_SERIAL_CX2450X_BOOTMSG */
+
+/*******************************************************************************/
+
+static inline void putc(char c)
+{
+#ifdef CONFIG_SERIAL_CX2450X_BOOTMSG
+	u32 val;
+	volatile u8 *FIFO;
+	volatile u8 *TXST;
+
+	for (val = 0; val < 3; val++) {
+		if (have_uart[val]) {
+			FIFO = (volatile u8 *) (UART_FIFO_BRDL_REG(val));
+			TXST = (volatile u8 *) (UART_TXSTA_REG(val));
+
+			while (*TXST & 0x1F);
+			*FIFO = c;
+
+			if (c == '\n') {
+				while (*TXST & 0x1F);
+				*FIFO = '\r';
+			}
+		}
+	}
+#endif				/* CONFIG_SERIAL_CX2450X_BOOTMSG */
+}
+
+/*******************************************************************************/
+
+static inline void flush(void)
+{
+	/* nothing to do here */
+}
+
+/*******************************************************************************/
+
+static __inline__ void arch_decomp_setup(void)
+{
+#ifdef CONFIG_SERIAL_CX2450X_BOOTMSG
+	volatile u32 *reg;
+	volatile u8 *FIFO;
+	volatile u8 *IRQE;
+	volatile u8 *FIFC;
+	volatile u8 *FRMC;
+	u32 val;
+	u32 brdiv = (54000000 / (16 * BAUDRATE)) - 1;
+
+	/* check for UART 1 (PIO 1 (TX), PIO 2 (RX)) */
+	have_uart[0] = 0;
+	reg = (volatile u32 *) SREG_SEC_MUX_REG_BASE(0);
+	if ((*reg & 0x00000006) == 0) {
+		reg = (volatile u32 *) SREG_PRI_MUX_REG_BASE(0);
+		if ((*reg & 0x00000006) == 0x00000006)
+			have_uart[0] = 1;
+	}
+
+	/* check for UART 2 (can be configured on various pins) */
+	have_uart[1] = 0;
+	reg = (volatile u32 *) SREG_ALT_PIN_FUNC_REG;
+	val = (*reg >> 4) & 0x03;
+	if (val == 0) {		/* PIO 3 (TX), 4 (RX) */
+		reg = (volatile u32 *) SREG_SEC_MUX_REG_BASE(0);
+		if ((*reg & 0x00000018) == 0) {
+			reg = (volatile u32 *) SREG_PRI_MUX_REG_BASE(0);
+			if ((*reg & 0x00000018) == 0x00000018)
+				have_uart[1] = 1;
+		}
+
+	} else if (val == 1) {	/* PIO 71 (RX), 72 (TX) */
+		reg = (volatile u32 *) SREG_SEC_MUX_REG_BASE(2);
+		if ((*reg & 0x00000018) == 0) {
+			reg = (volatile u32 *) SREG_PRI_MUX_REG_BASE(2);
+			if ((*reg & 0x00000018) == 0x00000018)
+				have_uart[1] = 1;
+		}
+	} else if (val == 2) {	/* PIO 11 (RX), 73 (TX) */
+		reg = (volatile u32 *) SREG_SEC_MUX_REG_BASE(2);
+		if ((*reg & 0x00000020) == 0) {
+			reg = (volatile u32 *) SREG_PRI_MUX_REG_BASE(2);
+			if ((*reg & 0x00000020) == 0x00000020) {
+				reg = (volatile u32 *) SREG_SEC_MUX_REG_BASE(0);
+				if ((*reg & 0x00000800) == 0) {
+					reg = (volatile u32 *) SREG_PRI_MUX_REG_BASE(0);
+					if ((*reg & 0x00000800) == 0x00000800)
+						have_uart[1] = 1;
+				}
+			}
+		}
+	}
+
+	/* check for UART 3 (PIO 14 (TX), PIO 15 (RX)) */
+	have_uart[2] = 0;
+	reg = (volatile u32 *) SREG_SEC_MUX_REG_BASE(0);
+	if ((*reg & 0x0000C000) == 0) {
+		reg = (volatile u32 *) SREG_PRI_MUX_REG_BASE(0);
+		if ((*reg & 0x0000C000) == 0x0000C000)
+			have_uart[2] = 1;
+	}
+
+	for (val = 0; val < 3; val++) {
+		if (have_uart[val]) {
+			FIFO = (volatile u8 *) (UART_FIFO_BRDL_REG(val));
+			IRQE = (volatile u8 *) (UART_IRQE_BRDU_REG(val));
+			FIFC = (volatile u8 *) (UART_FIFC_REG(val));
+			FRMC = (volatile u8 *) (UART_FRMC_REG(val));
+
+			/* setup Baudradte */
+			*FRMC |= 0x80;	/* set BDS to access FIFO and IRQE as baudrate registers */
+			*FIFO = brdiv & 0xFF;
+			*IRQE = (brdiv >> 8) & 0xFF;
+			*FRMC &= 0x7F;
+			*IRQE = 0x00;
+			*FRMC = 0x01;	/* 8 databits, 1 stopbit, no parity */
+			*FIFC = 0x03;	/* clear RX-RX-FIFO */
+		}
+	}
+#endif				/* CONFIG_SERIAL_CX2450X_BOOTMSG */
+}
+
+/*******************************************************************************/
+
+#define arch_decomp_wdog()
+
+#endif				/* __ASM_ARCH_UNCOMPRESS_H */
diff --git a/arch/arm/mach-nevis/include/mach/vmalloc.h b/arch/arm/mach-nevis/include/mach/vmalloc.h
new file mode 100644
index 0000000..a19ba77
--- /dev/null
+++ b/arch/arm/mach-nevis/include/mach/vmalloc.h
@@ -0,0 +1,25 @@
+/*******************************************************************************************
+ *  linux/include/asm-arm/arch-nevis/vmalloc.h
+ *
+ *  Copyright (C) 2008 CoolStream International Limited.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License Version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02111-1307  USA
+ *********************************************************************************************/
+
+#ifndef __ASM_ARCH_VMALLOC_H
+#define __ASM_ARCH_VMALLOC_H
+
+#define VMALLOC_END		(0xE0000000UL)
+
+#endif
diff --git a/arch/arm/mach-nevis/irq.c b/arch/arm/mach-nevis/irq.c
new file mode 100644
index 0000000..69f338a
--- /dev/null
+++ b/arch/arm/mach-nevis/irq.c
@@ -0,0 +1,359 @@
+/*****************************************************************************
+ *  linux/arch/arm/mach-nevis/irq.c
+ *
+ *  Copyright (C) 2007 Conexant Systems Inc, USA.
+ *  Copyright (C) 2008 Coolstream International
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License Version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/irq.h>
+#include <asm/io.h>
+/*#include <asm/mach/irq.h>*/
+#include <mach/param.h>
+#include <mach/irq.h>
+#include <mach/cx2450x.h>
+
+static volatile u32 *intena_reg[4] = {
+	(volatile u32 *)ITC_ENABLE_REG_BASE(0),
+	(volatile u32 *)ITC_ENABLE_REG_BASE(1),
+	(volatile u32 *)ITC_ENABLE_REG_BASE(2),
+	(volatile u32 *)ITC_ENABLE_REG_BASE(3)
+};
+
+static volatile u32 *intclr_reg[4] = {
+	(volatile u32 *)ITC_STATCLR_REG_BASE(0),
+	(volatile u32 *)ITC_STATCLR_REG_BASE(1),
+	(volatile u32 *)ITC_STATCLR_REG_BASE(2),
+	(volatile u32 *)ITC_STATCLR_REG_BASE(3)
+};
+
+static volatile u32 *piointstat_reg[7] = {
+	(volatile u32 *)GPIO_INTSTAT_REG_BASE(0),
+	(volatile u32 *)GPIO_INTSTAT_REG_BASE(1),
+	(volatile u32 *)GPIO_INTSTAT_REG_BASE(2),
+	(volatile u32 *)GPIO_INTSTAT_REG_BASE(3),
+	(volatile u32 *)GPIO_INTSTAT_REG_BASE(4),
+	(volatile u32 *)GPIO_INTSTAT_REG_BASE(5),
+	(volatile u32 *)GPIO_INTSTAT_REG_BASE(6)
+};
+
+static volatile u32 *piointena_reg[7] = {
+	(volatile u32 *)GPIO_INTENA_REG_BASE(0),
+	(volatile u32 *)GPIO_INTENA_REG_BASE(1),
+	(volatile u32 *)GPIO_INTENA_REG_BASE(2),
+	(volatile u32 *)GPIO_INTENA_REG_BASE(3),
+	(volatile u32 *)GPIO_INTENA_REG_BASE(4),
+	(volatile u32 *)GPIO_INTENA_REG_BASE(5),
+	(volatile u32 *)GPIO_INTENA_REG_BASE(6)
+};
+
+/* a simple array to mask out one of 32 possible interrupts */
+static const u32 irq_mask[128] = {
+	/* Group 1 Interrupts */
+	0x00000001, 0x00000002, 0x00000004, 0x00000008, 0x00000010, 0x00000020, 0x00000040, 0x00000080,
+	0x00000100, 0x00000200, 0x00000400, 0x00000800, 0x00001000, 0x00002000, 0x00004000, 0x00008000,
+	0x00010000, 0x00020000, 0x00040000, 0x00080000, 0x00100000, 0x00200000, 0x00400000, 0x00800000,
+	0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000,	0x40000000, 0x80000000,
+	/* Group 2 Interrupts */
+	0x00000001, 0x00000002, 0x00000004, 0x00000008, 0x00000010, 0x00000020, 0x00000040, 0x00000080,
+	0x00000100, 0x00000200, 0x00000400, 0x00000800, 0x00001000, 0x00002000, 0x00004000, 0x00008000,
+	0x00010000, 0x00020000, 0x00040000, 0x00080000, 0x00100000, 0x00200000, 0x00400000, 0x00800000,
+	0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000,
+	/* Group 3 Interrupts */
+	0x00000001, 0x00000002, 0x00000004, 0x00000008, 0x00000010, 0x00000020, 0x00000040, 0x00000080,
+	0x00000100, 0x00000200, 0x00000400, 0x00000800, 0x00001000, 0x00002000, 0x00004000, 0x00008000,
+	0x00010000, 0x00020000, 0x00040000, 0x00080000, 0x00100000, 0x00200000, 0x00400000, 0x00800000,
+	0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000,
+	/* Group 4 Interrupts */
+	0x00000001, 0x00000002, 0x00000004, 0x00000008, 0x00000010, 0x00000020, 0x00000040, 0x00000080,
+	0x00000100, 0x00000200, 0x00000400, 0x00000800, 0x00001000, 0x00002000, 0x00004000, 0x00008000,
+	0x00010000, 0x00020000, 0x00040000, 0x00080000, 0x00100000, 0x00200000, 0x00400000, 0x00800000,
+	0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000,
+};
+
+static const u32 irq_idx[128] = {
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+};
+
+/**************************************************/
+/*    TYPEDEFs                                    */
+/**************************************************/
+struct s_latency latency = {
+	.count	= 0,
+};
+
+/**************************************************/
+/*    STATIC GLOBALS                              */
+/**************************************************/
+
+int get_latency_list(char *buf)
+{
+	int min = 1000000, avg = 0, max = 0;
+	int mindur = 1000000, avgdur = 0, maxdur = 0;
+	int i;
+	char *p = buf;
+
+	p += sprintf(p,
+		     "Sample size = %d.  freq(sample) = freq(tick) (%d mS)\n\n",
+		     LATENCY_COUNT, 1000 / HZ);
+
+	for (i = 0; i < LATENCY_COUNT; i++) {
+		if (latency.duration[i] < mindur)
+			mindur = latency.duration[i];
+		if (latency.duration[i] > maxdur)
+			maxdur = latency.duration[i];
+		if (latency.delta[i] < min)
+			min = latency.delta[i];
+		if (latency.delta[i] > max)
+			max = latency.delta[i];
+		avg	+= latency.delta[i];
+		avgdur	+= latency.duration[i];
+	}
+	p += sprintf(p, "min lat : %d uS\n", min / 54);
+	p += sprintf(p, "avg lat : %d uS\n", avg / (LATENCY_COUNT * 54));
+	p += sprintf(p, "max lat : %d uS\n", max / 54);
+
+	p += sprintf(p, "min dur : %d uS\n", mindur);
+	p += sprintf(p, "avg dur : %d uS\n", avgdur / LATENCY_COUNT);
+	p += sprintf(p, "max dur : %d uS\n", maxdur);
+
+	return p - buf;
+}
+
+/*******************************************************************************/
+
+/* Interrupt handlers for the main interrupt controller */
+static void ack_irq_itc(u32 irq)
+{
+	*intena_reg[irq_idx[irq]] &= ~irq_mask[irq];	/* disable the interrupt */
+}
+
+static void mask_irq_itc(u32 irq)
+{
+	*intena_reg[irq_idx[irq]] &= ~irq_mask[irq];	/* disable the interrupt */
+}
+
+static void unmask_irq_itc(u32 irq)
+{
+	*intclr_reg[irq_idx[irq]] = irq_mask[irq];	/* clear the interrupt */
+	*intena_reg[irq_idx[irq]] |= irq_mask[irq];	/* enable interrupt */
+}
+
+#ifdef CONFIG_PCI
+/* Interrupt Handlers for the PCI-controller. We use an own 'chip' here, even if
+   the IRQ comes from the normal ITC. The reason is, that, beside resetting the
+   status in the ITC, also the status in the PCI-controller must be set. PCI-
+   devicedrivers didn't know the PCI-Controller itself, so we must setup it here.
+   If we put INT_PCI into the main handler, we need a "if" statement to filter
+   this IRQ, which costs time, much time */
+
+static void ack_irq_pci(u32 irq)
+{
+	volatile u32 *pcistat_reg = (volatile u32 *)PCI_INTSTAT_REG;
+
+	*intena_reg[irq_idx[irq]] &= ~irq_mask[irq];	/* disable the interrup */
+	*intclr_reg[irq_idx[irq]] = irq_mask[irq];	/* clear the interrupt */
+	*pcistat_reg = 1;	/* set INTA and reset all other stats in PCI-controller */
+}
+
+static void mask_irq_pci(u32 irq)
+{
+	*intena_reg[irq_idx[irq]] &= ~irq_mask[irq];	/* disable the interrupt */
+}
+
+static void unmask_irq_pci(u32 irq)
+{
+	*intena_reg[irq_idx[irq]] |= irq_mask[irq];	/* enable the interrupt */
+}
+#endif
+
+/* Interrupt handlers for the general purpose I/O pins
+ * (if not used by other fuctions)
+ */
+static void ack_irq_gpio(u32 irq)
+{
+	u32 bank, bit;
+
+	irq -= IRQ_GPIO(0);
+	bank = irq / 32;
+	bit = irq % 32;
+	*piointena_reg[bank] &= ~irq_mask[bit];
+	*piointstat_reg[bank] |= irq_mask[bit];
+}
+
+static void mask_irq_gpio(u32 irq)
+{
+	*piointena_reg[irq / 32] &= ~irq_mask[irq % 32];
+}
+
+static void unmask_irq_gpio(u32 irq)
+{
+	*piointena_reg[irq / 32] |= irq_mask[irq % 32];
+}
+
+static int set_type_irq_gpio(u32 irq, u32 type)
+{
+	u32 bank, bit;
+	volatile u32 *piolevel_reg;
+	volatile u32 *piopedge_reg;
+	volatile u32 *pionedge_reg;
+
+	if (irq < IRQ_GPIO(0))
+		return -EINVAL;
+
+	irq -= IRQ_GPIO(0);
+	bank = irq / 32;
+	bit = irq % 32;
+
+	piolevel_reg = (volatile u32 *)(GPIO_LEVEL_REG_BASE(bank));
+	piopedge_reg = (volatile u32 *)(GPIO_POS_EDGE_REG_BASE(bank));
+	pionedge_reg = (volatile u32 *)(GPIO_NEG_EDGE_REG_BASE(bank));
+
+	switch (type) {
+	case IRQ_TYPE_LEVEL_HIGH:	/* High level trigger */
+		*piopedge_reg &= ~irq_mask[bit];	/* disable rising edge trigger */
+		*pionedge_reg &= ~irq_mask[bit];	/* disable falling edge trigger */
+		*piolevel_reg |= irq_mask[bit];	/* enable high level trigger */
+		break;
+	case IRQ_TYPE_LEVEL_LOW:	/* Low level trigger */
+		*piopedge_reg &= ~irq_mask[bit];	/* disable rising edge trigger */
+		*pionedge_reg &= ~irq_mask[bit];	/* disable falling edge trigger */
+		*piolevel_reg &= ~irq_mask[bit];	/* disable high level trigger */
+		break;
+	case IRQ_TYPE_EDGE_RISING:	/* Rising edge trigger */
+		*pionedge_reg &= ~irq_mask[bit];	/* disable falling edge trigger */
+		*piopedge_reg |= irq_mask[bit];	/* enable rising edge trigger */
+		break;
+	case IRQ_TYPE_EDGE_FALLING:	/* Falling edge trigger */
+		*piopedge_reg &= ~irq_mask[bit];	/* disable rising edge trigger */
+		*pionedge_reg |= irq_mask[bit];	/* enable falling edge trigger */
+		break;
+	case IRQ_TYPE_EDGE_BOTH:	/* Rising AND Falling edge trigger */
+		*piopedge_reg |= irq_mask[bit];	/* enable rising edge trigger */
+		*pionedge_reg |= irq_mask[bit];	/* enable falling edge trigger */
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/*******************************************************************************/
+
+static void nevis_irq_handle_gpio_chain(unsigned int irq, struct irq_desc *desc)
+{
+	u32 bank, bit, irqno;
+	u32 active;
+
+	for (bank = 0; bank < 7; bank++) {
+		active = *piointena_reg[bank] & *piointstat_reg[bank];
+		if (!active)
+			continue;	/* no pending interrupt in this bank */
+
+		for(bit = 0; bit < 32; bit++) {
+			if (active & irq_mask[bit]) {
+				generic_handle_irq(IRQ_GPIO(0) + (bank << 5) + bit);
+			}
+		}
+	}
+}
+
+/*******************************************************************************/
+
+static struct irq_chip cx2450x_itc = {
+	.name		= "cx2450x_itc",
+	.mask	= mask_irq_itc,
+	.unmask	= unmask_irq_itc,
+	.ack	= ack_irq_itc,
+	.disable	= mask_irq_itc
+};
+
+#ifdef CONFIG_PCI
+static struct irq_chip cx2450x_chip_pci = {
+	.name		= "cx2450x_pci",
+	.mask	= mask_irq_pci,
+	.unmask	= unmask_irq_pci,
+	.ack	= ack_irq_pci,
+	.disable	= mask_irq_pci
+};
+#endif
+
+static struct irq_chip cx2450x_chip_gpio = {
+	.name		= "cx2450x_gpio",
+	.mask	= mask_irq_gpio,
+	.unmask	= unmask_irq_gpio,
+	.ack	= ack_irq_gpio,
+	.disable	= mask_irq_gpio,
+	.set_type	= set_type_irq_gpio
+
+};
+
+/*******************************************************************************/
+
+void __init cx2450x_init_irq(void)
+{
+	u32 irq;
+	volatile u32 *reg;
+
+	/* Disable Interrupt Generation */
+	*intena_reg[0] = 0x00000000;
+	*intena_reg[1] = 0x00000000;
+	*intena_reg[2] = 0x00000000;
+	*intena_reg[3] = 0x00000000;
+
+	for (irq = 0; irq < NR_IRQS; irq++) {
+		/* dont interrupt for the 2nd timer unlatched or register */
+		switch (irq) {
+		case 0 ... (IRQ_PCI - 1): /* interrupts from the 4 banks of the ITC except PCI */
+		case (IRQ_PCI + 1) ... 127:
+			set_irq_chip(irq, &cx2450x_itc);
+			set_irq_flags(irq, IRQF_VALID);
+			set_irq_handler(irq, handle_level_irq);
+			break;
+#ifdef CONFIG_PCI
+		case IRQ_PCI:		/* for speedup, the PCI interrupt is handled by it's own "ITC" */
+			set_irq_chip(irq, &cx2450x_chip_pci);
+			set_irq_flags(irq, IRQF_VALID);
+			set_irq_handler(irq, handle_level_irq);
+			break;
+#endif
+		case 128 ... 351:	/* PIO 0 to 223 in 7 banks */
+			set_irq_chip(irq, &cx2450x_chip_gpio);
+			set_irq_flags(irq, IRQF_VALID);
+			set_irq_handler(irq, handle_level_irq);
+			break;
+		default:
+			break;
+		}
+	}
+
+	/* setup chained handler for the GPIO controller */
+	set_irq_chained_handler(IRQ_GPIOC, nevis_irq_handle_gpio_chain);
+
+	/* Enable IRQ mode */
+	reg = (volatile u32 *)ITC_DEST_REG_BASE(0);
+	*reg = 0xFFFFFFFF;
+	reg = (volatile u32 *)ITC_DEST_REG_BASE(1);
+	*reg = 0xFFFFFFFF;
+	reg = (volatile u32 *)ITC_DEST_REG_BASE(2);
+	*reg = 0xFFFFFFFF;
+	reg = (volatile u32 *)ITC_DEST_REG_BASE(3);
+	*reg = 0xFFFFFFFF;
+}
diff --git a/arch/arm/mach-nevis/mach.c b/arch/arm/mach-nevis/mach.c
new file mode 100644
index 0000000..c3166ce
--- /dev/null
+++ b/arch/arm/mach-nevis/mach.c
@@ -0,0 +1,477 @@
+/***************************************************************************
+ * linux/arch/arm/mach-nevis/mach.c
+ *
+ * Copyright (C) 2011 Coolstream International Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as published 
+ * by the Free Software Foundation.
+ *
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,51 Franklin St, FIfth Floor, Boston, MA  02111-1307  USA
+ *
+ ****************************************************************************/
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+/* #include <linux/memblock.h> */
+#include <linux/bootmem.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <mach/irq.h>
+#include <mach/cx2450x.h>
+#include "devices.h"
+#include "clock.h"
+#include <mach/memmap.h>
+#include <mach/platform.h>
+
+#define FALSE 0
+#define TRUE 1
+
+/* should be inside some config.h */
+#define ATAGLIST_MAX_WORDS		192
+
+/* ToCheck : Should this be in gpi_pecos.h */
+#define DRIVE_GPIO_LOW_BANK_CLEAR(b, x)	*(volatile u32 *)(GPI_DRIVE_LOW_REG +  \
+						((b)*GPI_BANK_SIZE)) &= (~(1<<(x)))
+
+#define DRIVE_GPIO_HIGH_BANK_SET(b, x)	*(volatile u32 *)(GPI_DRIVE_HIGH_REG +  \
+						((b)*GPI_BANK_SIZE)) |= (1<<(x))
+
+#define PERI_PORT_REMAP_REG_VALUE	0xE8000009
+
+/*   **************************************************************  */
+/*   * PIT bit definition values (used in hardware config files)  *  */
+/*   **************************************************************  */
+#define PIT_GEN_CLOCK_SYNC			0x00000001
+#define PIT_GEN_ASTB				0x00000002
+#define PIT_DATA_BURST_WHEN_INDIC		0x00000001
+#define PIT_DATA_MEM_BURST			0x00000002
+#define PIT_DATA_LOCAL_READ_CACHE		0x00000004
+#define PIT_DATA_WRITE_GATHER			0x00000008
+#define PIT_DATA_READ_REORDER			0x00000010
+#define PIT_INSTR_BUFFER			0x00000001
+#define PIT_INSTR_BUFFER_NONCACHE		0x00000002
+#define PIT_INSTR_CONCUR_MEMXFER		0x00000004
+#define PIT_INSTR_AUTO_POSTLOAD			0x00000008
+#define PIT_INSTR_PGTBL_PARLEL_FETCH		0x00000010
+#define PIT_INSTR_PARSER_BUF			0x00002000
+#define PIT_INSTR_ROM_BUF			0x00004000
+#define PIT_INSTR_MEM_BUF			0x00008000
+#define PIT_INSTR_AUTO_BUF_REFETCH		0x00010000
+#define PIT_INSTR_PREFETCH_INDICATOR		0x00020000
+
+#define HSX_PIT_GENERAL_REG_DEFAULT		(PIT_GEN_CLOCK_SYNC)
+#define HSX_PIT_DATA_REG_DEFAULT		(0)
+#define HSX_PIT_INSTR_REG_DEFAULT		(0x00800000 | PIT_INSTR_PREFETCH_INDICATOR | PIT_INSTR_MEM_BUF | PIT_INSTR_CONCUR_MEMXFER | PIT_INSTR_BUFFER)
+#define HSX_PIT_GENERAL_REG_DEFAULT_DEBUG	(PIT_GEN_CLOCK_SYNC)
+#define HSX_PIT_DATA_REG_DEFAULT_DEBUG		(0)
+#define HSX_PIT_INSTR_REG_DEFAULT_DEBUG		(0x00800000)
+
+#define UPPER_PLL_SELECT(x)			(((x) & 0x0F000000UL) >> 24)
+#define UPPER_PLL_DIV(x)			(((x) & 0x00FF0000UL) >> 16)
+#define LOWER_PLL_SELECT(x)			(((x) & 0x0000F000UL) >> 8)
+#define LOWER_PLL_DIV(x)			(((x) & 0x000000FFUL))
+
+#define PLL_POST_DIV(x)				(((x) & 0x00F00000UL) >> 20)
+#define PLL_PRE_DIV(x)				(((x) & 0x000F0000UL) >> 16)
+#define PLL_XTAL_CLK_BYPASS(x)			(((x) & 0x02000000UL))
+#define PLL_FERNUS_DIV_CLK(x)			(((x) & 0x3F000000UL) >> 24)
+#define PLL_FERNUS_DIV_2(x)			(((x) & 0x00000001UL))
+#define xtal_frequency				60000000UL
+
+/*
+ * Removed this from 'setup.c' to get a cleaner patch. There is no need to put this
+ * inside a generic file.
+ * Conexant MAC address from TAG List
+ */
+u8 mac_address[6];
+EXPORT_SYMBOL(mac_address);
+
+unsigned long ChipID;
+EXPORT_SYMBOL(ChipID);
+
+unsigned long ChipRevID;
+EXPORT_SYMBOL(ChipRevID);
+
+u32 uKernelAtaglist[ATAGLIST_MAX_WORDS];
+EXPORT_SYMBOL(uKernelAtaglist);
+
+unsigned int decarm_shared_start = 0;
+unsigned int decarm_shared_size = 0;
+unsigned int decarm_code_start = 0;
+unsigned int decarm_code_size = 0;
+unsigned int arm11_pll; /* For use in mipidle routine */
+
+EXPORT_SYMBOL(decarm_shared_start);
+EXPORT_SYMBOL(decarm_shared_size);
+EXPORT_SYMBOL(decarm_code_start);
+EXPORT_SYMBOL(decarm_code_size);
+
+#if 0 /* keep, we can use this for MMU debugging  */
+static int cx2450x_abort(unsigned long addr, unsigned int fsr, struct pt_regs *regs)
+{
+	printk("Data abort: address = 0x%08lx "
+		    "fsr = 0x%03x PC = 0x%08lx LR = 0x%08lx",
+		addr, fsr, regs->ARM_pc, regs->ARM_lr);
+
+	/*  If it was an imprecise abort, then we need to correct the
+	 *  return address to be _after_ the instruction.
+	 */
+	if (fsr & (1 << 10))
+		regs->ARM_pc += 4;
+
+	return 0;
+}
+#endif
+
+/*
+ * 0x242714F1 / NEVIS: Reading MAC address from ATAG list 
+ * WARNING: Linux will NEVER accept this patch as is. We better get the MAC address
+ * from the NIC directly. For now it works ;)
+ */
+static int __init parse_tag_mac_address(const struct tag *tag)
+{
+	int ic;
+
+	for (ic = 0; ic < 6; ic++)
+		mac_address[ic] = (u8) (tag->u.mac.mac_addr[ic]);
+
+	return 0;
+}
+__tagtable(ATAG_MAC, parse_tag_mac_address);
+
+/*
+ * Setup Mapping for Register Space and Flash needed by BSP
+ */
+static struct map_desc cnxt_io_desc[] = {
+	{
+		.virtual = ASX_VADDR_BASE,
+		.pfn = __phys_to_pfn(ASX_PHYS_BASE),
+		.length = ASX_IO_SIZE,
+		.type = MT_DEVICE,
+	}, {
+		.virtual = EXT_IO_VADDR_BASE,
+		.pfn = __phys_to_pfn(EXT_IO_PHYS_BASE),
+		.length = EXT_IO_SIZE,
+		.type = MT_DEVICE,
+	}, {
+		.virtual = TEMPEST_VADDR_BASE,
+		.pfn = __phys_to_pfn(TEMPEST_PHYS_BASE),
+		.length = TEMPEST_IO_SIZE,
+		.type = MT_DEVICE,
+#ifdef CONFIG_PCI
+	}, {
+		.virtual = PCI_MEM_VADDR_BASE,
+		.pfn = __phys_to_pfn(PCI_MEM_PHYS_BASE),
+		.length = PCI_MEM_SIZE,
+		.type = MT_DEVICE,
+#endif
+	}, {
+		.virtual = APP_VADDR_BASE,
+		.pfn = __phys_to_pfn(APP_PHYS_BASE),
+		.length = APP_IO_SIZE,
+		.type = MT_DEVICE,
+	}
+};
+
+#define UPPER_PLL_SELECT(x)	(((x) & 0x0F000000UL) >> 24)
+#define UPPER_PLL_DIV(x)	(((x) & 0x00FF0000UL) >> 16)
+#define LOWER_PLL_SELECT(x)	(((x) & 0x0000F000UL) >> 8)
+#define LOWER_PLL_DIV(x)	(((x) & 0x000000FFUL))
+
+#define PLL_POST_DIV(x)		(((x) & 0x00F00000UL) >> 20)
+#define PLL_PRE_DIV(x)		(((x) & 0x000F0000UL) >> 16)
+#define PLL_XTAL_CLK_BYPASS(x)	(((x) & 0x02000000UL))
+#define PLL_FERNUS_DIV_CLK(x)	(((x) & 0x3F000000UL) >> 24)
+#define PLL_FERNUS_DIV_2(x)	(((x) & 0x00000001UL))
+#define xtal_frequency		60000000UL
+
+static unsigned long long getpll_clk_val(uint32_t pll_select, uint32_t pll_div)
+{
+	struct pll_reg_data_struct {
+		uint32_t intfrac;
+		uint32_t ctrl;
+	};			/* E0440000 -- E0440034 */
+
+	unsigned long long freq;
+	static volatile struct pll_reg_data_struct __iomem *pll_data;
+
+	pll_data = (volatile struct pll_reg_data_struct __iomem *)PLL_BASE;
+
+	if (pll_select > 8) {
+		return 0;
+	} else if (pll_select > 3) {
+		pll_data += pll_select - 1;
+	} else {
+		pll_data += pll_select;
+	}
+	/* Freq = (Fin pre_div) * (lpdiv_int + lpdiv_freq/(1<<25) * (1/post_div) */
+	if (!PLL_XTAL_CLK_BYPASS(pll_data->ctrl)) {
+		printk("Value of Bypass clk not known\n");
+		return 0;
+	}
+
+	if (pll_select == 7) {
+		freq =
+		    (unsigned long long)(xtal_frequency *
+					 PLL_FERNUS_DIV_CLK(pll_data->intfrac));
+		if (PLL_FERNUS_DIV_2(pll_data->intfrac)) {
+			freq = freq / 2;
+		}
+	} else {
+		freq = (unsigned long long)pll_data->intfrac;
+	}
+
+	freq *= (unsigned long long)xtal_frequency;
+	if (pll_select != 7) {
+		freq /= (unsigned long long)PLL_PRE_DIV(pll_data->ctrl);
+		freq /= (unsigned long long)PLL_POST_DIV(pll_data->ctrl);
+	}
+	freq /= (unsigned long long)(1 << 25);
+
+	if (freq > 0x00000000FFFFFFFFLL) {
+		return 0;
+	}
+
+	return (freq / pll_div);
+}
+
+/* Get arm11 pll value */
+static void cx2450x_getpll_values(void)
+{
+	static volatile uint32_t __iomem div_mux_ctl1;
+
+	div_mux_ctl1	= *((volatile uint32_t __iomem *)PLL_DIV_MUX_CTRL1_REG);
+	arm11_pll	= (unsigned int)getpll_clk_val(UPPER_PLL_SELECT(div_mux_ctl1), UPPER_PLL_DIV(div_mux_ctl1));
+}
+
+static void __init cx2450x_map_io(void)
+{
+	iotable_init(cnxt_io_desc, ARRAY_SIZE(cnxt_io_desc));
+}
+
+/* This function is used to get the chipid and chipRevId */
+
+static void __init cnxt_get_chip_rev_id(struct machine_desc *pmach, struct tag *ptag, char **pptr, struct meminfo *pmem)
+{
+	volatile u32 *pPCICfgAddr;
+	volatile u32 *pPCICfgData;
+	volatile u32 *pFuse = (volatile u32 *) 0xe0440148;
+
+	iotable_init(cnxt_io_desc, 1);
+	//iotable_init(cnxt_io_desc + 3, 1);
+
+
+	/* Take care of some special cases first. Pecos and Nevis need fixing   */
+	/* up for A0 and B0, Nevis needs fixup for C0.                          */
+	/* PCI Chip ID | PCI Chip Rev | PBIN Fuse | Build Target | "Real" Chip  */
+	/* ===================================================================  */
+	/*      X      |       0      |     X     |     Pecos    |   Pecos A0   */
+	/*      X      |       0      |     X     |     Nevis    |   Nevis A0   */
+	/*   <Pecos>   |      0x10    |     0     |       X      |   Pecos B0   */
+	/*   <Pecos>   |      0x10    |     1     |       X      |   Nevis B0   */
+	/*   <Nevis>   |      0x10    |     X     |       X      |   Nevis C0   */
+
+	pPCICfgAddr = (volatile u32 *) PCI_CFG_ADDR_REG;
+	pPCICfgData = (volatile u32 *) PCI_CFG_DATA_REG;
+
+	/* Read vendor/device ID */
+	*pPCICfgAddr = 0x0;
+	ChipID = *pPCICfgData;
+
+	/* Read Rev Id */
+	*pPCICfgAddr = 0x8;
+	ChipRevID = *pPCICfgData & 0xFF;
+
+	/* paraphrased from cnxt_base/drivers/startup/api.s */
+	if (ChipRevID < 0x10) {
+		/* TODO:  When mach-nevis and mach-pecos get merged, we'll need to 
+		   use a KCONFIG switch to decide which chip we are. For Rev A chips
+		   we're always going to read "Pecos", but obviously we want to report
+		   nevis when we're running on a nevis.  For now, I KNOW I'm a nevis 
+		   because I am the file mach-nevis/mach.c */
+		ChipID = 0x245014F1;
+	} else if (ChipRevID == 0x10) {
+		if (ChipID == 0x242714F1) {
+			/* We could be a Pecos OR a nevis.  Look at the fuses to tell */
+			if (*pFuse == 0x0) {
+				/* fuses have not been set, follow the same logic for RevID < 0x10 */
+				ChipID = 0x245014F1;
+			} else {
+				/* Fuses are set so we can differentiate between Pecos and Nevis. */
+				if (*pFuse & 0x01000000) {
+					ChipID = 0x242714F1;
+				} else {
+					ChipID = 0x245014F1;
+				}
+			}
+		} else if (ChipID == 0x245014F1) {
+			/* If we read a nevis and we thought we were a B0, we're really a C0 */
+			ChipRevID = 0x20;
+		}
+	} else {		/* our chiprev > 0x10 */
+
+		/* do nothing, our ChipID is already correct. What needs to be done
+		   with the rev is undefined at the time of this writing. */
+	}
+#ifdef DEBUG
+	printk("cx2450x: ChipID=0x%lx ChipRevID=0x%lx\n", ChipID, ChipRevID);
+#endif
+}
+
+
+/* fixup function */
+static void __init cx2450x_fixup(struct machine_desc *pmach, struct tag *ptag, char **pptr, struct meminfo *pmem)
+{
+	/* copy the ataglist to the global variable uKernelAtaglist */
+	memcpy(uKernelAtaglist, ptag, ATAGLIST_MAX_WORDS * 4);
+
+	cnxt_get_chip_rev_id(pmach, ptag, pptr, pmem);
+}
+
+unsigned int GetChipRev(void)
+{
+	return ChipRevID;
+}
+EXPORT_SYMBOL(GetChipRev);
+
+unsigned int GetChipID(void)
+{
+	return ChipID;
+}
+EXPORT_SYMBOL(GetChipID);
+
+struct cx2450x_pll_config {
+	volatile u32 *preg;
+	unsigned long val;
+};
+
+#define PLLCONF(__reg, __val)				\
+	{						\
+		.preg	= (volatile u32 *)(__reg),	\
+		.val	= (__val)			\
+	}
+
+#define PLLCONF_GPIO(__name, __idx)			\
+	PLLCONF(SREG_##__name##_MUX_REG_BASE(__idx),CONFIG_PLL_##__name##_GPIO_MUX##__idx##_REG_DEFAULT)
+
+static const struct cx2450x_pll_config cx2450x_conf_pll[] __initdata = {
+	/* Initialize the GPIO pin mux and alt func registers */
+#ifdef CONFIG_PLL_CONFIG0_REG_DEFAULT
+	PLLCONF(PLL_CONFIG0_REG, CONFIG_PLL_CONFIG0_REG_DEFAULT),
+#endif
+	/* Initialize the primary pin MUX registers */
+	PLLCONF_GPIO(PRI, 0),
+	PLLCONF_GPIO(PRI, 1),
+	PLLCONF_GPIO(PRI, 2),
+	PLLCONF_GPIO(PRI, 3),
+	PLLCONF_GPIO(PRI, 4),
+	PLLCONF_GPIO(PRI, 5),
+	PLLCONF_GPIO(PRI, 6),
+	/*Initialize the secondary pin MUX registers */
+	PLLCONF_GPIO(SEC, 0),
+	PLLCONF_GPIO(SEC, 1),
+	PLLCONF_GPIO(SEC, 2),
+	PLLCONF_GPIO(SEC, 3),
+	PLLCONF_GPIO(SEC, 4),
+	PLLCONF_GPIO(SEC, 5),
+	PLLCONF_GPIO(SEC, 6),
+	PLLCONF(SREG_ALT_PIN_FUNC_REG, CONFIG_PLL_ALT_FUNC_REG_DEFAULT)
+};
+
+static void cx2450x_register_devices(void)
+{
+#ifdef CONFIG_CX2450X_USB0
+	/* register USB controller #0 as platform device, if enabled */
+	if (platform_device_register(&cx2450x_device_usb0))
+		printk(KERN_ERR "cx2450x: failed to add device %s\n", cx2450x_device_usb0.name);
+#endif
+
+#ifdef CONFIG_CX2450X_USB1
+	/* register USB controller #1 as platform device, if enabled */
+	if (platform_device_register(&cx2450x_device_usb1))
+		printk(KERN_ERR "cx2450x: failed to add device %s\n", cx2450x_device_usb1.name);
+#endif
+
+#ifdef CONFIG_ARCVMAC
+	if (platform_device_register(&cx2450x_device_vmac))
+		printk(KERN_ERR "cx2450x: failed to add device %s\n", cx2450x_device_vmac.name);
+#endif
+}
+
+static void cx2450x_setup_hsx(void)
+{
+	/*
+	 * Re-Load the PIT values, to allow customers with "locked" boot loaders to
+	 * alter the PIT settings
+	 */
+#ifdef DEBUG
+	__raw_writel(HSX_PIT_GENERAL_REG_DEFAULT_DEBUG, (void __iomem *)HSX_PIT_GENERAL_REG);
+	__raw_writel(HSX_PIT_DATA_REG_DEFAULT_DEBUG, (void __iomem *)HSX_PIT_DATA_REG);
+	__raw_writel(HSX_PIT_INSTR_REG_DEFAULT_DEBUG, (void __iomem *)HSX_PIT_INSTR_REG);
+#else
+	__raw_writel(HSX_PIT_GENERAL_REG_DEFAULT, (void __iomem *)HSX_PIT_GENERAL_REG);
+	__raw_writel(HSX_PIT_DATA_REG_DEFAULT, (void __iomem *)HSX_PIT_DATA_REG);
+	__raw_writel(HSX_PIT_INSTR_REG_DEFAULT, (void __iomem *)HSX_PIT_INSTR_REG);
+#endif
+}
+
+static void cx2450x_setup_pio_mux(void)
+{
+	int i;
+
+	for(i = 0; i < ARRAY_SIZE(cx2450x_conf_pll); i++)
+		__raw_writel(cx2450x_conf_pll[i].val, (void __iomem *)cx2450x_conf_pll[i].preg);
+}
+
+static void __init cx2450x_init(void)
+{
+#if 0 /* keep, we can use this for MMU debugging */
+	hook_fault_code(16 +6, cx2450x_abort, SIGBUS, 0, "imprecise external abort");
+#endif
+	cx2450x_setup_pio_mux();
+
+	/* Setup the HSX PIT registers */
+	cx2450x_clk_init();
+	cx2450x_setup_hsx();
+	cx2450x_register_devices();
+	cx2450x_getpll_values();
+}
+
+static void __init cx2450x_reserve(void)
+{
+	/* Reserve memory for decarm F/W start code */
+	/* reserve_bootmem(0x10000, 0x10000, BOOTMEM_EXCLUSIVE); */
+}
+
+extern struct sys_timer cx2450x_sys_timer;	/* in arch/arm/mach-nevis/time.c */
+
+/*
+ * boot_pararms will be placed (by the loader) at the megabyte boundary
+ * just below where the kernel is loaded.  Since the kernel is loaded 
+ * at a 0x18000 boundary (in conexant's case, 0x48000), we're always
+ * guaranteed to have a PTE so the kernel can find the ATAG list here. 
+ * The ATAG list is only temporary and will eventually get over-written
+ * so we copy it in our machine fixup call.
+ */
+MACHINE_START(NEVIS, "CoolStream HDx IRD")
+	.boot_params	=  0x00000100,
+	.map_io		=  cx2450x_map_io,
+	.init_machine	=  cx2450x_init,
+	.init_irq	=  cx2450x_init_irq,
+	.timer		= &cx2450x_sys_timer,
+	.fixup		=  cx2450x_fixup,
+	//.reserve	=  cx2450x_reserve
+MACHINE_END
diff --git a/arch/arm/mach-nevis/mipidle.c b/arch/arm/mach-nevis/mipidle.c
new file mode 100644
index 0000000..306e8f5
--- /dev/null
+++ b/arch/arm/mach-nevis/mipidle.c
@@ -0,0 +1,127 @@
+/****************************************************************************
+ *
+ *  arch/arm/mach-pecos/mipidle.c
+ *
+ *  Copyright (C) 2007 Conexant Systems Inc, USA.
+ *  Copyright (C) 2008 Coolstream International Limited
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License Version 2 as published by
+ *  the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., Franklin St, Fifth Floor, Boston, MA  02111-1307  USA
+ *
+ ****************************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/proc_fs.h>
+#include <linux/sched.h>
+#include <linux/seq_file.h>
+#include <linux/seqlock.h>
+
+#include <asm/param.h>		/* for HZ */
+#include <mach/cx2450x.h>
+
+/**********
+* Globals *
+**********/
+extern unsigned int arm11_pll;
+unsigned long gIdleCount = 0;
+
+#define TICKS_PER_MIN  ((HZ) * 60)	/* ooops, hello Conexant ! That is only true, as long as HZ is defined as 100 !!! */
+
+static unsigned long idleSample[TICKS_PER_MIN];
+static int index;
+
+void cpu_v6_do_idle(void);
+void idleAddCount(void);
+void cnxt_mip_idle(void) __attribute__ ((pure));
+
+void idleAddCount()
+{
+	idleSample[index++] = gIdleCount;
+	if (index == TICKS_PER_MIN)
+		index = 0;
+	gIdleCount = 0;
+}
+
+int get_idle_list(struct seq_file *m, void *v)
+{
+	unsigned int i;
+	unsigned int j;		/* Cycles per second */
+	unsigned int k;		/* seconds per minute */
+	unsigned int sum;
+	unsigned int sum2 = 0;
+	unsigned int avg_mips = 0;
+	unsigned int min_mips = 450000000;
+	unsigned int max_mips = 0;
+
+
+	if (arm11_pll != 0) {
+		min_mips = arm11_pll;
+	} else {
+		min_mips = 595000000;
+	}
+
+	seq_printf(m, "Idle MIPS for last minute:\n\n");
+
+	if ((index + 1) == TICKS_PER_MIN)
+		i = 0;
+	else
+		i = index;
+
+	k = 60;
+	while (k--) {
+		sum = 0;
+		j = HZ;
+		while (j--) {
+			sum += idleSample[i++];
+			if (i == TICKS_PER_MIN)
+				i = 0;
+		}
+		seq_printf(m, "%2d: %10d\n", k, sum);
+		sum2 += (sum / 10000);
+		if (sum < min_mips)
+			min_mips = sum;
+		if (sum > max_mips)
+			max_mips = sum;
+	}
+	avg_mips = (sum2 / 60);
+
+	seq_printf(m, "Avg Idle MIPS = %5d  x 10^4\n", avg_mips);
+	seq_printf(m, "Min Idle MIPS = %10d\n", min_mips);
+	seq_printf(m, "Max Idle MIPS = %10d\n", max_mips);
+	seq_printf(m, "\n");
+
+	return 0;
+}
+
+void cnxt_mip_idle()
+{
+	/* The timer is started together with the system timer in time.c. It's 
+	 * setup with a base of 54, so the timer counts up by one every 1 us
+	 */
+	u32 timein, timeout;
+	volatile u32 *ptimVal = (volatile u32 *)TIMER_VALUE_REG_BASE(7);
+	unsigned int pll_mul;
+
+	if (arm11_pll != 0) {
+		pll_mul = arm11_pll / 1000000;
+	} else {
+		pll_mul = 595;
+	}
+
+	timein = *ptimVal;
+	cpu_v6_do_idle();
+	timeout = *ptimVal;
+
+	/* Nevis C is running at 594 MHz */
+	gIdleCount += ((timeout - timein) * pll_mul) / 54;
+}
diff --git a/arch/arm/mach-nevis/pci.c b/arch/arm/mach-nevis/pci.c
new file mode 100644
index 0000000..ce1c85b
--- /dev/null
+++ b/arch/arm/mach-nevis/pci.c
@@ -0,0 +1,310 @@
+/****************************************************************************
+ *
+ *  arch/arm/mach-nevis/pci.c
+ *
+ *  Copyright (C) 2007 Conexant Systems Inc, USA.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License Version 2as published by
+ *  the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02111-1307  USA
+ *
+ ****************************************************************************/
+/*$Id: pci.c,v 1.3, 2007-05-22 13:32:05Z, Nitin Garg$
+ ****************************************************************************/
+
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+
+#include <asm/hardware.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/mach/pci.h>
+#include <mach/dma.h>
+#include <mach/platform.h>
+#include <mach/intid.h>
+
+#include <asm/mach-types.h>
+
+#ifdef CONFIG_PCI
+
+#define WORD_SIZE               4	/* bytes */
+
+#undef  DEBUG
+
+static u8 pecos_swizzle(struct pci_dev *dev, u8 * pin);
+static int pecos_setup(int nr, struct pci_sys_data *sys);
+static int pecos_read_config(struct pci_bus *bus, unsigned int devfn, int where, int size, u32 * val);
+static int pecos_write_config(struct pci_bus *bus, unsigned int devfn, int where, int size, u32 val);
+static void pci_arch_init(void);
+/*static void pci_arch_reset ( void );*/
+
+/***********************************************************************
+ *  dev->devfn:
+ *	     7:3 = slot
+ *	     2:0 = function
+ ***********************************************************************/
+static int pecos_read_config(struct pci_bus *bus, unsigned int devfn, int where, int size, u32 * val)
+{
+	switch (size) {
+	case 1:
+		{
+			__raw_writel((where & 0xFC) | (devfn << PCI_CFG_ADDR_FUNCTION_SHIFT), ASX_TO_VIRT(PCI_CFG_ADDR_REG));
+			*val = __raw_readb(ASX_TO_VIRT(PCI_CFG_DATA_REG | (where & 3)));
+
+#ifdef DEBUG
+			printk(KERN_INFO "CNXT: read_config_8 : addr:0x%08x idsel:0x%02x func:0x%02x data:0x%02x\n", where, PCI_SLOT(devfn), PCI_FUNC(devfn), *val);
+#endif
+		}
+		break;
+
+	case 2:
+		{
+			__raw_writel((where & 0xFC) | (devfn << 8), ASX_TO_VIRT(PCI_CFG_ADDR_REG));
+			*val = __raw_readw(ASX_TO_VIRT(PCI_CFG_DATA_REG | (where & 3)));
+#ifdef DEBUG
+			printk(KERN_INFO "  CNXT: read_config_16 : addr:0x%08x idsel:0x%02x func:0x%02x data:0x%04x\n", where, PCI_SLOT(devfn), PCI_FUNC(devfn), *val);
+#endif
+		}
+		break;
+
+	default:
+		{
+			__raw_writel(where | (devfn << PCI_CFG_ADDR_FUNCTION_SHIFT), ASX_TO_VIRT(PCI_CFG_ADDR_REG));
+			*val = __raw_readl(ASX_TO_VIRT(PCI_CFG_DATA_REG));
+#ifdef DEBUG
+			printk(KERN_INFO "  CNXT: read_config_32 : addr:0x%08x idsel:0x%02x func:0x%02x data:0x%08x\n", where, PCI_SLOT(devfn), PCI_FUNC(devfn), *val);
+#endif
+		}
+		break;
+	}
+	return PCIBIOS_SUCCESSFUL;
+}
+
+
+static int pecos_write_config(struct pci_bus *bus, unsigned int devfn, int where, int size, u32 val)
+{
+	switch (size) {
+	case 1:
+		{
+#ifdef DEBUG
+			printk(KERN_INFO "CNXT: write_config_8 : addr:%08x idsel:%02x func:%02x data:%02x\n", where, PCI_SLOT(devfn), PCI_FUNC(devfn), val);
+#endif
+			__raw_writel((where & 0xFC) | (devfn << PCI_CFG_ADDR_FUNCTION_SHIFT), ASX_TO_VIRT(PCI_CFG_ADDR_REG));
+			__raw_writeb(val, ASX_TO_VIRT(PCI_CFG_DATA_REG | (where & 3)));
+		}
+		break;
+
+	case 2:
+		{
+#ifdef DEBUG
+			printk(KERN_INFO "CNXT: write_config_16 : addr:%08x idsel:%02x func:%02x data:%04x\n", where, PCI_SLOT(devfn), PCI_FUNC(devfn), val);
+#endif
+			__raw_writel((where & 0xFC) | (devfn << PCI_CFG_ADDR_FUNCTION_SHIFT), ASX_TO_VIRT(PCI_CFG_ADDR_REG));
+			__raw_writew(val, ASX_TO_VIRT(PCI_CFG_DATA_REG | (where & 3)));
+		}
+		break;
+
+	default:
+		{
+#ifdef DEBUG
+			printk(KERN_INFO "CNXT: write_config_32 : addr:%08x idsel:%02x func:%02x data:%08x\n", where, PCI_SLOT(devfn), PCI_FUNC(devfn), val);
+#endif
+			__raw_writel(where | (devfn << PCI_CFG_ADDR_FUNCTION_SHIFT), ASX_TO_VIRT(PCI_CFG_ADDR_REG));
+			__raw_writel(val, ASX_TO_VIRT(PCI_CFG_DATA_REG));
+		}
+		break;
+	}
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static struct pci_ops edwards_ops = {
+	.read = pecos_read_config,
+	.write = pecos_write_config
+};
+
+static int __init pecos_setup(int nr, struct pci_sys_data *sys)
+{
+	struct resource *res;
+
+#ifdef DEBUG
+	printk(KERN_INFO "CNXT: pecos_setup called\n");
+#endif
+
+	if (nr != 0)
+		return 0;
+
+	res = kmalloc(sizeof(struct resource) * 2, GFP_KERNEL);
+	if (!res)
+		panic("PCI: unable to alloc resources");
+
+	memset(res, 0, sizeof(struct resource) * 2);
+
+	res[0].name	= "CX2427X PCI I/O Bridge",
+	res[0].start	= EXT_IO_PHYS_BASE,
+	res[0].end	= EXT_IO_PHYS_BASE + PCI_IO_SIZE + -1,
+	res[0].flags	= IORESOURCE_IO,
+	res[1].name	= "CX2427X PCI MEM Bridge",
+	res[1].start	= PCI_MEM_PHYS_BASE, res[1].end =
+	    PCI_MEM_PHYS_BASE + PCI_MEM_SIZE - 1, res[1].flags = IORESOURCE_MEM, request_resource(&ioport_resource, &res[0]);
+
+	request_resource(&iomem_resource, &res[1]);
+
+	sys->resource[0] = &res[0];
+	sys->resource[1] = &res[1];
+	sys->resource[2] = NULL;
+
+	return 1;
+}
+
+struct pci_bus *__init pecos_scan_bus(int nr, struct pci_sys_data *sys)
+{
+#ifdef DEBUG
+	printk(KERN_INFO "CNXT: pecos_scan_bus called\n");
+#endif
+
+	return pci_scan_bus(sys->busnr, &edwards_ops, sys);
+}
+
+/***********************************************************************/
+
+static void __init pci_arch_init(void)
+{				/* struct pci_sys_data sysdata  */
+	volatile unsigned int v32;
+
+#ifdef DEBUG
+	printk(KERN_INFO "CNXT: pci_arch_init:\n");
+#endif
+
+	/* Initialize Pecos PCI controller  */
+
+	/* Remap register: 31:29 Memory remapping bits, 15:4 IO remap bits  */
+	/*  This gives us a straight-thru mapping i.e. CPU addr == PCI addr */
+	__raw_writel(0x8000E100, ASX_TO_VIRT(PCI_REMAP_REG));
+
+	/* On newer chips (Wabash and beyond), need to set the PCI sync bits */
+	v32 = __raw_readl(ASX_TO_VIRT(PCI_ROM_MODE_REG));
+	__raw_writel((1UL << PCI_ROM_REQ0_SYNC_SHIFT)
+		     | (1UL << PCI_ROM_REQ1_SYNC_SHIFT)
+		     | (1UL << PCI_ROM_REQ2_SYNC_SHIFT), ASX_TO_VIRT(PCI_ROM_MODE_REG));
+
+	/* Set alt func register so PCI_REQGNT1 is on PIO006-7 instead of normal PCI_REQ pins */
+	v32 = __raw_readl(ASX_TO_VIRT(PLL_PIN_ALT_FUNC_REG));
+	__raw_writel((v32 & ~(PLL_PIN_ALT_FUNC_PCI_REQGNT2_MASK | PLL_PIN_ALT_FUNC_PCI_REQGNT1_MASK | PLL_PIN_ALT_FUNC_IO_RW_MASK))
+		     | PLL_PIN_ALT_FUNC_PCI_REQGNT2_PIO_64_63_5 | PLL_PIN_ALT_FUNC_PCI_REQGNT1_PIO_7_6 | PLL_PIN_ALT_FUNC_IO_RW_NORMAL, ASX_TO_VIRT(PLL_PIN_ALT_FUNC_REG));
+
+	/* Take PCI out of reset */
+	__raw_writel(PCI_RESET_DEASSERTED, ASX_TO_VIRT(PCI_RESET_REG));
+
+	/* Enable the bridge mode to forward interrupts */
+	__raw_writel(PCI_INTR_INTA_ENABLE_MASK, ASX_TO_VIRT(PCI_INTR_ENABLE_REG));
+
+	/* set Memory Space / Bus Master bits */
+	__raw_writel(PCI_CMD_STAT_OFF << 2, ASX_TO_VIRT(PCI_CFG_ADDR_REG));
+
+	v32 = __raw_readl(ASX_TO_VIRT(PCI_CFG_DATA_REG));
+	__raw_writel(v32 | PCI_CMD_MASTER_ENABLE_MASK | PCI_CMD_MEM_ACCESS_ENABLE_MASK, ASX_TO_VIRT(PCI_CFG_DATA_REG));
+
+#ifdef DEBUG
+	v32 = __raw_readl(ASX_TO_VIRT(PCI_CFG_DATA_REG));
+	printk(KERN_INFO "  CNXT: wrote 0x%x to bridge cmd_status\n", v32);
+#endif
+
+   /************************************************************************/
+   /******** NOTE: further treatment of Pecos Bridge in bios32.c **********/
+   /************************************************************************/
+	/*
+	 * Clear any error conditions
+	 */
+	__raw_writel(PCI_CMD_STAT_OFF << 2, ASX_TO_VIRT(PCI_CFG_ADDR_REG));
+	v32 = __raw_readl(ASX_TO_VIRT(PCI_CFG_DATA_REG));
+	__raw_writel(v32 | 0xF8000000, ASX_TO_VIRT(PCI_CFG_DATA_REG));
+
+	__raw_writel(PCI_CLS_LT_HT_BIST_OFF << 2, ASX_TO_VIRT(PCI_CFG_ADDR_REG));
+	__raw_writel(0x4000, ASX_TO_VIRT(PCI_CFG_DATA_REG));
+
+	__raw_writel(PCI_BASE_ENABLE_SIZE << 2, ASX_TO_VIRT(PCI_CFG_ADDR_REG));
+	__raw_writel(0x00000095, ASX_TO_VIRT(PCI_CFG_DATA_REG));
+
+#ifdef DEBUG
+	v32 = __raw_readl(ASX_TO_VIRT(PCI_CFG_DATA_REG));
+	printk(KERN_INFO "  CNXT: cmd_status - 0x%x\n", v32);
+	__raw_writel(PCI_BASE_ENABLE_SIZE << 2, ASX_TO_VIRT(PCI_CFG_ADDR_REG));
+	v32 = __raw_readl(ASX_TO_VIRT(PCI_CFG_DATA_REG));
+	printk(KERN_INFO "  CNXT: base0 remap / size - 0x%x\n", v32);
+	__raw_writel(PCI_BASE_REMAP << 2, ASX_TO_VIRT(PCI_CFG_ADDR_REG));
+	v32 = __raw_readl(ASX_TO_VIRT(PCI_CFG_DATA_REG));
+	printk(KERN_INFO "  CNXT: base1 remap / size - 0x%x\n", v32);
+#endif
+
+}
+
+static u8 pecos_swizzle(struct pci_dev *dev, u8 * pin)
+{
+#ifdef DEBUG
+	printk(KERN_INFO "CNXT: pecos_swizzle called\n");
+#endif
+
+	return 0;
+}
+
+static int __init pci_arch_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+#ifdef DEBUG
+	printk(KERN_INFO "CNXT: pci_arch_map_irq called\n");
+#endif
+
+	return INT_PCI;
+}
+
+struct hw_pci pecos_pci __initdata = {
+	.nr_controllers = 1,
+	.setup = pecos_setup,
+	.scan = pecos_scan_bus,
+	.preinit = pci_arch_init,
+	.swizzle = pecos_swizzle,
+	.map_irq = pci_arch_map_irq
+};
+
+/*
+static void pci_arch_reset ( void )
+{
+#ifdef DEBUG
+    printk( KERN_INFO "CNXT: pci_arch_reset called\n" );
+#endif
+
+    __raw_writel(PCI_RESET_ASSERTED , ASX_TO_VIRT( PCI_RESET_REG ));
+    __raw_writel(PCI_RESET_DEASSERTED , ASX_TO_VIRT( PCI_RESET_REG ));
+
+    return;
+}
+*/
+
+int __init pecos_pci_init(void)
+{
+#ifdef DEBUG
+	printk(KERN_INFO "CNXT: pecos_pci_init called\n");
+#endif
+	pci_common_init(&pecos_pci);
+	return 0;
+}
+
+subsys_initcall(pecos_pci_init);
+#endif
diff --git a/arch/arm/mach-nevis/pllc.c b/arch/arm/mach-nevis/pllc.c
new file mode 100644
index 0000000..5c830c5
--- /dev/null
+++ b/arch/arm/mach-nevis/pllc.c
@@ -0,0 +1,377 @@
+/*
+ *
+ *  arch/arm/mach-nevis/pll.c
+ *
+ *  Copyright (C) 2008 Coolstream International Limited
+ *  Copyright (C) 2007 Conexant Systems Inc, USA.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License Version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02111-1307  USA
+ *
+ */
+#include <linux/clocksource.h>
+#include <mach/hardware.h>
+/*#include <mach/startup.h>*/
+#include <mach/nevis.h>
+
+/* FIXME: TODO:  Need to use  a global definition of CNXT_GET */
+
+#define RMO(y)                   ( ((y) & 0x00000001) ?  0 : \
+                                   ( ((y) & 0x00000002) ?  1 : \
+                                     ( ((y) & 0x00000004) ?  2 : \
+                                       ( ((y) & 0x00000008) ?  3 : \
+                                         ( ((y) & 0x00000010) ?  4 : \
+                                           ( ((y) & 0x00000020) ?  5 : \
+                                             ( ((y) & 0x00000040) ?  6 : \
+                                               ( ((y) & 0x00000080) ?  7 : \
+                                                 ( ((y) & 0x00000100) ?  8 : \
+                                                   ( ((y) & 0x00000200) ?  9 : \
+                                                     ( ((y) & 0x00000400) ? 10 : \
+                                                       ( ((y) & 0x00000800) ? 11 : \
+                                                         ( ((y) & 0x00001000) ? 12 : \
+                                                           ( ((y) & 0x00002000) ? 13 : \
+                                                             ( ((y) & 0x00004000) ? 14 : \
+                                                               ( ((y) & 0x00008000) ? 15 : \
+                                                                 ( ((y) & 0x00010000) ? 16 : \
+                                                                   ( ((y) & 0x00020000) ? 17 : \
+                                                                     ( ((y) & 0x00040000) ? 18 : \
+                                                                       ( ((y) & 0x00080000) ? 19 : \
+                                                                         ( ((y) & 0x00100000) ? 20 : \
+                                                                           ( ((y) & 0x00200000) ? 21 : \
+                                                                             ( ((y) & 0x00400000) ? 22 : \
+                                                                               ( ((y) & 0x00800000) ? 23 : \
+                                                                                 ( ((y) & 0x01000000) ? 24 : \
+                                                                                   ( ((y) & 0x02000000) ? 25 : \
+                                                                                     ( ((y) & 0x04000000) ? 26 : \
+                                                                                       ( ((y) & 0x08000000) ? 27 : \
+                                                                                         ( ((y) & 0x10000000) ? 28 : \
+                                                                                           ( ((y) & 0x20000000) ? 29 : \
+                                                                                             ( ((y) & 0x40000000) ? 30 : \
+                                                                                               ( ((y) & 0x80000000) ? 31 : 0 ))))))))))))))))))))))))))))))))
+
+#define CNXT_GET(a, b)		(*((volatile unsigned int*)ASX_TO_VIRT(a)) & b)
+#define CNXT_GET_VAL(reg,mask)	((*((volatile unsigned int*)ASX_TO_VIRT(reg)) & (mask)) >> RMO(mask))
+typedef unsigned int u_int32;
+typedef unsigned long long u_int64;
+
+/********************************************************************/
+/*  CalcFreqFromFracPart                                            */
+/*                                                                  */
+/*  DESCRIPTION:                                                    */
+/*      Calculate ( freq * pll_frac ) / ( 2 ^ frac_len )            */
+/*      Note that ( freq * pll_frac ) is much bigger                */
+/*      than unsigned 0xffffffff.  The algorithm used may result    */
+/*      up to 3 less than what should be                            */
+/*                                                                  */
+/*  PARAMETERS:                                                     */
+/*      See description                                             */
+/*                                                                  */
+/*  RETURNS:                                                        */
+/*      result described above                                      */
+/********************************************************************/
+static u_int32 CalcFreqFromFracPart(
+                    u_int32 uFreq,
+                    u_int32 uPLLDivider,
+                    u_int32 uDividerWidth)
+{
+    u_int64 uCalc;
+
+    uCalc = ((u_int64)uFreq * (u_int64)(uPLLDivider & ((1 << uDividerWidth)-1)))/(u_int64)(1 << uDividerWidth);
+
+    return((u_int32)uCalc);
+}
+
+/******************************************************************************/
+/*  CalkClkFreqAndPeriod                                                      */
+/*                                                                            */
+/*  DESCRIPTION:                                                              */
+/*      Calculate clock frequency and period for a specific PLL.              */
+/*                                                                            */
+/*  PARAMETERS:                                                               */
+/*      pll_source - One of:  ARM_PLL_SOURCE, MEM_PLL_SOURCE, MPG0_PLL_SOURCE */
+/*      xtal_freq  - Xtal frequency in Hz                                     */
+/*                                                                            */
+/*  RETURNS:                                                                  */
+/*      frequency  - Returned clock frequency in Hz                           */
+/*      period     - Returned clock period in 100ns increments                */
+/******************************************************************************/
+void CalcClkFreqAndPeriod(u_int32 * frequency,
+			  u_int32 * period,
+			  PLL_SOURCE pll_source, u_int32 xtal_freq)
+{
+	u_int32 pll_int;
+	u_int32 pll_frac;
+	u_int32 pll_div;
+	u_int32 pll_prescale = 0;
+	u_int32 clk_freq;
+	u_int32 remainder;
+	u_int32 frac_shift = 0;
+	u_int32 clk_period;
+	u_int32 pll_sel = 0;
+
+	*frequency = 0;
+	*period = 0;
+
+	/*
+	 * Calculate the clk_freq and clk_period
+	 */
+
+	/* Calculation below depends on the PLL details of the chip.  */
+	/* According to Eric Deal (1/29/04) Trinity uses a XTAL       */
+	/* frequency of 74.25 MHz, but there is a divide by 2         */
+	/* before the clock ever reaches the PLL logic                */
+
+	/* We need to do a XTAL /2 for MEM and FENRUS PLLs only, the other Verve PLLs take the 60 Mhz crystal directly */
+	if (pll_source == MEM_PLL_SOURCE) {
+		//xtal_freq >>= 1;
+	}
+
+	/* In the following calculations, the frac value read from the */
+	/* PLL multiplier must be first converted to a floating       */
+	/* point value, then divided by the number of bits used to    */
+	/* represent the frac value (2^16) represented as a floating  */
+	/* point value. This will cause the fixed-point integer       */
+	/* representation of a fractional value to be converted to a  */
+	/* floating-point fractional value.                           */
+
+	/*
+	 * Read the PLL values from the chip
+	 */
+	switch (pll_source) {
+	case ARM_PLL_SOURCE:
+		/* For Pecos, there is no dedicated ARM PLL, any of the 9 PLLs can source it.
+		 * We need to derive this from the PLL_SEL bits for the ARM clock 
+		 * We are handling only the 7 Verve PLLs here.*/
+
+		pll_sel =
+		    CNXT_GET_VAL(DIV_MUX_CTRL1_REG,
+				 DIV_MUX_CTRL1_ARM926_PLL_SEL_MASK);
+
+		switch (pll_sel) {
+			/* Handle the Verve PLLs in a common fashion */
+			/* All the INTFRAC and CTRL regs for the Verve PLLs start at offset 0 of 
+			 * PLL_BASE with 0x4 increments. We derive the corresponding INTFRAC and
+			 * CTRL reg offsets from the corresponding PLL_SEL value
+			 */
+		case MPG0PLL:
+		case MPG1PLL:
+		case HDPLL:
+		case AUDPLL:
+			pll_int =
+			    CNXT_GET_VAL((PLL_BASE + (2 * pll_sel * 0x4)),
+					 PLL_MPG0_INTFRAC_INT_MASK);
+			pll_frac =
+			    CNXT_GET_VAL((PLL_BASE + (2 * pll_sel * 0x4)),
+					 PLL_MPG0_INTFRAC_FRAC_MASK);
+			pll_div =
+			    CNXT_GET_VAL(DIV_MUX_CTRL1_REG,
+					 DIV_MUX_CTRL1_ARM926_PLL_DIV_MASK);
+			pll_prescale =
+			    CNXT_GET_VAL((PLL_BASE + 4 +
+					  (2 * pll_sel * 0x4)),
+					 PLL_MPG0_CTRL_PRE_DIV_MASK);
+			break;
+		case PLL0:
+		case PLL1:
+		case PLL2:
+			pll_int =
+			    CNXT_GET_VAL((PLL_BASE +
+					  (2 * (pll_sel - 1) * 0x4)),
+					 PLL_MPG0_INTFRAC_INT_MASK);
+			pll_frac =
+			    CNXT_GET_VAL((PLL_BASE +
+					  (2 * (pll_sel - 1) * 0x4)),
+					 PLL_MPG0_INTFRAC_FRAC_MASK);
+			pll_div =
+			    CNXT_GET_VAL(DIV_MUX_CTRL1_REG,
+					 DIV_MUX_CTRL1_ARM926_PLL_DIV_MASK);
+			pll_prescale =
+			    CNXT_GET_VAL((PLL_BASE + 4 +
+					  (2 * (pll_sel - 1) * 0x4)),
+					 PLL_MPG0_CTRL_PRE_DIV_MASK);
+			break;
+		default:
+			return;
+		}
+		break;
+
+	case MEM_PLL_SOURCE:
+		/* For Pecos, use the INT/FRAC masks from the MEM_PLL_CTRL2 register, and the
+		 * MEM_PLL_CTRL1 register for the POSTDIV/PREDIV masks
+		 */
+		pll_int =
+		    CNXT_GET_VAL(MEM_PLL_CTRL2_REG,
+				 PLL_MEM_CTRL2_PLL_N_VALUE_MASK);
+		printk("pll_int %08x\n", pll_int);
+
+		pll_frac =
+		    CNXT_GET_VAL(MEM_PLL_CTRL2_REG,
+				 PLL_MEM_CTRL2_PLL_FRAC_VALUE_MASK);
+		printk("pll_frac %08x\n", pll_frac);
+		pll_div =
+		    CNXT_GET_VAL(MEM_PLL_CTRL1_REG,
+				 PLL_MEM_CTRL1_PLL_POST_DIV_MASK);
+		printk("pll_div %08x\n", pll_div);
+		pll_prescale =
+		    CNXT_GET_VAL(MEM_PLL_CTRL1_REG,
+				 PLL_MEM_CTRL1_PLL_PRE_DIV_MASK);
+		printk("pll_prescale %08x\n", pll_prescale);
+		frac_shift = PLL_MEM_CTRL2_PLL_FRAC_VALUE_SHIFT;
+		break;
+
+	case MPG0_PLL_SOURCE:
+		pll_int =
+		    CNXT_GET_VAL(PLL_MPG0_INTFRAC_REG,
+				 PLL_MPG0_INTFRAC_INT_MASK);
+		pll_frac =
+		    CNXT_GET_VAL(PLL_MPG0_INTFRAC_REG,
+				 PLL_MPG0_INTFRAC_FRAC_MASK);
+		pll_div = 1;	/* We want the basic PLL rate here, not the MPG0 clock rate */
+		pll_prescale =
+		    CNXT_GET_VAL(PLL_MPG0_CTRL_REG,
+				 PLL_MPG0_CTRL_PRE_DIV_MASK);
+		frac_shift = PLL_MPG0_INTFRAC_FRAC_SHIFT;
+		break;
+	case FENRUS_PLL_SOURCE:
+		/* For Pecos, there is no dedicated I/O PLL, any of the 9 PLLs can source it.
+		 * We need to derive this from the PLL_SEL bits for the HSX0 clock
+		 */
+
+		pll_sel =
+		    CNXT_GET_VAL(DIV_MUX_CTRL10_REG,
+				 DIV_MUX_CTRL10_HSX0_PLL_SEL_MASK);
+
+		switch (pll_sel) {
+			/* Handle the Verve PLLs in a common fashion */
+			/* All the INTFRAC and CTRL regs for the Verve PLLs start at offset 0 of 
+			 * PLL_BASE with 0x4 increments. We derive the corresponding INTFRAC and
+			 * CTRL reg offsets from the corresponding PLL_SEL value
+			 *
+			 * INT_MASK = 0x7E000000 
+			 * FRAC_MASK = 0x01FFFFFF 
+			 * PREDIV_MASK = 0x000F0000
+			 */
+		case MPG0PLL:
+		case MPG1PLL:
+		case HDPLL:
+		case AUDPLL:
+			pll_int =
+			    CNXT_GET_VAL((PLL_BASE + (2 * pll_sel * 0x4)),
+					 PLL_MPG0_INTFRAC_INT_MASK);
+			pll_frac =
+			    CNXT_GET_VAL((PLL_BASE + (2 * pll_sel * 0x4)),
+					 PLL_MPG0_INTFRAC_FRAC_MASK);
+			pll_div =
+			    CNXT_GET_VAL(DIV_MUX_CTRL10_REG,
+					 DIV_MUX_CTRL10_HSX0_PLL_DIV_MASK);
+			pll_prescale =
+			    CNXT_GET_VAL((PLL_BASE + 4 +
+					  (2 * pll_sel * 0x4)),
+					 PLL_MPG0_CTRL_PRE_DIV_MASK);
+			break;
+		case PLL0:
+		case PLL1:
+		case PLL2:
+			pll_int =
+			    CNXT_GET_VAL((PLL_BASE +
+					  (2 * (pll_sel - 1) * 0x4)),
+					 PLL_MPG0_INTFRAC_INT_MASK);
+			pll_frac =
+			    CNXT_GET_VAL((PLL_BASE +
+					  (2 * (pll_sel - 1) * 0x4)),
+					 PLL_MPG0_INTFRAC_FRAC_MASK);
+			pll_div =
+			    CNXT_GET_VAL(DIV_MUX_CTRL10_REG,
+					 DIV_MUX_CTRL10_HSX0_PLL_DIV_MASK);
+			pll_prescale =
+			    CNXT_GET_VAL((PLL_BASE + 4 +
+					  (2 * (pll_sel - 1) * 0x4)),
+					 PLL_MPG0_CTRL_PRE_DIV_MASK);
+			break;
+		case FENRUSPLL:
+			pll_int =
+			    CNXT_GET_VAL(PLL_FENRUS_CTRL_REG,
+					 PLL_FENRUS_CTRL_LOOP_DIV_MASK);
+			pll_frac = 0;
+			pll_div =
+			    CNXT_GET_VAL(DIV_MUX_CTRL10_REG,
+					 DIV_MUX_CTRL10_HSX0_PLL_DIV_MASK);
+			xtal_freq = CHIP_CRYSTAL_FREQUENCY;
+			pll_prescale = XTAL_PRESCALE_FACTOR;
+			break;
+		default:
+			return;
+		}
+		break;
+	default:
+		return;
+	}
+
+#ifdef DLOAD
+	/*
+	 * If called from the Download (DLOAD) Utility, run-time select the
+	 * appropriate calculation function.
+	 */
+
+	xtal_freq = CHIP_CRYSTAL_FREQUENCY;
+	pll_prescale = XTAL_PRESCALE_FACTOR;
+#endif /* DLOAD */
+	pll_div = pll_div * pll_prescale;
+
+	/* 
+	 * calculate clk_freq = xtal_freq*(pll_int+pll_frac/2^n)/pll_div
+	 * note that algorithm used here may result up to 4Hz less than what it should be
+	 */
+	clk_freq = xtal_freq / pll_div;
+	remainder = xtal_freq % pll_div;
+
+	/* 
+	 * The no. of fractional bits have not changed across Pecos and Trinity, except
+	 * for the MEM PLL in Pecos which is 20 fractional bits, instead of the usual 25 bits
+	 */
+	if ((pll_source == MEM_PLL_SOURCE) && (PLL_TYPE == PECOS)) {
+		clk_freq =
+		    CalcFreqFromFracPart(clk_freq, pll_frac,
+					 (32 - frac_shift))
+		    + (clk_freq * pll_int) +
+		    ((remainder * pll_int) / pll_div);
+	} else if ((pll_source == FENRUS_PLL_SOURCE) && (PLL_TYPE == PECOS)
+		   && (pll_sel == FENRUSPLL)) {
+		clk_freq = (clk_freq / pll_div) * pll_int;
+	} else {
+		clk_freq =
+		    CalcFreqFromFracPart(clk_freq, pll_frac,
+					 (25 - frac_shift))
+		    + (clk_freq * pll_int) +
+		    ((remainder * pll_int) / pll_div);
+	}
+
+	/*
+	 * Calculate clk_period = (10^11)/clk_freq
+	 * note that the algorithm will be broken if clk_freq is higher
+	 * than 429.5MHz.  it should not happen in the predictable future.
+	 */
+	clk_period = (1000000000 / clk_freq) * 100;
+	remainder = ( 1000000000 % clk_freq) * 10;
+
+	clk_period += (remainder / clk_freq) * 10;
+	remainder = (remainder % clk_freq) * 10;
+
+	clk_period += remainder / clk_freq;
+
+	/*
+	 * Return the values
+	 */
+	*frequency = clk_freq;
+	*period = clk_period;
+}
diff --git a/arch/arm/mach-nevis/pm.c b/arch/arm/mach-nevis/pm.c
new file mode 100644
index 0000000..f4b7c3c
--- /dev/null
+++ b/arch/arm/mach-nevis/pm.c
@@ -0,0 +1,149 @@
+/*
+ * arch/arm/mach-nevis/pm.c
+ * CX2450x Power Management
+ *
+ * Copyright (C) 2009 CoolStream International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/suspend.h>
+#include <linux/sched.h>
+#include <linux/proc_fs.h>
+#include <linux/interrupt.h>
+#include <linux/sysfs.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/atomic.h>
+#include <asm/mach/time.h>
+#include <asm/mach/irq.h>
+#include <asm/mach-types.h>
+
+#include <mach/cx2450x.h>
+#include <mach/gpio.h>
+
+static inline void ddr_selfrefresh_enable(void)
+{
+	volatile u32 *reg = (volatile u32 *)RST_LPCONFIG_REG;
+
+	*reg	|= 2; /* Self Refresh Enable in LP */
+}
+
+static inline void ddr_selfrefresh_disable(void)
+{
+	volatile u32 *reg = (volatile u32 *)RST_LPCONFIG_REG;
+
+	*reg	&= ~2; /* Self Refresh Disable in LP */
+}
+
+static int cx2450x_pm_is_valid_state(suspend_state_t state)
+{
+	switch (state) {
+		case PM_SUSPEND_ON:
+		case PM_SUSPEND_STANDBY:
+			return 1;
+		default:
+			return 0;
+	}
+}
+
+static suspend_state_t target_state;
+
+/*
+ * Called after processes are frozen, but before we shutdown devices.
+ */
+static int cx2450x_pm_begin(suspend_state_t state)
+{
+	volatile u32 *reg	= (volatile u32 *)RST_LPCONFIG_REG;
+	volatile u32 *wakeup	= (volatile u32 *)RST_WAKEUP_CTRL_REG;
+
+	*reg |= 0x1FF0;
+
+	*wakeup |= (1 << 2);
+
+	target_state = state;
+	return 0;
+}
+
+/*
+ *
+ */
+
+static int cx2450x_pm_enter(suspend_state_t state)
+{
+//	at91_gpio_suspend();
+//	at91_irq_suspend();
+
+	printk(KERN_DEBUG "cx2450x: PM - pm state %d\n", state);
+
+	switch (state) {
+		case PM_SUSPEND_STANDBY:
+			/*
+			 * NOTE: the Wait-for-Interrupt instruction needs to be
+			 * in icache so no SDRAM accesses are needed until the
+			 * wakeup IRQ occurs and self-refresh is terminated.
+			 */
+			asm("b 1f; .align 5; 1:");
+			asm("mcr p15, 0, r0, c7, c10, 4");	/* drain write buffer */
+			ddr_selfrefresh_enable();
+			asm("mcr p15, 0, r0, c7, c0, 4");	/* wait for interrupt */
+			ddr_selfrefresh_disable();
+			break;
+
+		case PM_SUSPEND_ON:
+			asm("mcr p15, 0, r0, c7, c0, 4");	/* wait for interrupt */
+			break;
+
+		default:
+			printk(KERN_DEBUG "cx2450x: PM - bogus suspend state %d\n", state);
+			goto error;
+	}
+
+	printk(KERN_DEBUG "cx2450x: PM - wakeup %08x\n", readl(RST_WAKEUP_CTRL_REG) & readl(RST_WAKEUP_STAT_REG));
+
+error:
+	ddr_selfrefresh_disable();
+	target_state = PM_SUSPEND_ON;
+//	at91_irq_resume();
+//	at91_gpio_resume();
+	return 0;
+}
+
+/*
+ * Called right prior to thawing processes.
+ */
+static void cx2450x_pm_end(void)
+{
+	volatile u32 *reg	= (volatile u32 *)RST_LPCONFIG_REG;
+	volatile u32 *wakeup	= (volatile u32 *)RST_WAKEUP_CTRL_REG;
+
+
+	*reg &= ~0x1FF0;
+	*wakeup &= ~(1 << 2);
+
+	target_state = PM_SUSPEND_ON;
+}
+
+static struct platform_suspend_ops cx2450x_pm_ops ={
+	.valid	= cx2450x_pm_is_valid_state,
+	.begin	= cx2450x_pm_begin,
+	.enter	= cx2450x_pm_enter,
+	.end	= cx2450x_pm_end,
+};
+
+static int __init cx2450x_pm_init(void)
+{
+	printk("CX2450x: Power Management\n");
+
+
+	suspend_set_ops(&cx2450x_pm_ops);
+
+	return 0;
+}
+arch_initcall(cx2450x_pm_init);
diff --git a/arch/arm/mach-nevis/time.c b/arch/arm/mach-nevis/time.c
new file mode 100644
index 0000000..89fb296
--- /dev/null
+++ b/arch/arm/mach-nevis/time.c
@@ -0,0 +1,228 @@
+/* linux/arch/arm/mach-cx2450x_sys/time.c
+ *
+ * system (tick) timer functions for systems based
+ * on the Conexant CX2450x (cx2450x) SoC
+ *
+ * Copyright (C) 2008 CoolStream International Limited.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <asm/mach/time.h>
+#include <mach/irq.h>
+#include <mach/cx2450x.h>
+
+#define LOCKCMD_REG	0xE0440120
+#define LOCKSTAT_REG	0xE0440124
+
+#define SYSTEM_TIMER_NUMBER	0
+#define MIPIDLE_TIMER_NUMBER	7
+
+static u32 old_mode = 0x0B;
+static u32 softlock_state;
+
+extern void idleAddCount(void);
+extern struct s_latency latency;	/* Conexants Latency dump */
+
+/*******************************************************************************/
+
+void cx2450x_unlock_timer(u32 timer_number)
+{
+	volatile u32 *reg = (volatile u32 *) LOCKCMD_REG;
+
+	*reg = 0x00;
+	*reg = 0xF8;
+	*reg = 0x2B;
+
+	reg = (volatile u32 *) LOCKSTAT_REG;
+	*reg &= ~(1 << (16 + timer_number));
+
+	reg = (volatile u32 *) LOCKCMD_REG;
+	*reg = 0x00;
+}
+
+/*******************************************************************************/
+
+s32 cx2450x_lock_timer(u32 timer_number)
+{
+	volatile u32 *reg;
+	s32 ret = 0;
+
+	reg = (volatile u32 *) LOCKCMD_REG;
+	*reg = 0x00;
+	*reg = 0xF8;
+	*reg = 0x2B;
+
+	if (softlock_state & (1 << timer_number))	/* timer is locked in software */
+		ret = -1;
+	else {
+		reg = (volatile u32 *) LOCKSTAT_REG;
+		*reg |= (1 << (16 + timer_number));
+	}
+
+	reg = (volatile u32 *) LOCKCMD_REG;
+	*reg = 0x00;
+
+	return ret;
+}
+
+/*******************************************************************************/
+
+s32 cx2450x_softlock_timer(u32 timer_number)
+{
+	volatile u32 *reg;
+	s32 ret = 0;
+
+	reg = (volatile u32 *) LOCKSTAT_REG;
+
+	if (*reg & (1 << (16 + timer_number)))	/* timer is locked in hardware */
+		ret = -1;
+	else
+		softlock_state |= (1 << timer_number);
+
+	return ret;
+}
+
+/*******************************************************************************/
+/* return time since last timer tick in us. Always called with interrupts      */
+/* disabled.                                                                   */
+
+static unsigned long cx2450x_sys_timer_gettimeoffset(void)
+{
+	/* get current counter value */
+	volatile u32 *reg = (volatile u32 *) TIMER_VALUE_REG_BASE(SYSTEM_TIMER_NUMBER);
+
+	return (unsigned long) *reg;
+}
+
+/*******************************************************************************/
+/* IRQ handler for the timer                                                   */
+
+static irqreturn_t cx2450x_sys_timer_interrupt(int irq, void *dev_id)
+{
+	volatile u32 *mod_reg = (volatile u32 *) TIMER_MODE_REG_BASE(SYSTEM_TIMER_NUMBER);
+	volatile u32 *val_reg = (volatile u32 *) TIMER_VALUE_REG_BASE(SYSTEM_TIMER_NUMBER);
+	volatile u32 *limit_reg = (volatile u32 *) TIMER_LIMIT_REG_BASE(SYSTEM_TIMER_NUMBER);
+	const u32 limit = *limit_reg;
+
+	*mod_reg &= ~0x08;	/* Disable IRQs */
+
+#ifdef ENABLE_LATENCY_TIMER
+	latency.delta[latency.count++] = *val_reg;
+	if (latency.count >= LATENCY_COUNT)
+		latency.count = 0;
+#endif
+
+	do {
+		*val_reg -= limit;
+		timer_tick();
+	} while (*val_reg >= limit);
+
+	*mod_reg |= 0x08;	/* Enable IRQs */
+
+	idleAddCount();
+
+	return IRQ_HANDLED;
+}
+
+/*******************************************************************************/
+
+static struct irqaction cx2450x_sys_timer_irq = {
+	.name = "System Timer (10ms)",
+	.flags = IRQF_DISABLED | IRQF_TIMER | IRQF_IRQPOLL,
+	.handler = cx2450x_sys_timer_interrupt
+};
+
+/*******************************************************************************/
+
+static void __init cx2450x_sys_timer_init(void)
+{
+	volatile u32 *reg;
+	u32 cnt;
+
+	softlock_state = 0;
+
+	for (cnt = 0; cnt < 16; cnt++) {
+		cx2450x_unlock_timer(cnt);
+		/* switch interrupt generation off */
+		reg = (volatile u32 *) TIMER_MODE_REG_BASE(cnt);
+		*reg = 0;
+
+		/* set counter value to zero */
+		reg = (volatile u32 *) TIMER_VALUE_REG_BASE(SYSTEM_TIMER_NUMBER);
+		*reg = 0;
+	}
+
+	/* setup the timebase (number of clock cycles after which the timer is
+	   increased by one). Set it to 54 cause the timer to tick every 1 usec.
+	   (fixed clock = 54 MHz, divided by 54 = 1 MHz, 1/1 MHz = 1 us) */
+	reg = (volatile u32 *) TIMER_BASE_REG_BASE(SYSTEM_TIMER_NUMBER);
+	*reg = 54;
+
+	/* Set limit to 10ms */
+	reg = (volatile u32 *) TIMER_LIMIT_REG_BASE(SYSTEM_TIMER_NUMBER);
+	*reg = 10000;		/* 10000us = 10ms */
+
+	setup_irq(IRQ_TIMER(0), &cx2450x_sys_timer_irq);
+
+	/* enable timer and interrupt generation. Allow the timer to overrun the limit for get_time_offset() */
+	reg = (volatile u32 *) TIMER_MODE_REG_BASE(SYSTEM_TIMER_NUMBER);
+	*reg = 0x0B;
+
+	/* the MIP idle timer - runs continous without any interrupt */
+	reg = (volatile u32 *) TIMER_BASE_REG_BASE(MIPIDLE_TIMER_NUMBER);
+	*reg = 54;
+	reg = (volatile u32 *) TIMER_LIMIT_REG_BASE(MIPIDLE_TIMER_NUMBER);
+	*reg = 0xFFFFFFFF;
+	reg = (volatile u32 *) TIMER_MODE_REG_BASE(MIPIDLE_TIMER_NUMBER);
+	*reg = 0x01;
+
+	cx2450x_softlock_timer(0);
+}
+
+/*******************************************************************************/
+
+static void cx2450x_sys_timer_suspend(void)
+{
+	volatile u32 *reg = (volatile u32 *) TIMER_MODE_REG_BASE(SYSTEM_TIMER_NUMBER);
+	old_mode = *reg;
+	*reg = 0;
+}
+
+/*******************************************************************************/
+
+static void cx2450x_sys_timer_resume(void)
+{
+	volatile u32 *reg = (volatile u32 *) TIMER_MODE_REG_BASE(SYSTEM_TIMER_NUMBER);
+	*reg = old_mode;
+}
+
+/*******************************************************************************/
+
+struct sys_timer cx2450x_sys_timer = {
+	.init	= cx2450x_sys_timer_init,
+	.offset	= cx2450x_sys_timer_gettimeoffset,
+	.suspend= cx2450x_sys_timer_suspend,
+	.resume	= cx2450x_sys_timer_resume,
+};
+
+/*******************************************************************************/
+
+EXPORT_SYMBOL(cx2450x_unlock_timer);
+EXPORT_SYMBOL(cx2450x_lock_timer);
+EXPORT_SYMBOL(cx2450x_softlock_timer);
diff --git a/arch/arm/mm/ioremap.c b/arch/arm/mm/ioremap.c
index 28c8b95..569b189 100644
--- a/arch/arm/mm/ioremap.c
+++ b/arch/arm/mm/ioremap.c
@@ -268,6 +268,14 @@ void __iomem * __arm_ioremap_pfn_caller(unsigned long pfn,
 	if (pfn >= 0x100000 && (__pfn_to_phys(pfn) & ~SUPERSECTION_MASK))
 		return NULL;
 
+	/*
+	 * Don't allow RAM to be mapped - this causes problems with ARMv6+
+	 */
+#if 0
+	if (WARN_ON(pfn_valid(pfn)))
+		return NULL;
+#endif
+
 	type = get_mem_type(mtype);
 	if (!type)
 		return NULL;
diff --git a/arch/arm/mm/mmu.c b/arch/arm/mm/mmu.c
index 241c24a..b0b28b5 100644
--- a/arch/arm/mm/mmu.c
+++ b/arch/arm/mm/mmu.c
@@ -910,6 +910,11 @@ void __init reserve_node_zero(pg_data_t *pgdat)
 #endif
 	}
 
+	/* Reserve decarm memory */
+#ifdef CONFIG_NEVIS
+	memblock_reserve(0x10000, 0x10000);
+#endif
+
 #ifdef CONFIG_SA1111
 	/*
 	 * Because of the SA1111 DMA bug, we want to preserve our
diff --git a/build.sh b/build.sh
new file mode 100755
index 0000000..f5b0b56
--- /dev/null
+++ b/build.sh
@@ -0,0 +1,4 @@
+#!/bin/sh
+make -j8 ARCH=arm CROSS_COMPILE=arm-cx2450x-linux-gnueabi- zImage
+#make -j8 ARCH=arm CROSS_COMPILE=arm-cx2450x-linux-gnueabi- modules
+./mkimage -A arm -O linux -T kernel -C none -a  0x48000 -e  0x48000 -n "Coolstream HDx Kernel" -d arch/arm/boot/zImage uImage
diff --git a/config-2.6.34.13 b/config-2.6.34.13
new file mode 100644
index 0000000..862ef1e
--- /dev/null
+++ b/config-2.6.34.13
@@ -0,0 +1,1752 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.34.13
+# Wed Sep  5 14:05:30 2012
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_CONSTRUCTORS=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION="-nevis"
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_BZIP2 is not set
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_LZO is not set
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+
+#
+# RCU Subsystem
+#
+# CONFIG_TREE_RCU is not set
+# CONFIG_TREE_PREEMPT_RCU is not set
+CONFIG_TINY_RCU=y
+# CONFIG_TREE_RCU_TRACE is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=17
+# CONFIG_CGROUPS is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_EXTRA_PASS=y
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+# CONFIG_BUG is not set
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+# CONFIG_SHMEM is not set
+CONFIG_AIO=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+# CONFIG_PERF_EVENTS is not set
+# CONFIG_PERF_COUNTERS is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_COMPAT_BRK=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+
+#
+# GCOV-based kernel profiling
+#
+CONFIG_SLOW_WORK=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_DEADLINE=y
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="deadline"
+# CONFIG_INLINE_SPIN_TRYLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK is not set
+# CONFIG_INLINE_SPIN_LOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
+CONFIG_INLINE_SPIN_UNLOCK=y
+# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
+CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
+# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_READ_TRYLOCK is not set
+# CONFIG_INLINE_READ_LOCK is not set
+# CONFIG_INLINE_READ_LOCK_BH is not set
+# CONFIG_INLINE_READ_LOCK_IRQ is not set
+# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
+CONFIG_INLINE_READ_UNLOCK=y
+# CONFIG_INLINE_READ_UNLOCK_BH is not set
+CONFIG_INLINE_READ_UNLOCK_IRQ=y
+# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_WRITE_TRYLOCK is not set
+# CONFIG_INLINE_WRITE_LOCK is not set
+# CONFIG_INLINE_WRITE_LOCK_BH is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
+CONFIG_INLINE_WRITE_UNLOCK=y
+# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
+CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
+# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
+# CONFIG_MUTEX_SPIN_ON_OWNER is not set
+# CONFIG_FREEZER is not set
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_BCMRING is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_STMP3XXX is not set
+# CONFIG_ARCH_NETX is not set
+CONFIG_ARCH_NEVIS=y
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_NUC93X is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_SHMOBILE is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5P6440 is not set
+# CONFIG_ARCH_S5P6442 is not set
+# CONFIG_ARCH_S5PC1XX is not set
+# CONFIG_ARCH_S5PV210 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+
+#
+# NXP CX2450X (Nevis) SoC support
+#
+CONFIG_MACH_NEVIS=y
+CONFIG_ED_COOLSTREAM_HD1=y
+CONFIG_ARCH_CNXT_EDWARDS=y
+CONFIG_CNXT_PHYS_OFFSET=0x0
+CONFIG_CNXT_TEXT_OFFSET=0x17048000
+CONFIG_CNXT_MODULE_START_OFFSET=0x00FB8000
+CONFIG_CNXT_MODULE_ADDRESS_SPACE_SIZE=0x1000000
+CONFIG_CNXT_VMALLOC_SIZE=0x40000000
+CONFIG_CNXT_DECARM_PHY_ADDRESS=0x17C00000
+CONFIG_CNXT_DECARM_CODE_MEM_SIZE=0x00300000
+CONFIG_CNXT_DECARM_SHARED_MEM_SIZE=0x00100000
+
+#
+# GPIO MUX defaults
+#
+CONFIG_PLL_CONFIG0_REG_DEFAULT=0xBFFFEFFE
+CONFIG_PLL_ALT_FUNC_REG_DEFAULT=0x00000010
+CONFIG_PLL_PRI_GPIO_MUX0_REG_DEFAULT=0x0000D000
+CONFIG_PLL_PRI_GPIO_MUX1_REG_DEFAULT=0x00000080
+CONFIG_PLL_PRI_GPIO_MUX2_REG_DEFAULT=0x000021C0
+CONFIG_PLL_PRI_GPIO_MUX3_REG_DEFAULT=0xFFBFC380
+CONFIG_PLL_PRI_GPIO_MUX4_REG_DEFAULT=0xFFFC0006
+CONFIG_PLL_PRI_GPIO_MUX5_REG_DEFAULT=0x0006F209
+CONFIG_PLL_PRI_GPIO_MUX6_REG_DEFAULT=0x00000002
+CONFIG_PLL_SEC_GPIO_MUX0_REG_DEFAULT=0x00000000
+CONFIG_PLL_SEC_GPIO_MUX1_REG_DEFAULT=0x00003000
+CONFIG_PLL_SEC_GPIO_MUX2_REG_DEFAULT=0x3F7C0000
+CONFIG_PLL_SEC_GPIO_MUX3_REG_DEFAULT=0x20000000
+CONFIG_PLL_SEC_GPIO_MUX4_REG_DEFAULT=0x00000000
+CONFIG_PLL_SEC_GPIO_MUX5_REG_DEFAULT=0x00000000
+CONFIG_PLL_SEC_GPIO_MUX6_REG_DEFAULT=0x00000000
+
+#
+# GPIO options
+#
+CONFIG_PIO_INIT_ON_BOOT=y
+CONFIG_PIO_EXCL_MASK_PIO_031_000=0x00000300
+CONFIG_PIO_EXCL_MASK_PIO_063_032=0x00000000
+CONFIG_PIO_EXCL_MASK_PIO_095_064=0x00000010
+CONFIG_PIO_EXCL_MASK_PIO_127_096=0x00000000
+CONFIG_PIO_EXCL_MASK_PIO_159_128=0x00000000
+CONFIG_PIO_EXCL_MASK_PIO_191_160=0x20000000
+CONFIG_PIO_EXCL_MASK_PIO_223_192=0x00000000
+
+#
+# Processor Type
+#
+CONFIG_CPU_V6=y
+# CONFIG_CPU_32v6K is not set
+CONFIG_CPU_32v6=y
+CONFIG_CPU_ABRT_EV6=y
+CONFIG_CPU_PABRT_V6=y
+CONFIG_CPU_CACHE_V6=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V6=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_THUMB is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_ARM_L1_CACHE_SHIFT=5
+CONFIG_CPU_HAS_PMU=y
+CONFIG_ARM_ERRATA_411920=y
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+# CONFIG_VMSPLIT_3G is not set
+CONFIG_VMSPLIT_2G=y
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0x80000000
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+CONFIG_HZ=100
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+CONFIG_ARCH_HAS_HOLES_MEMORYMODEL=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+# CONFIG_HIGHMEM is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="console=ttyRI0 ip=on root=/dev/nfs rw nfsroot=192.168.100.222:/home/lucgas/nfsexport/coolstream_hd1,rsize=2048,wsize=2048 mem=384M"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+CONFIG_NET_KEY=y
+# CONFIG_NET_KEY_MIGRATE is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_WIRELESS=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_WEXT_CORE=y
+CONFIG_WEXT_PROC=y
+CONFIG_WEXT_PRIV=y
+CONFIG_CFG80211=y
+# CONFIG_NL80211_TESTMODE is not set
+# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
+# CONFIG_CFG80211_REG_DEBUG is not set
+# CONFIG_CFG80211_DEFAULT_PS is not set
+# CONFIG_CFG80211_INTERNAL_REGDB is not set
+CONFIG_CFG80211_WEXT=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+# CONFIG_LIB80211 is not set
+CONFIG_MAC80211=y
+CONFIG_MAC80211_HAS_RC=y
+# CONFIG_MAC80211_RC_PID is not set
+CONFIG_MAC80211_RC_MINSTREL=y
+# CONFIG_MAC80211_RC_DEFAULT_PID is not set
+CONFIG_MAC80211_RC_DEFAULT_MINSTREL=y
+CONFIG_MAC80211_RC_DEFAULT="minstrel"
+# CONFIG_MAC80211_MESH is not set
+# CONFIG_MAC80211_LEDS is not set
+# CONFIG_MAC80211_DEBUG_MENU is not set
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+CONFIG_MTD_CFI_ADV_OPTIONS=y
+CONFIG_MTD_CFI_NOSWAP=y
+# CONFIG_MTD_CFI_BE_BYTE_SWAP is not set
+# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
+CONFIG_MTD_CFI_GEOMETRY=y
+# CONFIG_MTD_MAP_BANK_WIDTH_1 is not set
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+# CONFIG_MTD_MAP_BANK_WIDTH_4 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+# CONFIG_MTD_CFI_I2 is not set
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_OTP is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+CONFIG_MTD_CFI_AMDSTD=y
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+CONFIG_MTD_COMPLEX_MAPPINGS=y
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+CONFIG_MTD_NEVIS_FLASH=y
+# CONFIG_MTD_GPIO_ADDR is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+CONFIG_MTD_MTDRAM=m
+CONFIG_MTDRAM_TOTAL_SIZE=32768
+CONFIG_MTDRAM_ERASE_SIZE=128
+CONFIG_MTD_BLOCK2MTD=m
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+# CONFIG_MTD_NAND is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+
+#
+# DRBD disabled because PROC_FS, INET or CONNECTOR not selected
+#
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+# CONFIG_MISC_DEVICES is not set
+CONFIG_EEPROM_93CX6=m
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+CONFIG_SCSI_TGT=y
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+CONFIG_BLK_DEV_SR=y
+# CONFIG_BLK_DEV_SR_VENDOR is not set
+CONFIG_CHR_DEV_SG=y
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+CONFIG_SCSI_LOGGING=y
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+CONFIG_ATA=y
+# CONFIG_ATA_NONSTANDARD is not set
+CONFIG_ATA_VERBOSE_ERROR=y
+CONFIG_SATA_PMP=y
+CONFIG_ATA_SFF=y
+# CONFIG_SATA_MV is not set
+# CONFIG_PATA_PLATFORM is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_FIXED_PHY is not set
+CONFIG_MDIO_BITBANG=y
+CONFIG_MDIO_GPIO=y
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_AX88796 is not set
+CONFIG_ARCVMAC=y
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+# CONFIG_ETHOC is not set
+# CONFIG_SMC911X is not set
+# CONFIG_SMSC911X is not set
+# CONFIG_DNET is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+# CONFIG_KS8842 is not set
+# CONFIG_KS8851_MLL is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+CONFIG_WLAN=y
+# CONFIG_LIBERTAS_THINFIRM is not set
+# CONFIG_AT76C50X_USB is not set
+# CONFIG_USB_ZD1201 is not set
+# CONFIG_USB_NET_RNDIS_WLAN is not set
+CONFIG_RTL8187=m
+# CONFIG_MAC80211_HWSIM is not set
+# CONFIG_ATH_COMMON is not set
+# CONFIG_B43 is not set
+# CONFIG_B43LEGACY is not set
+# CONFIG_HOSTAP is not set
+# CONFIG_LIBERTAS is not set
+# CONFIG_P54_COMMON is not set
+CONFIG_RT2X00=y
+CONFIG_RT2500USB=m
+CONFIG_RT73USB=m
+CONFIG_RT2800USB=m
+CONFIG_RT2800USB_RT30XX=y
+# CONFIG_RT2800USB_RT35XX is not set
+# CONFIG_RT2800USB_UNKNOWN is not set
+CONFIG_RT2800_LIB=m
+CONFIG_RT2X00_LIB_USB=m
+CONFIG_RT2X00_LIB=m
+CONFIG_RT2X00_LIB_HT=y
+CONFIG_RT2X00_LIB_FIRMWARE=y
+CONFIG_RT2X00_LIB_CRYPTO=y
+# CONFIG_RT2X00_DEBUG is not set
+# CONFIG_WL12XX is not set
+# CONFIG_ZD1211RW is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_IPHETH is not set
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+CONFIG_INPUT_POLLDEV=y
+# CONFIG_INPUT_SPARSEKMAP is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=y
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_TIMBERDALE is not set
+CONFIG_SERIAL_CX2450X=y
+# CONFIG_SERIAL_CX2450X_BAUDRATE_230400 is not set
+CONFIG_SERIAL_CX2450X_BAUDRATE_115200=y
+# CONFIG_SERIAL_CX2450X_BAUDRATE_57600 is not set
+# CONFIG_SERIAL_CX2450X_BAUDRATE_38400 is not set
+# CONFIG_SERIAL_CX2450X_BAUDRATE_19200 is not set
+# CONFIG_SERIAL_CX2450X_BOOTMSG_9600 is not set
+CONFIG_SERIAL_CX2450X_CONSOLE=y
+CONFIG_SERIAL_CX2450X_BOOTMSG=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_SPI is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_GPIO_SYSFS is not set
+
+#
+# Memory mapped GPIO expanders:
+#
+# CONFIG_GPIO_IT8761E is not set
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_ADP5588 is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+
+#
+# AC97 GPIO expanders:
+#
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_AB3100_CORE is not set
+# CONFIG_REGULATOR is not set
+CONFIG_MEDIA_SUPPORT=m
+
+#
+# Multimedia core support
+#
+# CONFIG_VIDEO_DEV is not set
+CONFIG_DVB_CORE=m
+CONFIG_VIDEO_MEDIA=m
+
+#
+# Multimedia drivers
+#
+CONFIG_IR_CORE=m
+CONFIG_VIDEO_IR=m
+CONFIG_MEDIA_ATTACH=y
+CONFIG_MEDIA_TUNER=m
+CONFIG_MEDIA_TUNER_CUSTOMISE=y
+# CONFIG_MEDIA_TUNER_SIMPLE is not set
+# CONFIG_MEDIA_TUNER_TDA8290 is not set
+# CONFIG_MEDIA_TUNER_TDA827X is not set
+# CONFIG_MEDIA_TUNER_TDA18271 is not set
+# CONFIG_MEDIA_TUNER_TDA9887 is not set
+# CONFIG_MEDIA_TUNER_TEA5761 is not set
+# CONFIG_MEDIA_TUNER_TEA5767 is not set
+# CONFIG_MEDIA_TUNER_MT20XX is not set
+# CONFIG_MEDIA_TUNER_MT2060 is not set
+# CONFIG_MEDIA_TUNER_MT2266 is not set
+# CONFIG_MEDIA_TUNER_MT2131 is not set
+# CONFIG_MEDIA_TUNER_QT1010 is not set
+# CONFIG_MEDIA_TUNER_XC2028 is not set
+# CONFIG_MEDIA_TUNER_XC5000 is not set
+# CONFIG_MEDIA_TUNER_MXL5005S is not set
+# CONFIG_MEDIA_TUNER_MXL5007T is not set
+# CONFIG_MEDIA_TUNER_MC44S803 is not set
+# CONFIG_MEDIA_TUNER_MAX2165 is not set
+CONFIG_DVB_MAX_ADAPTERS=8
+# CONFIG_DVB_DYNAMIC_MINORS is not set
+CONFIG_DVB_CAPTURE_DRIVERS=y
+# CONFIG_TTPCI_EEPROM is not set
+
+#
+# Supported USB Adapters
+#
+# CONFIG_DVB_USB is not set
+# CONFIG_SMS_SIANO_MDTV is not set
+
+#
+# Supported FlexCopII (B2C2) Adapters
+#
+# CONFIG_DVB_B2C2_FLEXCOP is not set
+
+#
+# Supported DVB Frontends
+#
+CONFIG_DVB_FE_CUSTOMISE=y
+
+#
+# Customise DVB Frontends
+#
+
+#
+# Multistandard (satellite) frontends
+#
+# CONFIG_DVB_STB0899 is not set
+# CONFIG_DVB_STB6100 is not set
+# CONFIG_DVB_STV090x is not set
+# CONFIG_DVB_STV6110x is not set
+
+#
+# DVB-S (satellite) frontends
+#
+# CONFIG_DVB_CX24110 is not set
+# CONFIG_DVB_CX24123 is not set
+# CONFIG_DVB_MT312 is not set
+# CONFIG_DVB_ZL10036 is not set
+# CONFIG_DVB_ZL10039 is not set
+# CONFIG_DVB_S5H1420 is not set
+# CONFIG_DVB_STV0288 is not set
+# CONFIG_DVB_STB6000 is not set
+# CONFIG_DVB_STV0299 is not set
+# CONFIG_DVB_STV6110 is not set
+# CONFIG_DVB_STV0900 is not set
+# CONFIG_DVB_TDA8083 is not set
+# CONFIG_DVB_TDA10086 is not set
+# CONFIG_DVB_TDA8261 is not set
+# CONFIG_DVB_VES1X93 is not set
+# CONFIG_DVB_TUNER_ITD1000 is not set
+# CONFIG_DVB_TUNER_CX24113 is not set
+# CONFIG_DVB_TDA826X is not set
+# CONFIG_DVB_TUA6100 is not set
+# CONFIG_DVB_CX24116 is not set
+# CONFIG_DVB_SI21XX is not set
+# CONFIG_DVB_DS3000 is not set
+# CONFIG_DVB_MB86A16 is not set
+
+#
+# DVB-T (terrestrial) frontends
+#
+# CONFIG_DVB_SP8870 is not set
+# CONFIG_DVB_SP887X is not set
+# CONFIG_DVB_CX22700 is not set
+# CONFIG_DVB_CX22702 is not set
+# CONFIG_DVB_DRX397XD is not set
+# CONFIG_DVB_L64781 is not set
+# CONFIG_DVB_TDA1004X is not set
+# CONFIG_DVB_NXT6000 is not set
+# CONFIG_DVB_MT352 is not set
+# CONFIG_DVB_ZL10353 is not set
+# CONFIG_DVB_DIB3000MB is not set
+# CONFIG_DVB_DIB3000MC is not set
+# CONFIG_DVB_DIB7000M is not set
+# CONFIG_DVB_DIB7000P is not set
+# CONFIG_DVB_TDA10048 is not set
+# CONFIG_DVB_AF9013 is not set
+# CONFIG_DVB_EC100 is not set
+
+#
+# DVB-C (cable) frontends
+#
+# CONFIG_DVB_VES1820 is not set
+# CONFIG_DVB_TDA10021 is not set
+# CONFIG_DVB_TDA10023 is not set
+# CONFIG_DVB_STV0297 is not set
+
+#
+# ATSC (North American/Korean Terrestrial/Cable DTV) frontends
+#
+# CONFIG_DVB_NXT200X is not set
+# CONFIG_DVB_OR51211 is not set
+# CONFIG_DVB_OR51132 is not set
+# CONFIG_DVB_BCM3510 is not set
+# CONFIG_DVB_LGDT330X is not set
+# CONFIG_DVB_LGDT3304 is not set
+# CONFIG_DVB_LGDT3305 is not set
+# CONFIG_DVB_S5H1409 is not set
+# CONFIG_DVB_S5H1411 is not set
+
+#
+# ISDB-T (terrestrial) frontends
+#
+# CONFIG_DVB_S921 is not set
+# CONFIG_DVB_DIB8000 is not set
+
+#
+# Digital terrestrial only tuners/PLL
+#
+# CONFIG_DVB_PLL is not set
+# CONFIG_DVB_TUNER_DIB0070 is not set
+# CONFIG_DVB_TUNER_DIB0090 is not set
+
+#
+# SEC control devices for DVB-S
+#
+# CONFIG_DVB_LNBP21 is not set
+# CONFIG_DVB_ISL6405 is not set
+# CONFIG_DVB_ISL6421 is not set
+# CONFIG_DVB_ISL6423 is not set
+# CONFIG_DVB_LGS8GL5 is not set
+# CONFIG_DVB_LGS8GXX is not set
+# CONFIG_DVB_ATBM8830 is not set
+# CONFIG_DVB_TDA665x is not set
+
+#
+# Tools to develop new frontends
+#
+# CONFIG_DVB_DUMMY_FE is not set
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+# CONFIG_FB_CFB_FILLRECT is not set
+# CONFIG_FB_CFB_COPYAREA is not set
+# CONFIG_FB_CFB_IMAGEBLIT is not set
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+# CONFIG_LOGO is not set
+CONFIG_SOUND=y
+CONFIG_SOUND_OSS_CORE=y
+CONFIG_SOUND_OSS_CORE_PRECLAIM=y
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+# CONFIG_SND_SEQUENCER is not set
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
+CONFIG_SND_PCM_OSS_PLUGINS=y
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+CONFIG_SND_VERBOSE_PRINTK=y
+CONFIG_SND_DEBUG=y
+# CONFIG_SND_DEBUG_VERBOSE is not set
+CONFIG_SND_PCM_XRUN_DEBUG=y
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+CONFIG_SND_DRIVERS=y
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+CONFIG_SND_ARM=y
+CONFIG_SND_USB=y
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_UA101 is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_SOC is not set
+# CONFIG_SOUND_PRIME is not set
+# CONFIG_HID_SUPPORT is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_CX2450X_USB=y
+CONFIG_CX2450X_USB0=y
+CONFIG_CX2450X_USB1=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+# CONFIG_USB_EHCI_TT_NEWSCHED is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+# CONFIG_USB_MUSB_HDRC is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=m
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+CONFIG_USB_SERIAL=m
+# CONFIG_USB_EZUSB is not set
+# CONFIG_USB_SERIAL_GENERIC is not set
+# CONFIG_USB_SERIAL_AIRCABLE is not set
+# CONFIG_USB_SERIAL_ARK3116 is not set
+# CONFIG_USB_SERIAL_BELKIN is not set
+# CONFIG_USB_SERIAL_CH341 is not set
+# CONFIG_USB_SERIAL_WHITEHEAT is not set
+# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+# CONFIG_USB_SERIAL_CP210X is not set
+# CONFIG_USB_SERIAL_CYPRESS_M8 is not set
+# CONFIG_USB_SERIAL_EMPEG is not set
+CONFIG_USB_SERIAL_FTDI_SIO=m
+# CONFIG_USB_SERIAL_FUNSOFT is not set
+# CONFIG_USB_SERIAL_VISOR is not set
+# CONFIG_USB_SERIAL_IPAQ is not set
+# CONFIG_USB_SERIAL_IR is not set
+# CONFIG_USB_SERIAL_EDGEPORT is not set
+# CONFIG_USB_SERIAL_EDGEPORT_TI is not set
+# CONFIG_USB_SERIAL_GARMIN is not set
+# CONFIG_USB_SERIAL_IPW is not set
+# CONFIG_USB_SERIAL_IUU is not set
+# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+# CONFIG_USB_SERIAL_KEYSPAN is not set
+# CONFIG_USB_SERIAL_KLSI is not set
+# CONFIG_USB_SERIAL_KOBIL_SCT is not set
+# CONFIG_USB_SERIAL_MCT_U232 is not set
+# CONFIG_USB_SERIAL_MOS7720 is not set
+# CONFIG_USB_SERIAL_MOS7840 is not set
+# CONFIG_USB_SERIAL_MOTOROLA is not set
+# CONFIG_USB_SERIAL_NAVMAN is not set
+CONFIG_USB_SERIAL_PL2303=m
+# CONFIG_USB_SERIAL_OTI6858 is not set
+# CONFIG_USB_SERIAL_QCAUX is not set
+# CONFIG_USB_SERIAL_QUALCOMM is not set
+# CONFIG_USB_SERIAL_SPCP8X5 is not set
+# CONFIG_USB_SERIAL_HP4X is not set
+# CONFIG_USB_SERIAL_SAFE is not set
+# CONFIG_USB_SERIAL_SIEMENS_MPI is not set
+# CONFIG_USB_SERIAL_SIERRAWIRELESS is not set
+# CONFIG_USB_SERIAL_SYMBOL is not set
+# CONFIG_USB_SERIAL_TI is not set
+# CONFIG_USB_SERIAL_CYBERJACK is not set
+# CONFIG_USB_SERIAL_XIRCOM is not set
+# CONFIG_USB_SERIAL_OPTION is not set
+# CONFIG_USB_SERIAL_OMNINET is not set
+# CONFIG_USB_SERIAL_OPTICON is not set
+# CONFIG_USB_SERIAL_VIVOPAY_SERIAL is not set
+# CONFIG_USB_SERIAL_DEBUG is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_GADGET is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_ULPI is not set
+# CONFIG_NOP_USB_XCEIV is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_RTC_LIB=y
+# CONFIG_RTC_CLASS is not set
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+
+#
+# TI VLYNQ
+#
+CONFIG_STAGING=y
+# CONFIG_STAGING_EXCLUDE_BUILD is not set
+# CONFIG_USB_IP_COMMON is not set
+# CONFIG_W35UND is not set
+# CONFIG_PRISM2_USB is not set
+# CONFIG_ECHO is not set
+# CONFIG_OTUS is not set
+# CONFIG_COMEDI is not set
+# CONFIG_ASUS_OLED is not set
+CONFIG_RTL8192U=m
+# CONFIG_TRANZPORT is not set
+
+#
+# Qualcomm MSM Camera And Video
+#
+
+#
+# Camera Sensor Selection
+#
+# CONFIG_INPUT_GPIO is not set
+# CONFIG_POHMELFS is not set
+# CONFIG_LINE6_USB is not set
+# CONFIG_USB_SERIAL_QUATECH2 is not set
+# CONFIG_USB_SERIAL_QUATECH_USB2 is not set
+# CONFIG_VT6656 is not set
+# CONFIG_FB_UDL is not set
+
+#
+# RAR Register Driver
+#
+# CONFIG_RAR_REGISTER is not set
+# CONFIG_IIO is not set
+# CONFIG_RAMZSWAP is not set
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_STRIP is not set
+# CONFIG_FB_SM7XX is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+# CONFIG_EXT2_FS_POSIX_ACL is not set
+# CONFIG_EXT2_FS_SECURITY is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_XATTR=y
+# CONFIG_EXT4_FS_POSIX_ACL is not set
+# CONFIG_EXT4_FS_SECURITY is not set
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD=y
+CONFIG_JBD2=y
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+# CONFIG_DNOTIFY is not set
+# CONFIG_INOTIFY is not set
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+CONFIG_FUSE_FS=m
+# CONFIG_CUSE is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+CONFIG_NTFS_FS=m
+# CONFIG_NTFS_DEBUG is not set
+# CONFIG_NTFS_RW is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+CONFIG_JFFS2_SUMMARY=y
+# CONFIG_JFFS2_FS_XATTR is not set
+CONFIG_JFFS2_COMPRESSION_OPTIONS=y
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_LZO=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+# CONFIG_JFFS2_CMODE_NONE is not set
+CONFIG_JFFS2_CMODE_PRIORITY=y
+# CONFIG_JFFS2_CMODE_SIZE is not set
+# CONFIG_JFFS2_CMODE_FAVOURLZO is not set
+# CONFIG_LOGFS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CEPH_FS is not set
+CONFIG_CIFS=m
+# CONFIG_CIFS_STATS is not set
+CONFIG_CIFS_WEAK_PW_HASH=y
+# CONFIG_CIFS_XATTR is not set
+# CONFIG_CIFS_DEBUG2 is not set
+# CONFIG_CIFS_EXPERIMENTAL is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+CONFIG_EFI_PARTITION=y
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_737=m
+CONFIG_NLS_CODEPAGE_775=m
+CONFIG_NLS_CODEPAGE_850=m
+CONFIG_NLS_CODEPAGE_852=m
+CONFIG_NLS_CODEPAGE_855=m
+CONFIG_NLS_CODEPAGE_857=m
+CONFIG_NLS_CODEPAGE_860=m
+CONFIG_NLS_CODEPAGE_861=m
+CONFIG_NLS_CODEPAGE_862=m
+CONFIG_NLS_CODEPAGE_863=m
+CONFIG_NLS_CODEPAGE_864=m
+CONFIG_NLS_CODEPAGE_865=m
+CONFIG_NLS_CODEPAGE_866=m
+CONFIG_NLS_CODEPAGE_869=m
+CONFIG_NLS_CODEPAGE_936=m
+CONFIG_NLS_CODEPAGE_950=m
+CONFIG_NLS_CODEPAGE_932=m
+CONFIG_NLS_CODEPAGE_949=m
+CONFIG_NLS_CODEPAGE_874=m
+CONFIG_NLS_ISO8859_8=m
+CONFIG_NLS_CODEPAGE_1250=m
+CONFIG_NLS_CODEPAGE_1251=m
+CONFIG_NLS_ASCII=m
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_ISO8859_2=m
+CONFIG_NLS_ISO8859_3=m
+CONFIG_NLS_ISO8859_4=m
+CONFIG_NLS_ISO8859_5=m
+CONFIG_NLS_ISO8859_6=m
+CONFIG_NLS_ISO8859_7=m
+CONFIG_NLS_ISO8859_9=m
+CONFIG_NLS_ISO8859_13=m
+CONFIG_NLS_ISO8859_14=m
+CONFIG_NLS_ISO8859_15=m
+CONFIG_NLS_KOI8_R=m
+CONFIG_NLS_KOI8_U=m
+CONFIG_NLS_UTF8=y
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_STRIP_ASM_SYMS=y
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_LATENCYTOP is not set
+CONFIG_SYSCTL_SYSCALL_CHECK=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_ARM_UNWIND is not set
+# CONFIG_DEBUG_USER is not set
+# CONFIG_OC_ETM is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_DEFAULT_SECURITY_SELINUX is not set
+# CONFIG_DEFAULT_SECURITY_SMACK is not set
+# CONFIG_DEFAULT_SECURITY_TOMOYO is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=m
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_MANAGER_TESTS is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=y
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_GHASH is not set
+CONFIG_CRYPTO_MD4=m
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+# CONFIG_CRYPTO_ZLIB is not set
+CONFIG_CRYPTO_LZO=y
+
+#
+# Random Number Generation
+#
+CONFIG_CRYPTO_ANSI_CPRNG=m
+# CONFIG_CRYPTO_HW is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+CONFIG_CRC_ITU_T=m
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_NLATTR=y
+CONFIG_GENERIC_ATOMIC64=y
diff --git a/drivers/mtd/maps/Kconfig b/drivers/mtd/maps/Kconfig
index aa2807d..bbc4f2f 100644
--- a/drivers/mtd/maps/Kconfig
+++ b/drivers/mtd/maps/Kconfig
@@ -386,6 +386,10 @@ config MTD_FORTUNET
 	  This enables access to the Flash on the FortuNet board.  If you
 	  have such a board, say 'Y'.
 
+config MTD_NEVIS_FLASH
+	tristate "CFI Flash defice(s) mapped on NXP CX2450x (Nevis)"
+	depends on ARM && MTD_CFI
+
 config MTD_AUTCPU12
 	tristate "NV-RAM mapping AUTCPU12 board"
 	depends on ARCH_AUTCPU12
diff --git a/drivers/mtd/maps/Makefile b/drivers/mtd/maps/Makefile
index bb035cd..1967c94 100644
--- a/drivers/mtd/maps/Makefile
+++ b/drivers/mtd/maps/Makefile
@@ -9,6 +9,7 @@ endif
 # Chip mappings
 obj-$(CONFIG_MTD_CDB89712)	+= cdb89712.o
 obj-$(CONFIG_MTD_ARM_INTEGRATOR)+= integrator-flash.o
+obj-$(CONFIG_MTD_NEVIS_FLASH)	+= cx2450x-flash.o
 obj-$(CONFIG_MTD_CFI_FLAGADM)	+= cfi_flagadm.o
 obj-$(CONFIG_MTD_DC21285)	+= dc21285.o
 obj-$(CONFIG_MTD_DILNETPC)	+= dilnetpc.o
diff --git a/drivers/mtd/maps/cx2450x-flash.c b/drivers/mtd/maps/cx2450x-flash.c
new file mode 100644
index 0000000..f2894e0
--- /dev/null
+++ b/drivers/mtd/maps/cx2450x-flash.c
@@ -0,0 +1,336 @@
+/*======================================================================
+
+    drivers/mtd/maps/cx2450x-flash.c
+    map driver for CFI compliant NOR-flashes connected to an
+    Conexant CX2450x SoC
+
+    copyright (C) 2008 Coolstream International Limited
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+======================================================================*/
+
+#include <mach/cx2450x.h>
+#include <mach/platform.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#define	VERSION	"1.0"
+
+static u32 num_banks = 0;
+static struct cx2450xflash_info *info = NULL;
+
+/* a default Flash map for the case that no map given by the cmdline */
+static const struct mtd_partition default_partitions[] = {
+	{
+	 .name = "Bootloader",
+	 .size = 0x00060000,	/* 384K */
+	 .offset = 0,
+	 .mask_flags = 0	/* to make it readonly */
+	 },
+	{
+	 .name = "Bootloader Splash Image",
+	 .size = 0x00020000,	/* 128K */
+	 .offset = 0x00060000,
+	 .mask_flags = 0	/* to make it readonly */
+	 },
+	{
+	 .name = "Compressed Kernel",
+	 .size = 0x00400000,
+	 .offset = 0x00080000,
+	 .mask_flags = 0	/* to make it readonly */
+	 },
+	{
+	 .name = "systemFS",
+	 .size = 0x01B80000,
+	 .offset = 0x00480000,
+	 .mask_flags = 0}
+#if 0
+	,
+	{
+	 .name = "Root Filesystem (JFFS2)",
+	 .size = 0x01000000,
+	 .offset = 0x01000000,
+	 .mask_flags = 0}
+#endif
+};
+
+static inline void enter_flash_program_mode(void)
+{
+	writel(readl(PCI_ROM_DESC0_REG) | (1UL << 23), PCI_ROM_DESC0_REG);
+	writel(readl(PCI_ISAROM_DESC1_REG) | (1UL << 23), PCI_ISAROM_DESC1_REG);
+}
+
+static inline void exit_flash_program_mode(void)
+{
+	writel(readl(PCI_ROM_DESC0_REG) & ~(1UL << 23), PCI_ROM_DESC0_REG);
+	writel(readl(PCI_ISAROM_DESC1_REG) & ~(1UL << 23), PCI_ISAROM_DESC1_REG);
+}
+
+/*****************************************/
+/*       CNXT Flash map APIs             */
+/*****************************************/
+
+static map_word cnxt_map_read(struct map_info *map, unsigned long ofs)
+{
+	map_word r;
+	r.x[0] = readw(map->virt + ofs);
+	return r;
+}
+
+static void cnxt_map_write(struct map_info *map, const map_word datum, unsigned long ofs)
+{
+	enter_flash_program_mode();
+	writew(datum.x[0], map->virt + ofs);
+	exit_flash_program_mode();
+	mb();
+	/*printk("[0x%x]<=0x%x\n", map->virt + ofs, datum.x[0]); */
+}
+
+static void cnxt_map_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	uint16_t buf;
+	unsigned char *to_lval = to;
+	while (len > 0) {
+		buf = readw(map->virt + (from & 0xFFFFFFFE));
+		if (!(from & 1))
+			*((unsigned char *) to_lval) = (buf & 0xff);
+		else
+			*((unsigned char *) to_lval) = ((buf & 0xff00) >> 8);
+		to_lval++;
+		len--;
+		from++;
+	}
+}
+
+static void cnxt_map_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	uint16_t buf;
+	uint16_t *from_lval = (uint16_t *) from;
+	enter_flash_program_mode();
+	while (len > 0) {
+		buf = readw(map->virt + (to & 0xFFFFFFFE));
+		if (!(to & 1))
+			buf = (buf & 0xff00) | *((unsigned char *) from_lval);
+		else
+			buf = (buf & 0xff) | (((uint16_t) (*((unsigned char *) from_lval))) << 8);
+		writew(buf, map->virt + (to & 0xFFFFFFFE));
+		from_lval++;
+		len--;
+		to++;
+	}
+	exit_flash_program_mode();
+}
+
+void cnxt_map_init(struct map_info *map)
+{
+	map->read = cnxt_map_read;
+	map->write = cnxt_map_write;
+	map->copy_from = cnxt_map_copy_from;
+	map->copy_to = cnxt_map_copy_to;
+	writel(0x1000, PCI_ROM_DESC0_REG2);
+}
+
+struct cx2450xflash_info {
+	struct resource *res;
+	struct map_info map;
+	struct mtd_info *mtd;
+	struct mtd_partition *parts;
+};
+
+
+/*******************************************************************************/
+
+static void cx2450xflash_set_vpp(struct map_info *map, int on)
+{
+	volatile u32 *reg;
+	u32 bank;
+
+	for (bank = 0; bank < num_banks; bank++) {
+		reg = (volatile u32 *) ROM_DESC_REG_BASE(bank);
+		if (on)
+			*reg |= 0x00800000;
+		else
+			*reg &= 0xFF7FFFFF;
+	}
+}
+
+/*******************************************************************************/
+
+static int __init cx2450xflash_init(void)
+{
+	const char *probes[] = { "cmdlinepart", NULL };
+	int bank;
+	volatile u32 *reg;
+	u32 descreg, mapreg, bwidth;
+	u32 fl_size = 0;
+	u32 fl_start = 0xF0000000;
+	u32 b_start, b_size;
+	u32 b_ws0 = 0;
+	void __iomem *base = NULL;
+	int err = 0;
+
+	printk("CX2450x MTD driver v%s (%s, %s) (c) Coolstream International Ltd.\n", VERSION, __DATE__, __TIME__);
+
+	num_banks = 0;
+	info = kzalloc(sizeof(struct cx2450xflash_info), GFP_KERNEL);
+	if (!info)
+		return -ENOMEM;
+
+	/* we can have more than one Flash chip (theoretical 4 chips), so read the
+	   ISA descriptors, which have to be configured correctly by the bootloader */
+	for (bank = 0; bank < 4; bank++) {
+		reg = (volatile u32 *) ROM_DESC_REG_BASE(bank);
+		descreg = *reg;
+
+		if ((descreg & 0x80000000) == 0) {	/* if bit 31 not set, ROM is present */
+			bwidth = (descreg & 0x00000030) >> 4;	/* bit 5..4 encodes the bus width ( 8 or 16 bit) */
+			if ((bwidth == 1) || (bwidth == 2)) {
+				reg = (volatile u32 *) ROM_MAP_REG_BASE(bank);
+				mapreg = *reg;
+
+				b_start = (mapreg & 0x0FFF0000) + 0xF0000000;
+				b_size = (0x1000 - (mapreg & 0x00000FFF)) * 0x00010000;
+				if ((b_start == fl_start) && (b_size >= 0x00010000)) {
+					fl_size += b_size;
+					fl_start += b_size;
+					if (bank == 0)
+						b_ws0 = bwidth;
+					num_banks++;
+				} else {
+					printk("  Start/Size missmatch [0x%.8X / 0x%.8X]\n", b_start, fl_start);
+					bank = 4;
+				}
+			} else
+				bank = 4;	/* do not allow non continous range */
+		} else
+			bank = 4;	/* do not allow non continous range */
+	}
+	if ((fl_size) && (b_ws0)) {
+		fl_start = 0xF0000000;
+
+		base = ioremap(fl_start, fl_size);
+
+		if (!base) {
+			kfree(info);
+			return -ENOMEM;
+		}
+
+		info->res = request_mem_region(fl_start, fl_size, "cx2450xflash");
+		if (!info->res) {
+			iounmap(base);
+			kfree(info);
+			return -ENOMEM;
+		}
+
+		info->map.size = fl_size;
+		info->map.bankwidth = b_ws0;
+		info->map.phys = fl_start;
+		info->map.virt = base;
+		info->map.name = "cx2450xflash";
+		info->map.set_vpp = cx2450xflash_set_vpp;
+
+		cnxt_map_init(&info->map);
+
+		/* Note: We must enable VPP here manually, because CFI is not doing this for probe.
+		   On the CX2450x device, read's are made in a burst mode with cache. This mode
+		   does not allow writings, so the set_vpp() function switch into write-mode, which
+		   disabled burst and cache, but in fact we can not read in write mode. I.e. data
+		   written as 0x1122334455667788 is read as 0x1122112255665566 in write mode. */
+
+		cx2450xflash_set_vpp(&info->map, 1);
+		info->mtd = do_map_probe("cfi_probe", &info->map);
+		cx2450xflash_set_vpp(&info->map, 0);
+
+		if (!info->mtd) {
+			release_resource(info->res);
+			iounmap(base);
+			kfree(info->res);
+			kfree(info);
+			return -ENXIO;
+		}
+
+		info->mtd->owner = THIS_MODULE;
+
+		err = parse_mtd_partitions(info->mtd, probes, &info->parts, 0);
+		if (err >= 0) {
+			if (err == 0) {
+				printk("  no partitioning via cmdline present. Using defaults.\n");
+				err = add_mtd_partitions(info->mtd, default_partitions, ARRAY_SIZE(default_partitions));
+
+			} else
+				err = add_mtd_partitions(info->mtd, info->parts, err);
+			if (err)
+				printk(KERN_ERR "mtd partition registration failed: %d\n", err);
+		}
+
+		/* If we got an error, free all resources. */
+		if (err < 0) {
+			if (info->mtd) {
+				del_mtd_partitions(info->mtd);
+				map_destroy(info->mtd);
+			}
+			kfree(info->parts);
+			info->parts = NULL;
+
+			release_resource(info->res);
+			iounmap(base);
+			kfree(info->res);
+			info->res = NULL;
+
+			kfree(info);
+			info = NULL;
+		}
+	}
+	return err;
+}
+
+/*******************************************************************************/
+
+static void __exit cx2450xflash_exit(void)
+{
+	if (info) {
+		if (info->mtd) {
+			del_mtd_partitions(info->mtd);
+			map_destroy(info->mtd);
+		}
+		if (info->parts) {
+			kfree(info->parts);
+			info->parts = NULL;
+		}
+
+		iounmap(info->map.virt);
+		release_resource(info->res);
+
+		kfree(info->res);
+		kfree(info);
+	}
+}
+
+/*******************************************************************************/
+
+module_init(cx2450xflash_init);
+module_exit(cx2450xflash_exit);
+
+EXPORT_SYMBOL(cnxt_map_init);
+
+MODULE_AUTHOR("Coolstream International Limited Ltd..");
+MODULE_DESCRIPTION("Conexant CX2450x CFI MTD map driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
index 7b832c7..9847696 100644
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -248,6 +248,16 @@ config AX88796_93CX6
 	help
 	  Select this if your platform comes with an external 93CX6 eeprom.
 
+config ARCVMAC
+	tristate "ARC VMAC ethernet support"
+	depends on HAS_DMA
+	select MII
+	select PHYLIB
+	select CRC32
+
+	help
+	  MAC present on Zoran Quatro43XX
+
 config MACE
 	tristate "MACE (Power Mac ethernet) support"
 	depends on PPC_PMAC && PPC32
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index 263324b..e445141 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -137,6 +137,7 @@ obj-$(CONFIG_ULTRA32) += smc-ultra32.o 8390.o
 obj-$(CONFIG_E2100) += e2100.o 8390.o
 obj-$(CONFIG_ES3210) += es3210.o 8390.o
 obj-$(CONFIG_LNE390) += lne390.o 8390.o
+obj-$(CONFIG_ARCVMAC) += arcvmac.o
 obj-$(CONFIG_NE3210) += ne3210.o 8390.o
 obj-$(CONFIG_SB1250_MAC) += sb1250-mac.o
 obj-$(CONFIG_B44) += b44.o
diff --git a/drivers/net/arcvmac.c b/drivers/net/arcvmac.c
new file mode 100644
index 0000000..4ff469c
--- /dev/null
+++ b/drivers/net/arcvmac.c
@@ -0,0 +1,1478 @@
+/*
+ * ARC VMAC Driver
+ *
+ * Copyright (C) 2003-2006 Codito Technologies, for linux-2.4 port
+ * Copyright (C) 2006-2007 Celunite Inc, for linux-2.6 port
+ * Copyright (C) 2007-2008 Sagem Communications, Fehmi Hafsi
+ * Copyright (C) 2009-2011 Sagem Communications, Andreas Fenkart
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * external PHY support based on dnet.c
+ * ring management based on bcm63xx_enet.c
+ */
+
+#include <linux/clk.h>
+#include <linux/crc32.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/etherdevice.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/netdevice.h>
+#include <linux/phy.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+
+#include "arcvmac.h"
+
+/* Register access macros */
+#define vmac_writel(port, value, reg)	\
+	writel(cpu_to_le32(value), (port)->regs + VMAC_##reg)
+#define vmac_readl(port, reg)	le32_to_cpu(readl((port)->regs + VMAC_##reg))
+
+static int get_register_map(struct vmac_priv *ap);
+static int put_register_map(struct vmac_priv *ap);
+
+static unsigned char *read_mac_reg(struct net_device *dev,
+		unsigned char hwaddr[ETH_ALEN])
+{
+	struct vmac_priv *ap = netdev_priv(dev);
+	unsigned mac_lo, mac_hi;
+
+	WARN_ON(!hwaddr);
+	mac_lo = vmac_readl(ap, ADDRL);
+	mac_hi = vmac_readl(ap, ADDRH);
+
+	hwaddr[0] = (mac_lo >> 0) & 0xff;
+	hwaddr[1] = (mac_lo >> 8) & 0xff;
+	hwaddr[2] = (mac_lo >> 16) & 0xff;
+	hwaddr[3] = (mac_lo >> 24) & 0xff;
+	hwaddr[4] = (mac_hi >> 0) & 0xff;
+	hwaddr[5] = (mac_hi >> 8) & 0xff;
+	return hwaddr;
+}
+
+static void write_mac_reg(struct net_device *dev, unsigned char* hwaddr)
+{
+	struct vmac_priv *ap = netdev_priv(dev);
+	unsigned mac_lo, mac_hi;
+
+	mac_lo = hwaddr[3] << 24 | hwaddr[2] << 16 | hwaddr[1] << 8 |
+		hwaddr[0];
+	mac_hi = hwaddr[5] << 8 | hwaddr[4];
+
+	vmac_writel(ap, mac_lo, ADDRL);
+	vmac_writel(ap, mac_hi, ADDRH);
+}
+
+static void vmac_mdio_xmit(struct vmac_priv *ap, unsigned val)
+{
+	init_completion(&ap->mdio_complete);
+	vmac_writel(ap, val, MDIO_DATA);
+	wait_for_completion(&ap->mdio_complete);
+}
+
+static int vmac_mdio_read(struct mii_bus *bus, int phy_id, int phy_reg)
+{
+	struct vmac_priv *vmac = bus->priv;
+	unsigned int val;
+
+	/* only 5 bits allowed for phy-addr and reg_offset */
+	WARN_ON(phy_id & ~0x1f || phy_reg & ~0x1f);
+
+	val = MDIO_BASE | MDIO_OP_READ;
+	val |= phy_id << 23 | phy_reg << 18;
+	vmac_mdio_xmit(vmac, val);
+
+	val = vmac_readl(vmac, MDIO_DATA);
+	return val & MDIO_DATA_MASK;
+}
+
+static int vmac_mdio_write(struct mii_bus *bus, int phy_id, int phy_reg,
+			 u16 value)
+{
+	struct vmac_priv *vmac = bus->priv;
+	unsigned int val;
+
+	/* only 5 bits allowed for phy-addr and reg_offset */
+	WARN_ON(phy_id & ~0x1f || phy_reg & ~0x1f);
+
+	val = MDIO_BASE | MDIO_OP_WRITE;
+	val |= phy_id << 23 | phy_reg << 18;
+	val |= (value & MDIO_DATA_MASK);
+	vmac_mdio_xmit(vmac, val);
+
+	return 0;
+}
+
+static void vmac_handle_link_change(struct net_device *dev)
+{
+	struct vmac_priv *ap = netdev_priv(dev);
+	struct phy_device *phydev = ap->phy_dev;
+	unsigned long flags;
+	int report_change = 0;
+
+	spin_lock_irqsave(&ap->lock, flags);
+
+	if (phydev->duplex != ap->duplex) {
+		unsigned tmp;
+
+		tmp = vmac_readl(ap, ENABLE);
+
+		if (phydev->duplex)
+			tmp |= ENFL_MASK;
+		else
+			tmp &= ~ENFL_MASK;
+
+		vmac_writel(ap, tmp, ENABLE);
+
+		ap->duplex = phydev->duplex;
+		report_change = 1;
+	}
+
+	if (phydev->speed != ap->speed) {
+		ap->speed = phydev->speed;
+		report_change = 1;
+	}
+
+	if (phydev->link != ap->link) {
+		ap->link = phydev->link;
+		report_change = 1;
+	}
+
+	spin_unlock_irqrestore(&ap->lock, flags);
+
+	if (report_change)
+		phy_print_status(ap->phy_dev);
+}
+
+static int __devinit vmac_mii_probe(struct net_device *dev)
+{
+	struct vmac_priv *ap = netdev_priv(dev);
+	struct phy_device *phydev = NULL;
+	struct clk *vmac_clk;
+	unsigned long clock_rate;
+	int phy_addr, err;
+
+	/* find the first phy */
+	for (phy_addr = 0; phy_addr < PHY_MAX_ADDR; phy_addr++) {
+		if (ap->mii_bus->phy_map[phy_addr]) {
+			phydev = ap->mii_bus->phy_map[phy_addr];
+			break;
+		}
+	}
+
+	if (!phydev) {
+		dev_err(&ap->pdev->dev, "no PHY found\n");
+		return -ENODEV;
+	}
+
+	/* FIXME: add pin_irq, if avail */
+
+	phydev = phy_connect(dev, dev_name(&phydev->dev),
+			&vmac_handle_link_change, 0,
+			PHY_INTERFACE_MODE_MII);
+
+	if (IS_ERR(phydev)) {
+		err = PTR_ERR(phydev);
+		dev_err(&ap->pdev->dev, "could not attach to PHY %d\n", err);
+		goto err_out;
+	}
+
+	phydev->supported &= PHY_BASIC_FEATURES;
+	phydev->supported |= SUPPORTED_Asym_Pause | SUPPORTED_Pause;
+#if 0
+	vmac_clk = clk_get(&ap->pdev->dev, "arcvmac");
+	if (IS_ERR(vmac_clk)) {
+		err = PTR_ERR(vmac_clk);
+		goto err_disconnect;
+	}
+
+	clock_rate = clk_get_rate(vmac_clk);
+	clk_put(vmac_clk);
+#endif
+	clock_rate = 25 * 1000 * 1000;
+
+	dev_info(&ap->pdev->dev, "vmac_clk: %lu Hz\n", clock_rate);
+
+	if (clock_rate < 25000000)
+		phydev->supported &= ~(SUPPORTED_100baseT_Half |
+				SUPPORTED_100baseT_Full);
+
+	phydev->advertising = phydev->supported;
+
+	ap->link = 0;
+	ap->speed = 0;
+	ap->duplex = -1;
+	ap->phy_dev = phydev;
+
+	return 0;
+
+err_disconnect:
+	phy_disconnect(phydev);
+err_out:
+	return err;
+}
+
+static int __devinit vmac_mii_init(struct vmac_priv *ap)
+{
+	int err, i;
+
+	ap->mii_bus = mdiobus_alloc();
+	if (ap->mii_bus == NULL)
+		return -ENOMEM;
+
+	ap->mii_bus->name = "vmac_mii_bus";
+	ap->mii_bus->read = &vmac_mdio_read;
+	ap->mii_bus->write = &vmac_mdio_write;
+
+	snprintf(ap->mii_bus->id, MII_BUS_ID_SIZE, "arvmac_mii_bus%x", 0);
+
+	ap->mii_bus->priv = ap;
+
+	err = -ENOMEM;
+	ap->mii_bus->irq = kmalloc(sizeof(int) * PHY_MAX_ADDR, GFP_KERNEL);
+	if (!ap->mii_bus->irq)
+		goto err_out;
+
+	for (i = 0; i < PHY_MAX_ADDR; i++)
+		ap->mii_bus->irq[i] = PHY_POLL;
+
+	/* locking: mdio concurrency */
+
+	err = mdiobus_register(ap->mii_bus);
+	if (err)
+		goto err_out_free_mdio_irq;
+
+	err = vmac_mii_probe(ap->dev);
+	if (err)
+		goto err_out_unregister_bus;
+
+	return 0;
+
+err_out_unregister_bus:
+	mdiobus_unregister(ap->mii_bus);
+err_out_free_mdio_irq:
+	kfree(ap->mii_bus->irq);
+err_out:
+	mdiobus_free(ap->mii_bus);
+	return err;
+}
+
+static void vmac_mii_exit_unlocked(struct net_device *dev)
+{
+	struct vmac_priv *ap = netdev_priv(dev);
+
+	if (ap->phy_dev)
+		phy_disconnect(ap->phy_dev);
+
+	mdiobus_unregister(ap->mii_bus);
+	kfree(ap->mii_bus->irq);
+	mdiobus_free(ap->mii_bus);
+}
+
+static int vmacether_get_settings(struct net_device *dev,
+		struct ethtool_cmd *cmd)
+{
+	struct vmac_priv *ap = netdev_priv(dev);
+	struct phy_device *phydev = ap->phy_dev;
+
+	if (!phydev)
+		return -ENODEV;
+
+	return phy_ethtool_gset(phydev, cmd);
+}
+
+static int vmacether_set_settings(struct net_device *dev,
+		struct ethtool_cmd *cmd)
+{
+	struct vmac_priv *ap = netdev_priv(dev);
+	struct phy_device *phydev = ap->phy_dev;
+
+	if (!phydev)
+		return -ENODEV;
+
+	return phy_ethtool_sset(phydev, cmd);
+}
+
+static int vmac_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	struct vmac_priv *ap = netdev_priv(dev);
+	struct phy_device *phydev = ap->phy_dev;
+
+	if (!netif_running(dev))
+		return -EINVAL;
+
+	if (!phydev)
+		return -ENODEV;
+
+	return phy_mii_ioctl(phydev, if_mii(rq) /*rq*/, cmd);
+}
+
+static void vmacether_get_drvinfo(struct net_device *dev,
+		struct ethtool_drvinfo *info)
+{
+	struct vmac_priv *ap = netdev_priv(dev);
+
+	strlcpy(info->driver, DRV_NAME, sizeof(info->driver));
+	strlcpy(info->version, DRV_VERSION, sizeof(info->version));
+	snprintf(info->bus_info, sizeof(info->bus_info),
+			"platform 0x%pP", &ap->mem->start);
+}
+
+static int update_error_counters_unlocked(struct net_device *dev, int status)
+{
+	struct vmac_priv *ap = netdev_priv(dev);
+	dev_dbg(&ap->pdev->dev, "rx error counter overrun. status = 0x%x\n",
+			status);
+
+	/* programming error */
+	WARN_ON(status & TXCH_MASK);
+	WARN_ON(!(status & (MSER_MASK | RXCR_MASK | RXFR_MASK | RXFL_MASK)));
+
+	if (status & MSER_MASK)
+		dev->stats.rx_over_errors += 256; /* ran out of BD */
+	if (status & RXCR_MASK)
+		dev->stats.rx_crc_errors += 256;
+	if (status & RXFR_MASK)
+		dev->stats.rx_frame_errors += 256;
+	if (status & RXFL_MASK)
+		dev->stats.rx_fifo_errors += 256;
+
+	return 0;
+}
+
+static void update_tx_errors_unlocked(struct net_device *dev, int status)
+{
+	struct vmac_priv *ap = netdev_priv(dev);
+
+	if (status & BD_UFLO)
+		dev->stats.tx_fifo_errors++;
+
+	if (ap->duplex)
+		return;
+
+	/* half duplex flags */
+	if (status & BD_LTCL)
+		dev->stats.tx_window_errors++;
+	if (status & BD_RETRY_CT)
+		dev->stats.collisions += (status & BD_RETRY_CT) >> 24;
+	if (status & BD_DROP)  /* too many retries */
+		dev->stats.tx_aborted_errors++;
+	if (status & BD_DEFER)
+		dev_vdbg(&ap->pdev->dev, "\"defer to traffic\"\n");
+	if (status & BD_CARLOSS)
+		dev->stats.tx_carrier_errors++;
+}
+
+static noinline int vmac_rx_reclaim_force_unlocked(struct net_device *dev)
+{
+	struct vmac_priv *ap = netdev_priv(dev);
+	int ct;
+
+	/* locking: no conurrency, runs only during shutdown */
+	WARN_ON(!ap->shutdown);
+
+	dev_dbg(&ap->pdev->dev, "need to release %d rx sk_buff\n",
+			fifo_used(&ap->rx_ring));
+
+	ct = 0;
+	while (!fifo_empty(&ap->rx_ring) && ct++ < ap->rx_ring.size) {
+		struct vmac_buffer_desc *desc;
+		struct sk_buff *skb;
+		int desc_idx;
+
+		desc_idx = ap->rx_ring.tail;
+		desc = &ap->rxbd[desc_idx];
+		fifo_inc_tail(&ap->rx_ring);
+
+		if (!ap->rx_skbuff[desc_idx]) {
+			dev_err(&ap->pdev->dev, "non-populated rx_skbuff found %d\n",
+					desc_idx);
+			continue;
+		}
+
+		skb = ap->rx_skbuff[desc_idx];
+		ap->rx_skbuff[desc_idx] = NULL;
+
+		dma_unmap_single(&ap->pdev->dev, desc->data, ap->rx_skb_size,
+		    DMA_FROM_DEVICE);
+
+		dev_kfree_skb(skb);
+	}
+
+	if (!fifo_empty(&ap->rx_ring)) {
+		dev_err(&ap->pdev->dev, "failed to reclaim %d rx sk_buff\n",
+				fifo_used(&ap->rx_ring));
+	}
+
+	return 0;
+}
+
+/* Function refills empty buffer descriptors and passes ownership to DMA */
+static int vmac_rx_refill_unlocked(struct net_device *dev)
+{
+	struct vmac_priv *ap = netdev_priv(dev);
+
+	/* locking: protect from refill_timer */
+	/* locking: fct owns area outside rx_ring, head exclusive tail,
+	 *	modifies head */
+
+	spin_lock(&ap->refill_lock);
+
+	WARN_ON(fifo_full(&ap->rx_ring));
+
+	while (!fifo_full(&ap->rx_ring)) {
+		struct vmac_buffer_desc *desc;
+		struct sk_buff *skb;
+		dma_addr_t p;
+		int desc_idx;
+
+		desc_idx = ap->rx_ring.head;
+		desc = &ap->rxbd[desc_idx];
+
+		/* make sure we read the actual descriptor status */
+		rmb();
+
+		if (ap->rx_skbuff[desc_idx]) {
+			/* dropped packet / buffer chaining */
+			fifo_inc_head(&ap->rx_ring);
+
+			/* return to DMA */
+			wmb();
+			desc->info = cpu_to_le32(BD_DMA_OWN | ap->rx_skb_size);
+			continue;
+		}
+
+		skb = netdev_alloc_skb_ip_align(dev, ap->rx_skb_size);
+		if (!skb) {
+			dev_info(&ap->pdev->dev, "failed to allocate rx_skb, skb's left %d\n",
+					fifo_used(&ap->rx_ring));
+			break;
+		}
+
+		ap->rx_skbuff[desc_idx] = skb;
+
+		p = dma_map_single(&ap->pdev->dev, skb->data, ap->rx_skb_size,
+				DMA_FROM_DEVICE);
+
+		desc->data = p;
+
+		wmb();
+		desc->info = cpu_to_le32(BD_DMA_OWN | ap->rx_skb_size);
+
+		fifo_inc_head(&ap->rx_ring);
+	}
+
+	spin_unlock(&ap->refill_lock);
+
+	/* If rx ring is still empty, set a timer to try allocating
+	 * again at a later time. */
+	if (fifo_empty(&ap->rx_ring) && netif_running(dev)) {
+		dev_warn(&ap->pdev->dev, "unable to refill rx ring\n");
+		ap->refill_timer.expires = jiffies + HZ;
+		add_timer(&ap->refill_timer);
+	}
+
+	return 0;
+}
+
+/*
+ * timer callback to defer refill rx queue in case we're OOM
+ */
+static void vmac_refill_rx_timer(unsigned long data)
+{
+	vmac_rx_refill_unlocked((struct net_device *)data);
+}
+
+/* merge buffer chaining  */
+struct sk_buff *vmac_merge_rx_buffers_unlocked(struct net_device *dev,
+		struct vmac_buffer_desc *after,
+		int pkt_len) /* data */
+{
+	struct vmac_priv *ap = netdev_priv(dev);
+	struct sk_buff *merge_skb, *cur_skb;
+	struct dma_fifo *rx_ring;
+	struct vmac_buffer_desc *desc;
+
+	/* locking: same as vmac_rx_receive */
+
+	rx_ring = &ap->rx_ring;
+	desc = &ap->rxbd[rx_ring->tail];
+
+	WARN_ON(desc == after);
+
+	/* strip FCS */
+	pkt_len -= 4;
+
+	merge_skb = netdev_alloc_skb_ip_align(dev, pkt_len);
+	if (!merge_skb) {
+		dev_err(&ap->pdev->dev, "failed to allocate merged rx_skb, rx skb's left %d\n",
+				fifo_used(rx_ring));
+
+		return NULL;
+	}
+
+	while (desc != after && pkt_len) {
+		struct vmac_buffer_desc *desc;
+		int buf_len, valid;
+
+		/* desc needs wrapping */
+		desc = &ap->rxbd[rx_ring->tail];
+		cur_skb = ap->rx_skbuff[rx_ring->tail];
+		WARN_ON(!cur_skb);
+
+		dma_unmap_single(&ap->pdev->dev, desc->data, ap->rx_skb_size,
+				DMA_FROM_DEVICE);
+
+		/* do not copy FCS */
+		buf_len = le32_to_cpu(desc->info) & BD_LEN;
+		valid = min(pkt_len, buf_len);
+		pkt_len -= valid;
+
+		memcpy(skb_put(merge_skb, valid), cur_skb->data, valid);
+
+		fifo_inc_tail(rx_ring);
+	}
+
+	/* merging_pressure++ */
+
+	if (unlikely(pkt_len != 0))
+		dev_err(&ap->pdev->dev, "buffer chaining bytes missing %d\n",
+				pkt_len);
+
+	WARN_ON(desc != after);
+
+	return merge_skb;
+}
+
+int vmac_rx_receive(struct net_device *dev, int budget)
+{
+	struct vmac_priv *ap = netdev_priv(dev);
+	struct vmac_buffer_desc *first;
+	int processed, pkt_len, pkt_err;
+	struct dma_fifo lookahead;
+
+	/* true concurrency -> DMA engine running in parallel */
+	/* locking: fct owns rx_ring tail to current DMA read position, alias
+	 * 'received packets'. rx_refill owns area outside rx_ring, doesn't
+	 * modify tail */
+
+	processed = 0;
+
+	first = NULL;
+	pkt_err = pkt_len = 0;
+
+	/* look ahead, till packet complete */
+	lookahead = ap->rx_ring;
+
+	do {
+		struct vmac_buffer_desc *desc; /* cur_ */
+		int desc_idx; /* cur_ */
+		struct sk_buff *skb; /* pkt_ */
+
+		desc_idx = lookahead.tail;
+		desc = &ap->rxbd[desc_idx];
+
+		/* make sure we read the actual descriptor status */
+		rmb();
+
+		/* break if dma ownership belongs to hw */
+		if (desc->info & cpu_to_le32(BD_DMA_OWN)) {
+			/* safe the dma position */
+			ap->dma_rx_head = vmac_readl(ap, MAC_RXRING_HEAD);
+			break;
+		}
+
+		if (desc->info & cpu_to_le32(BD_FRST)) {
+			pkt_len = 0;
+			pkt_err = 0;
+
+			/* don't free current */
+			ap->rx_ring.tail = lookahead.tail;
+			first = desc;
+		}
+
+		fifo_inc_tail(&lookahead);
+
+		/* check bd */
+
+		pkt_len += desc->info & cpu_to_le32(BD_LEN);
+		pkt_err |= desc->info & cpu_to_le32(BD_BUFF);
+
+		if (!(desc->info & cpu_to_le32(BD_LAST)))
+			continue;
+
+		/* received complete packet */
+
+		if (unlikely(pkt_err || !first)) {
+			/* recycle buffers */
+			ap->rx_ring.tail = lookahead.tail;
+			continue;
+		}
+
+#ifdef DEBUG
+		WARN_ON(!(first->info & cpu_to_le32(BD_FRST)) ||
+				!(desc->info & cpu_to_le32(BD_LAST)));
+		WARN_ON(pkt_err);
+#endif
+
+		/* -- valid packet -- */
+
+		if (first != desc) {
+			skb = vmac_merge_rx_buffers_unlocked(dev, desc,
+					pkt_len);
+
+			if (!skb) {
+				/* kill packet */
+				ap->rx_ring.tail = lookahead.tail;
+				ap->rx_merge_error++;
+				continue;
+			}
+		} else {
+			dma_unmap_single(&ap->pdev->dev, desc->data,
+					ap->rx_skb_size, DMA_FROM_DEVICE);
+
+			skb = ap->rx_skbuff[desc_idx];
+			ap->rx_skbuff[desc_idx] = NULL;
+			/* desc->data != skb->data => desc->data is DMA
+			 * mapped */
+
+			/* strip FCS */
+			skb_put(skb, pkt_len - ETH_FCS_LEN);
+		}
+
+		/* free buffers */
+		ap->rx_ring.tail = lookahead.tail;
+
+#ifdef DEBUG
+		WARN_ON(skb->len != pkt_len - ETH_FCS_LEN);
+#endif
+		processed++;
+		skb->protocol = eth_type_trans(skb, dev);
+		dev->stats.rx_packets++;
+		dev->stats.rx_bytes += skb->len;
+		netif_receive_skb(skb);
+
+	} while (!fifo_empty(&lookahead) && (processed < budget));
+
+	dev_vdbg(&ap->pdev->dev, "processed pkt %d, remaining rx buff %d\n",
+			processed,
+			fifo_used(&ap->rx_ring));
+
+	if (processed || fifo_empty(&ap->rx_ring))
+		vmac_rx_refill_unlocked(dev);
+
+	return processed;
+}
+
+static void vmac_toggle_irqmask_unlocked(struct net_device *dev, int enable,
+		int mask)
+{
+	struct vmac_priv *ap = netdev_priv(dev);
+	unsigned long tmp;
+
+	tmp = vmac_readl(ap, ENABLE);
+	if (enable)
+		tmp |= mask;
+	else
+		tmp &= ~mask;
+	vmac_writel(ap, tmp, ENABLE);
+}
+
+static inline void vmac_toggle_txint_unlocked(struct net_device *dev, int enable)
+{
+	vmac_toggle_irqmask_unlocked(dev, enable, TXINT_MASK);
+}
+
+static inline void vmac_toggle_rxint_unlocked(struct net_device *dev, int enable)
+{
+	vmac_toggle_irqmask_unlocked(dev, enable, RXINT_MASK);
+}
+
+static int vmac_poll(struct napi_struct *napi, int budget)
+{
+	struct vmac_priv *ap;
+	struct net_device *dev;
+	int rx_work_done;
+	unsigned long flags;
+
+	ap = container_of(napi, struct vmac_priv, napi);
+	dev = ap->dev;
+
+	/* ack interrupt */
+	spin_lock_irqsave(&ap->lock, flags);
+	vmac_writel(ap, RXINT_MASK, STAT);
+	spin_unlock_irqrestore(&ap->lock, flags);
+
+	rx_work_done = vmac_rx_receive(dev, budget);
+
+	if (0 && printk_ratelimit()) {
+		dev_dbg(&ap->pdev->dev, "poll budget %d receive rx_work_done %d\n",
+				budget,
+				rx_work_done);
+	}
+
+	if (rx_work_done >= budget) {
+		/* rx queue is not yet empty/clean */
+		return rx_work_done;
+	}
+
+	/* no more packet in rx/tx queue, remove device from poll
+	 * queue */
+	spin_lock_irqsave(&ap->lock, flags);
+	napi_complete(napi);
+	vmac_toggle_rxint_unlocked(dev, 1);
+	spin_unlock_irqrestore(&ap->lock, flags);
+
+	return rx_work_done;
+}
+
+static int vmac_tx_reclaim_unlocked(struct net_device *dev, int force);
+
+static irqreturn_t vmac_intr(int irq, void *dev_instance)
+{
+	struct net_device *dev = dev_instance;
+	struct vmac_priv *ap = netdev_priv(dev);
+	unsigned int status;
+
+	spin_lock(&ap->lock);
+
+	status = vmac_readl(ap, STAT);
+	vmac_writel(ap, status, STAT);
+
+#ifdef DEBUG
+	if (unlikely(ap->shutdown))
+		dev_err(&ap->pdev->dev, "ISR during close\n");
+
+	if (unlikely(!status & (RXINT_MASK|MDIO_MASK|ERR_MASK)))
+		dev_err(&ap->pdev->dev, "No source of IRQ found\n");
+#endif
+
+	if ((status & RXINT_MASK) &&
+			(ap->dma_rx_head !=
+			 vmac_readl(ap, MAC_RXRING_HEAD))) {
+		vmac_toggle_rxint_unlocked(dev, 0);
+		napi_schedule(&ap->napi);
+	}
+
+	if (unlikely(netif_queue_stopped(dev) && (status & TXINT_MASK)))
+		vmac_tx_reclaim_unlocked(dev, 0);
+
+	if (status & MDIO_MASK)
+		complete(&ap->mdio_complete);
+
+	if (unlikely(status & ERR_MASK))
+		update_error_counters_unlocked(dev, status);
+
+	spin_unlock(&ap->lock);
+
+	return IRQ_HANDLED;
+}
+
+static noinline int vmac_tx_reclaim_unlocked(struct net_device *dev, int force)
+{
+	struct vmac_priv *ap = netdev_priv(dev);
+	int released = 0;
+
+	/* locking: modifies tx_ring tail, head only during shutdown */
+	/* locking: call with ap->lock held */
+	WARN_ON(force && !ap->shutdown);
+
+	/* buffer chaining not used, see vmac_start_xmit */
+
+	while (!fifo_empty(&ap->tx_ring)) {
+		struct vmac_buffer_desc *desc;
+		struct sk_buff *skb;
+		int desc_idx;
+
+		desc_idx = ap->tx_ring.tail;
+		desc = &ap->txbd[desc_idx];
+
+		/* ensure other field of the descriptor were not read
+		 * before we checked ownership */
+		rmb();
+
+		if ((desc->info & cpu_to_le32(BD_DMA_OWN)) && !force)
+			break;
+
+		if (desc->info & cpu_to_le32(BD_TX_ERR)) {
+			update_tx_errors_unlocked(dev,
+					le32_to_cpu(desc->info));
+			/* recycle packet, let upper level deal with it */
+		}
+
+		skb = ap->tx_skbuff[desc_idx];
+		ap->tx_skbuff[desc_idx] = NULL;
+		WARN_ON(!skb);
+
+		dma_unmap_single(&ap->pdev->dev, desc->data, skb->len,
+				DMA_TO_DEVICE);
+
+		dev_kfree_skb_any(skb);
+
+		released++;
+		fifo_inc_tail(&ap->tx_ring);
+	}
+
+	if (netif_queue_stopped(dev) && released) {
+		netif_wake_queue(dev);
+		vmac_toggle_txint_unlocked(dev, 0);
+	}
+
+	if (unlikely(force && !fifo_empty(&ap->tx_ring))) {
+		dev_err(&ap->pdev->dev, "failed to reclaim %d tx sk_buff\n",
+				fifo_used(&ap->tx_ring));
+	}
+
+	return released;
+}
+
+int vmac_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct vmac_priv *ap = netdev_priv(dev);
+	struct vmac_buffer_desc *desc;
+	unsigned long flags;
+	unsigned int tmp;
+
+	/* running under xmit lock */
+	/* locking: modifies tx_ring head, tx_reclaim only tail */
+
+	/* no scatter/gatter see features below */
+	WARN_ON(skb_shinfo(skb)->nr_frags != 0);
+	WARN_ON(skb->len > MAX_TX_BUFFER_LEN);
+
+	/* lock device data */
+	spin_lock_irqsave(&ap->lock, flags);
+
+	if (unlikely(fifo_full(&ap->tx_ring))) {
+		netif_stop_queue(dev);
+		vmac_toggle_txint_unlocked(dev, 1);
+		/* unlock device data */
+		spin_unlock_irqrestore(&ap->lock, flags);
+
+		dev_err(&ap->pdev->dev, "xmit called with no tx desc available\n");
+		return NETDEV_TX_BUSY;
+	}
+
+	/* unlock device data */
+	spin_unlock_irqrestore(&ap->lock, flags);
+
+	if (unlikely(skb->len < ETH_ZLEN)) {
+		struct sk_buff *short_skb;
+		short_skb = netdev_alloc_skb_ip_align(dev, ETH_ZLEN);
+		if (!short_skb)
+			return NETDEV_TX_LOCKED;
+
+		memset(short_skb->data, 0, ETH_ZLEN);
+		memcpy(skb_put(short_skb, ETH_ZLEN), skb->data, skb->len);
+		dev_kfree_skb(skb);
+		skb = short_skb;
+	}
+
+	/* fill descriptor */
+	ap->tx_skbuff[ap->tx_ring.head] = skb;
+	desc = &ap->txbd[ap->tx_ring.head];
+	WARN_ON(desc->info & cpu_to_le32(BD_DMA_OWN));
+
+	desc->data = dma_map_single(&ap->pdev->dev, skb->data, skb->len,
+			DMA_TO_DEVICE);
+
+	/* dma might already be polling */
+	wmb();
+	desc->info = cpu_to_le32(BD_DMA_OWN | BD_FRST | BD_LAST | skb->len);
+	wmb();
+
+	/* lock device data */
+	spin_lock_irqsave(&ap->lock, flags);
+
+	/* kick tx dma */
+	tmp = vmac_readl(ap, STAT);
+	vmac_writel(ap, tmp | TXPL_MASK, STAT);
+
+	dev->stats.tx_packets++;
+	dev->stats.tx_bytes += skb->len;
+	fifo_inc_head(&ap->tx_ring);
+
+	/* vmac_tx_reclaim outside of vmac_tx_timeout */
+	if (fifo_used(&ap->tx_ring) > (TX_BDT_LEN/2))
+		vmac_tx_reclaim_unlocked(dev, 0);
+
+	/* stop queue if no more desc available */
+	if (fifo_full(&ap->tx_ring)) {
+		netif_stop_queue(dev);
+		vmac_toggle_txint_unlocked(dev, 1);
+	}
+
+	/* unlock device data */
+	spin_unlock_irqrestore(&ap->lock, flags);
+
+	return NETDEV_TX_OK;
+}
+
+static int alloc_buffers_unlocked(struct net_device *dev)
+{
+	struct vmac_priv *ap = netdev_priv(dev);
+	int err = -ENOMEM;
+	int size;
+
+	fifo_init(&ap->rx_ring, RX_BDT_LEN);
+	fifo_init(&ap->tx_ring, TX_BDT_LEN);
+
+	/* initialize skb list */
+	memset(ap->rx_skbuff, 0, sizeof(ap->rx_skbuff));
+	memset(ap->tx_skbuff, 0, sizeof(ap->tx_skbuff));
+
+	/* allocate DMA received descriptors */
+	size = sizeof(*ap->rxbd) * ap->rx_ring.size;
+	ap->rxbd = dma_alloc_coherent(&ap->pdev->dev, size,
+			&ap->rxbd_dma,
+			GFP_KERNEL);
+	if (ap->rxbd == NULL)
+		goto err_out;
+
+	/* allocate DMA transmit descriptors */
+	size = sizeof(*ap->txbd) * ap->tx_ring.size;
+	ap->txbd = dma_alloc_coherent(&ap->pdev->dev, size,
+			&ap->txbd_dma,
+			GFP_KERNEL);
+	if (ap->txbd == NULL)
+		goto err_free_rxbd;
+
+	/* ensure 8-byte aligned */
+	WARN_ON(((uintptr_t)ap->txbd & 0x7) || ((uintptr_t)ap->rxbd & 0x7));
+
+	memset(ap->txbd, 0, sizeof(*ap->txbd) * ap->tx_ring.size);
+	memset(ap->rxbd, 0, sizeof(*ap->rxbd) * ap->rx_ring.size);
+
+	/* allocate rx skb */
+	err = vmac_rx_refill_unlocked(dev);
+	if (err)
+		goto err_free_txbd;
+
+	return 0;
+
+err_free_txbd:
+	dma_free_coherent(&ap->pdev->dev, sizeof(*ap->txbd) * ap->tx_ring.size,
+			ap->txbd, ap->txbd_dma);
+err_free_rxbd:
+	dma_free_coherent(&ap->pdev->dev, sizeof(*ap->rxbd) * ap->rx_ring.size,
+			ap->rxbd, ap->rxbd_dma);
+err_out:
+	return err;
+}
+
+static noinline int free_buffers_unlocked(struct net_device *dev)
+{
+	struct vmac_priv *ap = netdev_priv(dev);
+
+	/* free skbuff */
+	vmac_tx_reclaim_unlocked(dev, 1);
+	vmac_rx_reclaim_force_unlocked(dev);
+
+	/* free DMA ring */
+	dma_free_coherent(&ap->pdev->dev, sizeof(*ap->txbd) * ap->tx_ring.size,
+			ap->txbd, ap->txbd_dma);
+	dma_free_coherent(&ap->pdev->dev, sizeof(*ap->rxbd) * ap->rx_ring.size,
+			ap->rxbd, ap->rxbd_dma);
+
+	return 0;
+}
+
+static int vmac_hw_init(struct net_device *dev)
+{
+	struct vmac_priv *priv = netdev_priv(dev);
+
+	/* clear IRQ mask */
+	vmac_writel(priv, 0, ENABLE);
+
+	/* clear pending IRQ */
+	vmac_writel(priv, 0xffffffff, STAT);
+
+	/* Initialize logical address filter */
+	vmac_writel(priv, 0x0, LAFL);
+	vmac_writel(priv, 0x0, LAFH);
+
+	return 0;
+}
+
+int vmac_open(struct net_device *dev)
+{
+	struct vmac_priv *ap = netdev_priv(dev);
+	struct phy_device *phydev;
+	unsigned int temp, ctrl;
+	int err = 0;
+
+	/* locking: no concurrency yet */
+
+	if (ap == NULL)
+		return -ENODEV;
+
+	ap->shutdown = 0;
+
+	vmac_hw_init(dev);
+
+	/* mac address changed? */
+	write_mac_reg(dev, dev->dev_addr);
+
+	err = alloc_buffers_unlocked(dev);
+	if (err)
+		return err;
+
+	/* install DMA ring pointers */
+	vmac_writel(ap, ap->rxbd_dma, RXRINGPTR);
+	vmac_writel(ap, ap->txbd_dma, TXRINGPTR);
+
+	/* set poll rate to 1 ms */
+	vmac_writel(ap, POLLRATE_TIME, POLLRATE);
+
+	/* Set control */
+	ctrl = (RX_BDT_LEN << 24) | (TX_BDT_LEN << 16) | TXRN_MASK | RXRN_MASK;
+	vmac_writel(ap, ctrl, CONTROL);
+
+	/* make sure we enable napi before rx interrupt  */
+	napi_enable(&ap->napi);
+
+	err = request_irq(dev->irq, &vmac_intr, 0, dev->name, dev);
+	if (err) {
+		dev_err(&ap->pdev->dev, "Unable to request IRQ %d (error %d)\n",
+				dev->irq, err);
+		goto err_free_buffers;
+	}
+
+	/* IRQ mask */
+	temp = RXINT_MASK | ERR_MASK | TXCH_MASK | MDIO_MASK;
+	vmac_writel(ap, temp, ENABLE);
+
+	/* enable, after all other bits are set */
+	vmac_writel(ap, ctrl | EN_MASK, CONTROL);
+
+	/* locking: concurrency */
+	netif_start_queue(dev);
+	netif_carrier_off(dev);
+
+	/* register the PHY board fixup, if needed */
+	err = vmac_mii_init(ap);
+	if (err)
+		goto err_free_irq;
+
+	/* schedule a link state check */
+	phy_start(ap->phy_dev);
+
+	phydev = ap->phy_dev;
+	dev_info(&ap->pdev->dev, "PHY driver [%s] (mii_bus:phy_addr=%s, irq=%d)\n",
+	       phydev->drv->name, dev_name(&phydev->dev), phydev->irq);
+
+	return 0;
+
+err_free_irq:
+	free_irq(dev->irq, dev);
+err_free_buffers:
+	napi_disable(&ap->napi);
+	free_buffers_unlocked(dev);
+	return err;
+}
+
+int vmac_close(struct net_device *dev)
+{
+	struct vmac_priv *ap = netdev_priv(dev);
+	unsigned long flags;
+	unsigned int temp;
+
+	netif_stop_queue(dev);
+	napi_disable(&ap->napi);
+	del_timer_sync(&ap->refill_timer);
+
+	/* shut it down now */
+	ap->shutdown = 1;
+
+	/* locking: protect everything, DMA / IRQ / timer */
+	spin_lock_irqsave(&ap->lock, flags);
+
+	/* complete running transfer, then stop */
+	temp = vmac_readl(ap, CONTROL);
+	temp &= ~(TXRN_MASK | RXRN_MASK);
+	vmac_writel(ap, temp, CONTROL);
+
+	/* reenable IRQ, process pending */
+	spin_unlock_irqrestore(&ap->lock, flags);
+
+	/* wait for the tasks to be finished */
+	set_current_state(TASK_INTERRUPTIBLE);
+	schedule_timeout(msecs_to_jiffies(20));
+
+	/* disable phy */
+	phy_stop(ap->phy_dev);
+	vmac_mii_exit_unlocked(dev);
+	netif_carrier_off(dev);
+
+	/* disable interrupts */
+	vmac_writel(ap, 0, ENABLE);
+	free_irq(dev->irq, dev);
+
+	/* turn off vmac */
+	vmac_writel(ap, 0, CONTROL);
+	/* vmac_reset_hw(vmac) */
+
+	free_buffers_unlocked(dev);
+
+	return 0;
+}
+
+void update_vmac_stats_unlocked(struct net_device *dev)
+{
+	struct net_device_stats *_stats = &dev->stats;
+	struct vmac_priv *ap = netdev_priv(dev);
+	unsigned long miss, rxerr;
+	unsigned long rxfram, rxcrc, rxoflow;
+
+	/* compare with /proc/net/dev,
+	 * see net/core/dev.c:dev_seq_printf_stats */
+
+	/* rx stats */
+	rxerr = vmac_readl(ap, RXERR);
+	miss = vmac_readl(ap, MISS);
+
+	rxcrc = (rxerr & RXERR_CRC);
+	rxfram = (rxerr & RXERR_FRM) >> 8;
+	rxoflow = (rxerr & RXERR_OFLO) >> 16;
+
+	_stats->rx_length_errors = 0;
+	_stats->rx_over_errors += miss;
+	_stats->rx_crc_errors += rxcrc;
+	_stats->rx_frame_errors += rxfram;
+	_stats->rx_fifo_errors += rxoflow;
+	_stats->rx_missed_errors = 0;
+
+	/* TODO check rx_dropped/rx_errors/tx_dropped/tx_errors have not
+	 * been updated elsewhere */
+	_stats->rx_dropped = _stats->rx_over_errors +
+		_stats->rx_fifo_errors +
+		ap->rx_merge_error;
+
+	_stats->rx_errors = _stats->rx_length_errors + _stats->rx_crc_errors +
+		_stats->rx_frame_errors +
+		_stats->rx_missed_errors +
+		_stats->rx_dropped;
+
+	/* tx stats */
+	_stats->tx_dropped = 0; /* otherwise queue stopped */
+
+	_stats->tx_errors = _stats->tx_aborted_errors +
+		_stats->tx_carrier_errors +
+		_stats->tx_fifo_errors +
+		_stats->tx_heartbeat_errors +
+		_stats->tx_window_errors +
+		_stats->tx_dropped +
+		ap->tx_timeout_error;
+}
+
+struct net_device_stats *vmac_stats(struct net_device *dev)
+{
+	/* struct vmac_priv *ap = netdev_priv(dev); */
+
+	update_vmac_stats_unlocked(dev);
+
+	return &dev->stats;
+}
+
+void vmac_tx_timeout(struct net_device *dev)
+{
+	struct vmac_priv *ap = netdev_priv(dev);
+	unsigned int status;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ap->lock, flags);
+
+	/* queue did not progress for timeo jiffies */
+	WARN_ON(!netif_queue_stopped(dev));
+	WARN_ON(!fifo_full(&ap->tx_ring));
+
+	/* TX IRQ lost? */
+	status = vmac_readl(ap, STAT);
+	if (status & TXINT_MASK) {
+		dev_err(&ap->pdev->dev, "lost tx interrupt, IRQ mask %x\n",
+				vmac_readl(ap, ENABLE));
+		vmac_writel(ap, TXINT_MASK, STAT);
+	}
+
+	/* TODO RX/MDIO/ERR as well? */
+
+	vmac_tx_reclaim_unlocked(dev, 0);
+	if (fifo_full(&ap->tx_ring))
+		dev_err(&ap->pdev->dev, "DMA state machine not active\n");
+
+	/* We can accept TX packets again */
+	ap->tx_timeout_error++;
+	spin_unlock_irqrestore(&ap->lock, flags);
+
+	netif_wake_queue(dev);
+}
+
+static void create_multicast_filter(struct net_device *dev,
+	unsigned long *bitmask)
+{
+	u32 crc;
+	char *addrs;
+
+	/* locking: done by net_device */
+
+	WARN_ON(netdev_mc_count(dev) == 0);
+	WARN_ON(dev->flags & IFF_ALLMULTI);
+
+	bitmask[0] = bitmask[1] = 0;
+
+	{
+		struct dev_addr_list * ha;
+		netdev_for_each_mc_addr(ha, dev) {
+			addrs = ha->da_addr;
+
+			/* skip non-multicast addresses */
+			if (!(*addrs & 1))
+				continue;
+
+			crc = ether_crc_le(ETH_ALEN, addrs);
+			set_bit((crc >> 26) & 0x3f, bitmask);
+		}
+	}
+}
+
+static void vmac_set_multicast_list(struct net_device *dev)
+{
+	struct vmac_priv *ap = netdev_priv(dev);
+	unsigned long flags, bitmask[2];
+	int promisc, reg;
+
+	spin_lock_irqsave(&ap->lock, flags);
+
+	promisc = !!(dev->flags & IFF_PROMISC);
+	reg = vmac_readl(ap, ENABLE);
+	if (promisc != !!(reg & PROM_MASK)) {
+		reg ^= PROM_MASK;
+		vmac_writel(ap, reg, ENABLE);
+	}
+
+	if (dev->flags & IFF_ALLMULTI)
+		memset(bitmask, 1, sizeof(bitmask));
+	else if (netdev_mc_count(dev) == 0)
+		memset(bitmask, 0, sizeof(bitmask));
+	else
+		create_multicast_filter(dev, bitmask);
+
+	vmac_writel(ap, bitmask[0], LAFL);
+	vmac_writel(ap, bitmask[1], LAFH);
+
+	spin_unlock_irqrestore(&ap->lock, flags);
+}
+
+static const struct ethtool_ops vmac_ethtool_ops = {
+	.get_settings		= vmacether_get_settings,
+	.set_settings		= vmacether_set_settings,
+	.get_drvinfo		= vmacether_get_drvinfo,
+	.get_link		= ethtool_op_get_link,
+};
+
+static const struct net_device_ops vmac_netdev_ops = {
+	.ndo_open		= vmac_open,
+	.ndo_stop		= vmac_close,
+	.ndo_get_stats		= vmac_stats,
+	.ndo_start_xmit		= vmac_start_xmit,
+	.ndo_do_ioctl		= vmac_ioctl,
+	.ndo_set_mac_address	= eth_mac_addr,
+	.ndo_tx_timeout		= vmac_tx_timeout,
+	.ndo_set_multicast_list = vmac_set_multicast_list,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_change_mtu		= eth_change_mtu,
+};
+
+static int get_register_map(struct vmac_priv *ap)
+{
+	int err;
+
+	err = -EBUSY;
+	if (!request_mem_region(ap->mem->start, resource_size(ap->mem),
+				DRV_NAME)) {
+		dev_err(&ap->pdev->dev, "no memory region available\n");
+		return err;
+	}
+
+	err = -ENOMEM;
+	ap->regs = ioremap(ap->mem->start, resource_size(ap->mem));
+	if (!ap->regs) {
+		dev_err(&ap->pdev->dev, "failed to map registers, aborting.\n");
+		goto err_out_release_mem;
+	}
+
+	return 0;
+
+err_out_release_mem:
+	release_mem_region(ap->mem->start, resource_size(ap->mem));
+	return err;
+}
+
+static int put_register_map(struct vmac_priv *ap)
+{
+	iounmap(ap->regs);
+	release_mem_region(ap->mem->start, resource_size(ap->mem));
+	return 0;
+}
+
+static int __devinit vmac_probe(struct platform_device *pdev)
+{
+	struct net_device *dev;
+	struct vmac_priv *ap;
+	struct resource *mem;
+	int err;
+
+	/* locking: no concurrency */
+
+	if (dma_get_mask(&pdev->dev) > DMA_BIT_MASK(32) ||
+			pdev->dev.coherent_dma_mask > DMA_BIT_MASK(32)) {
+		dev_err(&pdev->dev, "arcvmac supports only 32-bit DMA addresses\n");
+		return -ENODEV;
+	}
+
+	dev = alloc_etherdev(sizeof(*ap));
+	if (!dev) {
+		dev_err(&pdev->dev, "etherdev alloc failed, aborting.\n");
+		return -ENOMEM;
+	}
+
+	ap = netdev_priv(dev);
+
+	err = -ENODEV;
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!mem) {
+		dev_err(&pdev->dev, "no mmio resource defined\n");
+		goto err_out;
+	}
+	ap->mem = mem;
+
+	err = platform_get_irq(pdev, 0);
+	if (err < 0) {
+		dev_err(&pdev->dev, "no irq found\n");
+		goto err_out;
+	}
+	dev->irq = err;
+
+	spin_lock_init(&ap->lock);
+
+	SET_NETDEV_DEV(dev, &pdev->dev);
+	ap->dev = dev;
+	ap->pdev = pdev;
+
+	/* init rx timeout (used for oom) */
+	init_timer(&ap->refill_timer);
+	ap->refill_timer.function = vmac_refill_rx_timer;
+	ap->refill_timer.data = (unsigned long)dev;
+	spin_lock_init(&ap->refill_lock);
+
+	netif_napi_add(dev, &ap->napi, vmac_poll, 64);
+	dev->netdev_ops = &vmac_netdev_ops;
+	dev->ethtool_ops = &vmac_ethtool_ops;
+
+	dev->flags |= IFF_MULTICAST;
+
+	dev->base_addr = (unsigned long)ap->regs; /* TODO */
+
+	/* prevent buffer chaining, favor speed over space */
+	ap->rx_skb_size = ETH_FRAME_LEN + VMAC_BUFFER_PAD;
+
+
+	/* private struct functional */
+
+	/* temporarily map registers to fetch mac addr */
+	err = get_register_map(ap);
+	if (err)
+		goto err_out;
+
+	/* mac address intialize, set vmac_open  */
+	read_mac_reg(dev, dev->dev_addr); /* TODO */
+
+	if (!is_valid_ether_addr(dev->dev_addr))
+		random_ether_addr(dev->dev_addr);
+
+	err = register_netdev(dev);
+	if (err) {
+		dev_err(&pdev->dev, "Cannot register net device, aborting.\n");
+		goto err_out;
+	}
+
+	dev_info(&pdev->dev, "ARC VMAC at 0x%pP irq %d %pM\n", &mem->start,
+	    dev->irq, dev->dev_addr);
+	platform_set_drvdata(pdev, ap);
+
+	return 0;
+
+err_out:
+	free_netdev(dev);
+	return err;
+}
+
+static int __devexit vmac_remove(struct platform_device *pdev)
+{
+	struct vmac_priv *ap;
+
+	/* locking: no concurrency */
+
+	ap = platform_get_drvdata(pdev);
+	if (!ap) {
+		dev_err(&pdev->dev, "vmac_remove no valid dev found\n");
+		return 0;
+	}
+
+	/* MAC */
+	unregister_netdev(ap->dev);
+
+	/* release the memory region */
+	put_register_map(ap);
+	netif_napi_del(&ap->napi);
+
+	platform_set_drvdata(pdev, NULL);
+	free_netdev(ap->dev);
+	return 0;
+}
+
+static struct platform_driver arcvmac_driver = {
+	.probe		= vmac_probe,
+	.remove		= __devexit_p(vmac_remove),
+	.driver		= {
+		.name		= "arcvmac",
+	},
+};
+
+static int __init vmac_init(void)
+{
+	return platform_driver_register(&arcvmac_driver);
+}
+
+static void __exit vmac_exit(void)
+{
+	platform_driver_unregister(&arcvmac_driver);
+}
+
+module_init(vmac_init);
+module_exit(vmac_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("ARC VMAC Ethernet driver");
+MODULE_AUTHOR("afenkart@xxxxxxxxx");
diff --git a/drivers/net/arcvmac.h b/drivers/net/arcvmac.h
new file mode 100644
index 0000000..93d25b8
--- /dev/null
+++ b/drivers/net/arcvmac.h
@@ -0,0 +1,265 @@
+/*
+ * ARC VMAC Driver
+ *
+ * Copyright (C) 2003-2006 Codito Technologies, for linux-2.4 port
+ * Copyright (C) 2006-2007 Celunite Inc, for linux-2.6 port
+ * Copyright (C) 2007-2008 Sagem Communications, Fehmi HAFSI
+ * Copyright (C) 2009-2011 Sagem Communications, Andreas Fenkart
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef _ARCVMAC_H
+#define _ARCVMAC_H
+
+#define DRV_NAME		"arcvmac"
+#define DRV_VERSION		"1.0"
+
+/* Buffer descriptors */
+#define TX_BDT_LEN		128    /* Number of receive BD's */
+#define RX_BDT_LEN		128   /* Number of transmit BD's */
+
+/* BD poll rate, in 1024 cycles. @100Mhz: x * 1024 cy * 10ns = 1ms */
+#define POLLRATE_TIME		200
+
+/* next power of two, bigger than ETH_FRAME_LEN + VLAN  */
+#define MAX_RX_BUFFER_LEN	0x800	/* 2^11 = 2048 = 0x800 */
+#define MAX_TX_BUFFER_LEN	0x800	/* 2^11 = 2048 = 0x800 */
+
+/* 14 bytes of ethernet header, 4 bytes VLAN, FCS,
+ * plus extra pad to prevent buffer chaining of
+ * maximum sized ethernet packets (1514 bytes) */
+#define	VMAC_BUFFER_PAD		(ETH_HLEN + 4 + ETH_FCS_LEN + 4)
+
+/* VMAC register definitions, offsets in bytes */
+#define VMAC_ID			0x00
+
+/* stat/enable use same bit mask */
+#define VMAC_STAT		0x04
+#define VMAC_ENABLE		0x08
+#  define TXINT_MASK		0x00000001 /* Transmit interrupt */
+#  define RXINT_MASK		0x00000002 /* Receive interrupt */
+#  define ERR_MASK		0x00000004 /* Error interrupt */
+#  define TXCH_MASK		0x00000008 /* Transmit chaining error */
+#  define MSER_MASK		0x00000010 /* Missed packet counter error */
+#  define RXCR_MASK		0x00000100 /* RXCRCERR counter rolled over	 */
+#  define RXFR_MASK		0x00000200 /* RXFRAMEERR counter rolled over */
+#  define RXFL_MASK		0x00000400 /* RXOFLOWERR counter rolled over */
+#  define MDIO_MASK		0x00001000 /* MDIO complete */
+#  define TXPL_MASK		0x80000000 /* TXPOLL */
+
+#define VMAC_CONTROL		0x0c
+#  define EN_MASK		0x00000001 /* VMAC enable */
+#  define TXRN_MASK		0x00000008 /* TX enable */
+#  define RXRN_MASK		0x00000010 /* RX enable */
+#  define DSBC_MASK		0x00000100 /* Disable receive broadcast */
+#  define ENFL_MASK		0x00000400 /* Enable Full Duplex */
+#  define PROM_MASK		0x00000800 /* Promiscuous mode */
+
+#define VMAC_POLLRATE		0x10
+
+#define VMAC_RXERR		0x14
+#  define RXERR_CRC		0x000000ff
+#  define RXERR_FRM		0x0000ff00
+#  define RXERR_OFLO		0x00ff0000 /* fifo overflow */
+
+#define VMAC_MISS		0x18
+#define VMAC_TXRINGPTR		0x1c
+#define VMAC_RXRINGPTR		0x20
+#define VMAC_ADDRL		0x24
+#define VMAC_ADDRH		0x28
+#define VMAC_LAFL		0x2c
+#define VMAC_LAFH		0x30
+#define VMAC_MAC_TXRING_HEAD	0x38
+#define VMAC_MAC_RXRING_HEAD	0x3C
+
+#define VMAC_MDIO_DATA		0x34
+#  define MDIO_SFD		0xC0000000
+#  define MDIO_OP		0x30000000
+#  define MDIO_ID_MASK		0x0F800000
+#  define MDIO_REG_MASK		0x007C0000
+#  define MDIO_TA		0x00030000
+#  define MDIO_DATA_MASK	0x0000FFFF
+/* common combinations */
+#  define MDIO_BASE		0x40020000
+#  define MDIO_OP_READ		0x20000000
+#  define MDIO_OP_WRITE		0x10000000
+
+/* Buffer descriptor INFO bit masks */
+#define BD_DMA_OWN		0x80000000 /* buffer ownership, 0 CPU, 1 DMA */
+#define BD_BUFF			0x40000000 /* buffer invalid, rx */
+#define BD_UFLO			0x20000000 /* underflow, tx */
+#define BD_LTCL			0x10000000 /* late collision, tx  */
+#define BD_RETRY_CT		0x0f000000 /* tx */
+#define BD_DROP			0x00800000 /* drop, more than 16 retries, tx */
+#define BD_DEFER		0x00400000 /* traffic on the wire, tx */
+#define BD_CARLOSS		0x00200000 /* carrier loss while transmission, tx, rx? */
+/* 20:19 reserved */
+#define BD_ADCR			0x00040000 /* add crc, ignored if not disaddcrc */
+#define BD_LAST			0x00020000 /* Last buffer in chain */
+#define BD_FRST			0x00010000 /* First buffer in chain */
+/* 15:11 reserved */
+#define BD_LEN			0x000007FF
+
+/* common combinations */
+#define BD_TX_ERR		(BD_UFLO | BD_LTCL | BD_RETRY_CT | BD_DROP | \
+		BD_DEFER | BD_CARLOSS)
+
+
+/* arcvmac private data structures */
+struct vmac_buffer_desc {
+	__le32 info;
+	__le32 data;
+};
+
+struct dma_fifo {
+	int head; /* head */
+	int tail; /* tail */
+	int size;
+};
+
+struct	vmac_priv {
+	struct net_device *dev;
+	struct platform_device *pdev;
+
+	struct completion mdio_complete;
+	spinlock_t lock; /* protects structure plus hw regs of device */
+
+	/* base address of register set */
+	char *regs;
+	struct resource *mem;
+
+	/* DMA ring buffers */
+	struct vmac_buffer_desc *rxbd;
+	dma_addr_t rxbd_dma;
+
+	struct vmac_buffer_desc *txbd;
+	dma_addr_t txbd_dma;
+
+	/* socket buffers */
+	struct sk_buff *rx_skbuff[RX_BDT_LEN];
+	struct sk_buff *tx_skbuff[TX_BDT_LEN];
+	int rx_skb_size;
+
+	/* skb / dma desc managing */
+	struct dma_fifo rx_ring; /* valid rx buffers */
+	struct dma_fifo tx_ring;
+
+	/* descriptor last polled/processed by the VMAC */
+	unsigned long dma_rx_head;
+
+	/* timer to retry rx skb allocation, if failed during receive */
+	struct timer_list refill_timer;
+	spinlock_t refill_lock;
+
+	struct napi_struct napi;
+
+	/* rx buffer chaining */
+	int rx_merge_error;
+	int tx_timeout_error;
+
+	/* PHY stuff */
+	struct mii_bus *mii_bus;
+	struct phy_device *phy_dev;
+
+	int link;
+	int speed;
+	int duplex;
+
+	/* debug */
+	int shutdown;
+};
+
+/* DMA ring management */
+
+/* for a fifo with size n,
+ * - [0..n] fill levels are n + 1 states
+ * - there are only n different deltas (head - tail) values
+ * => not all fill levels can be represented with head, tail
+ *    pointers only
+ * we give up the n fill level, aka fifo full */
+
+/* sacrifice one elt as a sentinel */
+static inline int fifo_used(struct dma_fifo *f);
+static inline int fifo_inc_ct(int ct, int size);
+static inline void fifo_dump(struct dma_fifo *fifo);
+
+static inline int fifo_empty(struct dma_fifo *f)
+{
+	return f->head == f->tail;
+}
+
+static inline int fifo_free(struct dma_fifo *f)
+{
+	int free;
+
+	free = f->tail - f->head;
+	if (free <= 0)
+		free += f->size;
+
+	return free;
+}
+
+static inline int fifo_used(struct dma_fifo *f)
+{
+	int used;
+
+	used = f->head - f->tail;
+	if (used < 0)
+		used += f->size;
+
+	return used;
+}
+
+static inline int fifo_full(struct dma_fifo *f)
+{
+	return (fifo_used(f) + 1) == f->size;
+}
+
+/* manipulate */
+static inline void fifo_init(struct dma_fifo *fifo, int size)
+{
+	fifo->size = size;
+	fifo->head = fifo->tail = 0; /* empty */
+}
+
+static inline void fifo_inc_head(struct dma_fifo *fifo)
+{
+	BUG_ON(fifo_full(fifo));
+	fifo->head = fifo_inc_ct(fifo->head, fifo->size);
+}
+
+static inline void fifo_inc_tail(struct dma_fifo *fifo)
+{
+	BUG_ON(fifo_empty(fifo));
+	fifo->tail = fifo_inc_ct(fifo->tail, fifo->size);
+}
+
+/* internal funcs */
+static inline void fifo_dump(struct dma_fifo *fifo)
+{
+	printk(KERN_INFO "fifo: head %d, tail %d, size %d\n", fifo->head,
+			fifo->tail,
+			fifo->size);
+}
+
+static inline int fifo_inc_ct(int ct, int size)
+{
+	return (++ct == size) ? 0 : ct;
+}
+
+#endif	  /* _ARCVMAC_H */
diff --git a/drivers/serial/Kconfig b/drivers/serial/Kconfig
index f55c494..8e58453 100644
--- a/drivers/serial/Kconfig
+++ b/drivers/serial/Kconfig
@@ -1506,4 +1506,61 @@ config SERIAL_GRLIB_GAISLER_APBUART_CONSOLE
 	help
 	Support for running a console on the GRLIB APBUART
 
+config SERIAL_CX2450X
+	bool "Conexant CX2450x SoC UART support"
+	depends on ARCH_NEVIS
+	select SERIAL_CORE
+	default y
+	help
+	  The Conexant CX2450x SoC has three 16550 style UARTs. Each of them
+	  can be routed to various pins, but note that the pin routing must
+	  be correctly setup by the Bootloader/BIOS.
+
+	  This driver reads the pin config and enables all configured ports.
+
+	  If you enable the serial console support for this driver, the
+	  lowest configured port is used as the system console
+
+choice
+	prompt "Default Baud Rate for CX2450x SoC UATR's"
+	depends on SERIAL_CX2450X
+	default SERIAL_CX2450X_BAUDRATE_115200
+
+config SERIAL_CX2450X_BAUDRATE_230400
+	bool "230400 Baud"
+
+config SERIAL_CX2450X_BAUDRATE_115200
+	bool "115200 Baud"
+
+config SERIAL_CX2450X_BAUDRATE_57600
+	bool "57600 Baud"
+
+config SERIAL_CX2450X_BAUDRATE_38400
+	bool "38400 Baud"
+
+config SERIAL_CX2450X_BAUDRATE_19200
+	bool "19200 Baud"
+
+config SERIAL_CX2450X_BOOTMSG_9600
+	bool "9600 Baud"
+
+endchoice
+
+config SERIAL_CX2450X_CONSOLE
+	bool "Conexant CX2450x SoC UART console support"
+	depends on SERIAL_CX2450X=y
+	select SERIAL_CORE_CONSOLE
+	default y
+	help
+	  Provides support for serial console.
+	  The lowest configured port is used for the system console.
+
+config SERIAL_CX2450X_BOOTMSG
+	bool "Print early boot messages on Conexant CX2450x SoC UART's"
+	depends on SERIAL_CX2450X=y
+	default y
+	help
+	  Enable this option to see the the full boot message. If disabled
+	  you will see the bootmessage from late the UART-init stage.
+
 endmenu
diff --git a/drivers/serial/Makefile b/drivers/serial/Makefile
index 6aa4723..efdb56e 100644
--- a/drivers/serial/Makefile
+++ b/drivers/serial/Makefile
@@ -83,3 +83,4 @@ obj-$(CONFIG_KGDB_SERIAL_CONSOLE) += kgdboc.o
 obj-$(CONFIG_SERIAL_QE) += ucc_uart.o
 obj-$(CONFIG_SERIAL_TIMBERDALE)	+= timbuart.o
 obj-$(CONFIG_SERIAL_GRLIB_GAISLER_APBUART) += apbuart.o
+obj-$(CONFIG_SERIAL_CX2450X) += cx2450x_uart.o
diff --git a/drivers/serial/cx2450x_uart.c b/drivers/serial/cx2450x_uart.c
new file mode 100644
index 0000000..a18b8d4
--- /dev/null
+++ b/drivers/serial/cx2450x_uart.c
@@ -0,0 +1,918 @@
+/*
+ *  linux/drivers/serial/cx2450x_uart.c
+ *
+ *  Driver for Conexant CX2450x SoC serial ports
+ *
+ *  Based on drivers/serial/cnxt.c, by Deep Blue Solutions which was 
+ *    based on drivers/char/serial.c, by Linus Torvalds, Theodore Ts'o.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <generated/autoconf.h>
+
+#if defined(CONFIG_SERIAL_CX2450X_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+#define SUPPORT_SYSRQ
+#endif
+
+#include <linux/module.h>
+#include <linux/tty.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/serial.h>
+#include <linux/console.h>
+#include <linux/sysrq.h>
+#include <linux/delay.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <mach/memmap.h>
+#include <mach/cx2450x.h>
+#include <mach/irqs.h>
+
+#include <linux/serial_core.h>
+#include <asm/mach/serial_cnxt.h>
+
+//#if defined(CONFIG_ARCH_PECOS) || defined(CONFIG_ARCH_NEVIS)
+//#define CNXT_SET(reg,mask,val)	(*(LPREG)(reg)) =  ((*(LPREG)(reg) & ~(mask)) | ((val) & (mask)))
+//#endif
+
+#define CNXT_ISR_PASS_LIMIT	256
+
+/* Access macros for the CNXT UARTs */
+#define UART_GET_INT_STATUS(p)	readl((p)->membase + CNXT_IRLVL)
+
+#define UART_PUT_BRDL(p, c)     writel((c), (p)->membase + CNXT_BRDL)
+#define UART_PUT_BRDH(p, c)     writel((c), (p)->membase + CNXT_BRDH)
+
+#define UART_GET_CHAR(p)	readl((p)->membase + CNXT_FIFO)
+#define UART_PUT_CHAR(p, c)	writel((c), (p)->membase + CNXT_FIFO)
+
+#define UART_GET_STAT(p)	readl((p)->membase + CNXT_STAT)
+
+#define UART_GET_IRQE(p)	readl((p)->membase + CNXT_IRQE)
+#define UART_PUT_IRQE(p,c)	writel((c), (p)->membase + CNXT_IRQE)
+
+#define UART_GET_FIFC(p)	readl((p)->membase + CNXT_FIFC)
+#define UART_PUT_FIFC(p,c)	writel((c), (p)->membase + CNXT_FIFC)
+
+#define UART_GET_FRMC(p)	readl((p)->membase + CNXT_FRMC)
+#define UART_PUT_FRMC(p,c)	writel((c), (p)->membase + CNXT_FRMC)
+
+#define UART_RX_NUMCHARS(p)	readl((p)->membase + CNXT_RXSTA)
+
+#define UART_TX_READY(s)	(((s) & CNXT_STAT_TID) != 0)
+
+#define UART_TX_EMPTY(p)	((UART_GET_STAT(p) & CNXT_STAT_TID) != 0)
+
+#define UART_PUT_EXP(p, c)    writel((c), (p)->membase + CNXT_EXP)
+
+#define UART_DUMMY_RSR_RX	256
+#define UART_PORT_SIZE		0x34
+
+/* On the CNXT boards, we're not going to implement RTS/CTS flow control
+ * (not yet anyway).  These would be GPIO's however.
+ */
+#define SC_CTRLC	(while (0);)
+#define SC_CTRLS	(while (0);)
+
+/* We wrap our port structure around the generic uart_port. */
+
+struct uart_cnxt_port {
+	struct uart_port port;
+	u32 num;
+	u32 dtr_enable;
+	u32 rts_enable;
+	u32 old_status;
+};
+
+static u32 have_uart[3];
+
+#ifdef CONFIG_GDB_STUB_FOR_ARM
+/* Added by harsh for GDB kernel debugging support */
+int irq2_status = 0;
+/* Added for GDB kernel debugging support */
+/* Serial port has to be initialized */
+static volatile unsigned char *port = NULL;
+
+#define GDB_UART_BASE			IO_ADDRESS(CNXT_PORT0_BASE)
+#define GDB_UART_GET_CHAR(p)		readl((p) + CNXT_FIFO)
+#define GDB_UART_PUT_CHAR(p, c)		writel((c), (p) + CNXT_FIFO)
+#define GDB_UART_GET_STAT(p)		readl((p) + CNXT_STAT)
+
+/* Get a character from serial port */
+int debug_getc(void)
+{
+	unsigned int status;
+	int c;
+
+	port = (unsigned char *) GDB_UART_BASE;
+
+	status = GDB_UART_GET_STAT(port);
+
+	while (!(status & CNXT_STAT_RSR)) {
+		status = GDB_UART_GET_STAT(port);
+	}
+	c = GDB_UART_GET_CHAR(port);
+
+	c = c & 0x7f;
+
+	return c;
+}
+
+EXPORT_SYMBOL(debug_getc);
+/* Put a character to the serial port */
+int debug_putc(int c)
+{
+	unsigned int status;
+
+	port = (unsigned char *) GDB_UART_BASE;
+
+	status = GDB_UART_GET_STAT(port);
+
+	while (!(status & CNXT_STAT_TSR)) {
+		status = GDB_UART_GET_STAT(port);
+	}
+
+	GDB_UART_PUT_CHAR(port, (c | 0x80));
+	return c;
+}
+
+EXPORT_SYMBOL(debug_putc);
+#endif
+
+static void cnxtuart_stop_tx(struct uart_port *port)
+{
+	unsigned int cr;
+
+	cr = UART_GET_IRQE(port);
+	/* turn off fifo threshold interrupt and transmitter idle interrupt */
+	/* TODO: Check if this is appropriate.  Only one may need to go off */
+	cr &= ~(CNXT_IRQE_TIDE | CNXT_IRQE_TSRE);
+	UART_PUT_IRQE(port, cr);
+}
+
+static void cnxtuart_start_tx(struct uart_port *port)
+{
+	unsigned int cr;
+
+	cr = UART_GET_IRQE(port);
+	cr |= (CNXT_IRQE_TIDE);
+	UART_PUT_IRQE(port, cr);
+}
+
+static void cnxtuart_stop_rx(struct uart_port *port)
+{
+	unsigned int cr;
+
+	cr = UART_GET_IRQE(port);
+	cr &= ~(CNXT_IRQE_RSRE);
+	UART_PUT_IRQE(port, cr);
+}
+
+/* CNXT doesn't really have modem status */
+static void cnxtuart_enable_ms(struct uart_port *port)
+{
+
+}
+
+static void cnxtuart_rx_chars(struct uart_port *port)
+{
+	struct tty_struct *tty = port->state->port.tty;
+	unsigned int ch, rsr, max_count = 256;
+	unsigned int rxchars;
+	char flag;
+
+	rxchars = UART_RX_NUMCHARS(port);
+	while (rxchars && max_count--) {
+		/* Status bits on CNXT refer to the bottom character
+		 * on the FIFO.   If we read the character before the status 
+		 * register, the status won't apply to the current character.
+		 */
+		rsr = UART_GET_STAT(port) | UART_DUMMY_RSR_RX;
+		ch = UART_GET_CHAR(port);
+
+		tty_flip_buffer_push(tty);
+
+		flag = TTY_NORMAL;
+		port->icount.rx++;
+
+		if (rsr & CNXT_STAT_ANY) {
+			if (rsr & CNXT_STAT_RBK) {
+				rsr &= ~(CNXT_STAT_FRE | CNXT_STAT_PAE);
+				port->icount.brk++;
+				if (uart_handle_break(port)) {
+					goto ignore_char;
+				}
+			} else if (rsr & CNXT_STAT_PAE)
+				port->icount.parity++;
+			else if (rsr & CNXT_STAT_FRE)
+				port->icount.frame++;
+			if (rsr & CNXT_STAT_RFO)
+				port->icount.overrun++;
+
+			rsr &= port->read_status_mask;
+
+			if (rsr & CNXT_STAT_RBK)
+				flag = TTY_BREAK;
+
+			else if (rsr & CNXT_STAT_PAE)
+				flag = TTY_PARITY;
+			else if (rsr & CNXT_STAT_FRE)
+				flag = TTY_FRAME;
+		}
+
+		if (uart_handle_sysrq_char(port, ch))
+			goto ignore_char;
+
+		uart_insert_char(port, rsr, CNXT_STAT_RFO, ch, flag);
+
+	      ignore_char:
+		rxchars = UART_RX_NUMCHARS(port);
+	}
+	/*
+	 * Drop the lock here since it might end up calling
+	 * uart_start(), which takes the lock.
+	 */
+
+	tty_flip_buffer_push(tty);
+	return;
+}
+
+static void cnxtuart_tx_chars(struct uart_port *port)
+{
+	/* This funciton is called from the UART ISR if the transmitter
+	 * empty interrupt fired */
+	struct circ_buf *xmit = &port->state->xmit;
+	int count;
+	unsigned int status;
+
+	if (port->x_char) {
+		do {
+			status = UART_GET_STAT(port);
+			if (UART_TX_READY(status))
+				break;
+			cpu_relax();
+		} while (1);
+
+		UART_PUT_CHAR(port, port->x_char);
+		port->icount.tx++;
+		port->x_char = 0;
+		return;
+	}
+	if (uart_circ_empty(xmit) || uart_tx_stopped(port)) {
+		cnxtuart_stop_tx(port);
+		return;
+	}
+
+	count = port->fifosize >> 1;
+	do {
+		do {
+			status = UART_GET_STAT(port);
+			if (UART_TX_READY(status))
+				break;
+			cpu_relax();
+		} while (1);
+
+		UART_PUT_CHAR(port, xmit->buf[xmit->tail]);
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		port->icount.tx++;
+		if (uart_circ_empty(xmit))
+			break;
+	} while (--count > 0);
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(port);
+
+	if (uart_circ_empty(xmit))
+		cnxtuart_stop_tx(port);
+}
+
+static irqreturn_t cnxtuart_int(int irq, void *dev_id)
+{
+	struct uart_port *port = dev_id;
+	unsigned int status, pass_counter = CNXT_ISR_PASS_LIMIT;
+
+	/* there should really be a need to read the interrupt level register.
+	 * In either of the interruptable cases below, they will be handled
+	 * quickly.  Furthermore, the framing and parity errors will be handled
+	 * in the rx() routine
+	 */
+	status = UART_GET_STAT(port);
+	do {
+		if (status & (CNXT_STAT_RSR))
+			cnxtuart_rx_chars(port);
+		if (status & CNXT_STAT_TSR)
+			cnxtuart_tx_chars(port);
+
+		if (pass_counter-- == 0)
+			break;
+
+		status = UART_GET_STAT(port);
+	}
+	while (status & (CNXT_STAT_RSR | CNXT_STAT_TSR));
+
+	return IRQ_HANDLED;
+}
+
+static unsigned int cnxtuart_tx_empty(struct uart_port *port)
+{
+	return UART_GET_STAT(port) & CNXT_STAT_TID ? 0 : TIOCSER_TEMT;
+}
+
+static unsigned int cnxtuart_get_mctrl(struct uart_port *port)
+{
+	unsigned int result = 0;
+
+	/* TODO: This may need changing in the future.
+	 *
+	 * Lie and say we're good to go for apps that are picky about 
+	 * hardware flow control
+	 */
+	result = TIOCM_CAR | TIOCM_DSR | TIOCM_CTS;
+
+	return result;
+}
+
+static void cnxtuart_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+	/* No modem control stuff on CNXT for now... */
+}
+
+static void cnxtuart_break_ctl(struct uart_port *port, int break_state)
+{
+	/* Dummy */
+}
+
+static int cnxtuart_startup(struct uart_port *port)
+{
+	struct uart_cnxt_port *uap = (struct uart_cnxt_port *) port;
+	int retval;
+
+	/*  Allocate the IRQ */
+	retval = request_irq(port->irq, cnxtuart_int, 0, "CX2450x UART", port);
+	if (retval)
+		return retval;
+
+	/*  initialise the old status of the modem signals */
+	uap->old_status = 0;
+
+	UART_PUT_FIFC(port, CNXT_FIFC_RFT_EIGHT | CNXT_FIFC_TFT_SXTN | CNXT_FIFC_TFC | CNXT_FIFC_RFC);
+
+	/* Finally, enable interrupts */
+	UART_PUT_IRQE(port, CNXT_IRQE_TIDE | CNXT_IRQE_TSRE | CNXT_IRQE_RSRE);
+
+#ifdef CONFIG_GDB_STUB_FOR_ARM
+	/* Set that IRQ2 is allocated :to be used by GDB */
+	irq2_status = 1;
+#endif
+	return 0;
+}
+
+static void cnxtuart_shutdown(struct uart_port *port)
+{
+	/* Free the interrupt */
+	free_irq(port->irq, port);
+	/* disable all interrupts, disable the port */
+	UART_PUT_IRQE(port, 0);
+	UART_PUT_FIFC(port, CNXT_FIFC_TFC | CNXT_FIFC_RFC);
+}
+
+static void cnxtuart_set_termios(struct uart_port *port, struct ktermios *new1, struct ktermios *old)
+{
+#warning check baudrate setup
+	unsigned long flags;
+	int baud = uart_get_baud_rate(port, new1, old, 9600, 115200);
+	unsigned int fcr, old_cr, quot;
+	unsigned int cflag = new1->c_cflag;
+
+	quot = (port->uartclk / (16 * baud));
+	switch (cflag & CSIZE) {
+	case CS7:
+		fcr = 0;
+		break;
+	default:		// CS8
+		fcr = CNXT_FRMC_FRS;
+		break;
+	}
+
+	if (cflag & CSTOPB)
+		fcr |= CNXT_FRMC_SBS;
+
+	if (cflag & PARENB) {
+		fcr |= CNXT_FRMC_PEN;
+
+		if (!(cflag & PARODD))
+			fcr |= CNXT_FRMC_EOP;
+	}
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	uart_update_timeout(port, cflag, baud);
+	/*  Ignore all characters if CREAD is not set.  */
+	if ((cflag & CREAD) == 0)
+		port->ignore_status_mask |= UART_DUMMY_RSR_RX;
+
+	old_cr = UART_GET_FRMC(port);
+
+	UART_PUT_FRMC(port, 0x80);
+
+	/* Set baud rate */
+	/*
+	 * Set the fractional part, based on the fact that we shifted the
+	 * uartclk by 2, to allow 2 bits of fraction to be carried in the
+	 * quotient value passed into this routine
+	 */
+	UART_PUT_EXP(port, (quot & 0x00003));
+	quot = quot >> 2;
+
+	quot -= 1;
+	UART_PUT_BRDH(port, ((quot & 0xff00) >> 8));
+	UART_PUT_BRDL(port, (quot & 0xff));
+
+	/*
+	 * ----------v----------v----------v----------v-----
+	 * NOTE: MUST BE WRITTEN AFTER UARTLCR_M & UARTLCR_L
+	 * ----------^----------^----------^----------^-----
+	 */
+	UART_PUT_FRMC(port, fcr);
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static const char *cnxtuart_type(struct uart_port *port)
+{
+	return port->type == PORT_CNXT ? "CX2450x UART" : NULL;
+}
+
+/* Release the memory region(s) being used by 'port' */
+static void cnxtuart_release_port(struct uart_port *port)
+{
+	release_mem_region(port->mapbase, UART_PORT_SIZE);
+}
+
+/* Request the memory region(s) being used by 'port' */
+static int cnxtuart_request_port(struct uart_port *port)
+{
+	return request_mem_region(port->mapbase, UART_PORT_SIZE, "CX2450x UART") != NULL ? 0 : -EBUSY;
+}
+
+/* Configure/autoconfigure the port.  */
+static void cnxtuart_config_port(struct uart_port *port, int flags)
+{
+	if (flags & UART_CONFIG_TYPE) {
+		port->type = PORT_CNXT;
+		cnxtuart_request_port(port);
+	}
+}
+
+/* verify the new serial_struct (for TIOCSSERIAL).  */
+static int cnxtuart_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	int ret;
+	/* TODO:  MFB - evaluate if this is really necessary later */
+	ret = 0;
+	return ret;
+}
+
+static struct uart_ops cnxt_pops = {
+	.tx_empty	= cnxtuart_tx_empty,
+	.set_mctrl	= cnxtuart_set_mctrl,
+	.get_mctrl	= cnxtuart_get_mctrl,
+	.stop_tx	= cnxtuart_stop_tx,
+	.start_tx	= cnxtuart_start_tx,
+	.stop_rx	= cnxtuart_stop_rx,
+	.enable_ms	= cnxtuart_enable_ms,
+	.break_ctl	= cnxtuart_break_ctl,
+	.startup	= cnxtuart_startup,
+	.shutdown	= cnxtuart_shutdown,
+	.set_termios	= cnxtuart_set_termios,
+	.type		= cnxtuart_type,
+	.release_port	= cnxtuart_release_port,
+	.request_port	= cnxtuart_request_port,
+	.config_port	= cnxtuart_config_port,
+	.verify_port	= cnxtuart_verify_port
+};
+
+/*******************************************************************************/
+
+/* note, addresses and interrupts here are only valid placeholders. They are 
+   overwritten in the init routine for proper sorting (to have the system 
+   console while boot identical to the working console) */
+static struct uart_cnxt_port cnxt_ports[3] = {
+	{
+		.port = {
+			.membase	= (void *) IO_ADDRESS(UART_FIFO_BRDL_REG(0)),
+			.mapbase	= UART_FIFO_BRDL_REG(0),
+			.iotype		= UPIO_MEM,
+			.irq		= IRQ_UART1,
+			.uartclk	= (54000000 << 2),
+			.fifosize	= 16,
+			.ops		= &cnxt_pops,
+			.flags		= UPF_BOOT_AUTOCONF,
+			.line		= 2,
+		},
+		.dtr_enable	= 0,
+		.rts_enable	= 0,
+	}, {
+		.port = {
+			.membase	= (void *) IO_ADDRESS(UART_FIFO_BRDL_REG(1)),
+			.mapbase	= UART_FIFO_BRDL_REG(1),
+			.iotype		= UPIO_MEM,
+			.irq		= IRQ_UART2,
+			.uartclk	= (54000000 << 2),
+			.fifosize	= 16,
+			.ops		= &cnxt_pops,
+			.flags		= UPF_BOOT_AUTOCONF,
+			.line		= 1,
+		 },
+		.dtr_enable	= 0,
+		.rts_enable	= 0,
+	}, {
+		.port = {
+			.membase	= (void *) IO_ADDRESS(UART_FIFO_BRDL_REG(2)),
+			.mapbase	= UART_FIFO_BRDL_REG(2),
+			.iotype		= UPIO_MEM,
+			.irq		= IRQ_UART3,
+			.uartclk	= (54000000 << 2),
+			.fifosize	= 16,
+			.ops		= &cnxt_pops,
+			.flags		= UPF_BOOT_AUTOCONF,
+			.line		= 0,
+		},
+		.dtr_enable	= 0,
+		.rts_enable	= 0,
+	 },
+};
+
+/*******************************************************************************/
+
+#ifdef CONFIG_SERIAL_CX2450X_CONSOLE
+static void cnxtuart_console_write(struct console *co, const char *s, unsigned int count)
+{
+	struct uart_port *port = &cnxt_ports[co->index].port;
+	unsigned int status, old_cr;
+	int i;
+
+	/* First save the CR then disable the interrupts */
+	old_cr = UART_GET_IRQE(port);
+	UART_PUT_IRQE(port, 0);
+
+	/* Now, do each character */
+	for (i = 0; i < count; i++) {
+		do {
+			status = UART_GET_STAT(port);
+			if (UART_TX_READY(status))
+				break;
+			cpu_relax();
+		}
+		while (1);
+		UART_PUT_CHAR(port, s[i]);
+		if (s[i] == '\n') {
+			do {
+				status = UART_GET_STAT(port);
+				if (UART_TX_READY(status))
+					break;
+				cpu_relax();
+			} while (1);
+			UART_PUT_CHAR(port, '\r');
+		}
+	}
+
+	/* Finally, wait for transmitter to become empty and restore the TCR */
+	do {
+		status = UART_GET_STAT(port);
+	}
+	while ((status & CNXT_STAT_TID) == 0);
+	UART_PUT_IRQE(port, old_cr);
+}
+
+struct tty_driver *cnxtuart_console_device(struct console *co, int *index)
+{
+	struct uart_driver *p = co->data;
+
+	*index = co->index;
+	return p->tty_driver;
+}
+
+/*
+static void __init cnxtuart_console_get_options(struct uart_port *port, int *baud, int *parity, int *bits)
+{
+#warning report correct settings
+	*baud = 115200;
+	*parity = 'n';
+	*bits = 8;
+}
+*/
+/*******************************************************************************/
+
+static int __init cnxtuart_console_setup(struct console *co, char *options)
+{
+	struct uart_port *port;
+	int baud = 115200;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+
+	/* get default baudrate from Kernel config */
+#ifdef CONFIG_SERIAL_CX2450X_BAUDRATE_230400
+	baud = 230400;
+#else
+#ifdef CONFIG_SERIAL_CX2450X_BAUDRATE_115200
+	baud = 115200;
+#else
+#ifdef  CONFIG_SERIAL_CX2450X_BAUDRATE_57600
+	baud = 57600;
+#else
+#ifdef  CONFIG_SERIAL_CX2450X_BAUDRATE_38400
+	baud = 38400;
+#else
+#ifdef  CONFIG_SERIAL_CX2450X_BAUDRATE_19200
+	baud = 19200;
+#else
+#ifdef  CONFIG_SERIAL_CX2450X_BAUDRATE_9600
+	baud = 9600;
+#endif /* CONFIG_SERIAL_CX2450X_BAUDRATE_9600   */
+#endif /* CONFIG_SERIAL_CX2450X_BAUDRATE_19200  */
+#endif /* CONFIG_SERIAL_CX2450X_BAUDRATE_38400  */
+#endif /* CONFIG_SERIAL_CX2450X_BAUDRATE_57600  */
+#endif /* CONFIG_SERIAL_CX2450X_BAUDRATE_115200 */
+#endif /* CONFIG_SERIAL_CX2450X_BAUDRATE_230400 */
+
+	/* Check whether an invalid uart number has been specified, and if so, 
+	   search for the first available port that does have console support. */
+	if (co->index > 2)
+		co->index = 0;
+	port = &cnxt_ports[co->index].port;
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+
+	return uart_set_options(port, co, baud, parity, bits, flow);
+}
+
+/*******************************************************************************/
+
+static struct console cnxt_console;
+static struct uart_driver cnxt_reg;
+
+/*******************************************************************************/
+
+static struct console cnxt_console = {
+	.name	= "ttyRI",
+	.write	= cnxtuart_console_write,
+	.device	= cnxtuart_console_device,
+	.setup	= cnxtuart_console_setup,
+	.flags	= CON_PRINTBUFFER,
+	.index	= -1,
+	.data	= &cnxt_reg,
+};
+
+static int __init cnxtuart_console_init(void)
+{
+	u32 val;
+	u32 num = 0;
+	u32 irqtab[3] = { IRQ_UART1, IRQ_UART2, IRQ_UART3 };
+	volatile u32 *reg;
+
+#ifdef CONFIG_SERIAL_CX2450X_BOOTMSG
+	/* check for available UART's (enabled by the Bootloader/BIOS).
+	   You may think, this is stupid, yes I think so too, but to have the early 
+	   bootmessages on the specified console, we have to detect the ports and to 
+	   sort the addresses and interrupts. */
+
+	/* UART 1 (PIO 1 (TX), PIO 2 (RX)) */
+	have_uart[0] = 0xFF;
+	reg = (volatile u32 *) SREG_SEC_MUX_REG_BASE(0);
+	if ((*reg & 0x00000006) == 0) {
+		reg = (volatile u32 *) SREG_PRI_MUX_REG_BASE(0);
+		if ((*reg & 0x00000006) == 0x00000006) {
+			have_uart[0] = num;
+			num++;
+		}
+	}
+
+	/* check for UART 2 (can be configured on various pins) */
+	have_uart[1] = 0xFF;
+	reg = (volatile u32 *) SREG_ALT_PIN_FUNC_REG;
+	val = (*reg >> 4) & 0x03;
+	if (val == 0) {		/* PIO 3 (TX), 4 (RX) */
+		reg = (volatile u32 *) SREG_SEC_MUX_REG_BASE(0);
+		if ((*reg & 0x00000018) == 0) {
+			reg = (volatile u32 *) SREG_PRI_MUX_REG_BASE(0);
+			if ((*reg & 0x00000018) == 0x00000018) {
+				have_uart[1] = num;
+				num++;
+			}
+		}
+	} else if (val == 1) {	/* PIO 71 (RX), 72 (TX) */
+		reg = (volatile u32 *) SREG_SEC_MUX_REG_BASE(2);
+		if ((*reg & 0x00000018) == 0) {
+			reg = (volatile u32 *) SREG_PRI_MUX_REG_BASE(2);
+			if ((*reg & 0x00000018) == 0x00000018) {
+				have_uart[1] = num;
+				num++;
+			}
+		}
+	} else if (val == 2) {	/* PIO 11 (RX), 73 (TX) */
+		reg = (volatile u32 *) SREG_SEC_MUX_REG_BASE(2);
+		if ((*reg & 0x00000020) == 0) {
+			reg = (volatile u32 *) SREG_PRI_MUX_REG_BASE(2);
+			if ((*reg & 0x00000020) == 0x00000020) {
+				reg = (volatile u32 *) SREG_SEC_MUX_REG_BASE(0);
+				if ((*reg & 0x00000800) == 0) {
+					reg = (volatile u32 *) SREG_PRI_MUX_REG_BASE(0);
+					if ((*reg & 0x00000800) == 0x00000800) {
+						have_uart[1] = num;
+						num++;
+					}
+				}
+			}
+		}
+	}
+
+	/* check for UART 3 (PIO 14 (TX), PIO 15 (RX)) */
+	have_uart[2] = 0xFF;
+	reg = (volatile u32 *) SREG_SEC_MUX_REG_BASE(0);
+	if ((*reg & 0x0000C000) == 0) {
+		reg = (volatile u32 *) SREG_PRI_MUX_REG_BASE(0);
+		if ((*reg & 0x0000C000) == 0x0000C000)
+			have_uart[2] = num;
+	}
+
+	/* finally register the detected ports */
+	for (val = 0; val < 3; val++) {
+		if (have_uart[val] < 3) {
+			cnxt_ports[have_uart[val]].port.membase = (void *) IO_ADDRESS(UART_FIFO_BRDL_REG(val));
+			cnxt_ports[have_uart[val]].port.mapbase = UART_FIFO_BRDL_REG(val);
+			cnxt_ports[have_uart[val]].port.irq = irqtab[val];
+			cnxt_ports[have_uart[val]].port.line = have_uart[val];
+		}
+	}
+#endif /* CONFIG_SERIAL_CX2450X_BOOTMSG */
+
+	register_console(&cnxt_console);
+	return 0;
+}
+
+/*******************************************************************************/
+
+console_initcall(cnxtuart_console_init);
+#define CNXT_CONSOLE	&cnxt_console
+#else
+/* no console support enabled */
+#define CNXT_CONSOLE	NULL
+#endif /* CONFIG_SERIAL_CX2450X_CONSOLE */
+
+/*******************************************************************************/
+
+static struct uart_driver cnxt_reg = {
+	.owner		= THIS_MODULE,
+	.driver_name	= "CX2450X UART",
+	.dev_name	= "ttyRI",
+	.major		= 204,
+	.minor		= 16,
+	.nr		= 3,		/* max count of supported ports */
+	.cons		= CNXT_CONSOLE,
+	.state		= NULL,
+	.tty_driver	= NULL,
+};
+
+/*******************************************************************************/
+
+static int __init cnxtuart_init(void)
+{
+	int ret;
+	u32 val;
+	u32 num = 0;
+	u32 irqtab[3] = { IRQ_UART1, IRQ_UART2, IRQ_UART3 };
+	volatile u32 *reg;
+
+	ret = uart_register_driver(&cnxt_reg);
+
+	if (ret == 0) {
+#ifndef CONFIG_SERIAL_CX2450X_BOOTMSG
+		/* if early boot messages are enabled, the detection is done in the console 
+		   init. In that case the kernel calls that function before. */
+
+		/* check for available UART's (enabled by the Bootloader/BIOS) */
+
+		/* UART 1 (PIO 1 (TX), PIO 2 (RX)) */
+		have_uart[0] = 0xFF;
+		reg = (volatile u32 *) SREG_SEC_MUX_REG_BASE(0);
+		if ((*reg & 0x00000006) == 0) {
+			reg = (volatile u32 *) SREG_PRI_MUX_REG_BASE(0);
+			if ((*reg & 0x00000006) == 0x00000006) {
+				have_uart[0] = num;
+				num++;
+			}
+		}
+
+		/* check for UART 2 (can be configured on various pins) */
+		have_uart[1] = 0xFF;
+		reg = (volatile u32 *) SREG_ALT_PIN_FUNC_REG;
+		val = (*reg >> 4) & 0x03;
+		if (val == 0) {	/* PIO 3 (TX), 4 (RX) */
+			reg = (volatile u32 *) SREG_SEC_MUX_REG_BASE(0);
+			if ((*reg & 0x00000018) == 0) {
+				reg = (volatile u32 *) SREG_PRI_MUX_REG_BASE(0);
+				if ((*reg & 0x00000018) == 0x00000018) {
+					have_uart[1] = num;
+					num++;
+				}
+			}
+		} else if (val == 1) {	/* PIO 71 (RX), 72 (TX) */
+			reg = (volatile u32 *) SREG_SEC_MUX_REG_BASE(2);
+			if ((*reg & 0x00000018) == 0) {
+				reg = (volatile u32 *) SREG_PRI_MUX_REG_BASE(2);
+				if ((*reg & 0x00000018) == 0x00000018) {
+					have_uart[1] = num;
+					num++;
+				}
+			}
+		} else if (val == 2) {	/* PIO 11 (RX), 73 (TX) */
+			reg = (volatile u32 *) SREG_SEC_MUX_REG_BASE(2);
+			if ((*reg & 0x00000020) == 0) {
+				reg = (volatile u32 *) SREG_PRI_MUX_REG_BASE(2);
+				if ((*reg & 0x00000020) == 0x00000020) {
+					reg = (volatile u32 *) SREG_SEC_MUX_REG_BASE(0);
+					if ((*reg & 0x00000800) == 0) {
+						reg = (volatile u32 *) SREG_PRI_MUX_REG_BASE(0);
+						if ((*reg & 0x00000800) == 0x00000800) {
+							have_uart[1] = num;
+							num++;
+						}
+					}
+				}
+			}
+		}
+
+		/* check for UART 3 (PIO 14 (TX), PIO 15 (RX)) */
+		have_uart[2] = 0xFF;
+		reg = (volatile u32 *) SREG_SEC_MUX_REG_BASE(0);
+		if ((*reg & 0x0000C000) == 0) {
+			reg = (volatile u32 *) SREG_PRI_MUX_REG_BASE(0);
+			if ((*reg & 0x0000C000) == 0x0000C000)
+				have_uart[2] = num;
+		}
+#endif /* CONFIG_SERIAL_CX2450X_BOOTMSG */
+
+		/* finally register the detected ports */
+		for (val = 0; val < 3; val++) {
+			if (have_uart[val] < 3) {
+#ifndef CONFIG_SERIAL_CX2450X_BOOTMSG
+				cnxt_ports[have_uart[val]].port.membase = (void *) IO_ADDRESS(UART_FIFO_BRDL_REG(val));
+				cnxt_ports[have_uart[val]].port.mapbase = UART_FIFO_BRDL_REG(val);
+				cnxt_ports[have_uart[val]].port.irq = irqtab[val];
+				cnxt_ports[have_uart[val]].port.line = have_uart[val];
+#endif /* CONFIG_SERIAL_CX2450X_BOOTMSG */
+				uart_add_one_port(&cnxt_reg, &cnxt_ports[have_uart[val]].port);
+			}
+		}
+	}
+
+	return ret;
+}
+
+/*******************************************************************************/
+
+static void __exit cnxtuart_exit(void)
+{
+	if (have_uart[0] != 0xFF) {
+		uart_remove_one_port(&cnxt_reg, &cnxt_ports[have_uart[0]].port);
+		have_uart[0] = 0xFF;
+	}
+
+	if (have_uart[1] != 0xFF) {
+		uart_remove_one_port(&cnxt_reg, &cnxt_ports[have_uart[1]].port);
+		have_uart[1] = 0xFF;
+	}
+
+	if (have_uart[2] != 0xFF) {
+		uart_remove_one_port(&cnxt_reg, &cnxt_ports[have_uart[2]].port);
+		have_uart[2] = 0xFF;
+	}
+
+	uart_unregister_driver(&cnxt_reg);
+}
+
+/*******************************************************************************/
+
+module_init(cnxtuart_init);
+module_exit(cnxtuart_exit);
+
+MODULE_AUTHOR("Conexant Systems, Inc. & Coolstream International Ltd.");
+MODULE_DESCRIPTION("Conexant CX2450x UART driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/staging/rtl8192u/Kconfig b/drivers/staging/rtl8192u/Kconfig
index 0439c90..e2d3362 100644
--- a/drivers/staging/rtl8192u/Kconfig
+++ b/drivers/staging/rtl8192u/Kconfig
@@ -1,6 +1,7 @@
 config RTL8192U
 	tristate "RealTek RTL8192U Wireless LAN NIC driver"
-	depends on PCI && WLAN && USB
+	depends on WLAN && USB
+	depends on m
 	select WIRELESS_EXT
 	select WEXT_PRIV
 	default N
diff --git a/drivers/usb/Kconfig b/drivers/usb/Kconfig
index 6a58cb1..933e648 100644
--- a/drivers/usb/Kconfig
+++ b/drivers/usb/Kconfig
@@ -64,6 +64,7 @@ config USB_ARCH_HAS_EHCI
 	default y if ARCH_AT91SAM9G45
 	default y if ARCH_MXC
 	default y if ARCH_OMAP3
+	default y if ARCH_NEVIS
 	default PCI
 
 # ARM SA1111 chips have a non-PCI based "OHCI-compatible" USB host interface.
diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index 8d3df03..857c9cd 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -37,6 +37,31 @@ config USB_XHCI_HCD_DEBUGGING
 
 	  If unsure, say N.
 
+config CX2450X_USB
+	bool "Conexant CX2450x (Nevis) USB support"
+	depends on USB && USB_ARCH_HAS_EHCI && ARCH_NEVIS
+	select USB_EHCI_HCD
+	select USB_EHCI_ROOT_HUB_TT
+	select USB_EHCI_SPLIT_ISO
+	---help---
+	  Enable this option to support the EHCI USB-Controller(s) included in
+	  the Conexant CX2450x (Nevis) SoC.
+
+config CX2450X_USB0
+	bool "enable USB port 1 on CX2450x"
+	depends on CX2450X_USB
+	default y
+
+config CX2450X_USB1
+	bool "enable USB port 2 on CX2450x"
+	depends on CX2450X_USB
+	default n
+	---help---
+	If you enable this option, the second USB-Controller available in
+	Chip revision C and later. Note that this controller needs the correct
+	GPIO-Setup from a bootloader or the init process, because this USB-port
+	can be routed to various GPIO-pins.
+
 config USB_EHCI_HCD
 	tristate "EHCI HCD (USB 2.0) support"
 	depends on USB && USB_ARCH_HAS_EHCI
diff --git a/drivers/usb/host/ehci-cx2450x.c b/drivers/usb/host/ehci-cx2450x.c
new file mode 100644
index 0000000..1a03a46
--- /dev/null
+++ b/drivers/usb/host/ehci-cx2450x.c
@@ -0,0 +1,247 @@
+/*
+ * EHCI HCD (Host Controller Driver) for USB.
+ *
+ * Bus Glue for NXP CX2450X (Nevis) SoC
+ * (C) Copyright 2008 CoolStream Ltd.
+ *
+ * Based on "ehci-fsl.c"
+ * (C) Copyright 2005 MontaVista Software
+ *
+ * Based on "ehci-au1xxx.c" Bus Glue for AMD Alchemy Au1xxx
+ * (C) Copyright 2000-2004 David Brownell <dbrownell@users.sourceforge.net>
+ *
+ * This file is licenced under the GPL.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/version.h>
+#include <mach/gpio.h>
+#include <mach/cx2450x.h>
+
+#define PORTSC_REG_OFS	0x00000084
+
+/*******************************************************************************/
+
+/*
+ * configure so an HC device and id are always called with process context; 
+ * sleeping is OK
+ *
+ */
+
+/* usb_ehci_cx2450x_probe - initialize cx2450x-based HCDs
+ * Context: !in_interrupt()
+ *
+ * Allocates basic resources for this USB host controller, and then invokes the 
+ * start() method for the HCD associated with it through the hotplug entry's 
+ * driver_data.
+ */
+
+int usb_ehci_cx2450x_probe(const struct hc_driver *driver, struct platform_device *pdev)
+{
+	int retval;
+	struct usb_hcd *hcd;
+	struct resource *res;
+	int irq;
+
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "%s: found hostcontroller with no IRQ. Check your setup!\n", dev_name(&pdev->dev));
+		return -ENODEV;
+	}
+	irq = res->start;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "%s: found hostcontroller with no register address. Check your setup!\n", dev_name(&pdev->dev));
+		return -ENODEV;
+	}
+
+	hcd = usb_create_hcd(driver, &pdev->dev, dev_name(&pdev->dev));
+
+	if (!hcd)
+		return -ENOMEM;
+
+	hcd->rsrc_start = res->start;
+	hcd->rsrc_len = res->end - res->start + 1;
+
+	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
+		usb_put_hcd(hcd);
+		return -EBUSY;
+	}
+
+	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
+
+	if (!hcd->regs) {
+		printk(KERN_ERR "failed to ioremap USB driver\n");
+		release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+		usb_put_hcd(hcd);
+		return -ENOMEM;
+	}
+
+	retval = usb_add_hcd(hcd, irq, IRQF_SHARED | IRQF_DISABLED);
+
+	if (!retval)
+		return retval;
+
+	iounmap(hcd->regs);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+	usb_put_hcd(hcd);
+
+	return retval;
+}
+
+/*******************************************************************************/
+
+/* may be called without controller electrically present */
+/* may be called with controller, bus, and devices active */
+
+/*
+ * usb_ehci_hcd_cx2450x_remove - shutdown processing for cx2450x-based HCDs
+ * @dev: USB Host Controller being removed
+ * Context: !in_interrupt()
+ *
+ * Reverses the effect of usb_ehci_hcd_cx2450x_probe(), first invoking
+ * the HCD's stop() method.  It is always called from a thread
+ * context, normally "rmmod", "apmd", or something similar.
+ *
+ */
+
+void usb_ehci_cx2450x_remove(struct usb_hcd *hcd, struct platform_device *pdev)
+{
+	usb_remove_hcd(hcd);
+	iounmap(hcd->regs);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+	usb_put_hcd(hcd);
+}
+
+/*******************************************************************************/
+
+static int ehci_cx2450x_reinit(struct ehci_hcd *ehci)
+{
+	volatile u32 *usb_enable = (volatile u32 *) SREG_USB_ENABLE_REG;
+
+	*usb_enable |= 0x00000703;	/* datasheet is wrong. For "active low" power control bit 6 and 7 must be leave at 0 */
+	msleep(200);
+
+	ehci_port_power(ehci, 0);
+
+	return 0;
+}
+
+/*******************************************************************************/
+
+static int ehci_cx2450x_setup(struct usb_hcd *hcd)
+{
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	int retval;
+
+	/* Conexant EHCI capability registers start at 0x100 */
+	ehci->caps = hcd->regs;
+	ehci->regs = hcd->regs + HC_LENGTH(readl(&ehci->caps->hc_capbase));
+
+	/* Conexant USB controller has a TT. 
+	   FIXME: Should we set high or lowspeed here ? */
+	hcd->has_tt = 1;
+
+	dbg_hcs_params(ehci, "reset");
+	dbg_hcc_params(ehci, "reset");
+
+	/* cache this readonly data; minimize chip reads */
+	ehci->hcs_params = readl(&ehci->caps->hcs_params);
+
+	ehci_reset(ehci);
+	retval = ehci_halt(ehci);
+	if (retval)
+		return retval;
+
+	/* data structure init */
+	retval = ehci_init(hcd);
+	if (retval)
+		return retval;
+#if 0
+	temp = HCS_N_CC(ehci->hcs_params) * HCS_N_PCC(ehci->hcs_params);
+	temp &= 0x0F;
+	if (temp && HCS_N_PORTS(ehci->hcs_params) > temp) {
+		printk("bogus port configuration: "
+		       "cc=%d x pcc=%d < ports=%d\n", HCS_N_CC(ehci->hcs_params), HCS_N_PCC(ehci->hcs_params), HCS_N_PORTS(ehci->hcs_params));
+	}
+#endif
+	retval = ehci_cx2450x_reinit(ehci);
+	return retval;
+}
+
+/*******************************************************************************/
+
+static const struct hc_driver ehci_cx2450x_hc_driver = {
+	.description = hcd_name,
+	.product_desc = "Trident CX2450X EHCI USB-Controller",
+	.hcd_priv_size = sizeof(struct ehci_hcd),
+
+	/* generic hardware linkage */
+	.irq = ehci_irq,
+	.flags = HCD_MEMORY | HCD_USB2,
+
+	/* basic lifecycle operations */
+	.reset = ehci_cx2450x_setup,
+	.start = ehci_run,
+	.stop = ehci_stop,
+	.shutdown = ehci_shutdown,
+
+	/* managing i/o requests and associated device resources */
+	.urb_enqueue = ehci_urb_enqueue,
+	.urb_dequeue = ehci_urb_dequeue,
+	.endpoint_disable = ehci_endpoint_disable,
+	.endpoint_reset = ehci_endpoint_reset,
+
+	/* scheduling support */
+	.get_frame_number = ehci_get_frame,
+
+	/* root hub support */
+	.hub_status_data = ehci_hub_status_data,
+	.hub_control = ehci_hub_control,
+
+	.relinquish_port = ehci_relinquish_port,
+	.port_handed_over = ehci_port_handed_over,
+#ifdef CONFIG_PM
+	.bus_suspend = ehci_bus_suspend,
+	.bus_resume = ehci_bus_resume,
+#endif
+	.clear_tt_buffer_complete = ehci_clear_tt_buffer_complete,
+
+};
+
+/*******************************************************************************/
+
+static int ehci_hcd_cx2450x_drv_probe(struct platform_device *pdev)
+{
+	if (usb_disabled())
+		return -ENODEV;
+
+	return usb_ehci_cx2450x_probe(&ehci_cx2450x_hc_driver, pdev);
+}
+
+/*******************************************************************************/
+
+static int ehci_hcd_cx2450x_drv_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+
+	usb_ehci_cx2450x_remove(hcd, pdev);
+	return 0;
+}
+
+/*******************************************************************************/
+
+MODULE_ALIAS("platform:cx2450x-ehci");
+
+static struct platform_driver ehci_cx2450x_driver = {
+	.probe		= ehci_hcd_cx2450x_drv_probe,
+	.remove		= ehci_hcd_cx2450x_drv_remove,
+	.shutdown	= usb_hcd_platform_shutdown,
+	.driver	= {
+		.name	= "cx2450x-ehci",
+		.bus	= &platform_bus_type
+	}
+};
+
+/*******************************************************************************/
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 5a32023..aeeb6ef 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1127,6 +1127,11 @@ MODULE_LICENSE ("GPL");
 #define PLATFORM_DRIVER		ehci_mxc_driver
 #endif
 
+#ifdef CONFIG_CX2450X_USB
+#include "ehci-cx2450x.c"
+#define PLATFORM_DRIVER		ehci_cx2450x_driver
+#endif
+
 #ifdef CONFIG_SOC_AU1200
 #include "ehci-au1xxx.c"
 #define	PLATFORM_DRIVER		ehci_hcd_au1xxx_driver
diff --git a/fs/proc/Makefile b/fs/proc/Makefile
index 11a7b5c..65677d9 100644
--- a/fs/proc/Makefile
+++ b/fs/proc/Makefile
@@ -26,3 +26,4 @@ proc-$(CONFIG_PROC_VMCORE)	+= vmcore.o
 proc-$(CONFIG_PROC_DEVICETREE)	+= proc_devtree.o
 proc-$(CONFIG_PRINTK)	+= kmsg.o
 proc-$(CONFIG_PROC_PAGE_MONITOR)	+= page.o
+proc-$(CONFIG_ARCH_NEVIS)	+= mipidle.o
diff --git a/fs/proc/mipidle.c b/fs/proc/mipidle.c
new file mode 100644
index 0000000..91ddb67
--- /dev/null
+++ b/fs/proc/mipidle.c
@@ -0,0 +1,27 @@
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+#include <linux/sched.h>
+#include <linux/seq_file.h>
+#include <linux/seqlock.h>
+
+extern int get_idle_list(struct seq_file *m, void *v);
+
+static int mipidle_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, get_idle_list, NULL);
+}
+
+static const struct file_operations mipidle_proc_fops = {
+	.open		= mipidle_proc_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static int __init proc_mipidle_init(void)
+{
+	proc_create("mipidle", 0, NULL, &mipidle_proc_fops);
+	return 0;
+}
+module_init(proc_mipidle_init);
diff --git a/include/linux/kernel.h b/include/linux/kernel.h
index 9365227..aa972b0 100644
--- a/include/linux/kernel.h
+++ b/include/linux/kernel.h
@@ -611,17 +611,21 @@ static inline void ftrace_dump(void) { }
  * strict type-checking.. See the
  * "unnecessary" pointer comparison.
  */
+#ifndef min
 #define min(x, y) ({				\
 	typeof(x) _min1 = (x);			\
 	typeof(y) _min2 = (y);			\
 	(void) (&_min1 == &_min2);		\
 	_min1 < _min2 ? _min1 : _min2; })
+#endif
 
+#ifndef max
 #define max(x, y) ({				\
 	typeof(x) _max1 = (x);			\
 	typeof(y) _max2 = (y);			\
 	(void) (&_max1 == &_max2);		\
 	_max1 > _max2 ? _max1 : _max2; })
+#endif
 
 /**
  * clamp - return a value clamped to a given range with strict typechecking
diff --git a/include/linux/semaphore.h b/include/linux/semaphore.h
index 7415839..6cc6b5e 100644
--- a/include/linux/semaphore.h
+++ b/include/linux/semaphore.h
@@ -41,6 +41,7 @@ static inline void sema_init(struct semaphore *sem, int val)
 
 extern void down(struct semaphore *sem);
 extern int __must_check down_interruptible(struct semaphore *sem);
+extern int __must_check down_timeout_interruptible(struct semaphore *sem, long jiffies);
 extern int __must_check down_killable(struct semaphore *sem);
 extern int __must_check down_trylock(struct semaphore *sem);
 extern int __must_check down_timeout(struct semaphore *sem, long jiffies);
diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 78dd1e7..abc1ea9 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -182,6 +182,9 @@
 /* Aeroflex Gaisler GRLIB APBUART */
 #define PORT_APBUART    90
 
+/* Conexant CX2450X */
+#define PORT_CNXT	93
+
 #ifdef __KERNEL__
 
 #include <linux/compiler.h>
diff --git a/kernel/semaphore.c b/kernel/semaphore.c
index 94a62c0..4cbdf39 100644
--- a/kernel/semaphore.c
+++ b/kernel/semaphore.c
@@ -37,6 +37,7 @@ static noinline void __down(struct semaphore *sem);
 static noinline int __down_interruptible(struct semaphore *sem);
 static noinline int __down_killable(struct semaphore *sem);
 static noinline int __down_timeout(struct semaphore *sem, long jiffies);
+static noinline int __down_timeout_interruptible(struct semaphore *sem, long jiffies);
 static noinline void __up(struct semaphore *sem);
 
 /**
@@ -169,6 +170,32 @@ int down_timeout(struct semaphore *sem, long jiffies)
 EXPORT_SYMBOL(down_timeout);
 
 /**
+ * down_timeout_interruptible - acquire the semaphore within a specified time
+ * @sem: the semaphore to be acquired
+ * @jiffies: how long to wait before failing
+ *
+ * Attempts to acquire the semaphore.  If no more tasks are allowed to
+ * acquire the semaphore, calling this function will put the task to sleep.
+ * If the semaphore is not released within the specified number of jiffies,
+ * this function returns -ETIME.  It returns 0 if the semaphore was acquired.
+ */
+int down_timeout_interruptible(struct semaphore *sem, long jiffies)
+{
+	unsigned long flags;
+	int result = 0;
+
+	spin_lock_irqsave(&sem->lock, flags);
+	if (likely(sem->count > 0))
+		sem->count--;
+	else
+		result = __down_timeout_interruptible(sem, jiffies);
+	spin_unlock_irqrestore(&sem->lock, flags);
+
+	return result;
+}
+EXPORT_SYMBOL(down_timeout_interruptible);
+
+/**
  * up - release the semaphore
  * @sem: the semaphore to release
  *
@@ -253,6 +280,11 @@ static noinline int __sched __down_timeout(struct semaphore *sem, long jiffies)
 	return __down_common(sem, TASK_UNINTERRUPTIBLE, jiffies);
 }
 
+static noinline int __sched __down_timeout_interruptible(struct semaphore *sem, long jiffies)
+{
+	return __down_common(sem, TASK_INTERRUPTIBLE, jiffies);
+}
+
 static noinline void __sched __up(struct semaphore *sem)
 {
 	struct semaphore_waiter *waiter = list_first_entry(&sem->wait_list,
diff --git a/mm/init-mm.c b/mm/init-mm.c
index 57aba0d..81a39d7 100644
--- a/mm/init-mm.c
+++ b/mm/init-mm.c
@@ -4,6 +4,7 @@
 #include <linux/spinlock.h>
 #include <linux/list.h>
 #include <linux/cpumask.h>
+#include <linux/module.h>
 
 #include <asm/atomic.h>
 #include <asm/pgtable.h>
diff --git a/net/core/filter.c b/net/core/filter.c
index 85d1340..a481aed 100644
--- a/net/core/filter.c
+++ b/net/core/filter.c
@@ -292,9 +292,11 @@ load_b:
 			mem[f_k] = X;
 			continue;
 		default:
+#if 0
 			WARN_RATELIMIT(1, "Unknown code:%u jt:%u tf:%u k:%u\n",
 				       fentry->code, fentry->jt,
 				       fentry->jf, fentry->k);
+#endif
 			return 0;
 		}
 
-- 
1.7.10.4

