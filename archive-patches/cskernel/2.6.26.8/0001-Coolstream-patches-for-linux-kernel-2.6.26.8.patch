From 540692b65123f883ec194ca01bc4561099665019 Mon Sep 17 00:00:00 2001
From: "[CST] Focus" <focus.cst@gmail.com>
Date: Tue, 4 Sep 2012 11:38:28 +0400
Subject: [PATCH] Coolstream patches for linux kernel 2.6.26.8

---
 Makefile                                 |   12 +-
 arch/arm/Kconfig                         |   30 +-
 arch/arm/Makefile                        |   11 +-
 arch/arm/kernel/armksyms.c               |   10 +-
 arch/arm/kernel/calls.S                  |    4 +-
 arch/arm/kernel/head.S                   |    1 +
 arch/arm/lib/Makefile                    |    3 +-
 arch/arm/lib/arm11jmp.S                  |   51 +
 arch/arm/lib/clear_user.S                |   14 +-
 arch/arm/lib/delay.S                     |    2 +
 arch/arm/lib/lib1funcs.S                 |   38 +
 arch/arm/mach-nevis/Kconfig              |  224 ++++
 arch/arm/mach-nevis/Makefile             |   21 +
 arch/arm/mach-nevis/Makefile.boot        |    2 +
 arch/arm/mach-nevis/devices.c            |  220 ++++
 arch/arm/mach-nevis/devices.h            |   47 +
 arch/arm/mach-nevis/dma.c                |   37 +
 arch/arm/mach-nevis/gpio.c               |  236 ++++
 arch/arm/mach-nevis/irq.c                |  385 ++++++
 arch/arm/mach-nevis/mach.c               |  420 ++++++
 arch/arm/mach-nevis/mipidle.c            |  140 ++
 arch/arm/mach-nevis/pci.c                |  325 +++++
 arch/arm/mach-nevis/pllc.c               |  314 +++++
 arch/arm/mach-nevis/time.c               |  238 ++++
 arch/arm/mm/Kconfig                      |    2 +-
 arch/arm/mm/alignment.c                  |   26 +-
 arch/arm/mm/cache-v6.S                   |   57 +-
 arch/arm/mm/fault-armv.c                 |    4 +
 arch/arm/mm/flush.c                      |   24 +-
 arch/arm/mm/ioremap.c                    |    1 +
 arch/arm/mm/mmu.c                        |   19 +-
 build.sh                                 |    4 +
 config-2.6.26.8-nevis                    | 1456 +++++++++++++++++++++
 drivers/ata/libata-core.c                |    2 +-
 drivers/ata/libata-sff.c                 |    5 +-
 drivers/char/hw_random/Kconfig           |   13 +
 drivers/char/hw_random/Makefile          |    1 +
 drivers/char/hw_random/cx2450x-rng.c     |   65 +
 drivers/i2c/i2c-dev.c                    |    4 +
 drivers/mtd/maps/Kconfig                 |    4 +
 drivers/mtd/maps/Makefile                |    1 +
 drivers/mtd/maps/cx2450x-flash.c         |  335 +++++
 drivers/net/Kconfig                      |    2 +
 drivers/net/Makefile                     |    1 +
 drivers/net/cnxt_emac/Kconfig            |   79 ++
 drivers/net/cnxt_emac/Makefile           |    2 +
 drivers/net/cnxt_emac/emac.h             |  186 +++
 drivers/net/cnxt_emac/emac_drv.c         |  737 +++++++++++
 drivers/net/cnxt_emac/emac_prv.c         | 2080 ++++++++++++++++++++++++++++++
 drivers/net/cnxt_emac/emac_prv.h         |  476 +++++++
 drivers/serial/Kconfig                   |   79 ++
 drivers/serial/Makefile                  |    2 +-
 drivers/serial/cx2450x_uart.c            |  985 ++++++++++++++
 drivers/usb/Kconfig                      |    1 +
 drivers/usb/host/Kconfig                 |   28 +
 drivers/usb/host/ehci-cx2450x.c          |  259 ++++
 drivers/usb/host/ehci-hcd.c              |    5 +
 fs/direct-io.c                           |   11 +-
 fs/proc/proc_misc.c                      |   16 +-
 include/asm-arm/arch-nevis/cx2450x.h     |  159 +++
 include/asm-arm/arch-nevis/debug-macro.S |   51 +
 include/asm-arm/arch-nevis/dma.h         |   27 +
 include/asm-arm/arch-nevis/drivers.h     |   17 +
 include/asm-arm/arch-nevis/entry-macro.S |  109 ++
 include/asm-arm/arch-nevis/gpio.h        |   83 ++
 include/asm-arm/arch-nevis/hardware.h    |   41 +
 include/asm-arm/arch-nevis/ide.h         |   30 +
 include/asm-arm/arch-nevis/io.h          |   53 +
 include/asm-arm/arch-nevis/irq.h         |   37 +
 include/asm-arm/arch-nevis/irqs.h        |   55 +
 include/asm-arm/arch-nevis/memmap.h      |   60 +
 include/asm-arm/arch-nevis/memory.h      |  103 ++
 include/asm-arm/arch-nevis/param.h       |   34 +
 include/asm-arm/arch-nevis/platform.h    |   40 +
 include/asm-arm/arch-nevis/startup.h     |   84 ++
 include/asm-arm/arch-nevis/system.h      |   47 +
 include/asm-arm/arch-nevis/time.h        |   37 +
 include/asm-arm/arch-nevis/timex.h       |   24 +
 include/asm-arm/arch-nevis/uncompress.h  |  184 +++
 include/asm-arm/arch-nevis/vmalloc.h     |   34 +
 include/asm-arm/arm11jmp.h               |   35 +
 include/asm-arm/cacheflush.h             |   49 +-
 include/asm-arm/hardware/serial_cnxt.h   |   97 ++
 include/asm-arm/memory.h                 |   10 +-
 include/asm-arm/mmu_context.h            |    5 +
 include/asm-arm/processor.h              |    8 +-
 include/asm-arm/setup.h                  |   26 +
 include/linux/kernel.h                   |    4 +
 include/linux/serial_core.h              |    3 +
 89 files changed, 11258 insertions(+), 45 deletions(-)
 create mode 100644 arch/arm/lib/arm11jmp.S
 create mode 100644 arch/arm/mach-nevis/Kconfig
 create mode 100644 arch/arm/mach-nevis/Makefile
 create mode 100644 arch/arm/mach-nevis/Makefile.boot
 create mode 100644 arch/arm/mach-nevis/devices.c
 create mode 100644 arch/arm/mach-nevis/devices.h
 create mode 100644 arch/arm/mach-nevis/dma.c
 create mode 100644 arch/arm/mach-nevis/gpio.c
 create mode 100644 arch/arm/mach-nevis/irq.c
 create mode 100644 arch/arm/mach-nevis/mach.c
 create mode 100644 arch/arm/mach-nevis/mipidle.c
 create mode 100644 arch/arm/mach-nevis/pci.c
 create mode 100644 arch/arm/mach-nevis/pllc.c
 create mode 100644 arch/arm/mach-nevis/time.c
 create mode 100755 build.sh
 create mode 100644 config-2.6.26.8-nevis
 create mode 100644 drivers/char/hw_random/cx2450x-rng.c
 create mode 100644 drivers/mtd/maps/cx2450x-flash.c
 create mode 100644 drivers/net/cnxt_emac/Kconfig
 create mode 100644 drivers/net/cnxt_emac/Makefile
 create mode 100644 drivers/net/cnxt_emac/emac.h
 create mode 100644 drivers/net/cnxt_emac/emac_drv.c
 create mode 100644 drivers/net/cnxt_emac/emac_prv.c
 create mode 100644 drivers/net/cnxt_emac/emac_prv.h
 create mode 100644 drivers/serial/cx2450x_uart.c
 create mode 100644 drivers/usb/host/ehci-cx2450x.c
 create mode 100644 include/asm-arm/arch-nevis/cx2450x.h
 create mode 100644 include/asm-arm/arch-nevis/debug-macro.S
 create mode 100644 include/asm-arm/arch-nevis/dma.h
 create mode 100644 include/asm-arm/arch-nevis/drivers.h
 create mode 100644 include/asm-arm/arch-nevis/entry-macro.S
 create mode 100644 include/asm-arm/arch-nevis/gpio.h
 create mode 100644 include/asm-arm/arch-nevis/hardware.h
 create mode 100644 include/asm-arm/arch-nevis/ide.h
 create mode 100644 include/asm-arm/arch-nevis/io.h
 create mode 100644 include/asm-arm/arch-nevis/irq.h
 create mode 100644 include/asm-arm/arch-nevis/irqs.h
 create mode 100644 include/asm-arm/arch-nevis/memmap.h
 create mode 100644 include/asm-arm/arch-nevis/memory.h
 create mode 100644 include/asm-arm/arch-nevis/param.h
 create mode 100644 include/asm-arm/arch-nevis/platform.h
 create mode 100644 include/asm-arm/arch-nevis/startup.h
 create mode 100644 include/asm-arm/arch-nevis/system.h
 create mode 100644 include/asm-arm/arch-nevis/time.h
 create mode 100644 include/asm-arm/arch-nevis/timex.h
 create mode 100644 include/asm-arm/arch-nevis/uncompress.h
 create mode 100644 include/asm-arm/arch-nevis/vmalloc.h
 create mode 100644 include/asm-arm/arm11jmp.h
 create mode 100644 include/asm-arm/hardware/serial_cnxt.h

diff --git a/Makefile b/Makefile
index 7f13632..307c420 100644
--- a/Makefile
+++ b/Makefile
@@ -431,7 +431,11 @@ ifeq ($(config-targets),1)
 include $(srctree)/arch/$(SRCARCH)/Makefile
 export KBUILD_DEFCONFIG
 
-config %config: scripts_basic outputmakefile FORCE
+config: scripts_basic outputmakefile FORCE
+	$(Q)mkdir -p include/linux include/config
+	$(Q)$(MAKE) $(build)=scripts/kconfig $@
+
+%config: scripts_basic outputmakefile FORCE
 	$(Q)mkdir -p include/linux include/config
 	$(Q)$(MAKE) $(build)=scripts/kconfig $@
 
@@ -1548,7 +1552,11 @@ endif
 	$(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@)
 
 # Modules
-/ %/: prepare scripts FORCE
+/: prepare scripts FORCE
+	$(cmd_crmodverdir)
+	$(Q)$(MAKE) KBUILD_MODULES=$(if $(CONFIG_MODULES),1) \
+	$(build)=$(build-dir)
+%/: prepare scripts FORCE
 	$(cmd_crmodverdir)
 	$(Q)$(MAKE) KBUILD_MODULES=$(if $(CONFIG_MODULES),1) \
 	$(build)=$(build-dir)
diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index b786e68..fa0841f 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -80,6 +80,10 @@ config GENERIC_HARDIRQS
 	bool
 	default y
 
+config SETJMP_INCLUDED
+        bool
+        default y
+
 config STACKTRACE_SUPPORT
 	bool
 	default y
@@ -147,6 +151,10 @@ config FIQ
 config ARCH_MTD_XIP
 	bool
 
+config GENERIC_HARDIRQS_NO__DO_IRQ
+	bool
+	def_bool y
+
 if OPROFILE
 
 config OPROFILE_ARMV6
@@ -383,6 +391,14 @@ config ARCH_ORION5X
 	  Support for the following Marvell Orion 5x series SoCs:
 	  Orion-1 (5181), Orion-NAS (5182), Orion-2 (5281.)
 
+config ARCH_NEVIS
+	bool "Nevis"
+	depends on MMU
+	select GENERIC_GPIO
+	select HAVE_GPIO_LIB
+	help
+	  Support for Conexant 2450x processor.
+
 config ARCH_PNX4008
 	bool "Philips Nexperia PNX4008 Mobile"
 	help
@@ -504,6 +520,8 @@ source "arch/arm/mach-ixp23xx/Kconfig"
 
 source "arch/arm/mach-pxa/Kconfig"
 
+source "arch/arm/mach-nevis/Kconfig"
+
 source "arch/arm/mach-sa1100/Kconfig"
 
 source "arch/arm/plat-omap/Kconfig"
@@ -582,6 +600,16 @@ if !MMU
 source "arch/arm/Kconfig-nommu"
 endif
 
+config ARM_ERRATA_411920
+	bool "Workaround for the global I cache invalidation on ARM1136"
+	depends on CPU_V6 && !SMP
+	default n
+	help
+	  Invalidation of the Instruction Cache operation can
+	  fail. This Erratum is present in 1136, 1156 and 1176. It
+	  does not affect the MPCore. This option enables the ARM Ltd.
+	  recommended workaround.
+
 endmenu
 
 source "arch/arm/common/Kconfig"
@@ -615,7 +643,7 @@ config ISA_DMA_API
 	bool
 
 config PCI
-	bool "PCI support" if ARCH_INTEGRATOR_AP || ARCH_VERSATILE_PB || ARCH_IXP4XX || ARCH_KS8695 || MACH_ARMCORE
+	bool "PCI support" if ARCH_INTEGRATOR_AP || ARCH_VERSATILE_PB || ARCH_IXP4XX || ARCH_KS8695 || MACH_ARMCORE || ARCH_NEVIS
 	help
 	  Find out whether you have a PCI motherboard. PCI is the name of a
 	  bus system, i.e. the way the CPU talks to the other stuff inside
diff --git a/arch/arm/Makefile b/arch/arm/Makefile
index e72db27..8f1ac0e 100644
--- a/arch/arm/Makefile
+++ b/arch/arm/Makefile
@@ -76,8 +76,8 @@ tune-$(CONFIG_CPU_SA110)	:=-mtune=strongarm110
 tune-$(CONFIG_CPU_SA1100)	:=-mtune=strongarm1100
 tune-$(CONFIG_CPU_XSCALE)	:=$(call cc-option,-mtune=xscale,-mtune=strongarm110) -Wa,-mcpu=xscale
 tune-$(CONFIG_CPU_XSC3)		:=$(call cc-option,-mtune=xscale,-mtune=strongarm110) -Wa,-mcpu=xscale
-tune-$(CONFIG_CPU_V6)		:=$(call cc-option,-mtune=arm1136j-s,-mtune=strongarm)
-
+#tune-$(CONFIG_CPU_V6)		:=$(call cc-option,-mtune=arm1136j-s,-mtune=strongarm)
+tune-$(CONFIG_CPU_V6)		:=$(call cc-option,-mtune=arm1176jz-s,-mtune=strongarm)
 ifeq ($(CONFIG_AEABI),y)
 CFLAGS_ABI	:=-mabi=aapcs-linux -mno-thumb-interwork
 else
@@ -140,6 +140,13 @@ endif
  machine-$(CONFIG_ARCH_MX3)	   := mx3
  machine-$(CONFIG_ARCH_ORION5X)	   := orion5x
  machine-$(CONFIG_ARCH_MSM7X00A)   := msm
+ machine-$(CONFIG_ARCH_NEVIS)	   := nevis
+ textofs-$(CONFIG_ARCH_NEVIS)	   := $(CONFIG_CNXT_TEXT_OFFSET)
+
+
+ifeq ($(CONFIG_ARCH_NEVIS),y)
+KBUILD_CFLAGS	+= -DTEXT_OFFSET=$(CONFIG_CNXT_TEXT_OFFSET)
+endif
 
 ifeq ($(CONFIG_ARCH_EBSA110),y)
 # This is what happens if you forget the IOCS16 line.
diff --git a/arch/arm/kernel/armksyms.c b/arch/arm/kernel/armksyms.c
index 688b7b1..ddeaf82 100644
--- a/arch/arm/kernel/armksyms.c
+++ b/arch/arm/kernel/armksyms.c
@@ -18,7 +18,7 @@
 #include <asm/io.h>
 #include <asm/system.h>
 #include <asm/uaccess.h>
-
+#include <asm/arm11jmp.h>
 /*
  * libgcc functions - functions that are used internally by the
  * compiler...  (prototypes are not correct though, but that
@@ -44,6 +44,7 @@ extern void __aeabi_lmul(void);
 extern void __aeabi_uidiv(void);
 extern void __aeabi_uidivmod(void);
 extern void __aeabi_ulcmp(void);
+extern void __aeabi_uldivmod(void);
 
 extern void fpundefinstr(void);
 extern void fp_enter(void);
@@ -153,6 +154,7 @@ EXPORT_SYMBOL(__aeabi_lmul);
 EXPORT_SYMBOL(__aeabi_uidiv);
 EXPORT_SYMBOL(__aeabi_uidivmod);
 EXPORT_SYMBOL(__aeabi_ulcmp);
+EXPORT_SYMBOL(__aeabi_uldivmod);
 #endif
 
 	/* bitops */
@@ -180,4 +182,10 @@ EXPORT_SYMBOL(_find_first_bit_be);
 EXPORT_SYMBOL(_find_next_bit_be);
 #endif
 
+/* setjmp and longjmp functions */
+#ifdef CONFIG_SETJMP_INCLUDED
+EXPORT_SYMBOL(_setjmp);
+EXPORT_SYMBOL(longjmp);
+#endif
+
 EXPORT_SYMBOL(copy_page);
diff --git a/arch/arm/kernel/calls.S b/arch/arm/kernel/calls.S
index 30a67a5..fb1b8bd 100644
--- a/arch/arm/kernel/calls.S
+++ b/arch/arm/kernel/calls.S
@@ -262,10 +262,10 @@
 /* 250 */	CALL(sys_epoll_create)
 		CALL(ABI(sys_epoll_ctl, sys_oabi_epoll_ctl))
 		CALL(ABI(sys_epoll_wait, sys_oabi_epoll_wait))
-	 	CALL(sys_remap_file_pages)
+		CALL(sys_remap_file_pages)
 		CALL(sys_ni_syscall)	/* sys_set_thread_area */
 /* 255 */	CALL(sys_ni_syscall)	/* sys_get_thread_area */
- 		CALL(sys_set_tid_address)
+		CALL(sys_set_tid_address)
 		CALL(sys_timer_create)
 		CALL(sys_timer_settime)
 		CALL(sys_timer_gettime)
diff --git a/arch/arm/kernel/head.S b/arch/arm/kernel/head.S
index bff4c6e..e474231 100644
--- a/arch/arm/kernel/head.S
+++ b/arch/arm/kernel/head.S
@@ -251,6 +251,7 @@ __create_page_tables:
 	add	r6, r4, r6, lsr #18
 1:	cmp	r0, r6
 	add	r3, r3, #1 << 20
+	it	ls
 	strls	r3, [r0], #4
 	bls	1b
 
diff --git a/arch/arm/lib/Makefile b/arch/arm/lib/Makefile
index 30351cd..8635ffa 100644
--- a/arch/arm/lib/Makefile
+++ b/arch/arm/lib/Makefile
@@ -13,7 +13,8 @@ lib-y		:= backtrace.o changebit.o csumipv6.o csumpartial.o   \
 		   testchangebit.o testclearbit.o testsetbit.o        \
 		   ashldi3.o ashrdi3.o lshrdi3.o muldi3.o             \
 		   ucmpdi2.o lib1funcs.o div64.o sha1.o               \
-		   io-readsb.o io-writesb.o io-readsl.o io-writesl.o
+		   io-readsb.o io-writesb.o io-readsl.o io-writesl.o  \
+	           arm11jmp.o
 
 mmu-y	:= clear_user.o copy_page.o getuser.o putuser.o
 
diff --git a/arch/arm/lib/arm11jmp.S b/arch/arm/lib/arm11jmp.S
new file mode 100644
index 0000000..b7944f8
--- /dev/null
+++ b/arch/arm/lib/arm11jmp.S
@@ -0,0 +1,51 @@
+/* linux/arch/arm/lin/arm11jmp.S
+ *
+ * ASM helpers for longjmp and setjmp
+ * 
+ * Copyright (C) 2010 CoolStream International Limited.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+
+.global longjmp
+.align 2
+
+longjmp:
+    mov		ip, r0
+    movs	r0, r1
+    moveq	r0, #1
+    ldmia	ip!,  {v1-v6, sl, fp, sp, lr}
+#ifdef CONFIG_FRAME_POINTER
+    bx		lr
+#else
+    mov		pc, lr
+#endif
+
+/*******************************************************************************/
+
+.global _setjmp
+.align 2
+
+_setjmp:
+    mov		ip, r0
+    stmia	ip!, {v1-v6, sl, fp, sp, lr}
+    mov		r0, #0
+#ifdef CONFIG_FRAME_POINTER
+    bx		lr
+#else
+    mov		pc, lr
+#endif
+
diff --git a/arch/arm/lib/clear_user.S b/arch/arm/lib/clear_user.S
index ecb28dc..0210da9 100644
--- a/arch/arm/lib/clear_user.S
+++ b/arch/arm/lib/clear_user.S
@@ -19,7 +19,7 @@
  * Returns  : number of bytes NOT cleared
  */
 ENTRY(__clear_user)
-		stmfd	sp!, {r1, lr}
+		stmfd	sp!, {r1, r3, lr}
 		mov	r2, #0
 		cmp	r1, #4
 		blt	2f
@@ -32,6 +32,13 @@ USER(		strltbt	r2, [r0], #1)
 		rsb	ip, ip, #4
 		sub	r1, r1, ip		@  7  6  5  4  3  2  1
 1:		subs	r1, r1, #8		@ -1 -2 -3 -4 -5 -6 -7
+#ifndef CONFIG_OUTER_CACHE
+		tstpl	r0, #0x1f		@  see if we are at the beginning of a cache line
+USER(		ldreqt	r3, [r0])		@  force line allocate if we are
+		cmp	r1, #0		@  The flag set as a result of the SUSB instruction is
+						@  positive, Zero or Negative. comparing r1 with zero would
+						@  result in the same flags getting set again.
+#endif
 USER(		strplt	r2, [r0], #4)
 USER(		strplt	r2, [r0], #4)
 		bpl	1b
@@ -41,12 +48,13 @@ USER(		strplt	r2, [r0], #4)
 USER(		strnebt	r2, [r0], #1)
 USER(		strnebt	r2, [r0], #1)
 		tst	r1, #1			@ x1 x0 x1 x0 x1 x0 x1
+		it	ne
 USER(		strnebt	r2, [r0], #1)
 		mov	r0, #0
-		ldmfd	sp!, {r1, pc}
+		ldmfd	sp!, {r1, r3,  pc}
 
 		.section .fixup,"ax"
 		.align	0
-9001:		ldmfd	sp!, {r0, pc}
+9001:		ldmfd	sp!, {r0, r3, pc}
 		.previous
 
diff --git a/arch/arm/lib/delay.S b/arch/arm/lib/delay.S
index 930a702..575a1f5 100644
--- a/arch/arm/lib/delay.S
+++ b/arch/arm/lib/delay.S
@@ -31,6 +31,7 @@ ENTRY(__const_udelay)				@ 0 <= r0 <= 0x7fffff06
 		mov	r2, r2, lsr #10		@ max = 0x00007fff
 		mul	r0, r2, r0		@ max = 2^32-1
 		movs	r0, r0, lsr #6
+		it	eq
 		moveq	pc, lr
 
 /*
@@ -58,5 +59,6 @@ ENTRY(__delay)
 		movls	pc, lr
 		subs	r0, r0, #1
 #endif
+		it	hi
 		bhi	__delay
 		mov	pc, lr
diff --git a/arch/arm/lib/lib1funcs.S b/arch/arm/lib/lib1funcs.S
index 4e492f4..252f621 100644
--- a/arch/arm/lib/lib1funcs.S
+++ b/arch/arm/lib/lib1funcs.S
@@ -327,6 +327,44 @@ ENTRY(__aeabi_idivmod)
 
 #endif
 
+#ifdef CONFIG_AEABI
+
+/* Patch added by Conexant
+    Inputs:-    r0, r1   -   divisor
+                r2, r3   -   divident  ( the higher bit is ignored in current implementation as we call __do_div64
+    Outputs:-   r0, r1   -   quotient
+                r2, r3   -   remainder
+*/
+
+ENTRY(__aeabi_uldivmod)
+      stmfd    sp!, {r4, ip, lr}
+
+#ifdef __ARMEB__  /* If we have big-endian then move r3 to r4, because __do_div64 has 32-bit divisor */
+      mov      r4, r3
+#else
+      mov      r4, r2
+#endif
+      bl       __do_div64    /* The result is in r2 and r3 . and this is also written in assembly */
+
+      mov      r4, r0
+      mov      r0, r2
+      mov      r2, r4
+
+      mov      r4, r1
+      mov      r1, r3
+      mov      r3, r4
+
+#ifndef __ARMEB__
+      mov      r4, r2
+      mov      r2, r3
+      mov      r3, r4
+#endif
+
+      ldmfd    sp!, {r4, ip, lr}
+      mov      pc, lr
+#endif
+
+
 Ldiv0:
 
 	str	lr, [sp, #-8]!
diff --git a/arch/arm/mach-nevis/Kconfig b/arch/arm/mach-nevis/Kconfig
new file mode 100644
index 0000000..eb49774
--- /dev/null
+++ b/arch/arm/mach-nevis/Kconfig
@@ -0,0 +1,224 @@
+if ARCH_NEVIS
+
+menu "Conexant CX2450X (Nevis) SoC support"
+	depends on ARCH_NEVIS
+
+config	MACH_NEVIS
+	bool "Nevis IRD board support"
+	help
+	 Enables CX2450X based IRDs
+
+config  ED_COOLSTREAM_HD1
+	depends on MACH_NEVIS
+	bool  "CoolStream HD1 IRD"
+	default y
+
+config  ARCH_CNXT_EDWARDS
+	bool "Conexant Edwards API"
+	default y
+	help
+	 Enables the use of Conexant Edwards API.
+
+config  CNXT_PHYS_OFFSET
+	depends on ARCH_CNXT_EDWARDS
+	hex "PHYS Offset"
+	default 0x0
+	help
+	 PHYS_OFFSET is the address at which the kernel thinks
+	 RAM begins.  If there is an address hole/alias at
+	 physical address 0, then PHYS_OFFSET would probably
+	 NOT be 0.
+
+config  CNXT_TEXT_OFFSET
+	depends on ARCH_CNXT_EDWARDS
+	hex "Kernel Text Offset"
+	default 0x0f048000
+	help
+	 TEXT_OFFSET tells the kernel where to begin its
+	 text section relative to where it thinks the beginning
+	 of RAM is.  ie.  The kernel is loaded at
+	 TEXT_OFFSET + PHYS_OFFSET.  The kernel requires that
+	 this address end in 0xYYYZ8000.  Conexant requires that
+	 Z be greater than 0.
+
+config  CNXT_MODULE_START_OFFSET
+	depends on ARCH_CNXT_EDWARDS
+	hex "Module address space start offset"
+	default 0x00FB8000
+
+config  CNXT_MODULE_ADDRESS_SPACE_SIZE
+	depends on ARCH_CNXT_EDWARDS
+	hex "Module address space size"
+	default 0x1000000
+
+config  CNXT_VMALLOC_SIZE
+	depends on ARCH_CNXT_EDWARDS
+	hex "VMALLOC size"
+	default 0x18000000
+
+config  CNXT_DECARM_PHY_ADDRESS
+	depends on ARCH_CNXT_EDWARDS
+	hex "DECARM Physical Start Address"
+	default 0x17800000
+	help
+	 This is the physical address at which the kernel
+	 will reserve memory for use by the DECARM slave CPU.
+	 Be sure to avoid any overlapping memory regions with
+	 the KAL memory.
+
+config  CNXT_DECARM_CODE_MEM_SIZE
+	depends on ARCH_CNXT_EDWARDS
+	hex "Conexant DECARM Code Memory Size"
+	default 0x00300000
+	help
+	 This tells the kernel how much memory is being
+	 reserved for MALONE. The default is 3MB.
+
+config  CNXT_DECARM_SHARED_MEM_SIZE
+	depends on ARCH_CNXT_EDWARDS
+	hex "Conexant DECARM Shared Memory Size"
+	default 0x00100000
+	help
+	 This tells the kernel how much memory is being
+	 reserved for MALONE shared memory. This memory is
+	 is shared between the host CPU and the slave. The
+	 default is 1MB.
+
+menu "GPIO MUX defaults"
+depends on ARCH_CNXT_EDWARDS
+config PLL_CONFIG0_REG_DEFAULT
+	hex "PLL CONFIG 0 register"
+	default CONFIG_PLL_CONFIG0_REG_DEFAULT
+
+config PLL_PIN_ALT_FUNC_REG_DEFAULT
+	hex "PLL PIN ALT FUNC register"
+	default CONFIG_PLL_PIN_ALT_FUNC_REG_DEFAULT
+
+config PLL_PIN_GPIO_MUX0_REG_DEFAULT
+	hex "PLL PIN GPIO MUX0 REG"
+	default CONFIG_PLL_PIN_GPIO_MUX0_REG_DEFAULT
+
+config PLL_PIN_GPIO_MUX1_REG_DEFAULT
+	hex "PLL PIN GPIO MUX1 REG"
+	default CONFIG_PLL_PIN_GPIO_MUX1_REG_DEFAULT
+
+config PLL_PIN_GPIO_MUX2_REG_DEFAULT
+	hex "PLL PIN GPIO MUX2 REG"
+	default CONFIG_PLL_PIN_GPIO_MUX2_REG_DEFAULT
+
+config PLL_PIN_GPIO_MUX3_REG_DEFAULT
+	hex "PLL PIN GPIO MUX3 REG"
+	default CONFIG_PLL_PIN_GPIO_MUX3_REG_DEFAULT
+
+config PLL_PIN_GPIO_MUX4_REG_DEFAULT
+	hex "PLL PIN GPIO MUX4 REG"
+	default CONFIG_PLL_PIN_GPIO_MUX4_REG_DEFAULT
+
+config PLL_PIN_GPIO_MUX5_REG_DEFAULT
+	hex "PLL PIN GPIO MUX5 REG"
+	default CONFIG_PLL_PIN_GPIO_MUX5_REG_DEFAULT
+
+config PLL_PIN_GPIO_MUX6_REG_DEFAULT
+	hex "PLL PIN GPIO MUX6 REG"
+	default CONFIG_PLL_PIN_GPIO_MUX6_REG_DEFAULT
+
+config SREG_2ND_PIN_MUX0_REG_DEFAULT
+	hex "SREG 2ND PIN MUX0 REG"
+	default CONFIG_SREG_2ND_PIN_MUX0_REG_DEFAULT
+
+config SREG_2ND_PIN_MUX1_REG_DEFAULT
+	hex "SREG 2ND PIN MUX1 REG"
+	default CONFIG_SREG_2ND_PIN_MUX1_REG_DEFAULT
+
+config SREG_2ND_PIN_MUX2_REG_DEFAULT
+	hex "SREG 2ND PIN MUX2 REG"
+	default CONFIG_SREG_2ND_PIN_MUX2_REG_DEFAULT
+
+config SREG_2ND_PIN_MUX3_REG_DEFAULT
+	hex "SREG 2ND PIN MUX3 REG"
+	default CONFIG_SREG_2ND_PIN_MUX3_REG_DEFAULT
+
+config SREG_2ND_PIN_MUX4_REG_DEFAULT
+	hex "SREG 2ND PIN MUX4 REG"
+	default CONFIG_SREG_2ND_PIN_MUX4_REG_DEFAULT
+
+config SREG_2ND_PIN_MUX5_REG_DEFAULT
+	hex "SREG 2ND PIN MUX5 REG"
+	default CONFIG_SREG_2ND_PIN_MUX5_REG_DEFAULT
+
+config SREG_2ND_PIN_MUX6_REG_DEFAULT
+	hex "SREG 2ND PIN MUX6 REG"
+	default CONFIG_SREG_2ND_PIN_MUX6_REG_DEFAULT
+
+endmenu
+
+menu "GPIO options"
+	depends on MACH_NEVIS
+config	PIO_INIT_ON_BOOT
+	bool "Initialize GPIO's on boot"
+	default y
+	help
+	 If enabled, all exisiting GPIO pins will be 
+	 initialized to be inputs in the early boot.
+
+config	PIO_EXCL_MASK_PIO_031_000
+	depends on PIO_INIT_ON_BOOT
+	hex "Exclude mask for PIO  31 to   0"
+	default 0x00000000
+	help
+	 GPIO's marked with 1 here are excluded from
+	 the initialization.
+
+config	PIO_EXCL_MASK_PIO_063_032
+	depends on PIO_INIT_ON_BOOT
+	hex "Exclude mask for PIO  63 to  32"
+	default 0x00000000
+	help
+	 GPIO's marked with 1 here are excluded from
+	 the initialization.
+
+config	PIO_EXCL_MASK_PIO_095_064
+	depends on PIO_INIT_ON_BOOT
+	hex "Exclude mask for PIO  95 to  64"
+	default 0x00000000
+	help
+	 GPIO's marked with 1 here are excluded from
+	 the initialization.
+
+config	PIO_EXCL_MASK_PIO_127_096
+	depends on PIO_INIT_ON_BOOT
+	hex "Exclude mask for PIO 127 to  96"
+	default 0x00000000
+	help
+	 GPIO's marked with 1 here are excluded from
+	 the initialization.
+
+config	PIO_EXCL_MASK_PIO_159_128
+	depends on PIO_INIT_ON_BOOT
+	hex "Exclude mask for PIO 159 to 128"
+	default 0x00000000
+	help
+	 GPIO's marked with 1 here are excluded from
+	 the initialization.
+
+config	PIO_EXCL_MASK_PIO_191_160
+	depends on PIO_INIT_ON_BOOT
+	hex "Exclude mask for PIO 191 to 160"
+	default 0x00000000
+	help
+	 GPIO's marked with 1 here are excluded from
+	 the initialization.
+
+config	PIO_EXCL_MASK_PIO_223_192
+	depends on PIO_INIT_ON_BOOT
+	hex "Exclude mask for PIO 223 to 192"
+	default 0x00000000
+	help
+	 GPIO's marked with 1 here are excluded from
+	 the initialization.
+
+endmenu
+
+endmenu
+
+endif
diff --git a/arch/arm/mach-nevis/Makefile b/arch/arm/mach-nevis/Makefile
new file mode 100644
index 0000000..8f2ed06
--- /dev/null
+++ b/arch/arm/mach-nevis/Makefile
@@ -0,0 +1,21 @@
+#
+# Makefile for the linux kernel.
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+
+USE_STANDARD_AS_RULE := true
+
+# Object file lists.
+
+obj-y			:= irq.o dma.o mach.o pllc.o mipidle.o devices.o gpio.o time.o
+obj-m			:=
+obj-n			:=
+obj-			:=
+
+#export-objs		:= mach.o
+
+obj-$(CONFIG_PCI)	+= pci.o
+
+#include $(TOPDIR)/Rules.make
diff --git a/arch/arm/mach-nevis/Makefile.boot b/arch/arm/mach-nevis/Makefile.boot
new file mode 100644
index 0000000..bd07dc5
--- /dev/null
+++ b/arch/arm/mach-nevis/Makefile.boot
@@ -0,0 +1,2 @@
+zreladdr-y	:=  $(CONFIG_CNXT_TEXT_OFFSET)
+
diff --git a/arch/arm/mach-nevis/devices.c b/arch/arm/mach-nevis/devices.c
new file mode 100644
index 0000000..37098d4
--- /dev/null
+++ b/arch/arm/mach-nevis/devices.c
@@ -0,0 +1,220 @@
+/* linux/arch/arm/mach-nevis/devices.c
+ *
+ * Platform device definitions and helper functions for systems based
+ * on the Conexant CX2450x (Nevis) SoC
+ *
+ * Copyright (C) 2008 CoolStream International Limited.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/list.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/irq.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+
+#include <asm/arch/memory.h>
+#include "devices.h"
+
+static u64 cx2450x_device_dmamask = DMA_BIT_MASK(32);
+
+/* 
+ * USB Host Controllers
+ */
+#ifdef CONFIG_CX2450X_USB0
+static struct resource cx2450x_usb_res0[] = {
+	[0] = {
+	       .start = 0xE8000100,
+	       .end = 0xE80001FB,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = IRQ_USB0,
+	       .end = IRQ_USB0,
+	       .flags = IORESOURCE_IRQ,
+	       }
+};
+#endif
+
+#ifdef CONFIG_CX2450X_USB1
+static struct resource cx2450x_usb_res1[] = {
+	[0] = {
+	       .start = 0xE8001100,
+	       .end = 0xE80011FB,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = IRQ_USB1,
+	       .end = IRQ_USB1,
+	       .flags = IORESOURCE_IRQ,
+	       }
+};
+#endif
+
+#ifdef CONFIG_SERIAL_CNXT_UART
+#if CONFIG_SERIAL_CNXT_UART >= 1
+
+/*
+ * Serial port #0, by default we use Conexant UART #3 for console etc.
+ * Resources from 0xE041x00 - 0xE041x3C, where x is 0, 0x1000, 0x2000, 0x3000
+ * Note: we reversed the mappings because the serial console is hooked up at UART #3.
+ *	 This simplifies the mapping. So ttyRI0 will be the real console.
+ *	 WARNING: Do not change the id because the driver depends on this.
+ */
+static struct resource cx2450x_ser0_res[] = {
+	[0] = {
+	       .start = 0xE0412000,
+	       .end   = 0xE041203F,
+	       .flags = IORESOURCE_MEM,
+	      },
+	[1] = {
+	       .start = IRQ_UART3,
+	       .end   = IRQ_UART3,
+	       .flags = IORESOURCE_IRQ,
+	      }
+};
+
+/*******************************************************************************/
+
+struct platform_device cx2450x_device_ser0 = {
+	.name = "cnxt_uart",
+	.id = 0,
+	.num_resources = ARRAY_SIZE (cx2450x_ser0_res),
+	.resource = cx2450x_ser0_res,
+	.dev = {
+		.dma_mask = &cx2450x_device_dmamask,
+		.coherent_dma_mask = DMA_BIT_MASK (32),
+		}
+};
+#endif
+
+/*******************************************************************************/
+
+#if CONFIG_SERIAL_CNXT_UART >= 2
+static struct resource cx2450x_ser1_res[] = {
+	[0] = {
+	       .start = 0xE0411000,
+	       .end   = 0xE041103F,
+	       .flags = IORESOURCE_MEM,
+	      },
+	[1] = {
+	       .start = IRQ_UART2,
+	       .end   = IRQ_UART2,
+	       .flags = IORESOURCE_IRQ,
+	      }
+};
+
+/*******************************************************************************/
+
+struct platform_device cx2450x_device_ser1 = {
+	.name = "cnxt_uart",
+	.id = 1,
+	.num_resources = ARRAY_SIZE (cx2450x_ser1_res),
+	.resource = cx2450x_ser1_res,
+	.dev = {
+		.dma_mask = &cx2450x_device_dmamask,
+		.coherent_dma_mask = DMA_BIT_MASK (32),
+	       }
+};
+#endif
+
+/*******************************************************************************/
+
+#if CONFIG_SERIAL_CNXT_UART >= 3
+static struct resource cx2450x_ser2_res[] = {
+	[0] = {
+	       .start = 0xE0410000,
+	       .end   = 0xE041003B,
+	       .flags = IORESOURCE_MEM,
+	      },
+	[1] = {
+	       .start = IRQ_UART1,
+	       .end   = IRQ_UART1,
+	       .flags = IORESOURCE_IRQ,
+	      }
+};
+
+/*******************************************************************************/
+
+struct platform_device cx2450x_device_ser2 = {
+	.name = "cnxt_uart",
+	.id = 2,
+	.num_resources = ARRAY_SIZE (cx2450x_ser2_res),
+	.resource = cx2450x_ser2_res,
+	.dev = {
+		.dma_mask = &cx2450x_device_dmamask,
+		.coherent_dma_mask = DMA_BIT_MASK (32),
+		}
+};
+
+#endif
+#endif
+
+/*******************************************************************************/
+
+#ifdef CONFIG_CX2450X_USB0
+struct platform_device cx2450x_device_usb0 = {
+	.name = "cx2450x-ehci",
+	.id = 0,
+	.num_resources = ARRAY_SIZE (cx2450x_usb_res0),
+	.resource = cx2450x_usb_res0,
+	.dev = {
+		.dma_mask = &cx2450x_device_dmamask,
+		.coherent_dma_mask = 0xFFFFFFFFUL}
+};
+#endif
+
+#ifdef CONFIG_CX2450X_USB1
+struct platform_device cx2450x_device_usb1 = {
+	.name = "cx2450x-ehci",
+	.id = 1,
+	.num_resources = ARRAY_SIZE (cx2450x_usb_res1),
+	.resource = cx2450x_usb_res1,
+	.dev = {
+		.dma_mask = &cx2450x_device_dmamask,
+		.coherent_dma_mask = 0xFFFFFFFFUL}
+};
+#endif
+
+/*******************************************************************************/
+
+#ifdef CONFIG_CX2450X_USB0
+EXPORT_SYMBOL (cx2450x_device_usb0);
+#endif
+
+#ifdef CONFIG_CX2450X_USB1
+EXPORT_SYMBOL (cx2450x_device_usb1);
+#endif
+
+#ifdef CONFIG_SERIAL_CNXT_UART
+#if CONFIG_SERIAL_CNXT_UART >= 1
+EXPORT_SYMBOL (cx2450x_device_ser0);
+#endif
+#if CONFIG_SERIAL_CNXT_UART >= 2
+EXPORT_SYMBOL (cx2450x_device_ser1);
+#endif
+#if CONFIG_SERIAL_CNXT_UART >= 3
+EXPORT_SYMBOL (cx2450x_device_ser2);
+#endif
+#endif
diff --git a/arch/arm/mach-nevis/devices.h b/arch/arm/mach-nevis/devices.h
new file mode 100644
index 0000000..7d17563
--- /dev/null
+++ b/arch/arm/mach-nevis/devices.h
@@ -0,0 +1,47 @@
+/* arch/arm/mach-nevis/devs.h
+ *
+ * Header file for cx2450x platform devices
+ *
+ * Copyright (C) 2008 Coolstream International Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Modifications:
+*/
+#ifndef __DEVICES_H
+#define __DEVICES_H
+
+#include <linux/autoconf.h>
+#include <linux/platform_device.h>
+
+#ifdef CONFIG_CX2450X_USB0
+extern struct platform_device cx2450x_device_usb0;	/* USB EHCI Controller #0 */
+#endif
+#ifdef CONFIG_CX2450X_USB1
+extern struct platform_device cx2450x_device_usb1;	/* USB EHCI Controller #1 */
+#endif
+
+#ifdef CONFIG_SERIAL_CNXT_UART
+#if CONFIG_SERIAL_CNXT_UART >= 1
+extern struct platform_device cx2450x_device_ser0;	/* UART #2 */
+#endif
+#if CONFIG_SERIAL_CNXT_UART >= 2
+extern struct platform_device cx2450x_device_ser1;	/* UART #1 */
+#endif
+#if CONFIG_SERIAL_CNXT_UART >= 3
+extern struct platform_device cx2450x_device_ser2;	/* UART #0 */
+#endif
+#endif
+
+#endif /* __DEVICES_H */
diff --git a/arch/arm/mach-nevis/dma.c b/arch/arm/mach-nevis/dma.c
new file mode 100644
index 0000000..5f30419
--- /dev/null
+++ b/arch/arm/mach-nevis/dma.c
@@ -0,0 +1,37 @@
+/*****************************************************************************
+ * linux/arch/arm/mach-nevis/dma.c
+ * 
+ * Copyright (C) 2007 Conexant Systems Inc, USA.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License Version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02111-1307  USA
+ *****************************************************************************/
+/*$Id$
+ ******************************************************************************/
+
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/mman.h>
+#include <linux/init.h>
+
+#include <asm/page.h>
+#include <asm/pgtable.h>
+#include <asm/dma.h>
+#include <asm/io.h>
+#include <asm/hardware.h>
+
+#include <asm/mach/dma.h>
+
+void __init arch_dma_init(dma_t * dma)
+{
+}
diff --git a/arch/arm/mach-nevis/gpio.c b/arch/arm/mach-nevis/gpio.c
new file mode 100644
index 0000000..9a748aa
--- /dev/null
+++ b/arch/arm/mach-nevis/gpio.c
@@ -0,0 +1,236 @@
+/* linux/arch/arm/mach-nevis/gpio.c
+ *
+ * GPIO helpers
+ *
+ * (C) Copyright 2008
+ * Coolstream Internation Limited
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/init.h>
+#include <linux/input.h>	/* for EXPORT_SYMBOL */
+#include <linux/module.h>
+#include <linux/irq.h>
+#include <linux/sysdev.h>
+
+#include <asm/gpio.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/arch/cx2450x.h>
+
+struct cx2450x_gpio_chip {
+	struct gpio_chip chip;
+	void __iomem     *regbase;
+};
+
+DEFINE_SPINLOCK(gpio_lock);
+
+/* some helpers for the GPIO controller */
+/*******************************************************************************/
+/* switch the pio number to the given state (PIO_HIGH, PIO_LOW, PIO_OFF)       */
+
+void gpio_drive(u32 pio, u32 state)
+{
+	unsigned long flags;
+	volatile u32 *reg, val;
+	/* decode the requested PIO to the assigned bank/bit */
+	u32 bank = pio / 32;
+	u32 bit  = pio % 32;
+
+	val = state + (bank * 0x40);
+
+	if (bank < 7) {
+		spin_lock_irqsave(&gpio_lock, flags);
+		reg = (volatile u32*)val;
+		*reg = (1 << bit);
+		spin_unlock_irqrestore(&gpio_lock, flags);
+	}
+}
+
+/*******************************************************************************/
+/* read the state of one GPIO pin (if configured as input before)              */
+
+u32 gpio_read(u32 pio)
+{
+	unsigned long flags;
+	volatile u32 *reg;
+	u32 bank = pio / 32;
+	u32 bit  = pio % 32;
+	u32 ret  = 0;
+
+	if (bank < 7) {
+		spin_lock_irqsave(&gpio_lock, flags);
+		reg = (volatile u32*)(PIO_READ_REG + (bank * 0x40));
+		if ((*reg) & (1 << bit))
+			ret = 1;
+		spin_unlock_irqrestore(&gpio_lock, flags);
+	}
+
+	return ret;
+}
+
+/*******************************************************************************/
+
+EXPORT_SYMBOL(gpio_drive);
+EXPORT_SYMBOL(gpio_read);
+
+#define PIO_BASE		0xE0470000
+#define PIO_BANKS		0x07
+#define PIO_BANK_SIZE		0x40
+#define PIO_READ_OFFSET		0x00
+#define PIO_HIGH_OFFSET		0x04
+#define PIO_LOW_OFFSET		0x08
+#define PIO_OFF_OFFSET		0x0C
+
+static int cx2450x_gpio_direction_input(struct gpio_chip *chip, unsigned offset)
+{
+	u32				mask = 1 << offset;
+	u32				value;
+	unsigned long			flags;
+	struct cx2450x_gpio_chip	*cx;
+	void __iomem			*pio_off;
+
+	cx	= container_of(chip, struct cx2450x_gpio_chip, chip);
+	pio_off = cx->regbase + PIO_OFF_OFFSET;
+
+	spin_lock_irqsave(&gpio_lock, flags);
+	value 	= readl(pio_off);
+	value 	|= mask;
+	writel(value, pio_off);
+	spin_unlock_irqrestore(&gpio_lock, flags);
+
+	return 0;
+}
+
+static int cx2450x_gpio_direction_output(struct gpio_chip *chip, unsigned offset, int value)
+{
+	u32				mask = 1 << offset;
+	unsigned long			flags;
+	struct cx2450x_gpio_chip	*cx;
+	void __iomem			*pio_off;
+
+	cx	= container_of(chip, struct cx2450x_gpio_chip, chip);
+	pio_off = cx->regbase + (value ? PIO_HIGH_OFFSET : PIO_LOW_OFFSET);
+
+	spin_lock_irqsave(&gpio_lock, flags);
+	writel(mask, pio_off);
+	spin_unlock_irqrestore(&gpio_lock, flags);
+
+	return 0;
+}
+
+/*
+ * Return GPIO level
+ */
+static int cx2450x_gpio_get(struct gpio_chip *chip, unsigned offset)
+{
+	u32				mask = 1 << offset;
+	struct cx2450x_gpio_chip	*cx;
+
+	cx = container_of(chip, struct cx2450x_gpio_chip, chip);
+	return !!(readl(cx->regbase + PIO_READ_OFFSET) & mask);
+}
+
+/*
+ * Set output GPIO level
+ */
+static void cx2450x_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
+{
+	u32				mask = 1 << offset;
+	struct cx2450x_gpio_chip	*cx;
+
+	cx = container_of(chip, struct cx2450x_gpio_chip, chip);
+
+	if (value)
+		writel(mask, cx->regbase + PIO_HIGH_OFFSET);
+	else
+		writel(mask, cx->regbase + PIO_LOW_OFFSET);
+}
+
+#define GPIO_CHIP(_n)								\
+	[_n] = {								\
+		.regbase = (void __iomem *)(PIO_BASE + ((_n) * PIO_BANK_SIZE)),	\
+		.chip = {							\
+			.label	    = "gpio-" #_n,				\
+			.direction_input	= cx2450x_gpio_direction_input,	\
+			.direction_output	= cx2450x_gpio_direction_output,\
+			.get			= cx2450x_gpio_get,		\
+			.set			= cx2450x_gpio_set,		\
+			.base			= (_n) * 32,			\
+			.ngpio			= 32,				\
+		},								\
+	}
+
+static struct cx2450x_gpio_chip cx2450x_gpio_chip[] = {
+	GPIO_CHIP(0),
+	GPIO_CHIP(1),
+	GPIO_CHIP(2),
+	GPIO_CHIP(3),
+	GPIO_CHIP(4),
+	GPIO_CHIP(5),
+	GPIO_CHIP(6),
+};
+
+int __init cx2450x_init_gpio(void)
+{
+	u32 i;
+#ifdef CONFIG_PIO_INIT_ON_BOOT
+	volatile u32 *reg;
+	u32 pio_excl_mask[7] = {
+		CONFIG_PIO_EXCL_MASK_PIO_031_000,
+		CONFIG_PIO_EXCL_MASK_PIO_063_032,
+		CONFIG_PIO_EXCL_MASK_PIO_095_064,
+		CONFIG_PIO_EXCL_MASK_PIO_127_096,
+		CONFIG_PIO_EXCL_MASK_PIO_159_128,
+		CONFIG_PIO_EXCL_MASK_PIO_191_160,
+		CONFIG_PIO_EXCL_MASK_PIO_223_192
+	};
+
+	/* Clear out GPIO registers. */
+	for (i = 0; i < PIO_BANKS; i++) {
+		/* Init all GPIO interrupt sources to known inactive state */
+		reg = (volatile u32*) GPIO_POS_EDGE_REG_BASE(i);
+		*reg = 0;
+		reg = (volatile u32*) GPIO_NEG_EDGE_REG_BASE(i);
+		*reg = 0;
+
+		/* Make sure all GPIOs are inactive and in high impedance state */
+		reg = (volatile u32*) GPIO_DRIVE_OFF_REG_BASE(i);
+		*reg = (0xFFFFFFFF ^ pio_excl_mask[i]);
+	}
+#endif /* CONFIG_PIO_INIT_ON_BOOT */
+
+	for (i = 0; i < PIO_BANKS; i++)
+		gpiochip_add(&cx2450x_gpio_chip[i].chip);
+
+	return 0;
+}
+
+
+static struct sysdev_class cx2450x_gpio_sysclass = {
+	.name		= "gpio",
+	.suspend	= NULL, //_gpio_suspend,
+	.resume		= NULL, //_gpio_resume,
+};
+
+static int __init cx2450x_gpio_init_sys(void)
+{
+	return sysdev_class_register(&cx2450x_gpio_sysclass);
+}
+
+core_initcall(cx2450x_gpio_init_sys);
+arch_initcall(cx2450x_init_gpio);
diff --git a/arch/arm/mach-nevis/irq.c b/arch/arm/mach-nevis/irq.c
new file mode 100644
index 0000000..75bb6b5
--- /dev/null
+++ b/arch/arm/mach-nevis/irq.c
@@ -0,0 +1,385 @@
+/*****************************************************************************
+ *  linux/arch/arm/mach-nevis/irq.c
+ *
+ *  Copyright (C) 2007 Conexant Systems Inc, USA.
+ *  Copyright (C) 2008 Coolstream International
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License Version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <asm/mach/irq.h>
+#include <asm/arch/param.h>
+#include <asm/arch/irq.h>
+#include <asm/arch/cx2450x.h>
+
+static volatile u32 *intena_reg[4] = {
+	(volatile u32 *)ITC_ENABLE_REG_BASE(0),
+	(volatile u32 *)ITC_ENABLE_REG_BASE(1),
+	(volatile u32 *)ITC_ENABLE_REG_BASE(2),
+	(volatile u32 *)ITC_ENABLE_REG_BASE(3)
+};
+
+static volatile u32 *intclr_reg[4] = {
+	(volatile u32 *)ITC_STATCLR_REG_BASE(0),
+	(volatile u32 *)ITC_STATCLR_REG_BASE(1),
+	(volatile u32 *)ITC_STATCLR_REG_BASE(2),
+	(volatile u32 *)ITC_STATCLR_REG_BASE(3)
+};
+
+static volatile u32 *intreq_reg[4] = {
+	(volatile u32 *)ITC_IRQREQ_REG_BASE(0),
+	(volatile u32 *)ITC_IRQREQ_REG_BASE(1),
+	(volatile u32 *)ITC_IRQREQ_REG_BASE(2),
+	(volatile u32 *)ITC_IRQREQ_REG_BASE(3),
+};
+
+static volatile u32 *piointstat_reg[7] = {
+	(volatile u32 *)GPIO_INTSTAT_REG_BASE(0),
+	(volatile u32 *)GPIO_INTSTAT_REG_BASE(1),
+	(volatile u32 *)GPIO_INTSTAT_REG_BASE(2),
+	(volatile u32 *)GPIO_INTSTAT_REG_BASE(3),
+	(volatile u32 *)GPIO_INTSTAT_REG_BASE(4),
+	(volatile u32 *)GPIO_INTSTAT_REG_BASE(5),
+	(volatile u32 *)GPIO_INTSTAT_REG_BASE(6)
+};
+
+static volatile u32 *piointena_reg[7] = {
+	(volatile u32 *)GPIO_INTENA_REG_BASE(0),
+	(volatile u32 *)GPIO_INTENA_REG_BASE(1),
+	(volatile u32 *)GPIO_INTENA_REG_BASE(2),
+	(volatile u32 *)GPIO_INTENA_REG_BASE(3),
+	(volatile u32 *)GPIO_INTENA_REG_BASE(4),
+	(volatile u32 *)GPIO_INTENA_REG_BASE(5),
+	(volatile u32 *)GPIO_INTENA_REG_BASE(6)
+};
+
+/* a simple array to mask out one of 32 possible interrupts */
+static const u32 irq_mask[128] = {
+	/* Group 1 Interrupts */
+	0x00000001, 0x00000002, 0x00000004, 0x00000008, 0x00000010, 0x00000020, 0x00000040, 0x00000080,
+	0x00000100, 0x00000200, 0x00000400, 0x00000800, 0x00001000, 0x00002000, 0x00004000, 0x00008000,
+	0x00010000, 0x00020000, 0x00040000, 0x00080000, 0x00100000, 0x00200000, 0x00400000, 0x00800000,
+	0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000,	0x40000000, 0x80000000,
+	/* Group 2 Interrupts */
+	0x00000001, 0x00000002, 0x00000004, 0x00000008, 0x00000010, 0x00000020, 0x00000040, 0x00000080,
+	0x00000100, 0x00000200, 0x00000400, 0x00000800, 0x00001000, 0x00002000, 0x00004000, 0x00008000,
+	0x00010000, 0x00020000, 0x00040000, 0x00080000, 0x00100000, 0x00200000, 0x00400000, 0x00800000,
+	0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000,
+	/* Group 3 Interrupts */
+	0x00000001, 0x00000002, 0x00000004, 0x00000008, 0x00000010, 0x00000020, 0x00000040, 0x00000080,
+	0x00000100, 0x00000200, 0x00000400, 0x00000800, 0x00001000, 0x00002000, 0x00004000, 0x00008000,
+	0x00010000, 0x00020000, 0x00040000, 0x00080000, 0x00100000, 0x00200000, 0x00400000, 0x00800000,
+	0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000,
+	/* Group 4 Interrupts */
+	0x00000001, 0x00000002, 0x00000004, 0x00000008, 0x00000010, 0x00000020, 0x00000040, 0x00000080,
+	0x00000100, 0x00000200, 0x00000400, 0x00000800, 0x00001000, 0x00002000, 0x00004000, 0x00008000,
+	0x00010000, 0x00020000, 0x00040000, 0x00080000, 0x00100000, 0x00200000, 0x00400000, 0x00800000,
+	0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000,
+};
+
+static const u32 irq_idx[128] = {
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+};
+
+#ifdef ENABLE_LATENCY_TIMER
+/**************************************************/
+/*    TYPEDEFs                                    */
+/**************************************************/
+struct s_latency latency = {
+	.count	= 0,
+};
+
+/**************************************************/
+/*    STATIC GLOBALS                              */
+/**************************************************/
+
+int get_latency_list(char *buf)
+{
+	int min = 1000000, avg = 0, max = 0;
+	int mindur = 1000000, avgdur = 0, maxdur = 0;
+	int i;
+	char *p = buf;
+
+	p += sprintf(p,
+		     "Sample size = %d.  freq(sample) = freq(tick) (%d mS)\n\n",
+		     LATENCY_COUNT, 1000 / HZ);
+
+	for (i = 0; i < LATENCY_COUNT; i++) {
+		if (latency.duration[i] < mindur)
+			mindur = latency.duration[i];
+		if (latency.duration[i] > maxdur)
+			maxdur = latency.duration[i];
+		if (latency.delta[i] < min)
+			min = latency.delta[i];
+		if (latency.delta[i] > max)
+			max = latency.delta[i];
+		avg	+= latency.delta[i];
+		avgdur	+= latency.duration[i];
+	}
+	p += sprintf(p, "min lat : %d uS\n", min / 54);
+	p += sprintf(p, "avg lat : %d uS\n", avg / (LATENCY_COUNT * 54));
+	p += sprintf(p, "max lat : %d uS\n", max / 54);
+
+	p += sprintf(p, "min dur : %d uS\n", mindur);
+	p += sprintf(p, "avg dur : %d uS\n", avgdur / LATENCY_COUNT);
+	p += sprintf(p, "max dur : %d uS\n", maxdur);
+
+	return p - buf;
+}
+#endif
+
+/*******************************************************************************/
+
+/* Interrupt handlers for the main interrupt controller */
+static void ack_irq_itc(u32 irq)
+{
+	u32 tmp;
+	tmp = *intreq_reg[irq_idx[irq]];
+#if 0
+	*intclr_reg[irq_idx[irq]] = irq_mask[irq];	/* clear the interrupt */
+#endif
+	*intena_reg[irq_idx[irq]] &= ~irq_mask[irq];	/* disable the interrupt */
+}
+
+static void mask_irq_itc(u32 irq)
+{
+	u32 tmp;
+	tmp = *intreq_reg[irq_idx[irq]];
+	*intena_reg[irq_idx[irq]] &= ~irq_mask[irq];	/* disable the interrupt */
+}
+
+static void unmask_irq_itc(u32 irq)
+{
+	*intclr_reg[irq_idx[irq]] = irq_mask[irq];	/* clear the interrupt */
+	*intena_reg[irq_idx[irq]] |= irq_mask[irq];	/* enable interrupt */
+}
+
+/*******************************************************************************/
+
+#ifdef CONFIG_PCI
+/* Interrupt Handlers for the PCI-controller. We use an own 'chip' here, even if
+   the IRQ comes from the normal ITC. The reason is, that, beside resetting the
+   status in the ITC, also the status in the PCI-controller must be set. PCI-
+   devicedrivers didn't know the PCI-Controller itself, so we must setup it here.
+   If we put INT_PCI into the main handler, we need a "if" statement to filter
+   this IRQ, which costs time, much time */
+
+static void ack_irq_pci(u32 irq)
+{
+	volatile u32 *pcistat_reg = (volatile u32 *)PCI_INTSTAT_REG;
+
+	*intena_reg[irq_idx[irq]] &= ~irq_mask[irq];	/* disable the interrup */
+	*intclr_reg[irq_idx[irq]] = irq_mask[irq];	/* clear the interrupt */
+	*pcistat_reg = 1;	/* set INTA and reset all other stats in PCI-controller */
+}
+
+static void mask_irq_pci(u32 irq)
+{
+	*intena_reg[irq_idx[irq]] &= ~irq_mask[irq];	/* disable the interrupt */
+}
+
+static void unmask_irq_pci(u32 irq)
+{
+	*intena_reg[irq_idx[irq]] |= irq_mask[irq];	/* enable the interrupt */
+}
+#endif
+/*******************************************************************************/
+
+/* Interrupt handlers for the general purpose I/O pins
+ * (if not used by other fuctions)
+ */
+static void ack_irq_gpio(u32 irq)
+{
+	u32 bank, bit;
+
+	irq -= IRQ_GPIO(0);
+	bank = irq / 32;
+	bit = irq % 32;
+	*piointena_reg[bank] &= ~irq_mask[bit];
+	*piointstat_reg[bank] |= irq_mask[bit];
+}
+
+static void mask_irq_gpio(u32 irq)
+{
+	irq -= IRQ_GPIO(0);
+	*piointena_reg[irq / 32] &= ~irq_mask[irq % 32];
+}
+
+static void unmask_irq_gpio(u32 irq)
+{
+	irq -= IRQ_GPIO(0);
+	*piointena_reg[irq / 32] |= irq_mask[irq % 32];
+}
+
+static int set_type_irq_gpio(u32 irq, u32 type)
+{
+	u32 bank, bit;
+	volatile u32 *piolevel_reg;
+	volatile u32 *piopedge_reg;
+	volatile u32 *pionedge_reg;
+
+	if (irq < IRQ_GPIO(0))
+		return -EINVAL;
+
+	irq -= IRQ_GPIO(0);
+	bank = irq / 32;
+	bit = irq % 32;
+
+	piolevel_reg = (volatile u32 *)(GPIO_LEVEL_REG_BASE(bank));
+	piopedge_reg = (volatile u32 *)(GPIO_POS_EDGE_REG_BASE(bank));
+	pionedge_reg = (volatile u32 *)(GPIO_NEG_EDGE_REG_BASE(bank));
+
+	switch (type) {
+	case IRQ_TYPE_LEVEL_HIGH:	/* High level trigger */
+		*piopedge_reg &= ~irq_mask[bit];	/* disable rising edge trigger */
+		*pionedge_reg &= ~irq_mask[bit];	/* disable falling edge trigger */
+		*piolevel_reg |= irq_mask[bit];	/* enable high level trigger */
+		break;
+	case IRQ_TYPE_LEVEL_LOW:	/* Low level trigger */
+		*piopedge_reg &= ~irq_mask[bit];	/* disable rising edge trigger */
+		*pionedge_reg &= ~irq_mask[bit];	/* disable falling edge trigger */
+		*piolevel_reg &= ~irq_mask[bit];	/* disable high level trigger */
+		break;
+	case IRQ_TYPE_EDGE_RISING:	/* Rising edge trigger */
+		*pionedge_reg &= ~irq_mask[bit];	/* disable falling edge trigger */
+		*piopedge_reg |= irq_mask[bit];	/* enable rising edge trigger */
+		break;
+	case IRQ_TYPE_EDGE_FALLING:	/* Falling edge trigger */
+		*piopedge_reg &= ~irq_mask[bit];	/* disable rising edge trigger */
+		*pionedge_reg |= irq_mask[bit];	/* enable falling edge trigger */
+		break;
+	case IRQ_TYPE_EDGE_BOTH:	/* Rising AND Falling edge trigger */
+		*piopedge_reg |= irq_mask[bit];	/* enable rising edge trigger */
+		*pionedge_reg |= irq_mask[bit];	/* enable falling edge trigger */
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/*******************************************************************************/
+
+static void nevis_irq_handle_gpio_chain(unsigned int irq, struct irq_desc *desc)
+{
+	u32 bank, bit, irqno;
+	u32 active;
+
+	for (bank = 0; bank < 7; bank++) {
+		active = *piointena_reg[bank] & *piointstat_reg[bank];
+		if (!active)
+			continue;	/* no pending interrupt in this bank */
+
+		for(bit = 0; bit < 32; bit++) {
+			if (active & irq_mask[bit]) {
+				irqno = IRQ_GPIO(0) + (bank << 5) + bit;
+				desc_handle_irq(irqno, irq_desc + irqno);
+			}
+		}
+	}
+}
+
+/*******************************************************************************/
+
+static struct irq_chip cx2450x_itc = {
+	.name	= "ITC",
+	.mask	= mask_irq_itc,
+	.unmask	= unmask_irq_itc,
+	.ack	= ack_irq_itc
+};
+
+#ifdef CONFIG_PCI
+static struct irq_chip cx2450x_chip_pci = {
+	.name	= "PCI",
+	.mask	= mask_irq_pci,
+	.unmask	= unmask_irq_pci,
+	.ack	= ack_irq_pci
+};
+#endif
+
+static struct irq_chip cx2450x_chip_gpio = {
+	.name	= "GPIO",
+	.mask	= mask_irq_gpio,
+	.unmask	= unmask_irq_gpio,
+	.ack	= ack_irq_gpio,
+	.set_type = set_type_irq_gpio
+};
+
+/*******************************************************************************/
+
+void __init cx2450x_init_irq(void)
+{
+	u32 irq;
+	volatile u32 *reg;
+
+	/* Disable Interrupt Generation */
+	*intena_reg[0] = 0x00000000;
+	*intena_reg[1] = 0x00000000;
+	*intena_reg[2] = 0x00000000;
+	*intena_reg[3] = 0x00000000;
+
+	for (irq = 0; irq < NR_IRQS; irq++) {
+#if defined(SKIP_LATCHED_TIMER)
+		/* dont interrupt for the 2nd timer unlatched or register */
+		if (irq == (32 + 7))
+			continue;
+#endif
+#if defined(SKIP_LATCHED_GPIO)
+		if (irq == (64 + 24))
+			continue;
+#endif
+
+		switch (irq) {
+		case 0 ... (IRQ_PCI - 1): /* interrupts from the 4 banks of the ITC except PCI */
+		case (IRQ_PCI + 1) ... 127:
+			set_irq_chip(irq, &cx2450x_itc);
+			set_irq_flags(irq, IRQF_VALID);
+			set_irq_handler(irq, handle_level_irq);
+			break;
+#ifdef CONFIG_PCI
+		case IRQ_PCI:		/* for speedup, the PCI interrupt is handled by it's own "ITC" */
+			set_irq_chip(irq, &cx2450x_chip_pci);
+			set_irq_flags(irq, IRQF_VALID);
+			set_irq_handler(irq, handle_level_irq);
+			break;
+#endif
+		case 128 ... 351:	/* PIO 0 to 223 in 7 banks */
+			set_irq_chip(irq, &cx2450x_chip_gpio);
+			set_irq_flags(irq, IRQF_VALID);
+			set_irq_handler(irq, handle_level_irq);
+			break;
+		default:
+			break;
+		}
+	}
+
+	/* setup chained handler for the GPIO controller */
+	set_irq_chained_handler(IRQ_GPIOC, nevis_irq_handle_gpio_chain);
+
+	/* Enable IRQ mode */
+	reg = (volatile u32 *)ITC_DEST_REG_BASE(0);
+	*reg = 0xFFFFFFFF;
+	reg = (volatile u32 *)ITC_DEST_REG_BASE(1);
+	*reg = 0xFFFFFFFF;
+	reg = (volatile u32 *)ITC_DEST_REG_BASE(2);
+	*reg = 0xFFFFFFFF;
+	reg = (volatile u32 *)ITC_DEST_REG_BASE(3);
+	*reg = 0xFFFFFFFF;
+}
diff --git a/arch/arm/mach-nevis/mach.c b/arch/arm/mach-nevis/mach.c
new file mode 100644
index 0000000..c20ee14
--- /dev/null
+++ b/arch/arm/mach-nevis/mach.c
@@ -0,0 +1,420 @@
+/***************************************************************************
+ * linux/arch/arm/mach-nevis/mach.c
+ *
+ * Copyright (C) 2010 Coolstream International Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as published 
+ * by the Free Software Foundation.
+ *
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,51 Franklin St, FIfth Floor, Boston, MA  02111-1307  USA
+ *
+ ****************************************************************************/
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/arch/irq.h>
+#include <asm/arch/cx2450x.h>
+#include "devices.h"
+
+#define FALSE 0
+#define TRUE 1
+
+/* should be inside some config.h */
+#define ATAGLIST_MAX_WORDS		192
+
+/* ToCheck : Should this be in gpi_pecos.h */
+#define DRIVE_GPIO_LOW_BANK_CLEAR(b, x)	*(volatile u32 *)(GPI_DRIVE_LOW_REG +  \
+						((b)*GPI_BANK_SIZE)) &= (~(1<<(x)))
+
+#define DRIVE_GPIO_HIGH_BANK_SET(b, x)	*(volatile u32 *)(GPI_DRIVE_HIGH_REG +  \
+						((b)*GPI_BANK_SIZE)) |= (1<<(x))
+
+#define PERI_PORT_REMAP_REG_VALUE	0xE8000009
+
+/*   **************************************************************  */
+/*   * PIT bit definition values (used in hardware config files)  *  */
+/*   **************************************************************  */
+#define PIT_GEN_CLOCK_SYNC			0x00000001
+#define PIT_GEN_ASTB				0x00000002
+#define PIT_DATA_BURST_WHEN_INDIC		0x00000001
+#define PIT_DATA_MEM_BURST			0x00000002
+#define PIT_DATA_LOCAL_READ_CACHE		0x00000004
+#define PIT_DATA_WRITE_GATHER			0x00000008
+#define PIT_DATA_READ_REORDER			0x00000010
+#define PIT_INSTR_BUFFER			0x00000001
+#define PIT_INSTR_BUFFER_NONCACHE		0x00000002
+#define PIT_INSTR_CONCUR_MEMXFER		0x00000004
+#define PIT_INSTR_AUTO_POSTLOAD			0x00000008
+#define PIT_INSTR_PGTBL_PARLEL_FETCH		0x00000010
+#define PIT_INSTR_PARSER_BUF			0x00002000
+#define PIT_INSTR_ROM_BUF			0x00004000
+#define PIT_INSTR_MEM_BUF			0x00008000
+#define PIT_INSTR_AUTO_BUF_REFETCH		0x00010000
+#define PIT_INSTR_PREFETCH_INDICATOR		0x00020000
+
+#define HSX_PIT_GENERAL_REG_DEFAULT		(PIT_GEN_CLOCK_SYNC)
+#define HSX_PIT_DATA_REG_DEFAULT		(0)
+#define HSX_PIT_INSTR_REG_DEFAULT		(0x00800000 | PIT_INSTR_PREFETCH_INDICATOR | PIT_INSTR_MEM_BUF | PIT_INSTR_CONCUR_MEMXFER | PIT_INSTR_BUFFER)
+#define HSX_PIT_GENERAL_REG_DEFAULT_DEBUG	(PIT_GEN_CLOCK_SYNC)
+#define HSX_PIT_DATA_REG_DEFAULT_DEBUG		(0)
+#define HSX_PIT_INSTR_REG_DEFAULT_DEBUG		(0x00800000)
+
+#define UPPER_PLL_SELECT(x)			(((x) & 0x0F000000UL) >> 24)
+#define UPPER_PLL_DIV(x)			(((x) & 0x00FF0000UL) >> 16)
+#define LOWER_PLL_SELECT(x)			(((x) & 0x0000F000UL) >> 8)
+#define LOWER_PLL_DIV(x)			(((x) & 0x000000FFUL))
+
+#define PLL_POST_DIV(x)				(((x) & 0x00F00000UL) >> 20)
+#define PLL_PRE_DIV(x)				(((x) & 0x000F0000UL) >> 16)
+#define PLL_XTAL_CLK_BYPASS(x)			(((x) & 0x02000000UL))
+#define PLL_FERNUS_DIV_CLK(x)			(((x) & 0x3F000000UL) >> 24)
+#define PLL_FERNUS_DIV_2(x)			(((x) & 0x00000001UL))
+#define xtal_frequency				60000000UL
+
+/*
+ * Removed this from 'setup.c' to get a cleaner patch. There is no need to put this
+ * inside a generic file.
+ * Conexant MAC address from TAG List
+ */
+u8 mac_address[6];
+EXPORT_SYMBOL(mac_address);
+
+unsigned long ChipID;
+EXPORT_SYMBOL(ChipID);
+
+unsigned long ChipRevID;
+EXPORT_SYMBOL(ChipRevID);
+
+u32 uKernelAtaglist[ATAGLIST_MAX_WORDS];
+EXPORT_SYMBOL(uKernelAtaglist);
+
+unsigned int decarm_shared_start = 0;
+unsigned int decarm_shared_size = 0;
+unsigned int decarm_code_start = 0;
+unsigned int decarm_code_size = 0;
+unsigned int arm11_pll; /* For use in mipidle routine */
+
+EXPORT_SYMBOL(decarm_shared_start);
+EXPORT_SYMBOL(decarm_shared_size);
+EXPORT_SYMBOL(decarm_code_start);
+EXPORT_SYMBOL(decarm_code_size);
+
+/*
+ * PECOS / NEVIS: Reading MAC address from ATAG list 
+ * WARNING: Linux will NEVER accept this patch as is. We better get the MAC address
+ * from the NIC directly. For now it works ;)
+ */
+static int __init parse_tag_mac_address(const struct tag *tag)
+{
+	int ic;
+
+	for (ic = 0; ic < 6; ic++)
+		mac_address[ic] = (u8) (tag->u.mac.mac_addr[ic]);
+
+	return 0;
+}
+__tagtable(ATAG_MAC, parse_tag_mac_address);
+
+/*
+ * Setup Mapping for Register Space and Flash needed by BSP
+ */
+static struct map_desc cnxt_io_desc[] = {
+	{
+		.virtual = ASX_VADDR_BASE,
+		.pfn = __phys_to_pfn(ASX_PHYS_BASE),
+		.length = ASX_IO_SIZE,
+		.type = MT_DEVICE,
+	}, {
+		.virtual = EXT_IO_VADDR_BASE,
+		.pfn = __phys_to_pfn(EXT_IO_PHYS_BASE),
+		.length = EXT_IO_SIZE,
+		.type = MT_DEVICE,
+	}, {
+		.virtual = TEMPEST_VADDR_BASE,
+		.pfn = __phys_to_pfn(TEMPEST_PHYS_BASE),
+		.length = TEMPEST_IO_SIZE,
+		.type = MT_DEVICE,
+	}, {
+#ifdef CONFIG_PCI
+		.virtual = PCI_MEM_VADDR_BASE,
+		.pfn = __phys_to_pfn(PCI_MEM_PHYS_BASE),
+		.length = PCI_MEM_SIZE,
+		.type = MT_DEVICE,
+	}, {
+#endif
+		.virtual = APP_VADDR_BASE,
+		.pfn = __phys_to_pfn(APP_PHYS_BASE),
+		.length = APP_IO_SIZE,
+		.type = MT_DEVICE,
+	}
+};
+
+
+static unsigned long long getpll_clk_val(uint32_t pll_select, uint32_t pll_div)
+{
+	struct pll_reg_data_struct {
+		uint32_t intfrac;
+		uint32_t ctrl;
+	}; /* E0440000 -- E0440034 */
+
+	unsigned long long freq;
+	static volatile struct pll_reg_data_struct __iomem *pll_data;
+
+	pll_data = (volatile struct pll_reg_data_struct __iomem *)PLL_BASE;
+
+	if (pll_select > 8) {
+		return 0;
+	} else if (pll_select > 3) {
+		pll_data += pll_select - 1;
+	} else {
+		pll_data += pll_select;
+	}
+
+	/* Freq = (Fin pre_div) * (lpdiv_int + lpdiv_freq/(1<<25) * (1/post_div) */
+	if (!PLL_XTAL_CLK_BYPASS(pll_data->ctrl)) {
+		printk("%s: Value of Bypass clk not known\n", __FUNCTION__);
+		return 0;
+	}
+
+	if (pll_select == 7) {
+		freq =
+		    (unsigned long long)(xtal_frequency *
+					 PLL_FERNUS_DIV_CLK(pll_data->intfrac));
+		if (PLL_FERNUS_DIV_2(pll_data->intfrac)) {
+			freq = freq / 2;
+		}
+	} else {
+		freq = (unsigned long long)pll_data->intfrac;
+	}
+
+	freq *= (unsigned long long)xtal_frequency;
+	if (pll_select != 7) {
+		freq /= (unsigned long long)PLL_PRE_DIV(pll_data->ctrl);
+		freq /= (unsigned long long)PLL_POST_DIV(pll_data->ctrl);
+	}
+	freq /= (unsigned long long)(1 << 25);
+
+	if (freq > 0x00000000FFFFFFFFLL) {
+		return 0;
+	}
+
+	return (freq / pll_div);
+}
+
+/* Get arm11 pll value */
+static void cx2450x_getpll_values(void)
+{
+	uint32_t div_mux_ctl1;
+
+	div_mux_ctl1	= *((volatile uint32_t *)PLL_DIV_MUX_CTRL1_REG);
+	arm11_pll	= (unsigned int)getpll_clk_val(UPPER_PLL_SELECT(div_mux_ctl1), UPPER_PLL_DIV(div_mux_ctl1));
+}
+
+static void __init cx2450x_map_io(void)
+{
+	iotable_init(cnxt_io_desc, ARRAY_SIZE(cnxt_io_desc));
+}
+
+/* This function is used to get the chipid and chipRevId */
+
+static void __init cnxt_get_chip_rev_id(struct machine_desc *pmach, struct tag *ptag, char **pptr, struct meminfo *pmem)
+{
+	volatile u32 *pPCICfgAddr;
+	volatile u32 *pPCICfgData;
+	volatile u32 *pFuse = (volatile u32 *) 0xe0440148;
+
+	iotable_init(cnxt_io_desc, 1);
+
+	/* Take care of some special cases first. Pecos and Nevis need fixing   */
+	/* up for A0 and B0, Nevis needs fixup for C0.                          */
+	/* PCI Chip ID | PCI Chip Rev | PBIN Fuse | Build Target | "Real" Chip  */
+	/* ===================================================================  */
+	/*      X      |       0      |     X     |     Pecos    |   Pecos A0   */
+	/*      X      |       0      |     X     |     Nevis    |   Nevis A0   */
+	/*   <Pecos>   |      0x10    |     0     |       X      |   Pecos B0   */
+	/*   <Pecos>   |      0x10    |     1     |       X      |   Nevis B0   */
+	/*   <Nevis>   |      0x10    |     X     |       X      |   Nevis C0   */
+
+	pPCICfgAddr = (volatile u32 *) PCI_CFG_ADDR_REG;
+	pPCICfgData = (volatile u32 *) PCI_CFG_DATA_REG;
+
+	/* Read vendor/device ID */
+	*pPCICfgAddr = 0x0;
+	ChipID = *pPCICfgData;
+
+	/* Read Rev Id */
+	*pPCICfgAddr = 0x8;
+	ChipRevID = *pPCICfgData & 0xFF;
+
+	/* paraphrased from cnxt_base/drivers/startup/api.s */
+	if (ChipRevID < 0x10) {
+		/* TODO:  When mach-nevis and mach-pecos get merged, we'll need to 
+		   use a KCONFIG switch to decide which chip we are. For Rev A chips
+		   we're always going to read "Pecos", but obviously we want to report
+		   nevis when we're running on a nevis.  For now, I KNOW I'm a nevis 
+		   because I am the file mach-nevis/mach.c */
+		ChipID = 0x245014F1; // Nevis;
+	} else if (ChipRevID == 0x10) {
+		if (ChipID == 0x242714F1) {
+			/* We could be a Pecos OR a nevis.  Look at the fuses to tell */
+			if (*pFuse == 0x0) {
+				/* fuses have not been set, follow the same logic for RevID < 0x10 */
+				ChipID = 0x245014F1; // Nevis;
+			} else {
+				/* Fuses are set so we can differentiate between Pecos and Nevis. */
+				if (*pFuse & 0x01000000) {
+					ChipID = 0x242714F1; // Pecos
+				} else {
+					ChipID = 0x245014F1; // Nevis;
+				}
+			}
+		} else if (ChipID == 0x245014F1) {
+			/* If we read a nevis and we thought we were a B0, we're really a C0 */
+			ChipRevID = 0x20;
+		}
+	} else {		/* our chiprev > 0x10 */
+
+		/* do nothing, our ChipID is already correct. What needs to be done
+		   with the rev is undefined at the time of this writing. */
+	}
+//	printk("ChipID=0x%lx ChipRevID=0x%lx\n", ChipIDChipRevID);
+}
+
+
+/* fixup function */
+static void __init cx2450x_fixup(struct machine_desc *pmach, struct tag *ptag, char **pptr, struct meminfo *pmem)
+{
+	/* copy the ataglist to the global variable uKernelAtaglist */
+	memcpy(uKernelAtaglist, ptag, ATAGLIST_MAX_WORDS * 4);
+
+	cnxt_get_chip_rev_id(pmach, ptag, pptr, pmem);
+}
+
+unsigned int GetChipRev(void)
+{
+	return ChipRevID;
+}
+EXPORT_SYMBOL(GetChipRev);
+
+unsigned int GetChipID(void)
+{
+	return ChipID;
+}
+EXPORT_SYMBOL(GetChipID);
+
+typedef struct {
+	volatile u32 *preg;
+	unsigned long val;
+} cnxt_pll_config_t;
+
+static const cnxt_pll_config_t cx2450x_conf_pll[] __initdata = {
+	/*Initialize the GPIO pin mux and alt func registers for unique */
+#ifdef CONFIG_PLL_CONFIG0_REG_DEFAULT
+	{(volatile u32 *) PLL_CONFIG0_REG, CONFIG_PLL_CONFIG0_REG_DEFAULT,},
+#endif
+	/*MUX settings */
+	{(volatile u32 *) SREG_PRI_MUX_REG_BASE(0), CONFIG_PLL_PIN_GPIO_MUX0_REG_DEFAULT,},
+	{(volatile u32 *) SREG_PRI_MUX_REG_BASE(1), CONFIG_PLL_PIN_GPIO_MUX1_REG_DEFAULT,},
+	{(volatile u32 *) SREG_PRI_MUX_REG_BASE(2), CONFIG_PLL_PIN_GPIO_MUX2_REG_DEFAULT,},
+	{(volatile u32 *) SREG_PRI_MUX_REG_BASE(3), CONFIG_PLL_PIN_GPIO_MUX3_REG_DEFAULT,},
+	{(volatile u32 *) SREG_PRI_MUX_REG_BASE(4), CONFIG_PLL_PIN_GPIO_MUX4_REG_DEFAULT,},
+	{(volatile u32 *) SREG_PRI_MUX_REG_BASE(5), CONFIG_PLL_PIN_GPIO_MUX5_REG_DEFAULT,},
+	{(volatile u32 *) SREG_PRI_MUX_REG_BASE(6), CONFIG_PLL_PIN_GPIO_MUX6_REG_DEFAULT,},
+	/*Initialize the secondary pin mux registers */
+	{(volatile u32 *) SREG_SEC_MUX_REG_BASE(0), CONFIG_SREG_2ND_PIN_MUX0_REG_DEFAULT,},
+	{(volatile u32 *) SREG_SEC_MUX_REG_BASE(1), CONFIG_SREG_2ND_PIN_MUX1_REG_DEFAULT,},
+	{(volatile u32 *) SREG_SEC_MUX_REG_BASE(2), CONFIG_SREG_2ND_PIN_MUX2_REG_DEFAULT,},
+	{(volatile u32 *) SREG_SEC_MUX_REG_BASE(3), CONFIG_SREG_2ND_PIN_MUX3_REG_DEFAULT,},
+	{(volatile u32 *) SREG_SEC_MUX_REG_BASE(4), CONFIG_SREG_2ND_PIN_MUX4_REG_DEFAULT,},
+	{(volatile u32 *) SREG_SEC_MUX_REG_BASE(5), CONFIG_SREG_2ND_PIN_MUX5_REG_DEFAULT,},
+	{(volatile u32 *) SREG_SEC_MUX_REG_BASE(6), CONFIG_SREG_2ND_PIN_MUX6_REG_DEFAULT,},
+	{(volatile u32 *) SREG_ALT_PIN_FUNC_REG,    CONFIG_PLL_PIN_ALT_FUNC_REG_DEFAULT ,},
+};
+
+static void cx2450x_setup_hsx(void)
+{
+	/*
+	 * Re-Load the PIT values, to allow customers with "locked" boot loaders to
+	 * alter the PIT settings
+	 */
+#ifdef DEBUG
+	__raw_writel(HSX_PIT_GENERAL_REG_DEFAULT_DEBUG, (void __iomem *)HSX_PIT_GENERAL_REG);
+	__raw_writel(HSX_PIT_DATA_REG_DEFAULT_DEBUG, (void __iomem *)HSX_PIT_DATA_REG);
+	__raw_writel(HSX_PIT_INSTR_REG_DEFAULT_DEBUG, (void __iomem *)HSX_PIT_INSTR_REG);
+#else
+	__raw_writel(HSX_PIT_GENERAL_REG_DEFAULT, (void __iomem *)HSX_PIT_GENERAL_REG);
+	__raw_writel(HSX_PIT_DATA_REG_DEFAULT, (void __iomem *)HSX_PIT_DATA_REG);
+	__raw_writel(HSX_PIT_INSTR_REG_DEFAULT, (void __iomem *)HSX_PIT_INSTR_REG);
+#endif
+}
+
+static void cx2450x_register_devices(void)
+{
+#ifdef CONFIG_CX2450X_USB0
+	/* register USB controller #0 as platform device, if enabled */
+	if (platform_device_register(&cx2450x_device_usb0))
+	        printk(KERN_ERR "cx2450x: failed to add device %s\n", cx2450x_device_usb0.name);
+#endif
+
+#ifdef CONFIG_CX2450X_USB1
+	/* register USB controller #1 as platform device, if enabled */
+	if (platform_device_register(&cx2450x_device_usb1))
+		printk(KERN_ERR "cx2450x: failed to add device %s\n", cx2450x_device_usb1.name);
+#endif
+}
+
+static void cx2450x_setup_pio_mux(void)
+{
+	int i;
+
+	for(i = 0; i < ARRAY_SIZE(cx2450x_conf_pll); i++)
+		__raw_writel(cx2450x_conf_pll[i].val, (void __iomem *)cx2450x_conf_pll[i].preg);
+}
+
+
+static void __init cx2450x_init(void)
+{
+
+	cx2450x_setup_pio_mux();
+
+	/* Setup the HSX PIT registers */
+	cx2450x_setup_hsx();
+	cx2450x_register_devices();
+	cx2450x_getpll_values();
+}
+
+extern struct sys_timer cx2450x_sys_timer;	/* in arch/arm/mach-nevis/time.c */
+
+/*
+ * boot_pararms will be placed (by the loader) at the megabyte boundary
+ * just below where the kernel is loaded.  Since the kernel is loaded 
+ * at a 0x18000 boundary (in conexant's case, 0x48000), we're always
+ * guaranteed to have a PTE so the kernel can find the ATAG list here. 
+ * The ATAG list is only temporary and will eventually get over-written
+ * so we copy it in our machine fixup call.
+ */
+MACHINE_START(NEVIS, "CoolStream HDx IRD")
+	.phys_io 	=  0xE0000000,
+	.io_pg_offst	= (0xE0000000 >> 18) & 0xFFFC,
+	.boot_params	=  0x00000100,
+	.map_io		=  cx2450x_map_io,
+	.init_machine	=  cx2450x_init,
+	.init_irq	=  cx2450x_init_irq,
+	.timer		= &cx2450x_sys_timer,
+	.fixup		=  cx2450x_fixup,
+MACHINE_END
diff --git a/arch/arm/mach-nevis/mipidle.c b/arch/arm/mach-nevis/mipidle.c
new file mode 100644
index 0000000..78b310a
--- /dev/null
+++ b/arch/arm/mach-nevis/mipidle.c
@@ -0,0 +1,140 @@
+/****************************************************************************
+ *
+ *  arch/arm/mach-nevis/mipidle.c
+ *
+ *  Copyright (C) 2007 Conexant Systems Inc, USA.
+ *  Copyright (C) 2008 Coolstream International Limited
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License Version 2 as published by
+ *  the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., Franklin St, Fifth Floor, Boston, MA  02111-1307  USA
+ *
+ ****************************************************************************/
+
+#include <linux/kernel.h>
+#include <asm/param.h>		/* for HZ */
+#include <asm/arch/cx2450x.h>
+#include <asm/proc-fns.h>
+/**********
+* Globals *
+**********/
+extern unsigned int arm11_pll;
+unsigned long gIdleCount = 0;
+
+#define TICKS_PER_MIN  ((HZ) * 60)	/* ooops, hello Conexant ! That is only true, as long as HZ is defined as 100 !!! */
+
+static unsigned long idleSample[TICKS_PER_MIN];
+static int index = 0;
+
+void idleAddCount(void);
+void cnxt_mip_idle(void);
+
+void idleAddCount()
+{
+	idleSample[index++] = gIdleCount;
+	if (index == TICKS_PER_MIN)
+		index = 0;
+	gIdleCount = 0;
+}
+
+int get_idle_list(char *buf)
+{
+	unsigned int i;
+	unsigned int j;		/* Cycles per second */
+	unsigned int k;		/* seconds per minute */
+	unsigned int sum;
+	unsigned int sum2 = 0;
+	unsigned int avg_mips = 0;
+	unsigned int min_mips = 450000000;
+	unsigned int max_mips = 0;
+
+	char *p = buf;
+
+	if (arm11_pll != 0) {
+		min_mips = arm11_pll;
+	} else {
+		min_mips = 595000000;
+	}
+
+	p += sprintf(p, "Idle MIPS for last minute:\n\n");
+
+	if ((index + 1) == TICKS_PER_MIN)
+		i = 0;
+	else
+		i = index;
+
+	k = 60;
+	while (k--) {
+		sum = 0;
+		j = HZ;
+		while (j--) {
+			sum += idleSample[i++];
+			if (i == TICKS_PER_MIN)
+				i = 0;
+		}
+		p += sprintf(p, "%2d: %10d\n", k, sum);
+		sum2 += (sum / 10000);
+		if (sum < min_mips)
+			min_mips = sum;
+		if (sum > max_mips)
+			max_mips = sum;
+	}
+	avg_mips = (sum2 / 60);
+
+	p += sprintf(p, "Avg Idle MIPS = %5d  x 10^4\n", avg_mips);
+	p += sprintf(p, "Min Idle MIPS = %10d\n", min_mips);
+	p += sprintf(p, "Max Idle MIPS = %10d\n", max_mips);
+	p += sprintf(p, "\n");
+
+	return p - buf;
+}
+
+void cnxt_mip_idle()
+{
+	/* The timer is started together with the system timer in time.c. It's 
+	 * setup with a base of 54, so the timer counts up by one every 1 us
+	 */
+	u32 timein, timeout;
+	volatile u32 *ptimVal = (u32 *) TIMER_VALUE_REG_BASE(7);
+	unsigned int pll_mul;
+
+	if (arm11_pll != 0) {
+		pll_mul = arm11_pll / 1000000;
+	} else {
+		pll_mul = 595;
+	}
+
+	timein = *ptimVal;
+	cpu_do_idle();
+	timeout = *ptimVal;
+
+	/* Nevis C is running at 594 MHz */
+	gIdleCount += ((timeout - timein) * pll_mul) / 54;
+}
+
+/****************************************************************************
+ * Modifications:
+ * $Log:
+ *  5    Coolstream Mods       8/7/08 16:58 CET       Coolstrem Dev. Team
+ *       moved timer setup to systimer setup (prevents an if state ment.
+ *       Changed timer to tic at 1 us to prevent an division.
+ *  4    Linux_SDK 1.3         8/2/07 5:37:11 PM IST  Har Yash Bahadur Add
+ *       calculation of Average, Minimum and Maximum Idle MIPS in the last one
+ *        minute.
+ *  3    Linux_SDK 1.2         6/5/07 3:15:16 PM IST  Vineet Seth     Cosmetic
+ *       changes to remove warning
+ *  2    Linux_SDK 1.1         3/27/07 5:16:05 PM IST Satpal Parmar   GPL
+ *       header and starteam footer addition.
+ *  1    Linux_SDK 1.0         3/1/07 10:53:09 PM IST Vineet Seth     
+ * $
+ *
+ ****************************************************************************/
diff --git a/arch/arm/mach-nevis/pci.c b/arch/arm/mach-nevis/pci.c
new file mode 100644
index 0000000..82594ab
--- /dev/null
+++ b/arch/arm/mach-nevis/pci.c
@@ -0,0 +1,325 @@
+/****************************************************************************
+ *
+ *  arch/arm/mach-nevis/pci.c
+ *
+ *  Copyright (C) 2007 Conexant Systems Inc, USA.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License Version 2as published by
+ *  the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02111-1307  USA
+ *
+ ****************************************************************************/
+/*$Id: pci.c,v 1.3, 2007-05-22 13:32:05Z, Nitin Garg$
+ ****************************************************************************/
+
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+
+#include <asm/hardware.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/mach/pci.h>
+#include <asm/arch/dma.h>
+#include <asm/arch/platform.h>
+#include <asm/arch/intid.h>
+
+#include <asm/mach-types.h>
+
+#ifdef CONFIG_PCI
+
+#define WORD_SIZE               4	/* bytes */
+
+#undef  DEBUG
+
+static u8 pecos_swizzle(struct pci_dev *dev, u8 * pin);
+static int pecos_setup(int nr, struct pci_sys_data *sys);
+static int pecos_read_config(struct pci_bus *bus, unsigned int devfn, int where, int size, u32 * val);
+static int pecos_write_config(struct pci_bus *bus, unsigned int devfn, int where, int size, u32 val);
+static void pci_arch_init(void);
+/*static void pci_arch_reset ( void );*/
+
+/***********************************************************************
+ *  dev->devfn:
+ *	     7:3 = slot
+ *	     2:0 = function
+ ***********************************************************************/
+static int pecos_read_config(struct pci_bus *bus, unsigned int devfn, int where, int size, u32 * val)
+{
+	switch (size) {
+	case 1:
+		{
+			__raw_writel((where & 0xFC) | (devfn << PCI_CFG_ADDR_FUNCTION_SHIFT), ASX_TO_VIRT(PCI_CFG_ADDR_REG));
+			*val = __raw_readb(ASX_TO_VIRT(PCI_CFG_DATA_REG | (where & 3)));
+
+#ifdef DEBUG
+			printk(KERN_INFO "CNXT: read_config_8 : addr:0x%08x idsel:0x%02x func:0x%02x data:0x%02x\n", where, PCI_SLOT(devfn), PCI_FUNC(devfn), *val);
+#endif
+		}
+		break;
+
+	case 2:
+		{
+			__raw_writel((where & 0xFC) | (devfn << 8), ASX_TO_VIRT(PCI_CFG_ADDR_REG));
+			*val = __raw_readw(ASX_TO_VIRT(PCI_CFG_DATA_REG | (where & 3)));
+#ifdef DEBUG
+			printk(KERN_INFO "  CNXT: read_config_16 : addr:0x%08x idsel:0x%02x func:0x%02x data:0x%04x\n", where, PCI_SLOT(devfn), PCI_FUNC(devfn), *val);
+#endif
+		}
+		break;
+
+	default:
+		{
+			__raw_writel(where | (devfn << PCI_CFG_ADDR_FUNCTION_SHIFT), ASX_TO_VIRT(PCI_CFG_ADDR_REG));
+			*val = __raw_readl(ASX_TO_VIRT(PCI_CFG_DATA_REG));
+#ifdef DEBUG
+			printk(KERN_INFO "  CNXT: read_config_32 : addr:0x%08x idsel:0x%02x func:0x%02x data:0x%08x\n", where, PCI_SLOT(devfn), PCI_FUNC(devfn), *val);
+#endif
+		}
+		break;
+	}
+	return PCIBIOS_SUCCESSFUL;
+}
+
+
+static int pecos_write_config(struct pci_bus *bus, unsigned int devfn, int where, int size, u32 val)
+{
+	switch (size) {
+	case 1:
+		{
+#ifdef DEBUG
+			printk(KERN_INFO "CNXT: write_config_8 : addr:%08x idsel:%02x func:%02x data:%02x\n", where, PCI_SLOT(devfn), PCI_FUNC(devfn), val);
+#endif
+			__raw_writel((where & 0xFC) | (devfn << PCI_CFG_ADDR_FUNCTION_SHIFT), ASX_TO_VIRT(PCI_CFG_ADDR_REG));
+			__raw_writeb(val, ASX_TO_VIRT(PCI_CFG_DATA_REG | (where & 3)));
+		}
+		break;
+
+	case 2:
+		{
+#ifdef DEBUG
+			printk(KERN_INFO "CNXT: write_config_16 : addr:%08x idsel:%02x func:%02x data:%04x\n", where, PCI_SLOT(devfn), PCI_FUNC(devfn), val);
+#endif
+			__raw_writel((where & 0xFC) | (devfn << PCI_CFG_ADDR_FUNCTION_SHIFT), ASX_TO_VIRT(PCI_CFG_ADDR_REG));
+			__raw_writew(val, ASX_TO_VIRT(PCI_CFG_DATA_REG | (where & 3)));
+		}
+		break;
+
+	default:
+		{
+#ifdef DEBUG
+			printk(KERN_INFO "CNXT: write_config_32 : addr:%08x idsel:%02x func:%02x data:%08x\n", where, PCI_SLOT(devfn), PCI_FUNC(devfn), val);
+#endif
+			__raw_writel(where | (devfn << PCI_CFG_ADDR_FUNCTION_SHIFT), ASX_TO_VIRT(PCI_CFG_ADDR_REG));
+			__raw_writel(val, ASX_TO_VIRT(PCI_CFG_DATA_REG));
+		}
+		break;
+	}
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static struct pci_ops edwards_ops = {
+	.read = pecos_read_config,
+	.write = pecos_write_config
+};
+
+static int __init pecos_setup(int nr, struct pci_sys_data *sys)
+{
+	struct resource *res;
+
+#ifdef DEBUG
+	printk(KERN_INFO "CNXT: pecos_setup called\n");
+#endif
+
+	if (nr != 0)
+		return 0;
+
+	res = kmalloc(sizeof(struct resource) * 2, GFP_KERNEL);
+	if (!res)
+		panic("PCI: unable to alloc resources");
+
+	memset(res, 0, sizeof(struct resource) * 2);
+
+	res[0].name	= "CX2427X PCI I/O Bridge",
+	res[0].start	= EXT_IO_PHYS_BASE,
+	res[0].end	= EXT_IO_PHYS_BASE + PCI_IO_SIZE + -1,
+	res[0].flags	= IORESOURCE_IO,
+	res[1].name	= "CX2427X PCI MEM Bridge",
+	res[1].start	= PCI_MEM_PHYS_BASE, res[1].end =
+	    PCI_MEM_PHYS_BASE + PCI_MEM_SIZE - 1, res[1].flags = IORESOURCE_MEM, request_resource(&ioport_resource, &res[0]);
+
+	request_resource(&iomem_resource, &res[1]);
+
+	sys->resource[0] = &res[0];
+	sys->resource[1] = &res[1];
+	sys->resource[2] = NULL;
+
+	return 1;
+}
+
+struct pci_bus *__init pecos_scan_bus(int nr, struct pci_sys_data *sys)
+{
+#ifdef DEBUG
+	printk(KERN_INFO "CNXT: pecos_scan_bus called\n");
+#endif
+
+	return pci_scan_bus(sys->busnr, &edwards_ops, sys);
+}
+
+/***********************************************************************/
+
+static void __init pci_arch_init(void)
+{				/* struct pci_sys_data sysdata  */
+	volatile unsigned int v32;
+
+#ifdef DEBUG
+	printk(KERN_INFO "CNXT: pci_arch_init:\n");
+#endif
+
+	/* Initialize Pecos PCI controller  */
+
+	/* Remap register: 31:29 Memory remapping bits, 15:4 IO remap bits  */
+	/*  This gives us a straight-thru mapping i.e. CPU addr == PCI addr */
+	__raw_writel(0x8000E100, ASX_TO_VIRT(PCI_REMAP_REG));
+
+	/* On newer chips (Wabash and beyond), need to set the PCI sync bits */
+	v32 = __raw_readl(ASX_TO_VIRT(PCI_ROM_MODE_REG));
+	__raw_writel((1UL << PCI_ROM_REQ0_SYNC_SHIFT)
+		     | (1UL << PCI_ROM_REQ1_SYNC_SHIFT)
+		     | (1UL << PCI_ROM_REQ2_SYNC_SHIFT), ASX_TO_VIRT(PCI_ROM_MODE_REG));
+
+	/* Set alt func register so PCI_REQGNT1 is on PIO006-7 instead of normal PCI_REQ pins */
+	v32 = __raw_readl(ASX_TO_VIRT(PLL_PIN_ALT_FUNC_REG));
+	__raw_writel((v32 & ~(PLL_PIN_ALT_FUNC_PCI_REQGNT2_MASK | PLL_PIN_ALT_FUNC_PCI_REQGNT1_MASK | PLL_PIN_ALT_FUNC_IO_RW_MASK))
+		     | PLL_PIN_ALT_FUNC_PCI_REQGNT2_PIO_64_63_5 | PLL_PIN_ALT_FUNC_PCI_REQGNT1_PIO_7_6 | PLL_PIN_ALT_FUNC_IO_RW_NORMAL, ASX_TO_VIRT(PLL_PIN_ALT_FUNC_REG));
+
+	/* Take PCI out of reset */
+	__raw_writel(PCI_RESET_DEASSERTED, ASX_TO_VIRT(PCI_RESET_REG));
+
+	/* Enable the bridge mode to forward interrupts */
+	__raw_writel(PCI_INTR_INTA_ENABLE_MASK, ASX_TO_VIRT(PCI_INTR_ENABLE_REG));
+
+	/* set Memory Space / Bus Master bits */
+	__raw_writel(PCI_CMD_STAT_OFF << 2, ASX_TO_VIRT(PCI_CFG_ADDR_REG));
+
+	v32 = __raw_readl(ASX_TO_VIRT(PCI_CFG_DATA_REG));
+	__raw_writel(v32 | PCI_CMD_MASTER_ENABLE_MASK | PCI_CMD_MEM_ACCESS_ENABLE_MASK, ASX_TO_VIRT(PCI_CFG_DATA_REG));
+
+#ifdef DEBUG
+	v32 = __raw_readl(ASX_TO_VIRT(PCI_CFG_DATA_REG));
+	printk(KERN_INFO "  CNXT: wrote 0x%x to bridge cmd_status\n", v32);
+#endif
+
+   /************************************************************************/
+   /******** NOTE: further treatment of Pecos Bridge in bios32.c **********/
+   /************************************************************************/
+	/*
+	 * Clear any error conditions
+	 */
+	__raw_writel(PCI_CMD_STAT_OFF << 2, ASX_TO_VIRT(PCI_CFG_ADDR_REG));
+	v32 = __raw_readl(ASX_TO_VIRT(PCI_CFG_DATA_REG));
+	__raw_writel(v32 | 0xF8000000, ASX_TO_VIRT(PCI_CFG_DATA_REG));
+
+	__raw_writel(PCI_CLS_LT_HT_BIST_OFF << 2, ASX_TO_VIRT(PCI_CFG_ADDR_REG));
+	__raw_writel(0x4000, ASX_TO_VIRT(PCI_CFG_DATA_REG));
+
+	__raw_writel(PCI_BASE_ENABLE_SIZE << 2, ASX_TO_VIRT(PCI_CFG_ADDR_REG));
+	__raw_writel(0x00000095, ASX_TO_VIRT(PCI_CFG_DATA_REG));
+
+#ifdef DEBUG
+	v32 = __raw_readl(ASX_TO_VIRT(PCI_CFG_DATA_REG));
+	printk(KERN_INFO "  CNXT: cmd_status - 0x%x\n", v32);
+	__raw_writel(PCI_BASE_ENABLE_SIZE << 2, ASX_TO_VIRT(PCI_CFG_ADDR_REG));
+	v32 = __raw_readl(ASX_TO_VIRT(PCI_CFG_DATA_REG));
+	printk(KERN_INFO "  CNXT: base0 remap / size - 0x%x\n", v32);
+	__raw_writel(PCI_BASE_REMAP << 2, ASX_TO_VIRT(PCI_CFG_ADDR_REG));
+	v32 = __raw_readl(ASX_TO_VIRT(PCI_CFG_DATA_REG));
+	printk(KERN_INFO "  CNXT: base1 remap / size - 0x%x\n", v32);
+#endif
+
+}
+
+static u8 pecos_swizzle(struct pci_dev *dev, u8 * pin)
+{
+#ifdef DEBUG
+	printk(KERN_INFO "CNXT: pecos_swizzle called\n");
+#endif
+
+	return 0;
+}
+
+static int __init pci_arch_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+#ifdef DEBUG
+	printk(KERN_INFO "CNXT: pci_arch_map_irq called\n");
+#endif
+
+	return INT_PCI;
+}
+
+struct hw_pci pecos_pci __initdata = {
+	.nr_controllers = 1,
+	.setup = pecos_setup,
+	.scan = pecos_scan_bus,
+	.preinit = pci_arch_init,
+	.swizzle = pecos_swizzle,
+	.map_irq = pci_arch_map_irq
+};
+
+/*
+static void pci_arch_reset ( void )
+{
+#ifdef DEBUG
+    printk( KERN_INFO "CNXT: pci_arch_reset called\n" );
+#endif
+
+    __raw_writel(PCI_RESET_ASSERTED , ASX_TO_VIRT( PCI_RESET_REG ));
+    __raw_writel(PCI_RESET_DEASSERTED , ASX_TO_VIRT( PCI_RESET_REG ));
+
+    return;
+}
+*/
+
+int __init pecos_pci_init(void)
+{
+#ifdef DEBUG
+	printk(KERN_INFO "CNXT: pecos_pci_init called\n");
+#endif
+	pci_common_init(&pecos_pci);
+	return 0;
+}
+
+subsys_initcall(pecos_pci_init);
+#endif
+
+/****************************************************************************
+ * Modifications:
+ * $Log:  
+ *  4    Linux_SDK 1.3         5/22/07 7:02:05 PM IST Nitin Garg      28041
+ *       28042: Changed the PCI memory aperture to 512MB. No need to set the
+ *       Base 0 register.
+ *  3    Linux_SDK 1.2         5/18/07 2:33:39 PM IST Nitin Garg      27910
+ *       27911: Changed PCI Base 0 register to map to 256MB.
+ *  2    Linux_SDK 1.1         3/27/07 5:17:41 PM IST Satpal Parmar   GPL
+ *       header and starteam footer addition.
+ *  1    Linux_SDK 1.0         3/16/07 11:12:29 AM ISTNitin Garg      
+ * $
+ *
+ ****************************************************************************/
diff --git a/arch/arm/mach-nevis/pllc.c b/arch/arm/mach-nevis/pllc.c
new file mode 100644
index 0000000..a2739a4
--- /dev/null
+++ b/arch/arm/mach-nevis/pllc.c
@@ -0,0 +1,314 @@
+/*
+ *
+ *  arch/arm/mach-nevis/pll.c
+ *
+ *  Copyright (C) 2008 Coolstream International Limited
+ *  Copyright (C) 2007 Conexant Systems Inc, USA.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License Version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02111-1307  USA
+ *
+ */
+#include <linux/clocksource.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/cx2450x.h>
+
+/* FIXME: TODO:  Need to use  a global definition of CNXT_GET */
+
+#define RMO(y)                   ( ((y) & 0x00000001) ?  0 : \
+                                   ( ((y) & 0x00000002) ?  1 : \
+                                     ( ((y) & 0x00000004) ?  2 : \
+                                       ( ((y) & 0x00000008) ?  3 : \
+                                         ( ((y) & 0x00000010) ?  4 : \
+                                           ( ((y) & 0x00000020) ?  5 : \
+                                             ( ((y) & 0x00000040) ?  6 : \
+                                               ( ((y) & 0x00000080) ?  7 : \
+                                                 ( ((y) & 0x00000100) ?  8 : \
+                                                   ( ((y) & 0x00000200) ?  9 : \
+                                                     ( ((y) & 0x00000400) ? 10 : \
+                                                       ( ((y) & 0x00000800) ? 11 : \
+                                                         ( ((y) & 0x00001000) ? 12 : \
+                                                           ( ((y) & 0x00002000) ? 13 : \
+                                                             ( ((y) & 0x00004000) ? 14 : \
+                                                               ( ((y) & 0x00008000) ? 15 : \
+                                                                 ( ((y) & 0x00010000) ? 16 : \
+                                                                   ( ((y) & 0x00020000) ? 17 : \
+                                                                     ( ((y) & 0x00040000) ? 18 : \
+                                                                       ( ((y) & 0x00080000) ? 19 : \
+                                                                         ( ((y) & 0x00100000) ? 20 : \
+                                                                           ( ((y) & 0x00200000) ? 21 : \
+                                                                             ( ((y) & 0x00400000) ? 22 : \
+                                                                               ( ((y) & 0x00800000) ? 23 : \
+                                                                                 ( ((y) & 0x01000000) ? 24 : \
+                                                                                   ( ((y) & 0x02000000) ? 25 : \
+                                                                                     ( ((y) & 0x04000000) ? 26 : \
+                                                                                       ( ((y) & 0x08000000) ? 27 : \
+                                                                                         ( ((y) & 0x10000000) ? 28 : \
+                                                                                           ( ((y) & 0x20000000) ? 29 : \
+                                                                                             ( ((y) & 0x40000000) ? 30 : \
+                                                                                               ( ((y) & 0x80000000) ? 31 : 0 ))))))))))))))))))))))))))))))))
+
+#define CNXT_GET(a, b)		(*((volatile unsigned int*)ASX_TO_VIRT(a)) & b)
+#define CNXT_GET_VAL(reg,mask)	((*((volatile unsigned int*)ASX_TO_VIRT(reg)) & (mask)) >> RMO(mask))
+typedef unsigned int u_int32;
+typedef unsigned long long u_int64;
+
+/********************************************************************/
+/*  CalcFreqFromFracPart                                            */
+/*                                                                  */
+/*  DESCRIPTION:                                                    */
+/*      Calculate ( freq * pll_frac ) / ( 2 ^ frac_len )            */
+/*      Note that ( freq * pll_frac ) is much bigger                */
+/*      than unsigned 0xffffffff.  The algorithm used may result    */
+/*      up to 3 less than what should be                            */
+/*                                                                  */
+/*  PARAMETERS:                                                     */
+/*      See description                                             */
+/*                                                                  */
+/*  RETURNS:                                                        */
+/*      result described above                                      */
+/********************************************************************/
+static u_int32 CalcFreqFromFracPart(
+                    u_int32 uFreq,
+                    u_int32 uPLLDivider,
+                    u_int32 uDividerWidth)
+{
+    u_int64 uCalc;
+
+    uCalc = ((u_int64)uFreq * (u_int64)(uPLLDivider & ((1 << uDividerWidth)-1)))/(u_int64)(1 << uDividerWidth);
+
+    return((u_int32)uCalc);
+}
+
+/******************************************************************************/
+/*  CalkClkFreqAndPeriod                                                      */
+/*                                                                            */
+/*  DESCRIPTION:                                                              */
+/*      Calculate clock frequency and period for a specific PLL.              */
+/*                                                                            */
+/*  PARAMETERS:                                                               */
+/*      pll_source - One of:  ARM_PLL_SOURCE, MEM_PLL_SOURCE, MPG0_PLL_SOURCE */
+/*      xtal_freq  - Xtal frequency in Hz                                     */
+/*                                                                            */
+/*  RETURNS:                                                                  */
+/*      frequency  - Returned clock frequency in Hz                           */
+/*      period     - Returned clock period in 100ns increments                */
+/******************************************************************************/
+void CalcClkFreqAndPeriod(u_int32 * frequency,
+			  u_int32 * period,
+			  PLL_SOURCE pll_source, u_int32 xtal_freq)
+{
+	u_int32 pll_int;
+	u_int32 pll_frac;
+	u_int32 pll_div;
+	u_int32 pll_prescale = 0;
+	u_int32 clk_freq;
+	u_int32 remainder;
+	u_int32 frac_shift = 0;
+	u_int32 clk_period;
+	u_int32 pll_sel = 0;
+
+	*frequency = 0;
+	*period = 0;
+
+	/*
+	 * Calculate the clk_freq and clk_period
+	 */
+
+	/* Calculation below depends on the PLL details of the chip.  */
+	/* According to Eric Deal (1/29/04) Trinity uses a XTAL       */
+	/* frequency of 74.25 MHz, but there is a divide by 2         */
+	/* before the clock ever reaches the PLL logic                */
+
+	/* We need to do a XTAL /2 for MEM and FENRUS PLLs only, the other Verve PLLs take the 60 Mhz crystal directly */
+	if (pll_source == MEM_PLL_SOURCE) {
+		//xtal_freq >>= 1;
+	}
+
+	/* In the following calculations, the frac value read from the */
+	/* PLL multiplier must be first converted to a floating       */
+	/* point value, then divided by the number of bits used to    */
+	/* represent the frac value (2^16) represented as a floating  */
+	/* point value. This will cause the fixed-point integer       */
+	/* representation of a fractional value to be converted to a  */
+	/* floating-point fractional value.                           */
+
+	/*
+	 * Read the PLL values from the chip
+	 */
+	switch (pll_source) {
+	case ARM_PLL_SOURCE:
+		/* For Pecos, there is no dedicated ARM PLL, any of the 9 PLLs can source it.
+		 * We need to derive this from the PLL_SEL bits for the ARM clock 
+		 * We are handling only the 7 Verve PLLs here.*/
+
+		pll_sel = CNXT_GET_VAL(PLL_DIV_MUX_CTRL1_REG, 0x00000F00);
+
+		switch (pll_sel) {
+			/* Handle the Verve PLLs in a common fashion */
+			/* All the INTFRAC and CTRL regs for the Verve PLLs start at offset 0 of 
+			 * PLL_BASE with 0x4 increments. We derive the corresponding INTFRAC and
+			 * CTRL reg offsets from the corresponding PLL_SEL value
+			 */
+		case MPG0PLL:
+		case MPG1PLL:
+		case HDPLL:
+		case AUDPLL:
+			pll_int      = CNXT_GET_VAL((PLL_BASE + (2 * pll_sel * 0x04)), 0x7E000000);
+			pll_frac     = CNXT_GET_VAL((PLL_BASE + (2 * pll_sel * 0x04)), 0x01FFFFFF);
+			pll_div      = CNXT_GET_VAL(PLL_DIV_MUX_CTRL1_REG, 0x000000FF);
+			pll_prescale = CNXT_GET_VAL((PLL_BASE + 4 + (2 * pll_sel * 0x4)), 0x000F0000);
+			break;
+		case PLL0:
+		case PLL1:
+		case PLL2:
+			pll_int      = CNXT_GET_VAL((PLL_BASE + (2 * (pll_sel - 1) * 0x4)), 0x7E000000);
+			pll_frac     = CNXT_GET_VAL((PLL_BASE + (2 * (pll_sel - 1) * 0x4)), 0x01FFFFFF);
+			pll_div      = CNXT_GET_VAL(PLL_DIV_MUX_CTRL1_REG, 0x000000FF);
+			pll_prescale = CNXT_GET_VAL((PLL_BASE + 4 + (2 * (pll_sel - 1) * 0x4)), 0x000F0000);
+			break;
+		default:
+			return;
+		}
+		break;
+
+	case MEM_PLL_SOURCE:
+		/* For Pecos, use the INT/FRAC masks from the MEM_PLL_CTRL2 register, and the
+		 * MEM_PLL_CTRL1 register for the POSTDIV/PREDIV masks
+		 */
+		pll_int      = CNXT_GET_VAL(MEM_PLL_CTRL2_REG, 0x000001FF);
+		pll_frac     = CNXT_GET_VAL(MEM_PLL_CTRL2_REG, 0xFFFFF000);
+		pll_div      = CNXT_GET_VAL(MEM_PLL_CTRL1_REG, 0x00000700);
+		pll_prescale = CNXT_GET_VAL(MEM_PLL_CTRL1_REG, 0x00000070);
+		frac_shift   = 12;
+		printk("pll_int:      %08x\n", pll_int);
+		printk("pll_frac:     %08x\n", pll_frac);
+		printk("pll_div:      %08x\n", pll_div);
+		printk("pll_prescale: %08x\n", pll_prescale);
+		break;
+
+	case MPG0_PLL_SOURCE:
+		pll_int      = CNXT_GET_VAL(PLL_MPG0_INTFRAC_REG, 0x7E000000);
+		pll_frac     = CNXT_GET_VAL(PLL_MPG0_INTFRAC_REG, 0x01FFFFFF);
+		pll_div      = 1;	/* We want the basic PLL rate here, not the MPG0 clock rate */
+		pll_prescale = CNXT_GET_VAL(PLL_MPG0_CTRL_REG, 0x000F0000);
+		frac_shift   = 0;
+		break;
+	case FENRUS_PLL_SOURCE:
+		/* For Pecos, there is no dedicated I/O PLL, any of the 9 PLLs can source it.
+		 * We need to derive this from the PLL_SEL bits for the HSX0 clock
+		 */
+
+		pll_sel = CNXT_GET_VAL(PLL_DIV_MUX_CTRL10_REG, 0x00000F00);
+
+		switch (pll_sel) {
+			/* Handle the Verve PLLs in a common fashion */
+			/* All the INTFRAC and CTRL regs for the Verve PLLs start at offset 0 of 
+			 * PLL_BASE with 0x4 increments. We derive the corresponding INTFRAC and
+			 * CTRL reg offsets from the corresponding PLL_SEL value
+			 *
+			 * INT_MASK = 0x7E000000 
+			 * FRAC_MASK = 0x01FFFFFF 
+			 * PREDIV_MASK = 0x000F0000
+			 */
+		case MPG0PLL:
+		case MPG1PLL:
+		case HDPLL:
+		case AUDPLL:
+			pll_int      = CNXT_GET_VAL((PLL_BASE + (2 * pll_sel * 0x4)), 0x7E000000);
+			pll_frac     = CNXT_GET_VAL((PLL_BASE + (2 * pll_sel * 0x4)), 0x01FFFFFF);
+			pll_div      = CNXT_GET_VAL(PLL_DIV_MUX_CTRL10_REG, 0x000000FF);
+			pll_prescale = CNXT_GET_VAL((PLL_BASE + 4 + (2 * pll_sel * 0x4)), 0x000F0000);
+			break;
+		case PLL0:
+		case PLL1:
+		case PLL2:
+			pll_int      = CNXT_GET_VAL((PLL_BASE + (2 * (pll_sel - 1) * 0x4)), 0x7E000000);
+			pll_frac     = CNXT_GET_VAL((PLL_BASE + (2 * (pll_sel - 1) * 0x4)), 0x01FFFFFF);
+			pll_div      = CNXT_GET_VAL(PLL_DIV_MUX_CTRL10_REG, 0x000000FF);
+			pll_prescale = CNXT_GET_VAL((PLL_BASE + 4 + (2 * (pll_sel - 1) * 0x4)), 0x000F0000);
+			break;
+		case FENRUSPLL:
+			pll_int      = CNXT_GET_VAL(PLL_FENRUS_CTRL_REG, 0x3F000000);
+			pll_frac     = 0;
+			pll_div      = CNXT_GET_VAL(PLL_DIV_MUX_CTRL10_REG, 0x000000FF);
+			xtal_freq    = CHIP_CRYSTAL_FREQUENCY;
+			pll_prescale = XTAL_PRESCALE_FACTOR;
+			break;
+		default:
+			return;
+		}
+		break;
+	default:
+		return;
+	}
+
+#ifdef DLOAD
+	/*
+	 * If called from the Download (DLOAD) Utility, run-time select the
+	 * appropriate calculation function.
+	 */
+
+	xtal_freq = CHIP_CRYSTAL_FREQUENCY;
+	pll_prescale = XTAL_PRESCALE_FACTOR;
+#endif /* DLOAD */
+	pll_div = pll_div * pll_prescale;
+
+	/* 
+	 * calculate clk_freq = xtal_freq*(pll_int+pll_frac/2^n)/pll_div
+	 * note that algorithm used here may result up to 4Hz less than what it should be
+	 */
+	clk_freq = xtal_freq / pll_div;
+	remainder = xtal_freq % pll_div;
+
+	/* 
+	 * The no. of fractional bits have not changed across Pecos and Trinity, except
+	 * for the MEM PLL in Pecos which is 20 fractional bits, instead of the usual 25 bits
+	 */
+	if (pll_source == MEM_PLL_SOURCE) {
+		clk_freq =
+		    CalcFreqFromFracPart(clk_freq, pll_frac,
+					 (32 - frac_shift))
+		    + (clk_freq * pll_int) +
+		    ((remainder * pll_int) / pll_div);
+	} else if ((pll_source == FENRUS_PLL_SOURCE)
+		   && (pll_sel == FENRUSPLL)) {
+		clk_freq = (clk_freq / pll_div) * pll_int;
+	} else {
+		clk_freq =
+		    CalcFreqFromFracPart(clk_freq, pll_frac,
+					 (25 - frac_shift))
+		    + (clk_freq * pll_int) +
+		    ((remainder * pll_int) / pll_div);
+	}
+
+	/*
+	 * Calculate clk_period = (10^11)/clk_freq
+	 * note that the algorithm will be broken if clk_freq is higher
+	 * than 429.5MHz.  it should not happen in the predictable future.
+	 */
+	clk_period = (1000000000 / clk_freq) * 100;
+	remainder = ( 1000000000 % clk_freq) * 10;
+
+	clk_period += (remainder / clk_freq) * 10;
+	remainder = (remainder % clk_freq) * 10;
+
+	clk_period += remainder / clk_freq;
+
+	/*
+	 * Return the values
+	 */
+	*frequency = clk_freq;
+	*period = clk_period;
+}
+
diff --git a/arch/arm/mach-nevis/time.c b/arch/arm/mach-nevis/time.c
new file mode 100644
index 0000000..ec5536e
--- /dev/null
+++ b/arch/arm/mach-nevis/time.c
@@ -0,0 +1,238 @@
+/* linux/arch/arm/mach-cx2450x_sys/time.c
+ *
+ * system (tick) timer functions for systems based
+ * on the Conexant CX2450x (cx2450x) SoC
+ *
+ * Copyright (C) 2008 CoolStream International Limited.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <asm/mach/time.h>
+#include <asm/arch/irq.h>
+#include <asm/arch/cx2450x.h>
+
+#define LOCKCMD_REG	0xE0440120
+#define LOCKSTAT_REG	0xE0440124
+
+#define SYSTEM_TIMER_NUMBER	0
+#define MIPIDLE_TIMER_NUMBER	7
+
+static u32 old_mode = 0x0B;
+static u32 softlock_state = 0;
+
+extern void idleAddCount(void);
+
+#ifdef ENABLE_LATENCY_TIMER
+extern struct s_latency latency;	/* Conexants Latency dump */
+#endif
+
+/*******************************************************************************/
+
+void cx2450x_unlock_timer(u32 timer_number)
+{
+    volatile u32 *reg = (volatile u32*) LOCKCMD_REG;
+
+    *reg = 0x00;
+    *reg = 0xF8;
+    *reg = 0x2B;
+
+     reg = (volatile u32*) LOCKSTAT_REG;
+    *reg &= ~(1 << (16 + timer_number));
+
+     reg = (volatile u32*) LOCKCMD_REG;
+    *reg = 0x00;
+}
+
+/*******************************************************************************/
+
+s32 cx2450x_lock_timer(u32 timer_number)
+{
+    volatile u32 *reg;
+    s32 ret = 0;
+
+     reg = (volatile u32*) LOCKCMD_REG;
+    *reg = 0x00;
+    *reg = 0xF8;
+    *reg = 0x2B;
+
+    if (softlock_state & (1 << timer_number))	/* timer is locked in software */
+	ret = -1;
+    else
+    {
+	 reg = (volatile u32*) LOCKSTAT_REG;
+	*reg |= (1 << (16 + timer_number));
+    }
+
+     reg = (volatile u32*) LOCKCMD_REG;
+    *reg = 0x00;
+
+    return ret;
+}
+
+/*******************************************************************************/
+
+s32 cx2450x_softlock_timer(u32 timer_number)
+{
+    volatile u32 *reg;
+    s32 ret = 0;
+
+    reg = (volatile u32*) LOCKSTAT_REG;
+
+    if (*reg & (1 << (16 + timer_number)))	/* timer is locked in hardware */
+	ret = -1;
+    else
+	softlock_state |= (1 << timer_number);
+
+    return ret;
+}
+
+/*******************************************************************************/
+/* return time since last timer tick in us. Always called with interrupts      */
+/* disabled.                                                                   */
+
+static unsigned long cx2450x_sys_timer_gettimeoffset(void)
+{
+    /* get current counter value */
+    volatile u32 *reg = (volatile u32*) TIMER_VALUE_REG_BASE(SYSTEM_TIMER_NUMBER);
+
+    return (unsigned long) *reg;
+}
+
+/*******************************************************************************/
+/* IRQ handler for the timer                                                   */
+
+static irqreturn_t cx2450x_sys_timer_interrupt(int irq, void *dev_id)
+{
+    volatile u32 *mod_reg	= (volatile u32*) TIMER_MODE_REG_BASE(SYSTEM_TIMER_NUMBER);
+    volatile u32 *val_reg	= (volatile u32*) TIMER_VALUE_REG_BASE(SYSTEM_TIMER_NUMBER);
+    volatile u32 *limit_reg	= (volatile u32*) TIMER_LIMIT_REG_BASE(SYSTEM_TIMER_NUMBER);
+    const u32 limit		= *limit_reg;
+
+
+    *mod_reg &= ~0x08; /* Disable IRQs */
+
+#ifdef ENABLE_LATENCY_TIMER
+    latency.delta[latency.count++] = *val_reg;
+    if (latency.count >= LATENCY_COUNT)
+            latency.count = 0;
+#endif
+
+    /* clear count to zero - even if the datasheet tells us, that this is not
+        needed (mode reg bit 1 = 0), the timer does not clear itself */
+    do {
+	    *val_reg      -= limit;
+	    timer_tick();
+    } while (*val_reg >= limit);
+
+    *mod_reg |= 0x08; /* Enable IRQs */
+    idleAddCount();
+
+    return IRQ_HANDLED;
+}
+
+/*******************************************************************************/
+
+static struct irqaction cx2450x_sys_timer_irq =
+{
+    .name    = "System Timer (10ms)",
+    .flags   = IRQF_DISABLED | IRQF_TIMER | IRQF_IRQPOLL,
+    .handler = cx2450x_sys_timer_interrupt,
+};
+
+/*******************************************************************************/
+
+static void __init cx2450x_sys_timer_init(void)
+{
+    volatile u32 *reg;
+    u32 cnt;
+
+    softlock_state = 0;
+
+    for (cnt = 0; cnt < 16; cnt++)
+    {
+	cx2450x_unlock_timer(cnt);
+	/* switch interrupt generation off */
+	reg = (volatile u32*) TIMER_MODE_REG_BASE(cnt);
+	*reg = 0;
+
+	/* set counter value to zero */
+	 reg = (volatile u32*) TIMER_VALUE_REG_BASE(SYSTEM_TIMER_NUMBER);
+	*reg = 0;
+    }
+
+    /* setup the timebase (number of clock cycles after which the timer is
+       increased by one). Set it to 54 cause the timer to tick every 1 usec.
+       (fixed clock = 54 MHz, divided by 54 = 1 MHz, 1/1 MHz = 1 us) */
+     reg = (volatile u32*) TIMER_BASE_REG_BASE(SYSTEM_TIMER_NUMBER);
+    *reg = 54;
+
+    /* Set limit to 10ms */
+     reg = (volatile u32*) TIMER_LIMIT_REG_BASE(SYSTEM_TIMER_NUMBER);
+    *reg = 10000;	/* 10000us = 10ms */
+
+    setup_irq(IRQ_TIMER(SYSTEM_TIMER_NUMBER), &cx2450x_sys_timer_irq);
+
+    /* enable timer and interrupt generation. Allow the timer to overrun the limit for get_time_offset() */
+     reg = (volatile u32*) TIMER_MODE_REG_BASE(SYSTEM_TIMER_NUMBER);
+    *reg = 0x0B;
+
+
+    /* the MIP idle timer - runs continous without any interrupt */
+     reg = (volatile u32*) TIMER_BASE_REG_BASE(MIPIDLE_TIMER_NUMBER);
+    *reg = 54;
+     reg = (volatile u32*) TIMER_LIMIT_REG_BASE(MIPIDLE_TIMER_NUMBER);
+    *reg = 0xFFFFFFFF;
+     reg = (volatile u32*) TIMER_MODE_REG_BASE(MIPIDLE_TIMER_NUMBER);
+    *reg = 0x01;
+
+    cx2450x_softlock_timer(0);
+}
+
+/*******************************************************************************/
+
+static void cx2450x_sys_timer_suspend(void)
+{
+    volatile u32 *reg = (volatile u32*) TIMER_MODE_REG_BASE(SYSTEM_TIMER_NUMBER);
+    old_mode = *reg;
+    *reg = 0;
+}
+
+/*******************************************************************************/
+
+static void cx2450x_sys_timer_resume(void)
+{
+    volatile u32 *reg = (volatile u32*) TIMER_MODE_REG_BASE(SYSTEM_TIMER_NUMBER);
+    *reg = old_mode;
+}
+
+/*******************************************************************************/
+
+struct sys_timer cx2450x_sys_timer =
+{
+    .init    = cx2450x_sys_timer_init,
+    .offset  = cx2450x_sys_timer_gettimeoffset,
+    .suspend = cx2450x_sys_timer_suspend,
+    .resume  = cx2450x_sys_timer_resume,
+};
+			    
+/*******************************************************************************/
+
+EXPORT_SYMBOL(cx2450x_unlock_timer);
+EXPORT_SYMBOL(cx2450x_lock_timer);
+EXPORT_SYMBOL(cx2450x_softlock_timer);
diff --git a/arch/arm/mm/Kconfig b/arch/arm/mm/Kconfig
index 33ed048..ed8de90 100644
--- a/arch/arm/mm/Kconfig
+++ b/arch/arm/mm/Kconfig
@@ -387,7 +387,7 @@ config CPU_FEROCEON_OLD_ID
 # ARMv6
 config CPU_V6
 	bool "Support ARM V6 processor"
-	depends on ARCH_INTEGRATOR || MACH_REALVIEW_EB || ARCH_OMAP2 || ARCH_MX3 || ARCH_MSM7X00A || MACH_REALVIEW_PB11MP || MACH_REALVIEW_PB1176
+	depends on ARCH_INTEGRATOR || MACH_REALVIEW_EB || ARCH_OMAP2 || ARCH_MX3 || ARCH_MSM7X00A || MACH_REALVIEW_PB11MP || MACH_REALVIEW_PB1176 || ARCH_NEVIS
 	default y if ARCH_MX3
 	default y if ARCH_MSM7X00A
 	select CPU_32v6
diff --git a/arch/arm/mm/alignment.c b/arch/arm/mm/alignment.c
index e162cca..9662995 100644
--- a/arch/arm/mm/alignment.c
+++ b/arch/arm/mm/alignment.c
@@ -69,6 +69,10 @@ static unsigned long ai_word;
 static unsigned long ai_dword;
 static unsigned long ai_multi;
 static int ai_usermode;
+ 
+#define UM_WARN		(1 << 0)
+#define UM_FIXUP	(1 << 1)
+#define UM_SIGNAL	(1 << 2)
 
 #ifdef CONFIG_PROC_FS
 static const char *usermode_action[] = {
@@ -754,7 +758,7 @@ do_alignment(unsigned long addr, unsigned int fsr, struct pt_regs *regs)
  user:
 	ai_user += 1;
 
-	if (ai_usermode & 1)
+	if (ai_usermode & UM_WARN)
 		printk("Alignment trap: %s (%d) PC=0x%08lx Instr=0x%0*lx "
 		       "Address=0x%08lx FSR 0x%03x\n", current->comm,
 			task_pid_nr(current), instrptr,
@@ -762,10 +766,10 @@ do_alignment(unsigned long addr, unsigned int fsr, struct pt_regs *regs)
 		        thumb_mode(regs) ? tinstr : instr,
 		        addr, fsr);
 
-	if (ai_usermode & 2)
+	if (ai_usermode & UM_FIXUP)
 		goto fixup;
 
-	if (ai_usermode & 4)
+	if (ai_usermode & UM_SIGNAL)
 		force_sig(SIGBUS, current);
 	else
 		set_cr(cr_no_alignment);
@@ -796,6 +800,22 @@ static int __init alignment_init(void)
 	res->write_proc = proc_alignment_write;
 #endif
 
+	/*
+	 * ARMv6 and later CPUs can perform unaligned accesses for
+	 * most single load and store instructions up to word size.
+	 * LDM, STM, LDRD and STRD still need to be handled.
+	 *
+	 * Ignoring the alignment fault is not an option on these
+	 * CPUs since we spin re-faulting the instruction without
+	 * making any progress.
+	 */
+	if (cpu_architecture() >= CPU_ARCH_ARMv6 && (cr_alignment & CR_U)) {
+		cr_alignment &= ~CR_A;
+		cr_no_alignment &= ~CR_A;
+		set_cr(cr_alignment);
+		ai_usermode = UM_FIXUP;
+	}
+
 	hook_fault_code(1, do_alignment, SIGILL, "alignment exception");
 	hook_fault_code(3, do_alignment, SIGILL, "alignment exception");
 
diff --git a/arch/arm/mm/cache-v6.S b/arch/arm/mm/cache-v6.S
index 2c6c2a7..e15b77c 100644
--- a/arch/arm/mm/cache-v6.S
+++ b/arch/arm/mm/cache-v6.S
@@ -20,6 +20,39 @@
 #define D_CACHE_LINE_SIZE	32
 #define BTB_FLUSH_SIZE		8
 
+#ifdef CONFIG_ARM_ERRATA_411920
+/*
+ * Invalidate the entire I cache (this code is a workaround for the ARM1136
+ * Errata 411920 - Invalidate Instruction Cache operation can fail. This
+ * Errata is present in 1136, 1156 and 1176. It does not affect the MPCore
+ *
+ * Registers:
+ *   r0 - set to 0
+ *   r1 - corrupted
+ */
+ENTRY(v6_icache_inval_all)
+	mov	r0, #0
+	mrs	r1, cpsr
+	cpsid	ifa				@ disable interrupts
+	mcr	p15, 0, r0, c7, c5, 0		@ invalidate entire I-cache
+	mcr	p15, 0, r0, c7, c5, 0		@ invalidate entire I-cache
+	mcr	p15, 0, r0, c7, c5, 0		@ invalidate entire I-cache
+	mcr	p15, 0, r0, c7, c5, 0		@ invalidate entire I-cache
+	msr	cpsr_cx, r1			@ restore interrupts
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	mov	pc, lr
+#endif
+
 /*
  *	v6_flush_cache_all()
  *
@@ -31,8 +64,12 @@ ENTRY(v6_flush_kern_cache_all)
 	mov	r0, #0
 #ifdef HARVARD_CACHE
 	mcr	p15, 0, r0, c7, c14, 0		@ D cache clean+invalidate
+#ifndef CONFIG_ARM_ERRATA_411920
 	mcr	p15, 0, r0, c7, c5, 0		@ I+BTB cache invalidate
 #else
+	b	v6_icache_inval_all
+#endif
+#else
 	mcr	p15, 0, r0, c7, c15, 0		@ Cache clean+invalidate
 #endif
 	mov	pc, lr
@@ -95,21 +132,39 @@ ENTRY(v6_coherent_user_range)
 
 #ifdef HARVARD_CACHE
 	bic	r0, r0, #CACHE_LINE_SIZE - 1
-1:	mcr	p15, 0, r0, c7, c10, 1		@ clean D line
+1:
+ USER(	mcr	p15, 0, r0, c7, c10, 1	)	@ clean D line
 	add	r0, r0, #CACHE_LINE_SIZE
+2:
 	cmp	r0, r1
 	blo	1b
 #endif
 	mov	r0, #0
 #ifdef HARVARD_CACHE
 	mcr	p15, 0, r0, c7, c10, 4		@ drain write buffer
+#ifndef CONFIG_ARM_ERRATA_411920
 	mcr	p15, 0, r0, c7, c5, 0		@ I+BTB cache invalidate
 #else
+	b	v6_icache_inval_all
+#endif
+#else
 	mcr	p15, 0, r0, c7, c5, 6		@ invalidate BTB
 #endif
 	mov	pc, lr
 
 /*
+ * Fault handling for the cache operation above. If the virtual address in r0
+ * isn't mapped, just try the next page.
+ */
+9001:
+	mov	r0, r0, lsr #12
+	mov	r0, r0, lsl #12
+	add	r0, r0, #4096
+	b	2b
+ENDPROC(v6_coherent_user_range)
+ENDPROC(v6_coherent_kern_range)
+
+/*
  *	v6_flush_kern_dcache_page(kaddr)
  *
  *	Ensure that the data held in the page kaddr is written back
diff --git a/arch/arm/mm/fault-armv.c b/arch/arm/mm/fault-armv.c
index 44558d5..fbfa260 100644
--- a/arch/arm/mm/fault-armv.c
+++ b/arch/arm/mm/fault-armv.c
@@ -144,13 +144,17 @@ void update_mmu_cache(struct vm_area_struct *vma, unsigned long addr, pte_t pte)
 	page = pfn_to_page(pfn);
 	mapping = page_mapping(page);
 	if (mapping) {
+#ifndef CONFIG_SMP
 		int dirty = test_and_clear_bit(PG_dcache_dirty, &page->flags);
 
 		if (dirty)
 			__flush_dcache_page(mapping, page);
+#endif
 
 		if (cache_is_vivt())
 			make_coherent(mapping, vma, addr, pfn);
+		else if (vma->vm_flags & VM_EXEC)
+			__flush_icache_all();
 	}
 }
 
diff --git a/arch/arm/mm/flush.c b/arch/arm/mm/flush.c
index 9df507d..ed6ffb3 100644
--- a/arch/arm/mm/flush.c
+++ b/arch/arm/mm/flush.c
@@ -31,10 +31,14 @@ static void flush_pfn_alias(unsigned long pfn, unsigned long vaddr)
 
 	asm(	"mcrr	p15, 0, %1, %0, c14\n"
 	"	mcr	p15, 0, %2, c7, c10, 4\n"
+#ifndef CONFIG_ARM_ERRATA_411920
 	"	mcr	p15, 0, %2, c7, c5, 0\n"
+#else
+	"	bl	v6_icache_inval_all\n"
+#endif
 	    :
 	    : "r" (to), "r" (to + PAGE_SIZE - L1_CACHE_BYTES), "r" (zero)
-	    : "cc");
+	    : "r0", "r1", "lr", "cc");
 }
 
 void flush_cache_mm(struct mm_struct *mm)
@@ -47,11 +51,15 @@ void flush_cache_mm(struct mm_struct *mm)
 
 	if (cache_is_vipt_aliasing()) {
 		asm(	"mcr	p15, 0, %0, c7, c14, 0\n"
+		"	mcr	p15, 0, %0, c7, c10, 4\n"
+#ifndef CONFIG_ARM_ERRATA_411920
 		"	mcr	p15, 0, %0, c7, c5, 0\n"
-		"	mcr	p15, 0, %0, c7, c10, 4"
+#else
+		"	bl	v6_icache_inval_all\n"
+#endif
 		    :
 		    : "r" (0)
-		    : "cc");
+		    : "r0", "r1", "lr", "cc");
 	}
 }
 
@@ -66,11 +74,15 @@ void flush_cache_range(struct vm_area_struct *vma, unsigned long start, unsigned
 
 	if (cache_is_vipt_aliasing()) {
 		asm(	"mcr	p15, 0, %0, c7, c14, 0\n"
+		"	mcr	p15, 0, %0, c7, c10, 4\n"
+#ifndef CONFIG_ARM_ERRATA_411920
 		"	mcr	p15, 0, %0, c7, c5, 0\n"
-		"	mcr	p15, 0, %0, c7, c10, 4"
+#else
+		"	bl	v6_icache_inval_all\n"
+#endif
 		    :
 		    : "r" (0)
-		    : "cc");
+		    : "r0", "r1", "lr", "cc");
 	}
 }
 
@@ -199,6 +211,8 @@ void flush_dcache_page(struct page *page)
 		__flush_dcache_page(mapping, page);
 		if (mapping && cache_is_vivt())
 			__flush_dcache_aliases(mapping, page);
+		else if (mapping)
+			__flush_icache_all();
 	}
 }
 EXPORT_SYMBOL(flush_dcache_page);
diff --git a/arch/arm/mm/ioremap.c b/arch/arm/mm/ioremap.c
index 303a7ff..6cb6213 100644
--- a/arch/arm/mm/ioremap.c
+++ b/arch/arm/mm/ioremap.c
@@ -64,6 +64,7 @@ static int remap_area_pte(pmd_t *pmd, unsigned long addr, unsigned long end,
  bad:
 	printk(KERN_CRIT "remap_area_pte: page already exists\n");
 	BUG();
+	return -EFAULT;
 }
 
 static inline int remap_area_pmd(pgd_t *pgd, unsigned long addr,
diff --git a/arch/arm/mm/mmu.c b/arch/arm/mm/mmu.c
index 2d6d682..1ee5b16 100644
--- a/arch/arm/mm/mmu.c
+++ b/arch/arm/mm/mmu.c
@@ -575,6 +575,10 @@ static inline void prepare_page_table(struct meminfo *mi)
 	/*
 	 * Clear out all the mappings below the kernel image.
 	 */
+#if (defined(CONFIG_ARCH_PECOS) || defined(CONFIG_ARCH_NEVIS) || defined(CONFIG_ARCH_PECOS_256M))
+	for (addr = 0; addr <= (unsigned long) (PAGE_OFFSET+TEXT_OFFSET-PGDIR_SIZE); addr += PGDIR_SIZE)
+		pmd_clear(pmd_off_k(addr));
+#else
 	for (addr = 0; addr < MODULE_START; addr += PGDIR_SIZE)
 		pmd_clear(pmd_off_k(addr));
 
@@ -584,7 +588,7 @@ static inline void prepare_page_table(struct meminfo *mi)
 #endif
 	for ( ; addr < PAGE_OFFSET; addr += PGDIR_SIZE)
 		pmd_clear(pmd_off_k(addr));
-
+#endif
 	/*
 	 * Clear out all the kernel space mappings, except for the first
 	 * memory bank, up to the end of the vmalloc region.
@@ -621,6 +625,19 @@ void __init reserve_node_zero(pg_data_t *pgdat)
 			     PTRS_PER_PGD * sizeof(pgd_t), BOOTMEM_DEFAULT);
 
 	/*
+	 * Reserve the Conexant Nevis specific areas
+	 * WARNING: Make sure the DECARM area is not exactly at the end of the RAM.
+	 * 	    It might not be reserved due to bootmem allocator?
+	 */
+	if (machine_is_nevis()) {
+		/* ARM9 Vector */
+		reserve_bootmem_node(pgdat, 0x10000, 0x10000,
+			BOOTMEM_DEFAULT);
+		/* Splash Image (2MB) */
+		reserve_bootmem_node(pgdat, 0x100000, 0x200000,
+			BOOTMEM_DEFAULT);
+	}
+	/*
 	 * Hmm... This should go elsewhere, but we really really need to
 	 * stop things allocating the low memory; ideally we need a better
 	 * implementation of GFP_DMA which does not assume that DMA-able
diff --git a/build.sh b/build.sh
new file mode 100755
index 0000000..d10a0ae
--- /dev/null
+++ b/build.sh
@@ -0,0 +1,4 @@
+#!/bin/sh
+make -j4 ARCH=arm CROSS_COMPILE=arm-cx2450x-linux-gnueabi- zImage
+make -j4 ARCH=arm CROSS_COMPILE=arm-cx2450x-linux-gnueabi- modules
+./mkimage -A arm -O linux -T kernel -C none -a 0x17048000 -e 0x17048000 -n "Coolstream HDx Kernel" -d arch/arm/boot/Image uImage
diff --git a/config-2.6.26.8-nevis b/config-2.6.26.8-nevis
new file mode 100644
index 0000000..9985e2a
--- /dev/null
+++ b/config-2.6.26.8-nevis
@@ -0,0 +1,1456 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.26.8
+# Wed May 23 16:29:57 2012
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+# CONFIG_GENERIC_TIME is not set
+# CONFIG_GENERIC_CLOCKEVENTS is not set
+CONFIG_MMU=y
+# CONFIG_NO_IOPORT is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_SETJMP_INCLUDED=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ARCH_SUPPORTS_AOUT=y
+CONFIG_ZONE_DMA=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION="-nevis"
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=17
+# CONFIG_CGROUPS is not set
+# CONFIG_GROUP_SCHED is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_SYSCTL_SYSCALL_CHECK=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_KALLSYMS_EXTRA_PASS=y
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_COMPAT_BRK=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+# CONFIG_SHMEM is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+# CONFIG_MARKERS is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+# CONFIG_HAVE_DMA_ATTRS is not set
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_TINY_SHMEM=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+# CONFIG_KMOD is not set
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+# CONFIG_BLK_DEV_BSG is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_CLASSIC_RCU=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_ORION5X is not set
+CONFIG_ARCH_NEVIS=y
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_MSM7X00A is not set
+
+#
+# Conexant CX2450X (Nevis) SoC support
+#
+CONFIG_MACH_NEVIS=y
+CONFIG_ED_COOLSTREAM_HD1=y
+CONFIG_ARCH_CNXT_EDWARDS=y
+CONFIG_CNXT_PHYS_OFFSET=0x0
+CONFIG_CNXT_TEXT_OFFSET=0x17048000
+CONFIG_CNXT_MODULE_START_OFFSET=0x00FB8000
+CONFIG_CNXT_MODULE_ADDRESS_SPACE_SIZE=0x1000000
+CONFIG_CNXT_VMALLOC_SIZE=0x18000000
+CONFIG_CNXT_DECARM_PHY_ADDRESS=0x17C00000
+CONFIG_CNXT_DECARM_CODE_MEM_SIZE=0x00300000
+CONFIG_CNXT_DECARM_SHARED_MEM_SIZE=0x00100000
+
+#
+# GPIO MUX defaults
+#
+CONFIG_PLL_CONFIG0_REG_DEFAULT=0xBFFFEFFE
+CONFIG_PLL_PIN_ALT_FUNC_REG_DEFAULT=0x00000010
+CONFIG_PLL_PIN_GPIO_MUX0_REG_DEFAULT=0x0000D000
+CONFIG_PLL_PIN_GPIO_MUX1_REG_DEFAULT=0x00000080
+CONFIG_PLL_PIN_GPIO_MUX2_REG_DEFAULT=0x000021C0
+CONFIG_PLL_PIN_GPIO_MUX3_REG_DEFAULT=0xFFBFC380
+CONFIG_PLL_PIN_GPIO_MUX4_REG_DEFAULT=0xFFFC0006
+CONFIG_PLL_PIN_GPIO_MUX5_REG_DEFAULT=0x0006F209
+CONFIG_PLL_PIN_GPIO_MUX6_REG_DEFAULT=0x00000002
+CONFIG_SREG_2ND_PIN_MUX0_REG_DEFAULT=0x00000000
+CONFIG_SREG_2ND_PIN_MUX1_REG_DEFAULT=0x00003000
+CONFIG_SREG_2ND_PIN_MUX2_REG_DEFAULT=0x3F7C0000
+CONFIG_SREG_2ND_PIN_MUX3_REG_DEFAULT=0x20000000
+CONFIG_SREG_2ND_PIN_MUX4_REG_DEFAULT=0x00000000
+CONFIG_SREG_2ND_PIN_MUX5_REG_DEFAULT=0x00000000
+CONFIG_SREG_2ND_PIN_MUX6_REG_DEFAULT=0x00000000
+
+#
+# GPIO options
+#
+CONFIG_PIO_INIT_ON_BOOT=y
+CONFIG_PIO_EXCL_MASK_PIO_031_000=0x00000300
+CONFIG_PIO_EXCL_MASK_PIO_063_032=0x00000000
+CONFIG_PIO_EXCL_MASK_PIO_095_064=0x00000010
+CONFIG_PIO_EXCL_MASK_PIO_127_096=0x00000000
+CONFIG_PIO_EXCL_MASK_PIO_159_128=0x00000000
+CONFIG_PIO_EXCL_MASK_PIO_191_160=0x20000000
+CONFIG_PIO_EXCL_MASK_PIO_223_192=0x00000000
+
+#
+# Boot options
+#
+
+#
+# Power management
+#
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_V6=y
+# CONFIG_CPU_32v6K is not set
+CONFIG_CPU_32v6=y
+CONFIG_CPU_ABRT_EV6=y
+CONFIG_CPU_PABRT_NOIFAR=y
+CONFIG_CPU_CACHE_V6=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V6=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_THUMB is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+# CONFIG_OUTER_CACHE is not set
+CONFIG_ARM_ERRATA_411920=y
+
+#
+# Bus support
+#
+# CONFIG_PCI is not set
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+# CONFIG_TICK_ONESHOT is not set
+# CONFIG_PREEMPT is not set
+# CONFIG_NO_IDLE_HZ is not set
+CONFIG_HZ=100
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+# CONFIG_ARCH_DISCONTIGMEM_ENABLE is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+# CONFIG_SPARSEMEM_VMEMMAP_ENABLE is not set
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_RESOURCES_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="console=ttyRI0 ip=on root=/dev/nfs rw nfsroot=192.168.100.222:/home/lucgas/nfsexport/coolstream_hd1,rsize=2048,wsize=2048 mem=384M"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_BINFMT_AOUT=y
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+CONFIG_NET_KEY=y
+# CONFIG_NET_KEY_MIGRATE is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+CONFIG_INET_AH=y
+CONFIG_INET_ESP=y
+CONFIG_INET_IPCOMP=y
+CONFIG_INET_XFRM_TUNNEL=y
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+CONFIG_INET_LRO=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+CONFIG_NET_SCH_FIFO=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+
+#
+# Wireless
+#
+CONFIG_CFG80211=m
+CONFIG_NL80211=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_MAC80211=m
+
+#
+# Rate control algorithm selection
+#
+CONFIG_MAC80211_RC_DEFAULT_PID=y
+# CONFIG_MAC80211_RC_DEFAULT_NONE is not set
+
+#
+# Selecting 'y' for an algorithm will
+#
+
+#
+# build the algorithm into mac80211.
+#
+CONFIG_MAC80211_RC_DEFAULT="pid"
+CONFIG_MAC80211_RC_PID=y
+# CONFIG_MAC80211_MESH is not set
+# CONFIG_MAC80211_LEDS is not set
+CONFIG_MAC80211_DEBUGFS=y
+# CONFIG_MAC80211_DEBUG_PACKET_ALIGNMENT is not set
+# CONFIG_MAC80211_DEBUG is not set
+CONFIG_IEEE80211=m
+# CONFIG_IEEE80211_DEBUG is not set
+CONFIG_IEEE80211_CRYPT_WEP=m
+CONFIG_IEEE80211_CRYPT_CCMP=m
+CONFIG_IEEE80211_CRYPT_TKIP=m
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_CONCAT=y
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+CONFIG_MTD_CFI_ADV_OPTIONS=y
+CONFIG_MTD_CFI_NOSWAP=y
+# CONFIG_MTD_CFI_BE_BYTE_SWAP is not set
+# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
+CONFIG_MTD_CFI_GEOMETRY=y
+# CONFIG_MTD_MAP_BANK_WIDTH_1 is not set
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+# CONFIG_MTD_MAP_BANK_WIDTH_4 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+# CONFIG_MTD_CFI_I2 is not set
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_OTP is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+CONFIG_MTD_CFI_AMDSTD=y
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+CONFIG_MTD_COMPLEX_MAPPINGS=y
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+CONFIG_MTD_NEVIS_FLASH=y
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+CONFIG_MTD_MTDRAM=m
+CONFIG_MTDRAM_TOTAL_SIZE=32768
+CONFIG_MTDRAM_ERASE_SIZE=128
+CONFIG_MTD_BLOCK2MTD=m
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+# CONFIG_MTD_NAND is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# UBI - Unsorted block images
+#
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_WL_THRESHOLD=4096
+CONFIG_MTD_UBI_BEB_RESERVE=1
+# CONFIG_MTD_UBI_GLUEBI is not set
+
+#
+# UBI debugging options
+#
+CONFIG_MTD_UBI_DEBUG=y
+CONFIG_MTD_UBI_DEBUG_MSG=y
+# CONFIG_MTD_UBI_DEBUG_PARANOID is not set
+# CONFIG_MTD_UBI_DEBUG_DISABLE_BGT is not set
+# CONFIG_MTD_UBI_DEBUG_USERSPACE_IO is not set
+# CONFIG_MTD_UBI_DEBUG_EMULATE_BITFLIPS is not set
+# CONFIG_MTD_UBI_DEBUG_EMULATE_WRITE_FAILURES is not set
+# CONFIG_MTD_UBI_DEBUG_EMULATE_ERASE_FAILURES is not set
+
+#
+# Additional UBI debugging messages
+#
+CONFIG_MTD_UBI_DEBUG_MSG_BLD=y
+# CONFIG_MTD_UBI_DEBUG_MSG_EBA is not set
+# CONFIG_MTD_UBI_DEBUG_MSG_WL is not set
+# CONFIG_MTD_UBI_DEBUG_MSG_IO is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MISC_DEVICES is not set
+CONFIG_EEPROM_93CX6=m
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+CONFIG_SCSI_TGT=y
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+CONFIG_BLK_DEV_SR=y
+# CONFIG_BLK_DEV_SR_VENDOR is not set
+CONFIG_CHR_DEV_SG=y
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+CONFIG_SCSI_LOGGING=y
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_SCSI_DEBUG is not set
+CONFIG_ATA=y
+# CONFIG_ATA_NONSTANDARD is not set
+CONFIG_SATA_PMP=y
+CONFIG_ATA_SFF=y
+# CONFIG_SATA_MV is not set
+# CONFIG_PATA_PLATFORM is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_NETDEVICES_MULTIQUEUE is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_AX88796 is not set
+CONFIG_CNXT_EMAC=y
+CONFIG_CNXT_EMAC0_ENABLE=y
+# CONFIG_CNXT_EMAC0_2xMODE_ENABLE is not set
+CONFIG_EMAC0_MDIO_SUPPORT=y
+CONFIG_EMAC0_MDIO_ADDRESS=0xFFFFFFFF
+# CONFIG_CNXT_EMAC1_ENABLE is not set
+CONFIG_MII_GPIO_BANK=3
+CONFIG_MII_GPIO_BIT=31
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_B44 is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+CONFIG_WLAN_80211=y
+CONFIG_LIBERTAS=m
+# CONFIG_LIBERTAS_USB is not set
+# CONFIG_LIBERTAS_DEBUG is not set
+CONFIG_USB_ZD1201=m
+CONFIG_USB_NET_RNDIS_WLAN=m
+CONFIG_RTL8187=m
+CONFIG_P54_COMMON=m
+# CONFIG_P54_USB is not set
+# CONFIG_IWLWIFI_LEDS is not set
+CONFIG_HOSTAP=m
+CONFIG_HOSTAP_FIRMWARE=y
+CONFIG_HOSTAP_FIRMWARE_NVRAM=y
+CONFIG_B43=m
+# CONFIG_B43_DEBUG is not set
+CONFIG_B43LEGACY=m
+# CONFIG_B43LEGACY_DEBUG is not set
+CONFIG_B43LEGACY_DMA=y
+CONFIG_B43LEGACY_PIO=y
+CONFIG_B43LEGACY_DMA_AND_PIO_MODE=y
+# CONFIG_B43LEGACY_DMA_MODE is not set
+# CONFIG_B43LEGACY_PIO_MODE is not set
+CONFIG_ZD1211RW=m
+# CONFIG_ZD1211RW_DEBUG is not set
+CONFIG_RT2X00=m
+CONFIG_RT2X00_LIB=m
+CONFIG_RT2X00_LIB_USB=m
+CONFIG_RT2X00_LIB_FIRMWARE=y
+CONFIG_RT2500USB=m
+CONFIG_RT73USB=m
+CONFIG_RT2X00_LIB_DEBUGFS=y
+# CONFIG_RT2X00_DEBUG is not set
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+CONFIG_USB_USBNET=m
+CONFIG_USB_NET_AX8817X=m
+CONFIG_USB_NET_CDCETHER=m
+# CONFIG_USB_NET_DM9601 is not set
+# CONFIG_USB_NET_GL620A is not set
+CONFIG_USB_NET_NET1080=m
+# CONFIG_USB_NET_PLUSB is not set
+# CONFIG_USB_NET_MCS7830 is not set
+CONFIG_USB_NET_RNDIS_HOST=m
+CONFIG_USB_NET_CDC_SUBSET=m
+# CONFIG_USB_ALI_M5632 is not set
+# CONFIG_USB_AN2720 is not set
+CONFIG_USB_BELKIN=y
+CONFIG_USB_ARMLINUX=y
+# CONFIG_USB_EPSON2888 is not set
+# CONFIG_USB_KC2190 is not set
+CONFIG_USB_NET_ZAURUS=m
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+CONFIG_INPUT_POLLDEV=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=y
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_SERIAL_CX2450X=y
+# CONFIG_SERIAL_CX2450X_BAUD_RATE_230400 is not set
+CONFIG_SERIAL_CX2450X_BAUD_RATE_115200=y
+# CONFIG_SERIAL_CX2450X_BAUD_RATE_57600 is not set
+# CONFIG_SERIAL_CX2450X_BAUD_RATE_38400 is not set
+# CONFIG_SERIAL_CX2450X_BAUD_RATE_19200 is not set
+# CONFIG_SERIAL_CX2450X_BAUD_RATE_9600 is not set
+CONFIG_CX2450X_BAUD_RATE=115200
+# CONFIG_SERIAL_CX2450X_UART1_ENABLE is not set
+# CONFIG_SERIAL_CX2450X_UART2_ENABLE is not set
+CONFIG_SERIAL_CX2450X_UART3_ENABLE=y
+CONFIG_SERIAL_CX2450X_CONSOLE=y
+CONFIG_SERIAL_CX2450X_BOOTMSG=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+CONFIG_HW_RANDOM_CX2450X=y
+# CONFIG_NVRAM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_TINY_USB is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_DS1682 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_PCF8575 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+# CONFIG_SPI is not set
+CONFIG_HAVE_GPIO_LIB=y
+
+#
+# GPIO Support
+#
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_WATCHDOG is not set
+
+#
+# Sonics Silicon Backplane
+#
+CONFIG_SSB_POSSIBLE=y
+CONFIG_SSB=m
+# CONFIG_SSB_SILENT is not set
+# CONFIG_SSB_DEBUG is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+
+#
+# Multimedia devices
+#
+
+#
+# Multimedia core support
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_VIDEO_MEDIA is not set
+
+#
+# Multimedia drivers
+#
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_CFB_FILLRECT is not set
+# CONFIG_FB_CFB_COPYAREA is not set
+# CONFIG_FB_CFB_IMAGEBLIT is not set
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+# CONFIG_LOGO is not set
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+
+#
+# Advanced Linux Sound Architecture
+#
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+# CONFIG_SND_SEQUENCER is not set
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
+CONFIG_SND_PCM_OSS_PLUGINS=y
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+CONFIG_SND_VERBOSE_PRINTK=y
+CONFIG_SND_DEBUG=y
+CONFIG_SND_DEBUG_DETECT=y
+CONFIG_SND_PCM_XRUN_DEBUG=y
+
+#
+# Generic devices
+#
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+
+#
+# ALSA ARM devices
+#
+
+#
+# USB devices
+#
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_CAIAQ is not set
+
+#
+# System on Chip audio support
+#
+# CONFIG_SND_SOC is not set
+
+#
+# ALSA SoC audio for Freescale SOCs
+#
+
+#
+# SoC Audio for the Texas Instruments OMAP
+#
+
+#
+# Open Sound System
+#
+# CONFIG_SOUND_PRIME is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=m
+# CONFIG_HID_DEBUG is not set
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=m
+# CONFIG_USB_HIDINPUT_POWERBOOK is not set
+# CONFIG_HID_FF is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# USB HID Boot Protocol drivers
+#
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_CX2450X_USB=y
+CONFIG_CX2450X_USB0=y
+CONFIG_CX2450X_USB1=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# may also be needed; see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USB_MON is not set
+
+#
+# USB port drivers
+#
+CONFIG_USB_SERIAL=m
+# CONFIG_USB_EZUSB is not set
+# CONFIG_USB_SERIAL_GENERIC is not set
+# CONFIG_USB_SERIAL_AIRCABLE is not set
+# CONFIG_USB_SERIAL_AIRPRIME is not set
+# CONFIG_USB_SERIAL_ARK3116 is not set
+# CONFIG_USB_SERIAL_BELKIN is not set
+# CONFIG_USB_SERIAL_CH341 is not set
+# CONFIG_USB_SERIAL_WHITEHEAT is not set
+# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+# CONFIG_USB_SERIAL_CP2101 is not set
+# CONFIG_USB_SERIAL_CYPRESS_M8 is not set
+# CONFIG_USB_SERIAL_EMPEG is not set
+CONFIG_USB_SERIAL_FTDI_SIO=m
+# CONFIG_USB_SERIAL_FUNSOFT is not set
+# CONFIG_USB_SERIAL_VISOR is not set
+# CONFIG_USB_SERIAL_IPAQ is not set
+# CONFIG_USB_SERIAL_IR is not set
+# CONFIG_USB_SERIAL_EDGEPORT is not set
+# CONFIG_USB_SERIAL_EDGEPORT_TI is not set
+# CONFIG_USB_SERIAL_GARMIN is not set
+# CONFIG_USB_SERIAL_IPW is not set
+# CONFIG_USB_SERIAL_IUU is not set
+# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+# CONFIG_USB_SERIAL_KEYSPAN is not set
+# CONFIG_USB_SERIAL_KLSI is not set
+# CONFIG_USB_SERIAL_KOBIL_SCT is not set
+# CONFIG_USB_SERIAL_MCT_U232 is not set
+# CONFIG_USB_SERIAL_MOS7720 is not set
+# CONFIG_USB_SERIAL_MOS7840 is not set
+# CONFIG_USB_SERIAL_MOTOROLA is not set
+# CONFIG_USB_SERIAL_NAVMAN is not set
+CONFIG_USB_SERIAL_PL2303=m
+# CONFIG_USB_SERIAL_OTI6858 is not set
+# CONFIG_USB_SERIAL_SPCP8X5 is not set
+# CONFIG_USB_SERIAL_HP4X is not set
+# CONFIG_USB_SERIAL_SAFE is not set
+# CONFIG_USB_SERIAL_SIERRAWIRELESS is not set
+# CONFIG_USB_SERIAL_TI is not set
+# CONFIG_USB_SERIAL_CYBERJACK is not set
+# CONFIG_USB_SERIAL_XIRCOM is not set
+# CONFIG_USB_SERIAL_OPTION is not set
+# CONFIG_USB_SERIAL_OMNINET is not set
+# CONFIG_USB_SERIAL_DEBUG is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGET is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_GADGET is not set
+# CONFIG_MMC is not set
+# CONFIG_NEW_LEDS is not set
+CONFIG_RTC_LIB=y
+# CONFIG_RTC_CLASS is not set
+# CONFIG_UIO is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+# CONFIG_EXT2_FS_POSIX_ACL is not set
+# CONFIG_EXT2_FS_SECURITY is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+# CONFIG_EXT4DEV_FS is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_XFS_FS=y
+# CONFIG_XFS_QUOTA is not set
+# CONFIG_XFS_POSIX_ACL is not set
+CONFIG_XFS_RT=y
+# CONFIG_XFS_DEBUG is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_DNOTIFY is not set
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+CONFIG_FUSE_FS=m
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+CONFIG_NTFS_FS=m
+# CONFIG_NTFS_DEBUG is not set
+# CONFIG_NTFS_RW is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+# CONFIG_JFFS2_FS_WRITEBUFFER is not set
+CONFIG_JFFS2_SUMMARY=y
+# CONFIG_JFFS2_FS_XATTR is not set
+CONFIG_JFFS2_COMPRESSION_OPTIONS=y
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_LZO=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+# CONFIG_JFFS2_CMODE_NONE is not set
+CONFIG_JFFS2_CMODE_PRIORITY=y
+# CONFIG_JFFS2_CMODE_SIZE is not set
+# CONFIG_JFFS2_CMODE_FAVOURLZO is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_SUNRPC_BIND34 is not set
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+CONFIG_CIFS=m
+# CONFIG_CIFS_STATS is not set
+CONFIG_CIFS_WEAK_PW_HASH=y
+# CONFIG_CIFS_XATTR is not set
+# CONFIG_CIFS_DEBUG2 is not set
+# CONFIG_CIFS_EXPERIMENTAL is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_737=m
+CONFIG_NLS_CODEPAGE_775=m
+CONFIG_NLS_CODEPAGE_850=m
+CONFIG_NLS_CODEPAGE_852=m
+CONFIG_NLS_CODEPAGE_855=m
+CONFIG_NLS_CODEPAGE_857=m
+CONFIG_NLS_CODEPAGE_860=m
+CONFIG_NLS_CODEPAGE_861=m
+CONFIG_NLS_CODEPAGE_862=m
+CONFIG_NLS_CODEPAGE_863=m
+CONFIG_NLS_CODEPAGE_864=m
+CONFIG_NLS_CODEPAGE_865=m
+CONFIG_NLS_CODEPAGE_866=m
+CONFIG_NLS_CODEPAGE_869=m
+CONFIG_NLS_CODEPAGE_936=m
+CONFIG_NLS_CODEPAGE_950=m
+CONFIG_NLS_CODEPAGE_932=m
+CONFIG_NLS_CODEPAGE_949=m
+CONFIG_NLS_CODEPAGE_874=m
+CONFIG_NLS_ISO8859_8=m
+CONFIG_NLS_CODEPAGE_1250=m
+CONFIG_NLS_CODEPAGE_1251=m
+CONFIG_NLS_ASCII=m
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_ISO8859_2=m
+CONFIG_NLS_ISO8859_3=m
+CONFIG_NLS_ISO8859_4=m
+CONFIG_NLS_ISO8859_5=m
+CONFIG_NLS_ISO8859_6=m
+CONFIG_NLS_ISO8859_7=m
+CONFIG_NLS_ISO8859_9=m
+CONFIG_NLS_ISO8859_13=m
+CONFIG_NLS_ISO8859_14=m
+CONFIG_NLS_ISO8859_15=m
+CONFIG_NLS_KOI8_R=m
+CONFIG_NLS_KOI8_U=m
+CONFIG_NLS_UTF8=y
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_UNUSED_SYMBOLS=y
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_SAMPLES is not set
+# CONFIG_DEBUG_USER is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_MANAGER=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=y
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=m
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_MICHAEL_MIC=m
+CONFIG_CRYPTO_SHA1=y
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=m
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=m
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+CONFIG_CRYPTO_LZO=y
+# CONFIG_CRYPTO_HW is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+# CONFIG_GENERIC_FIND_FIRST_BIT is not set
+# CONFIG_GENERIC_FIND_NEXT_BIT is not set
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=y
+CONFIG_CRC_ITU_T=m
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
diff --git a/drivers/ata/libata-core.c b/drivers/ata/libata-core.c
index 303fc0d..156ed86 100644
--- a/drivers/ata/libata-core.c
+++ b/drivers/ata/libata-core.c
@@ -3613,7 +3613,7 @@ int sata_link_hardreset(struct ata_link *link, const unsigned long *timing,
 	/* Couldn't find anything in SATA I/II specs, but AHCI-1.1
 	 * 10.4.2 says at least 1 ms.
 	 */
-	msleep(1);
+	msleep(4);
 
 	/* bring link back */
 	rc = sata_link_resume(link, timing, deadline);
diff --git a/drivers/ata/libata-sff.c b/drivers/ata/libata-sff.c
index c0908c2..18ab92e 100644
--- a/drivers/ata/libata-sff.c
+++ b/drivers/ata/libata-sff.c
@@ -1424,21 +1424,20 @@ unsigned int ata_sff_qc_issue(struct ata_queued_cmd *qc)
 		if (qc->tf.flags & ATA_TFLAG_POLLING)
 			ata_qc_set_polling(qc);
 
-		ata_tf_to_host(ap, &qc->tf);
 		ap->hsm_task_state = HSM_ST_LAST;
+		ata_tf_to_host(ap, &qc->tf);
 
 		if (qc->tf.flags & ATA_TFLAG_POLLING)
 			ata_pio_queue_task(ap, qc, 0);
-
 		break;
 
 	case ATA_PROT_DMA:
 		WARN_ON(qc->tf.flags & ATA_TFLAG_POLLING);
 
+		ap->hsm_task_state = HSM_ST_LAST;
 		ap->ops->sff_tf_load(ap, &qc->tf);  /* load tf registers */
 		ap->ops->bmdma_setup(qc);	    /* set up bmdma */
 		ap->ops->bmdma_start(qc);	    /* initiate bmdma */
-		ap->hsm_task_state = HSM_ST_LAST;
 		break;
 
 	case ATA_PROT_PIO:
diff --git a/drivers/char/hw_random/Kconfig b/drivers/char/hw_random/Kconfig
index efd0b4d..5e50f67 100644
--- a/drivers/char/hw_random/Kconfig
+++ b/drivers/char/hw_random/Kconfig
@@ -20,6 +20,19 @@ config HW_RANDOM
 
 	  If unsure, say Y.
 
+config HW_RANDOM_CX2450X
+	tristate "Trident/NXP CX2450x HW Random Number Generator support"
+	depends on HW_RANDOM && MACH_NEVIS
+	default HW_RANDOM
+	---help---
+	  This driver provides kernel-side support for the Random Number
+	  Generator hardware found on Trident/NXP CX2450x SoC.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called intel-rng.
+
+	  If unsure, say Y.
+
 config HW_RANDOM_INTEL
 	tristate "Intel HW Random Number Generator support"
 	depends on HW_RANDOM && (X86 || IA64) && PCI
diff --git a/drivers/char/hw_random/Makefile b/drivers/char/hw_random/Makefile
index b4940dd..d757d71 100644
--- a/drivers/char/hw_random/Makefile
+++ b/drivers/char/hw_random/Makefile
@@ -12,3 +12,4 @@ obj-$(CONFIG_HW_RANDOM_IXP4XX) += ixp4xx-rng.o
 obj-$(CONFIG_HW_RANDOM_OMAP) += omap-rng.o
 obj-$(CONFIG_HW_RANDOM_PASEMI) += pasemi-rng.o
 obj-$(CONFIG_HW_RANDOM_VIRTIO) += virtio-rng.o
+obj-$(CONFIG_HW_RANDOM_CX2450X) += cx2450x-rng.o
\ No newline at end of file
diff --git a/drivers/char/hw_random/cx2450x-rng.c b/drivers/char/hw_random/cx2450x-rng.c
new file mode 100644
index 0000000..04b8947
--- /dev/null
+++ b/drivers/char/hw_random/cx2450x-rng.c
@@ -0,0 +1,65 @@
+/*
+ * drivers/char/hw_random/cx2450x-rng.c
+ *
+ * RNG driver for Trident/NXP CX2450x type SoC's 
+ *
+ * Author: The Coolstream Development Team
+ *
+ * Copyright 2010 (c) Coolstream Intl. Ltd.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/bitops.h>
+#include <linux/hw_random.h>
+
+#include <asm/io.h>
+#include <asm/hardware.h>
+
+#define MC_RANDOM_REG 0xE0500398
+
+/******************************************************************************/
+
+static int cx2450x_rng_data_read(struct hwrng *rng, u32 *buffer)
+{
+	*buffer = *((volatile u32*)MC_RANDOM_REG);
+
+	return 4;
+}
+
+/******************************************************************************/
+
+static struct hwrng cx2450x_rng_ops = {
+	.name		= "cx2450x",
+	.data_read	= cx2450x_rng_data_read,
+};
+
+/******************************************************************************/
+
+static int __init cx2450x_rng_init(void)
+{
+	return hwrng_register(&cx2450x_rng_ops);
+}
+
+/******************************************************************************/
+
+static void __exit cx2450x_rng_exit(void)
+{
+	hwrng_unregister(&cx2450x_rng_ops);
+}
+
+/******************************************************************************/
+
+module_init(cx2450x_rng_init);
+module_exit(cx2450x_rng_exit);
+
+MODULE_AUTHOR("The Coolstream Development Team");
+MODULE_DESCRIPTION("H/W Random Number Generator (RNG) driver for CX2450x");
+MODULE_LICENSE("GPL");
diff --git a/drivers/i2c/i2c-dev.c b/drivers/i2c/i2c-dev.c
index 436c7e1..b2659cf 100644
--- a/drivers/i2c/i2c-dev.c
+++ b/drivers/i2c/i2c-dev.c
@@ -36,6 +36,10 @@
 #include <linux/i2c-dev.h>
 #include <asm/uaccess.h>
 
+#ifndef I2C_DRIVERID_I2CDEV
+#define I2C_DRIVERID_I2CDEV	900
+#endif
+
 static struct i2c_driver i2cdev_driver;
 
 /*
diff --git a/drivers/mtd/maps/Kconfig b/drivers/mtd/maps/Kconfig
index 17bc87a..c72adf7 100644
--- a/drivers/mtd/maps/Kconfig
+++ b/drivers/mtd/maps/Kconfig
@@ -383,6 +383,10 @@ config MTD_ARM_INTEGRATOR
 	tristate "CFI Flash device mapped on ARM Integrator/P720T"
 	depends on ARM && MTD_CFI
 
+config MTD_NEVIS_FLASH
+	tristate "CFI Flash defice(s) mapped on Conexant CX2450x (Nevis)"
+	depends on ARM && MTD_CFI
+
 config MTD_CDB89712
 	tristate "Cirrus CDB89712 evaluation board mappings"
 	depends on MTD_CFI && ARCH_CDB89712
diff --git a/drivers/mtd/maps/Makefile b/drivers/mtd/maps/Makefile
index 957fb5f..f104821 100644
--- a/drivers/mtd/maps/Makefile
+++ b/drivers/mtd/maps/Makefile
@@ -12,6 +12,7 @@ obj-$(CONFIG_MTD_CDB89712)	+= cdb89712.o
 obj-$(CONFIG_MTD_ARM_INTEGRATOR)+= integrator-flash.o
 obj-$(CONFIG_MTD_BAST)		+= bast-flash.o
 obj-$(CONFIG_MTD_CFI_FLAGADM)	+= cfi_flagadm.o
+obj-$(CONFIG_MTD_NEVIS_FLASH)	+= cx2450x-flash.o
 obj-$(CONFIG_MTD_DC21285)	+= dc21285.o
 obj-$(CONFIG_MTD_DILNETPC)	+= dilnetpc.o
 obj-$(CONFIG_MTD_L440GX)	+= l440gx.o
diff --git a/drivers/mtd/maps/cx2450x-flash.c b/drivers/mtd/maps/cx2450x-flash.c
new file mode 100644
index 0000000..5ad5230
--- /dev/null
+++ b/drivers/mtd/maps/cx2450x-flash.c
@@ -0,0 +1,335 @@
+/*======================================================================
+
+    drivers/mtd/maps/cx2450x-flash.c
+    map driver for CFI compliant NOR-flashes connected to an
+    Conexant CX2450x SoC
+
+    copyright (C) 2008 Coolstream International Limited
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+======================================================================*/
+
+#include <asm/arch/cx2450x.h>
+#include <linux/module.h>
+#include <linux/ioport.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#define	VERSION	"1.0"
+
+/* a default Flash map for the case that no map given by the cmdline */
+static const struct mtd_partition default_partitions[] = {
+	{
+	 .name = "Bootloader",
+	 .size = 0x00060000,	/* 384K */
+	 .offset = 0,
+	 .mask_flags = 0	/* to make it readonly */
+	 },
+	{
+	 .name = "Bootloader Splash Image",
+	 .size = 0x00020000,	/* 128K */
+	 .offset = 0x00060000,
+	 .mask_flags = 0	/* to make it readonly */
+	 },
+	{
+	 .name = "Compressed Kernel",
+	 .size = 0x00400000,
+	 .offset = 0x00080000,
+	 .mask_flags = 0	/* to make it readonly */
+	 },
+	{
+	 .name = "systemFS",
+	 .size = 0x01B80000,
+	 .offset = 0x00480000,
+	 .mask_flags = 0}
+#if 0
+	,
+	{
+	 .name = "Root Filesystem (JFFS2)",
+	 .size = 0x01000000,
+	 .offset = 0x01000000,
+	 .mask_flags = 0}
+#endif
+};
+
+#include <asm/arch/platform.h>
+
+inline void enter_flash_program_mode(void)
+{
+	writel(readl(PCI_ROM_DESC0_REG) | (1UL << 23), PCI_ROM_DESC0_REG);
+	writel(readl(PCI_ISAROM_DESC1_REG) | (1UL << 23), PCI_ISAROM_DESC1_REG);
+}
+
+inline void exit_flash_program_mode(void)
+{
+	writel(readl(PCI_ROM_DESC0_REG) & ~(1UL << 23), PCI_ROM_DESC0_REG);
+	writel(readl(PCI_ISAROM_DESC1_REG) & ~(1UL << 23), PCI_ISAROM_DESC1_REG);
+}
+
+/*****************************************/
+/*       CNXT Flash map APIs             */
+/*****************************************/
+
+static map_word cnxt_map_read(struct map_info *map, unsigned long ofs)
+{
+	map_word r;
+	r.x[0] = readw(map->virt + ofs);
+	return r;
+}
+
+static void cnxt_map_write(struct map_info *map, const map_word datum, unsigned long ofs)
+{
+	enter_flash_program_mode();
+	writew(datum.x[0], map->virt + ofs);
+	exit_flash_program_mode();
+	mb();
+	/*printk("[0x%x]<=0x%x\n", map->virt + ofs, datum.x[0]); */
+}
+
+static void cnxt_map_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	uint16_t buf;
+	unsigned char *to_lval = to;
+	while (len > 0) {
+		buf = readw(map->virt + (from & 0xFFFFFFFE));
+		if (!(from & 1))
+			*((unsigned char *) to_lval) = (buf & 0xff);
+		else
+			*((unsigned char *) to_lval) = ((buf & 0xff00) >> 8);
+		to_lval++;
+		len--;
+		from++;
+	}
+}
+
+static void cnxt_map_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	uint16_t buf;
+	uint16_t *from_lval = (uint16_t *) from;
+	enter_flash_program_mode();
+	while (len > 0) {
+		buf = readw(map->virt + (to & 0xFFFFFFFE));
+		if (!(to & 1))
+			buf = (buf & 0xff00) | *((unsigned char *) from_lval);
+		else
+			buf = (buf & 0xff) | (((uint16_t) (*((unsigned char *) from_lval))) << 8);
+		writew(buf, map->virt + (to & 0xFFFFFFFE));
+		from_lval++;
+		len--;
+		to++;
+	}
+	exit_flash_program_mode();
+}
+
+void cnxt_map_init(struct map_info *map)
+{
+	map->read = cnxt_map_read;
+	map->write = cnxt_map_write;
+	map->copy_from = cnxt_map_copy_from;
+	map->copy_to = cnxt_map_copy_to;
+	writel(0x1000, PCI_ROM_DESC0_REG2);
+}
+
+struct cx2450xflash_info {
+	struct resource *res;
+	struct map_info map;
+	struct mtd_info *mtd;
+	struct mtd_partition *parts;
+};
+
+static u32 num_banks = 0;
+static struct cx2450xflash_info *info = NULL;
+
+/*******************************************************************************/
+
+static void cx2450xflash_set_vpp(struct map_info *map, int on)
+{
+	volatile u32 *reg;
+	u32 bank;
+
+	for (bank = 0; bank < num_banks; bank++) {
+		reg = (volatile u32 *) ROM_DESC_REG_BASE(bank);
+		if (on)
+			*reg |= 0x00800000;
+		else
+			*reg &= 0xFF7FFFFF;
+	}
+}
+
+/*******************************************************************************/
+
+static int __init cx2450xflash_init(void)
+{
+	const char *probes[] = { "cmdlinepart", NULL };
+	int bank;
+	volatile u32 *reg;
+	u32 descreg, mapreg, bwidth;
+	u32 fl_size = 0;
+	u32 fl_start = 0xF0000000;
+	u32 b_start, b_size;
+	u32 b_ws0 = 0;
+	void __iomem *base = NULL;
+	int err = 0;
+
+	printk("CX2450x MTD driver v%s (%s, %s) (c) Coolstream International Ltd.\n", VERSION, __DATE__, __TIME__);
+
+	num_banks = 0;
+	info = kzalloc(sizeof(struct cx2450xflash_info), GFP_KERNEL);
+	if (!info)
+		return -ENOMEM;
+
+	/* we can have more than one Flash chip (theoretical 4 chips), so read the
+	   ISA descriptors, which have to be configured correctly by the bootloader */
+	for (bank = 0; bank < 4; bank++) {
+		reg = (volatile u32 *) ROM_DESC_REG_BASE(bank);
+		descreg = *reg;
+
+		if ((descreg & 0x80000000) == 0) {	/* if bit 31 not set, ROM is present */
+			bwidth = (descreg & 0x00000030) >> 4;	/* bit 5..4 encodes the bus width ( 8 or 16 bit) */
+			if ((bwidth == 1) || (bwidth == 2)) {
+				reg = (volatile u32 *) ROM_MAP_REG_BASE(bank);
+				mapreg = *reg;
+
+				b_start = (mapreg & 0x0FFF0000) + 0xF0000000;
+				b_size = (0x1000 - (mapreg & 0x00000FFF)) * 0x00010000;
+				if ((b_start == fl_start) && (b_size >= 0x00010000)) {
+					fl_size += b_size;
+					fl_start += b_size;
+					if (bank == 0)
+						b_ws0 = bwidth;
+					num_banks++;
+				} else {
+					printk("  Start/Size missmatch [0x%.8X / 0x%.8X]\n", b_start, fl_start);
+					bank = 4;
+				}
+			} else
+				bank = 4;	/* do not allow non continous range */
+		} else
+			bank = 4;	/* do not allow non continous range */
+	}
+	if ((fl_size) && (b_ws0)) {
+		fl_start = 0xF0000000;
+
+		base = ioremap(fl_start, fl_size);
+
+		if (!base) {
+			kfree(info);
+			return -ENOMEM;
+		}
+
+		info->res = request_mem_region(fl_start, fl_size, "cx2450xflash");
+		if (!info->res) {
+			iounmap(base);
+			kfree(info);
+			return -ENOMEM;
+		}
+
+		info->map.size = fl_size;
+		info->map.bankwidth = b_ws0;
+		info->map.phys = fl_start;
+		info->map.virt = base;
+		info->map.name = "cx2450xflash";
+		info->map.set_vpp = cx2450xflash_set_vpp;
+
+		cnxt_map_init(&info->map);
+
+		/* Note: We must enable VPP here manually, because CFI is not doing this for probe.
+		   On the CX2450x device, read's are made in a burst mode with cache. This mode
+		   does not allow writings, so the set_vpp() function switch into write-mode, which
+		   disabled burst and cache, but in fact we can not read in write mode. I.e. data
+		   written as 0x1122334455667788 is read as 0x1122112255665566 in write mode. */
+
+		cx2450xflash_set_vpp(&info->map, 1);
+		info->mtd = do_map_probe("cfi_probe", &info->map);
+		cx2450xflash_set_vpp(&info->map, 0);
+
+		if (!info->mtd) {
+			release_resource(info->res);
+			iounmap(base);
+			kfree(info->res);
+			kfree(info);
+			return -ENXIO;
+		}
+
+		info->mtd->owner = THIS_MODULE;
+
+		err = parse_mtd_partitions(info->mtd, probes, &info->parts, 0);
+		if (err >= 0) {
+			if (err == 0) {
+				printk("  no partitioning via cmdline present. Using defaults.\n");
+				err = add_mtd_partitions(info->mtd, default_partitions, ARRAY_SIZE(default_partitions));
+
+			} else
+				err = add_mtd_partitions(info->mtd, info->parts, err);
+			if (err)
+				printk(KERN_ERR "mtd partition registration failed: %d\n", err);
+		}
+
+		/* If we got an error, free all resources. */
+		if (err < 0) {
+			if (info->mtd) {
+				del_mtd_partitions(info->mtd);
+				map_destroy(info->mtd);
+			}
+			kfree(info->parts);
+			info->parts = NULL;
+
+			release_resource(info->res);
+			iounmap(base);
+			kfree(info->res);
+			info->res = NULL;
+
+			kfree(info);
+			info = NULL;
+		}
+	}
+	return err;
+}
+
+/*******************************************************************************/
+
+static void __exit cx2450xflash_exit(void)
+{
+	if (info) {
+		if (info->mtd) {
+			del_mtd_partitions(info->mtd);
+			map_destroy(info->mtd);
+		}
+		if (info->parts) {
+			kfree(info->parts);
+			info->parts = NULL;
+		}
+
+		iounmap(info->map.virt);
+		release_resource(info->res);
+
+		kfree(info->res);
+		kfree(info);
+	}
+}
+
+/*******************************************************************************/
+
+module_init(cx2450xflash_init);
+module_exit(cx2450xflash_exit);
+
+EXPORT_SYMBOL(cnxt_map_init);
+
+MODULE_AUTHOR("Coolstream International Limited Ltd..");
+MODULE_DESCRIPTION("Conexant CX2450x CFI MTD map driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
index f4182cf..be80056 100644
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -782,6 +782,8 @@ config WD80x3
 	  To compile this driver as a module, choose M here. The module
 	  will be called wd.
 
+source "drivers/net/cnxt_emac/Kconfig"
+
 config ULTRAMCA
 	tristate "SMC Ultra MCA support"
 	depends on NET_VENDOR_SMC && MCA
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index dcbfe84..5e508ba 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -4,6 +4,7 @@
 
 obj-$(CONFIG_E1000) += e1000/
 obj-$(CONFIG_E1000E) += e1000e/
+obj-$(CONFIG_CNXT_EMAC) += cnxt_emac/
 obj-$(CONFIG_IBM_EMAC) += ibm_emac/
 obj-$(CONFIG_IBM_NEW_EMAC) += ibm_newemac/
 obj-$(CONFIG_IGB) += igb/
diff --git a/drivers/net/cnxt_emac/Kconfig b/drivers/net/cnxt_emac/Kconfig
new file mode 100644
index 0000000..96cc3ed
--- /dev/null
+++ b/drivers/net/cnxt_emac/Kconfig
@@ -0,0 +1,79 @@
+if ARCH_NEVIS
+
+config CNXT_EMAC
+	tristate "CNXT 10/100 EMAC Driver Support"
+	depends on NET
+	---help---
+	This driver support CNXT EMAC Driver.Supports 2 EMAC core(EMAC0/EMAC1).
+
+config CNXT_EMAC0_ENABLE
+	bool "Enable EMAC0 interface"
+	depends on CNXT_EMAC
+	default y
+	---help---
+	Enables EMAC0 interface in driver.By default this interface is enabled.
+
+config CNXT_EMAC0_2xMODE_ENABLE
+	bool "Enable OverClocked MII(2xMode)"
+	depends on CNXT_EMAC0_ENABLE
+	default 0
+	---help---
+	Enables EMAC0 interface in 2xMode[OverClocked MII].Resulting in 200Mbps mode.
+
+config EMAC0_MDIO_SUPPORT
+	bool "Support MDIO operation in EMAC0"
+	depends on CNXT_EMAC0_ENABLE
+	default 0
+	---help---
+	Select 1- MDIO support required, 0- MDIO support not required.
+
+config EMAC0_MDIO_ADDRESS
+	hex "EMAC0 MDIO operation address"
+	depends on EMAC0_MDIO_SUPPORT
+	default 0xFFFFFFFF
+	---help---
+	Select MDIO address for EMAC0 interface, Default will be 0xFFFFFFFF
+	(driver will detect MDIO address).
+
+config CNXT_EMAC1_ENABLE
+	bool "Enable EMAC1 interface"
+	depends on CNXT_EMAC
+	default 0
+	---help---
+	Enables EMAC1 interface in driver.
+
+config CNXT_EMAC1_2xMODE_ENABLE
+	bool "Enable OverClocked MII(2xMode)"
+	depends on CNXT_EMAC1_ENABLE
+	default 0
+	---help---
+	Enables EMAC1 interface in 2xMode[OverClocked MII].Resulting in 200Mbps mode.
+
+config EMAC1_MDIO_SUPPORT
+	bool "Support MDIO operation in EMAC1"
+	depends on CNXT_EMAC1_ENABLE
+	default 0
+	---help---
+	Select 1- MDIO support required, 0- MDIO support not required.
+
+config EMAC1_MDIO_ADDRESS
+	hex "EMAC1 MDIO operation address"
+	depends on EMAC1_MDIO_SUPPORT
+	default 0xFFFFFFFF
+	---help---
+	Select MDIO address for EMAC1 interface, Default will be 0xFFFFFFFF
+	(driver will detect MDIO address).
+
+config MII_GPIO_BANK
+	int "MII_GPIO_BANK"
+	default 3
+	help
+	GPIO Bank Number.
+
+config MII_GPIO_BIT
+	int "MII_GPIO_BIT"
+	default 31
+	help
+	GPIO bit number.
+
+endif
diff --git a/drivers/net/cnxt_emac/Makefile b/drivers/net/cnxt_emac/Makefile
new file mode 100644
index 0000000..7c78cd5
--- /dev/null
+++ b/drivers/net/cnxt_emac/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_CNXT_EMAC) += cnxt_emac.o
+cnxt_emac-objs := emac_drv.o emac_prv.o
diff --git a/drivers/net/cnxt_emac/emac.h b/drivers/net/cnxt_emac/emac.h
new file mode 100644
index 0000000..3eb31dc
--- /dev/null
+++ b/drivers/net/cnxt_emac/emac.h
@@ -0,0 +1,186 @@
+/****************************************************************************
+ *
+ *  drivers/net/cnxt_emac/emac.h
+ *
+ *  Copyright (C) 2007 Conexant Systems,Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
+ *
+ */
+/****************************************************************************
+ *$Id$
+ ****************************************************************************/
+
+#ifndef __emac_h__
+#define __emac_h__
+
+#define PECOS_ETH_DEBUG		/* define this Macro to include print statements in emac driver */
+							       /*#define PECOS_ETH_TESTPRINT *//* define this Macro to include print statements in key test points 
+							          of emac driver */
+
+#define EMAC_DRIVER_STATISTICS	/* Enable this macro to provide ioctl and addtional driver 
+				   statistics useful to check complete error conditions, perfromance points */
+
+#define EMAC_MEDIA_MAINTANANCE	/* Enable this macro to enable thread and logic, which 
+				   checks and updates changes in the media */
+#ifdef PECOS_ETH_DEBUG
+#define EMACDBG(_x...) printk(KERN_EMERG _x)
+#else
+#define EMACDBG(_x...)
+#endif
+
+/* ToDo: Remove below macro's later, if buffer descriptor macro's are moved to enet_pecos.h */
+
+/* Tx Control Information Written By the CPU Bit Masks */
+/* Tx Length in this buffer to be Xmitted */
+#define ENET_TX_CTL_INFO_CPU_TX_LEN (0x000007FF)
+/* First Tx buffer in the packet */
+#define ENET_TX_CTL_INFO_CPU_FIRST  (0x00010000)
+/* Last Tx buffer in the packet */
+#define ENET_TX_CTL_INFO_CPU_LAST   (0x00020000)
+ /* Add the CRC tp the pkt */
+#define ENET_TX_CTL_INFO_CPU_ADDCRC (0x00040000)
+/* CPU/EMAC Ownership of buffer */
+#define ENET_TX_CTL_INFO_CPU_OWN    (0x80000000)
+
+/* Tx Control Information Written By the EMAC Bit Masks */
+/* Tx Length in this buffer to be Xmitted */
+#define ENET_TX_CTL_INFO_TX_LEN     (0x000007FF)
+/* First Tx buffer in the packet */
+#define ENET_TX_CTL_INFO_FIRST      (0x00010000)
+/* Last Tx buffer in the packet */
+#define ENET_TX_CTL_INFO_LAST       (0x00020000)
+/* Add the CRC to the pkt that is transmitted */
+#define ENET_TX_CTL_INFO_ADDCRC     (0x00040000)
+/* Carrier Lost during xmission */
+#define ENET_TX_CTL_INFO_CARR_LOSS  (0x00200000)
+/* xmission deferred due to traffic */
+#define ENET_TX_CTL_INFO_DEFER      (0x00400000)
+/* pkt dropped after 16 retries */
+#define ENET_TX_CTL_INFO_DROPPED    (0x00800000)
+/* Retry count for Tx */
+#define ENET_TX_CTL_INFO_RETRY      (0x0F000000)
+#define ENET_TX_CTL_INFO_RETRY_SHIFT 24
+/* Late Collision */
+#define ENET_TX_CTL_INFO_LATE_COLL  (0x10000000)
+/* Data not available on time */
+#define ENET_TX_CTL_INFO_UFLO       (0x20000000)
+/* Buffer error - bad FIRST and LAST */
+#define ENET_TX_CTL_INFO_BUFF       (0x40000000)
+/* CPU/EMAC Ownership of buffer */
+#define ENET_TX_CTL_INFO_OWN        (0x80000000)
+
+/* Pointer To Tx Buffer Bit Mask */
+/* Physical address of the start of the buffer of data */
+#define ENET_TX_BUFFER_PTR          (0xFFFFFFFF)
+
+/* Rx Control Information Written By the EMAC Bit Masks */
+/* Rx Length in this buffer to be Xmitted */
+#define ENET_RX_CTL_INFO_RX_LEN     (0x000007FF)
+/* First Rx buffer in the packet */
+#define ENET_RX_CTL_INFO_FIRST      (0x00010000)
+/* Last Rx buffer in the packet */
+#define ENET_RX_CTL_INFO_LAST       (0x00020000)
+/* buffer error in the packet */
+#define ENET_RX_CTL_INFO_BUFF_ERROR (0x40000000)
+/* Last Rx buffer in the packet */
+#define ENET_RX_CTL_INFO_OWN        (0x80000000)
+
+/* Rx Control Information Written By the CPU Bit Masks */
+/* Rx Length in this buffer to be Xmitted */
+#define ENET_RX_CTL_INFO_CPU_RX_LEN (0x000007FF)
+/* First Rx buffer in the packet */
+#define ENET_RX_CTL_INFO_CPU_FIRST  (0x00010000)
+/* Last Rx buffer in the packet */
+#define ENET_RX_CTL_INFO_CPU_LAST   (0x00020000)
+/* CPU/VMAC Ownership of buffer */
+#define ENET_RX_CTL_INFO_CPU_OWN    (0x80000000)
+
+/* Pointer To Rx Buffer Bit Mask */
+/* Physical address of the start of the buffer of data */
+#define ENET_RX_BUFFER_PTR          (0xFFFFFFFF)
+
+
+/* Macro for maximum PHY ID supported */
+#define PHY_ADDR_MAX 0x20
+
+/*PHY Register definations*/
+/* Control register bit definitions */
+#define PHY_CTRL_RESET         0x8000
+#define PHY_CTRL_LOOPBACK      0x4000
+#define PHY_CTRL_SPEED         0x2000
+#define PHY_CTRL_AUTONEG       0x1000
+#define PHY_CTRL_POWERDOWN     0x0800
+#define PHY_CTRL_ISOLATE       0x0400
+#define PHY_CTRL_DUPLEX        0x0100
+#define PHY_CTRL_RESTART_AUTO  0x0200
+#define PHY_CTRL_COLL          0x0080
+
+/* Status register bit definitions */
+#define PHY_STATUS_COMPLETE     0x20
+#define PHY_STATUS_AUTONEG_ABLE 0x04
+#define PHY_STATUS_100BASE_T4                  0x8000
+#define PHY_STATUS_100BASEX_FULLDUPLEX         0x4000
+#define PHY_STATUS_100BASEX_HALFDUPLEX         0x2000
+#define PHY_STATUS_10MBPS_FULLDUPLEX           0x1000
+#define PHY_STATUS_10MBPS_HALFDUPLEX           0x800
+#define PHY_STATUS_MF_PREAMBLE_SUPRESSION      0x40
+#define PHY_STATUS_AUTONEGOTIATION_COMPLETE    0x20
+#define PHY_STATUS_REMOTE_FAULT                0x10
+#define PHY_STATUS_AUTONEGOTIATION_ABILITY     0x8
+#define PHY_STATUS_LINK_STATUS                 0x4
+#define PHY_STATUS_JABBER_DETECT               0x2
+#define PHY_STATUS_EXTENDED_CAPABILITY         0x1
+
+
+/* Auto-negatiation advertisement register bit definitions */
+#define PHY_AUTONEG_ADV_100BTX_FULL     0x100
+#define PHY_AUTONEG_ADV_100BTX          0x80
+#define PHY_AUTONEG_ADV_10BTX_FULL      0x40
+#define PHY_AUTONEG_ADV_10BT            0x20
+#define AUTONEG_ADV_IEEE_8023           0x1
+
+/* Auto-negatiation Link register bit definitions */
+#define PHY_AUTONEG_LINK_100BTX_FULL     0x100
+#define PHY_AUTONEG_LINK_100BTX          0x80
+#define PHY_AUTONEG_LINK_10BTX_FULL      0x40
+
+/* PHY Registers */
+#define PHY_CTRL_REG               0x00
+#define PHY_STATUS_REG             0x01
+#define PHY_IDENTIFIER_REG1        0x02
+#define PHY_IDENTIFIER_REG2        0x03
+#define PHY_AUTONEG_ADV_REG        0x4
+#define PHY_AUTONEG_LINK_REG       0x5
+#define PHY_MIRROR_REG             0x10
+
+#define PHY_REG_MASK          0x1F
+#define PHY_ADDR_MASK         0x1F
+
+/* Specific to PHY's */
+#define REALTEK8201_MEDIACHEK_REG  0x00	/* RealTek PHY speed/duplex check register */
+#define REALTEK8201_PHY_SPEED      0x2000	/* RealTek PHY speed check bit */
+#define REALTEK8201_PHY_MODE       0x0100	/* RealTek PHY mode check bit */
+
+
+#define LXT972_MEDIACHEK_REG       0x11	/* LXT972 PHY speed/duplex check register */
+#define LXT972_PHY_SPEED           0x4000	/* LXT972 PHY speed check bit */
+#define LXT972_PHY_MODE            0x200	/* LXT972 PHY mode check bit */
+#endif
+
+/****************************************************************************
+ * Modifications:
+ * $Log$
+ *
+ ****************************************************************************/
diff --git a/drivers/net/cnxt_emac/emac_drv.c b/drivers/net/cnxt_emac/emac_drv.c
new file mode 100644
index 0000000..ad70d37
--- /dev/null
+++ b/drivers/net/cnxt_emac/emac_drv.c
@@ -0,0 +1,737 @@
+/****************************************************************************
+ *
+ *  drivers/net/cnxt_emac/emac_drv.c
+ *
+ *  Copyright (C) 2007 Conexant Systems,Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
+ *
+ */
+/****************************************************************************
+ *$Id: emac_drv.c,v 1.2, 2007-08-03 09:19:05Z, Upakul Barkakaty$
+ ****************************************************************************/
+
+#include <linux/autoconf.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/moduleparam.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>	/* printk() */
+#include <linux/slab.h>		/* kmalloc() */
+#include <linux/errno.h>	/* error codes */
+#include <linux/types.h>	/* size_t */
+#include <linux/interrupt.h>	/* mark_bh */
+#include <linux/in.h>
+#include <linux/netdevice.h>	/* struct device, and other headers */
+#include <linux/etherdevice.h>	/* eth_type_trans */
+#include <linux/skbuff.h>
+#include <linux/dma-mapping.h>
+#include <linux/delay.h>
+#include <linux/fcntl.h>
+#include <linux/ptrace.h>
+#include <linux/ioport.h>
+#include <linux/string.h>
+#include <linux/spinlock.h>
+#include <linux/if.h>
+#include <linux/mii.h>
+#include <linux/ethtool.h>
+
+#include "asm/arch/cx2450x.h"	/* file to get register definitions */
+#include "emac.h"
+#include "emac_prv.h"
+
+MODULE_AUTHOR("Conexant Systems, Inc.");
+MODULE_DESCRIPTION("CNXT Pecos ethernet driver");
+MODULE_LICENSE("GPL");
+
+#define DRV_NAME  "CNXT_EMAC"
+#define VER_INFO  "V 1.0"
+#define FRM_VER   "Firmware V 1.0"
+#define BUS_INFO  "BVCI Interface"
+
+/* Linux net_device structure representing an ethernet interface*/
+struct net_device *gNetDevice[MAX_EMAC];
+/* Linux device statistics structure*/
+struct net_device_stats gNetDevStats[MAX_EMAC];
+#ifdef EMAC_MEDIA_MAINTANANCE
+/* There is only one thread to manage, so no need to duplicate these */
+struct completion gThreadExitComplete;
+volatile int gThreadExitReq;
+#endif
+
+static int emacdev_ethtool_ioctl(struct net_device *dev, struct ifreq *ifr);
+
+/* Function provides interface/device number based on passed network device */
+static int get_deviceno(struct net_device *dev, int *deviceNo)
+{
+	int retVal = -ENODEV;
+	int devNo;
+
+	*deviceNo = 0;
+	for (devNo = 0; devNo < MAX_EMAC; devNo++) {
+		if (dev == gNetDevice[devNo]) {
+			*deviceNo = devNo;
+			retVal = 0;
+			break;
+		}
+	}
+
+	return retVal;
+}
+
+
+/* Initialise and start the EMAC for operation*/
+int emacdev_open(struct net_device *dev)
+{
+	int retVal, deviceNo;
+	int retValAPI;
+
+	/* Get the interface number */
+	retVal = get_deviceno(dev, &deviceNo);
+	if (0 == retVal) {
+		retValAPI = emac_open(deviceNo, dev);
+		if (0 == retValAPI) {
+			netif_start_queue(dev);
+		} else {
+			retVal = 1;
+		}
+	} else {
+		EMACDBG("Error : Can not Open Emac %d\n", retVal);
+	}
+
+	return retVal;
+}
+
+/* Stop EMAC operation */
+int emacdev_stop(struct net_device *dev)
+{
+	int retVal;
+
+	/* stop the device */
+	if (netif_device_present(dev)) {
+		netif_stop_queue(dev);
+	}
+	retVal = emac_close(dev);
+
+	return retVal;
+}
+
+/* Registered Transmit function. Traverse through the TX buffer descriptor 
+ * table. If OWN bit of the INFO field is 0 then put the buffer in the 
+ * descriptor and inform  EMAC to start the packet transmission immediately
+ */
+int emacdev_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	int retVal;
+
+	retVal = emac_start_transmit(dev, (void *) skb, skb->len);
+
+	return retVal;
+}
+
+/* Return the device statistics.. ex. tx_packets, rx_packets, rx_errors, 
+ * rx_dropped etc...All these are fields in struct net_device_stats
+ */
+struct net_device_stats *emacdev_get_stats(struct net_device *dev)
+{
+	int retVal;
+	int deviceNo;
+	EMAC_STATS emacStats;
+
+	retVal = get_deviceno(dev, &deviceNo);
+	if(retVal < 0) {
+		return NULL;
+	}
+
+	retVal = emac_get_device_statistics(dev, &emacStats);
+	if(retVal < 0) {
+		return NULL;
+	}
+
+	gNetDevStats[deviceNo].rx_packets = emacStats.uRxPktCnt;	/* total packets received       */
+	gNetDevStats[deviceNo].tx_packets = emacStats.uTxPktCnt;	/* total packets transmitted    */
+	gNetDevStats[deviceNo].rx_bytes = emacStats.uRxByteCnt;	/* total bytes received         */
+	gNetDevStats[deviceNo].tx_bytes = emacStats.uTxByteCnt;	/* total bytes transmitted      */
+	gNetDevStats[deviceNo].rx_errors = emacStats.uRxCRCErrDropCnt + emacStats.uRxFrameErrDropCnt + emacStats.uBDMissPktCnt + emacStats.uRxFifoOverflowDropCnt;	/* bad packets received         */
+	gNetDevStats[deviceNo].tx_errors = emacStats.uTxUnderflowErrCnt + emacStats.uTxDropCnt + emacStats.uTxLateCollisionDropCnt + emacStats.uTxChainingErrCnt + emacStats.uTxCarrLossCnt;
+	/* packet transmit problems     */
+	gNetDevStats[deviceNo].tx_dropped = 0;	/* no space available in linux  */
+	gNetDevStats[deviceNo].rx_dropped = 0;	/* no space in linux buffers    */
+	gNetDevStats[deviceNo].multicast = emacStats.uRxMulticastPktCnt;	/* multicast packets received   */
+	gNetDevStats[deviceNo].collisions = emacStats.uTxLateCollisionDropCnt;
+	gNetDevStats[deviceNo].rx_length_errors = emacStats.uRxShortPktErrCnt + emacStats.uRxLongPktErrCnt;
+	gNetDevStats[deviceNo].rx_over_errors = 0;	/* receiver ring buff overflow  *//* ToDo: check emacStats.uBDMissPktCnt */
+	gNetDevStats[deviceNo].rx_crc_errors = emacStats.uRxCRCErrDropCnt;	/* recved pkt with crc error    */
+	gNetDevStats[deviceNo].rx_frame_errors = emacStats.uRxFrameErrDropCnt;	/* recv'd frame alignment error */
+	gNetDevStats[deviceNo].rx_fifo_errors = emacStats.uRxFifoOverflowDropCnt;	/* recv'r fifo overrun          */
+	gNetDevStats[deviceNo].rx_missed_errors = emacStats.uBDMissPktCnt;	/* receiver missed packet       */
+	gNetDevStats[deviceNo].tx_aborted_errors = 0;
+	gNetDevStats[deviceNo].tx_carrier_errors = emacStats.uTxCarrLossCnt;
+	gNetDevStats[deviceNo].tx_fifo_errors = emacStats.uTxUnderflowErrCnt;
+	gNetDevStats[deviceNo].tx_heartbeat_errors = 0;
+	gNetDevStats[deviceNo].tx_window_errors = 0;
+	gNetDevStats[deviceNo].rx_compressed = 0;
+	gNetDevStats[deviceNo].tx_compressed = 0;
+
+	return (&gNetDevStats[deviceNo]);
+}
+
+/* Set the logical filtering */
+void emacdev_set_multicast_list(struct net_device *dev)
+{
+	emac_set_multicast_list(dev);
+}
+
+
+/* Called by networking subsystem when a packet transmission fails to complete
+ * within a reasonable period (value set earlier), on the assumtion that an 
+ * interrupt has been missed or the interface has locked up. This function will
+ * handle the problem and resume packet transmission It also will gather the 
+ * error statistics.
+ */
+void emacdev_tx_timeout(struct net_device *dev)
+{
+	EMAC_DEVICE *pEmacDevice;
+
+	pEmacDevice = (EMAC_DEVICE *) netdev_priv(dev);
+	EMACDBG("%s: transmit timed out?\n", dev->name);
+	/* Reset transmit activity */
+	emac_set_transmit_activity(dev, 0);
+	/* If MDIO operation supported */
+	if (pEmacDevice->uMDIO_support) {
+		/* restart transceiver */
+		phy_reset(dev);
+	}
+	/* Set transmit activity */
+	emac_set_transmit_activity(dev, 1);
+	/* logic to error state increments */
+	pEmacDevice->Stats.uTxDropCnt++;
+	/* Try to restart the adaptor. */
+	netif_wake_queue(dev);
+}
+
+/* Perform interface specific ioctl commands*/
+int emacdev_do_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+{
+	EMAC_DEVICE *pEmacDevice;
+	int retVal = 0;
+	struct mii_ioctl_data *data = if_mii(ifr);
+
+	pEmacDevice = (EMAC_DEVICE *) netdev_priv(dev);
+
+	/* All operation carried over MDIO interface, check it is supported */
+	if (!(pEmacDevice->uMDIO_support)) {
+		return -EOPNOTSUPP;
+	}
+
+	spin_lock(&pEmacDevice->lock);	/* Preempt protection */
+	switch (cmd) {
+	case SIOCETHTOOL:
+		retVal = emacdev_ethtool_ioctl(dev, ifr);
+		break;
+
+	case SIOCGMIIPHY:	/* Get PHY address */
+		data->phy_id = pEmacDevice->mii_if.phy_id;
+		break;
+
+	case SIOCGMIIREG:	/* Read MII register */
+		data->val_out = pEmacDevice->mii_if.mdio_read(dev, data->phy_id, data->reg_num);
+		break;
+
+	case SIOCSMIIREG:	/* Write MII register */
+		pEmacDevice->mii_if.mdio_write(dev, data->phy_id, data->reg_num, data->val_in);
+		break;
+#ifdef EMAC_DRIVER_STATISTICS
+	case EMAC_STATISTICS_DISPLAY:
+		emac_stats_display(dev);
+		break;
+	case EMAC_STATISTICS_CLEAR:
+		emac_stats_clear(dev);
+		break;
+#endif
+
+	default:
+		retVal = -EINVAL;
+		break;
+	}
+	spin_unlock(&pEmacDevice->lock);
+
+	return retVal;
+}
+
+
+static int emacdev_ethtool_ioctl(struct net_device *dev, struct ifreq *ifr)
+{
+	struct ethtool_cmd ecmd;
+	EMAC_DEVICE *pEmacDevice;
+#ifdef PECOS_ETH_TESTPRINT
+	unsigned long tmpVal;
+#endif
+
+	pEmacDevice = (EMAC_DEVICE *) netdev_priv(dev);
+
+	if (copy_from_user(&ecmd, ifr->ifr_data, sizeof(ecmd))) {
+		return -EFAULT;
+	}
+#ifdef PECOS_ETH_TESTPRINT
+	EMACDBG("start: cmd = %u, supported = %x, adv = %x, speed = %u, duplex = %u \n", ecmd.cmd, ecmd.supported, ecmd.advertising, ecmd.speed, ecmd.duplex);
+	EMACDBG("port = %u, phy_add = %x, transceiver = %x, autoneg = %u, maxtx = %x, maxrx = %x\n", ecmd.port, ecmd.phy_address, ecmd.transceiver, ecmd.autoneg, ecmd.maxtxpkt, ecmd.maxrxpkt);
+	tmpVal = EmacReadReg_PHY(dev, pEmacDevice->mii_if.phy_id, PHY_CTRL_REG);
+	EMACDBG("PHY_CTRL_REG = %08x\n", tmpVal);
+	tmpVal = EmacReadReg_PHY(dev, pEmacDevice->mii_if.phy_id, PHY_STATUS_REG);
+	EMACDBG("PHY_STATUS_REG = %08x\n", tmpVal);
+	tmpVal = EmacReadReg_PHY(dev, pEmacDevice->mii_if.phy_id, PHY_IDENTIFIER_REG1);
+	EMACDBG("PHY_IDENTIFIER_REG1 = %08x\n", tmpVal);
+	tmpVal = EmacReadReg_PHY(dev, pEmacDevice->mii_if.phy_id, PHY_IDENTIFIER_REG2);
+	EMACDBG("PHY_IDENTIFIER_REG2 = %08x\n", tmpVal);
+	tmpVal = EmacReadReg_PHY(dev, pEmacDevice->mii_if.phy_id, PHY_AUTONEG_ADV_REG);
+	EMACDBG("PHY_AUTONEG_ADV_REG = %08x\n", tmpVal);
+	tmpVal = EmacReadReg_PHY(dev, pEmacDevice->mii_if.phy_id, PHY_AUTONEG_LINK_REG);
+	EMACDBG("PHY_AUTONEG_LINK_REG = %08x\n", tmpVal);
+#endif
+
+	if ((!netif_running(dev))) {
+		return -EINVAL;
+	}
+
+	/* spin_lock_irq(&pEmacDevice->lock); */
+	switch (ecmd.cmd) {
+	case ETHTOOL_GSET:
+		{
+			memset((void *) &ecmd, 0, sizeof(ecmd));
+			/* MII port, Can be connected to twisted pair as well SUPPORTED_TP */
+			ecmd.supported = SUPPORTED_Autoneg | SUPPORTED_MII | SUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full | SUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full;
+			ecmd.port = PORT_MII;	/* MII port */
+			ecmd.transceiver = XCVR_EXTERNAL;
+			ecmd.phy_address = pEmacDevice->mii_if.phy_id;
+			ecmd.speed = pEmacDevice->uSpeed;
+			ecmd.duplex = pEmacDevice->uMode;
+			ecmd.advertising = ADVERTISED_MII;
+
+			/* Interface running in auto negotiation */
+			if (pEmacDevice->uAutoneg_enable) {
+				/* Update the advartised capability */
+				if ((pEmacDevice->uCurrent_speed_select == AUTO_SPEED) && (pEmacDevice->uCurrent_duplex_select == AUTO_DUPLEX)) {
+					ecmd.advertising |= ADVERTISED_Autoneg | ADVERTISED_10baseT_Half | ADVERTISED_10baseT_Full | ADVERTISED_100baseT_Half | ADVERTISED_100baseT_Full;
+				} else {
+					ecmd.advertising |= ADVERTISED_10baseT_Half | ADVERTISED_10baseT_Full | ADVERTISED_100baseT_Half | ADVERTISED_100baseT_Full;
+					if (pEmacDevice->uCurrent_speed_select == SPEED_10MBPS) {
+						ecmd.advertising &= ~(ADVERTISED_100baseT_Half | ADVERTISED_100baseT_Full);
+					} else if (pEmacDevice->uCurrent_speed_select == SPEED_100MBPS) {
+						ecmd.advertising &= ~(ADVERTISED_10baseT_Half | ADVERTISED_10baseT_Full);
+					}
+					if (pEmacDevice->uCurrent_duplex_select == HALF_DUPLEX) {
+						ecmd.advertising &= ~(ADVERTISED_10baseT_Full | ADVERTISED_100baseT_Full);
+					} else if (pEmacDevice->uCurrent_duplex_select == FULL_DUPLEX) {
+						ecmd.advertising &= ~(ADVERTISED_10baseT_Half | ADVERTISED_100baseT_Half);
+					}
+				}
+				/* Interface running in auto negotiation */
+				ecmd.autoneg = AUTONEG_ENABLE;
+			} else {
+				/* Interface not running in auto negotiation because either not supports / disabled */
+				ecmd.autoneg = AUTONEG_DISABLE;
+			}
+			if (copy_to_user(ifr->ifr_data, &ecmd, sizeof(ecmd))) {
+				return -EFAULT;
+			}
+		}
+		break;
+
+	case ETHTOOL_SSET:
+		{
+			if (!capable(CAP_NET_ADMIN)) {
+				return -EPERM;
+			}
+			if (ecmd.autoneg == AUTONEG_ENABLE) {
+				if (ecmd.advertising & (ADVERTISED_100baseT_Half | ADVERTISED_100baseT_Full)) {
+					pEmacDevice->uCurrent_speed_select = SPEED_100MBPS;
+				} else if (ecmd.advertising & (ADVERTISED_10baseT_Half | ADVERTISED_10baseT_Full)) {
+					pEmacDevice->uCurrent_speed_select = SPEED_10MBPS;
+				}
+
+				if ((pEmacDevice->uCurrent_speed_select == SPEED_100MBPS) & (ecmd.advertising & (ADVERTISED_10baseT_Half | ADVERTISED_10baseT_Full))) {
+					pEmacDevice->uCurrent_speed_select = AUTO_SPEED;
+				}
+				if (ecmd.advertising & (ADVERTISED_10baseT_Full | ADVERTISED_100baseT_Full)) {
+					pEmacDevice->uCurrent_duplex_select = FULL_DUPLEX;
+				} else if (ecmd.advertising & (ADVERTISED_10baseT_Half | ADVERTISED_100baseT_Half)) {
+					pEmacDevice->uCurrent_duplex_select = HALF_DUPLEX;
+				}
+				if ((pEmacDevice->uCurrent_duplex_select == FULL_DUPLEX) & (ecmd.advertising & (ADVERTISED_10baseT_Half | ADVERTISED_100baseT_Half))) {
+					pEmacDevice->uCurrent_speed_select = AUTO_DUPLEX;
+				}
+				emac_media_autonegotiate(dev);
+				pEmacDevice->uAutoneg_enable = 1;
+			} else {
+				emac_media_force(dev, ecmd.speed, ecmd.duplex);
+				pEmacDevice->uAutoneg_enable = 0;
+			}
+		}
+		break;
+
+	case ETHTOOL_GDRVINFO:	/* Provides the driver information */
+		{
+			struct ethtool_drvinfo info;
+			memset((void *) &info, 0, sizeof(info));
+			strncpy(info.driver, DRV_NAME, sizeof(info.driver) - 1);
+			strncpy(info.version, VER_INFO, sizeof(info.version) - 1);
+			strncpy(info.fw_version, FRM_VER, sizeof(info.fw_version) - 1);
+			strncpy(info.bus_info, BUS_INFO, sizeof(info.bus_info) - 1);
+			info.regdump_len = 0;
+			info.eedump_len = 0;
+			info.testinfo_len = 0;
+			if (copy_to_user(ifr->ifr_data, &info, sizeof(info))) {
+				return -EFAULT;
+			}
+		}
+		break;
+
+	case ETHTOOL_NWAY_RST:
+		{
+			if (phy_autonegotiation_supported(dev)) {
+				pEmacDevice->uCurrent_speed_select = AUTO_SPEED;
+				pEmacDevice->uCurrent_duplex_select = AUTO_DUPLEX;
+				emac_media_autonegotiate(dev);
+				pEmacDevice->uAutoneg_enable = 1;
+			} else {
+				return -EOPNOTSUPP;
+			}
+		}
+		break;
+
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	/* spin_unlock_irq(&pEmacDevice->lock); */
+
+#ifdef PECOS_ETH_TESTPRINT
+	EMACDBG("end: cmd = %u, supported = %x, adv = %x, speed = %u, duplex = %u \n", ecmd.cmd, ecmd.supported, ecmd.advertising, ecmd.speed, ecmd.duplex);
+	EMACDBG("port = %u, phy_add = %x, transceiver = %x, autoneg = %u, maxtx = %x, maxrx = %x\n", ecmd.port, ecmd.phy_address, ecmd.transceiver, ecmd.autoneg, ecmd.maxtxpkt, ecmd.maxrxpkt);
+	tmpVal = EmacReadReg_PHY(dev, pEmacDevice->mii_if.phy_id, PHY_CTRL_REG);
+	EMACDBG("PHY_CTRL_REG = %08x\n", tmpVal);
+	tmpVal = EmacReadReg_PHY(dev, pEmacDevice->mii_if.phy_id, PHY_STATUS_REG);
+	EMACDBG("PHY_STATUS_REG = %08x\n", tmpVal);
+	tmpVal = EmacReadReg_PHY(dev, pEmacDevice->mii_if.phy_id, PHY_IDENTIFIER_REG1);
+	EMACDBG("PHY_IDENTIFIER_REG1 = %08x\n", tmpVal);
+	tmpVal = EmacReadReg_PHY(dev, pEmacDevice->mii_if.phy_id, PHY_IDENTIFIER_REG2);
+	EMACDBG("PHY_IDENTIFIER_REG2 = %08x\n", tmpVal);
+	tmpVal = EmacReadReg_PHY(dev, pEmacDevice->mii_if.phy_id, PHY_AUTONEG_ADV_REG);
+	EMACDBG("PHY_AUTONEG_ADV_REG = %08x\n", tmpVal);
+	tmpVal = EmacReadReg_PHY(dev, pEmacDevice->mii_if.phy_id, PHY_AUTONEG_LINK_REG);
+	EMACDBG("PHY_AUTONEG_LINK_REG = %08x\n", tmpVal);
+#endif
+
+	return 0;
+}
+
+/* Changes the interface configuration like I/O address, intterrupt number etc. 
+ * at runtime.
+ */
+int emacdev_set_config(struct net_device *dev, struct ifmap *map)
+{
+	int retVal = 0;
+	EMAC_DEVICE *pEmacDevice;
+
+	pEmacDevice = (EMAC_DEVICE *) netdev_priv(dev);
+	if (!netif_running(dev)) {
+		return -EINVAL;
+	}
+
+	if (!(pEmacDevice->uMDIO_support)) {
+		return -EOPNOTSUPP;
+	}
+
+	spin_lock(&pEmacDevice->lock);	/* Preempt protection */
+
+	switch (map->port) {
+	case IF_PORT_UNKNOWN:
+		/* Use autoneg */
+		pEmacDevice->uCurrent_speed_select = AUTO_SPEED;
+		pEmacDevice->uCurrent_duplex_select = AUTO_DUPLEX;
+		emac_media_autonegotiate(dev);
+		pEmacDevice->uAutoneg_enable = 1;
+		break;
+
+	case IF_PORT_10BASET:
+		pEmacDevice->uCurrent_speed_select = SPEED_10MBPS;
+		pEmacDevice->uCurrent_duplex_select = AUTO_DUPLEX;
+		emac_media_autonegotiate(dev);
+		pEmacDevice->uAutoneg_enable = 1;
+		break;
+
+	case IF_PORT_100BASET:
+	case IF_PORT_100BASETX:
+		pEmacDevice->uCurrent_speed_select = SPEED_100MBPS;
+		pEmacDevice->uCurrent_duplex_select = AUTO_DUPLEX;
+		emac_media_autonegotiate(dev);
+		pEmacDevice->uAutoneg_enable = 1;
+		break;
+
+	case IF_PORT_100BASEFX:
+	case IF_PORT_10BASE2:
+	case IF_PORT_AUI:
+		retVal = -EOPNOTSUPP;	/* EOPNOTSUPP */
+		break;
+
+	default:
+		EMACDBG("%s: Invalid media selected\n", dev->name);
+		retVal = -EOPNOTSUPP;	/* EOPNOTSUPP */
+		break;
+	}
+
+	spin_unlock(&pEmacDevice->lock);
+
+	return retVal;
+}
+
+void init_netdevice(struct net_device *dev)
+{
+	dev->watchdog_timeo = 2 * HZ;
+	if (dev->dma == 0) {
+		dev->base_addr = EMAC0_BASE;
+		dev->irq = IRQ_EMAC0;
+
+		return;
+	}
+
+	dev->base_addr	= EMAC1_BASE;
+	dev->irq	= IRQ_EMAC1;
+
+	return;
+}
+
+void Initialize_private(EMAC_DEVICE * pEmacDevice)
+{
+	/* Initialize speed indicator stuff. */
+	pEmacDevice->uCurrent_speed_select = AUTO_SPEED;	/* Auto negotiation mode */
+	pEmacDevice->uCurrent_duplex_select = AUTO_DUPLEX;	/* Auto negotiation mode */
+	pEmacDevice->uMaxTxQDepth = MAX_TRANSMIT_QUEUE_LEN;
+	pEmacDevice->puDescriptorBase = NULL;
+	/* Initialize mii interface */
+	pEmacDevice->uMDIO_support = 0;
+	pEmacDevice->mii_if.mdio_read = NULL;	/* PHY read function */
+	pEmacDevice->mii_if.mdio_write = NULL;	/* PHY write function */
+	pEmacDevice->mii_if.dev = NULL;
+	pEmacDevice->mii_if.phy_id_mask = PHY_ADDR_MASK;
+	pEmacDevice->mii_if.reg_num_mask = PHY_REG_MASK;
+	pEmacDevice->mii_if.phy_id = 0xFFFFFFFF;	/* Not valid PHY Id for this port */
+
+	if (pEmacDevice->hNetDev->dma == 0) {
+		pEmacDevice->uInterfaceNo = 0;
+		pEmacDevice->uBaseAddress = EMAC0_BASE;
+		pEmacDevice->iIrq = IRQ_EMAC0;
+		pEmacDevice->uSpeed = EMAC0_DEFAULT_SPEED;	/* set default speed */
+		pEmacDevice->uMode = EMAC0_DEFAULT_MODE;	/* set default mode */
+		pEmacDevice->uTxDescCount = EMAC0_TX_DESCRIPTOR_CNT;
+		pEmacDevice->uRxDescCount = EMAC0_RX_DESCRIPTOR_CNT;
+		pEmacDevice->uMulticastEnable = EMAC0_DEFAULT_MULTICAST;
+		pEmacDevice->uPromiscousEnable = EMAC0_DEFAULT_PROMISCOUS;
+#ifdef CONFIG_EMAC0_MDIO_SUPPORT
+		pEmacDevice->uMDIO_support = 1;
+		pEmacDevice->mii_if.phy_id = CONFIG_EMAC0_MDIO_ADDRESS;	/* PHY Id for this port */
+		pEmacDevice->mii_if.mdio_read = EmacReadReg_PHY;	/* PHY read function */
+		pEmacDevice->mii_if.mdio_write = EmacWriteReg_PHY;	/* PHY write function */
+		pEmacDevice->mii_if.dev = pEmacDevice->hNetDev;
+#endif
+	} else {
+		pEmacDevice->uInterfaceNo = 1;
+		pEmacDevice->uBaseAddress = EMAC1_BASE;
+		pEmacDevice->iIrq = IRQ_EMAC1;
+		pEmacDevice->uSpeed = EMAC1_DEFAULT_SPEED;	/* set default speed */
+		pEmacDevice->uMode = EMAC1_DEFAULT_MODE;	/* set default mode */
+		pEmacDevice->uTxDescCount = EMAC1_TX_DESCRIPTOR_CNT;
+		pEmacDevice->uRxDescCount = EMAC1_RX_DESCRIPTOR_CNT;
+		pEmacDevice->uMulticastEnable = EMAC1_DEFAULT_MULTICAST;
+		pEmacDevice->uPromiscousEnable = EMAC1_DEFAULT_PROMISCOUS;
+#ifdef CONFIG_EMAC1_MDIO_SUPPORT
+		pEmacDevice->uMDIO_support = 1;
+		pEmacDevice->mii_if.phy_id = CONFIG_EMAC1_MDIO_ADDRESS;	/* PHY Id for this port */
+		pEmacDevice->mii_if.mdio_read = EmacReadReg_PHY;	/* PHY read function */
+		pEmacDevice->mii_if.mdio_write = EmacWriteReg_PHY;	/* PHY write function */
+		pEmacDevice->mii_if.dev = pEmacDevice->hNetDev;
+#endif
+	}
+	/* Set the MAC address in private structure */
+	Get_mac_Address(pEmacDevice->mac, pEmacDevice->uInterfaceNo, MAC_ADDR_LEN);
+
+	spin_lock_init(&pEmacDevice->lock);
+	init_MUTEX(&pEmacDevice->mutex);
+}
+static int emacdev_init(struct net_device *dev)
+{
+	EMACDBG("Inside emacdev_init function\n");
+	dev->open = emacdev_open;
+	dev->stop = emacdev_stop;
+	dev->set_config = emacdev_set_config;
+	dev->hard_start_xmit = emacdev_hard_start_xmit;
+	dev->do_ioctl = emacdev_do_ioctl;
+	dev->get_stats = emacdev_get_stats;
+	dev->tx_timeout = emacdev_tx_timeout;
+	dev->set_multicast_list = emacdev_set_multicast_list;
+
+	Get_mac_Address(dev->dev_addr, dev->dma, MAC_ADDR_LEN);
+	dev->addr_len = MAC_ADDR_LEN;
+
+	return 0;
+}
+void check_autonegotiation(struct net_device *dev)
+{
+	EMAC_DEVICE *pEmacDevice;
+
+	pEmacDevice = (EMAC_DEVICE *) netdev_priv(dev);
+
+
+	if (phy_autonegotiation_supported(dev)) {
+		pEmacDevice->uCurrent_speed_select = AUTO_SPEED;
+		pEmacDevice->uCurrent_duplex_select = AUTO_DUPLEX;
+		emac_media_autonegotiate(dev);
+		pEmacDevice->uAutoneg_enable = 1;
+	} else {
+		pEmacDevice->uAutoneg_enable = 0;
+		emac_media_force(dev, pEmacDevice->uMode, pEmacDevice->uSpeed);
+	}
+
+}
+static int __init emacdev_load(void)
+{
+	int devNo, retVal = 1;
+#ifdef EMAC_MEDIA_MAINTANANCE
+	int threadID;
+#endif
+	EMAC_DEVICE *pEmacDevice;
+
+	EMACDBG("Inside emacdev_load function\n");
+#ifdef CONFIG_CNXT_EMAC0_ENABLE
+#ifdef CONFIG_CNXT_EMAC1_ENABLE
+	for (devNo = 0; devNo < MAX_EMAC; devNo++)
+#else
+	for (devNo = 0; devNo < (MAX_EMAC - 1); devNo++)
+#endif
+#else
+#ifdef CONFIG_CNXT_EMAC1_ENABLE
+	for (devNo = 1; devNo < MAX_EMAC; devNo++)
+#endif
+#endif
+	{
+		gNetDevice[devNo] = alloc_etherdev(sizeof(EMAC_DEVICE));
+		if (gNetDevice[devNo] == NULL) {
+			EMACDBG("EMAC%d: Could not allocate ethernet device\n", devNo);
+			return -1;
+		}
+		gNetDevice[devNo]->dma = devNo;
+		/* Init function for EMAC */
+		gNetDevice[devNo]->init = emacdev_init;
+		/* Initialize global structure */
+		init_netdevice(gNetDevice[devNo]);
+
+		pEmacDevice = (EMAC_DEVICE *) netdev_priv(gNetDevice[devNo]);
+		memset(gNetDevice[devNo]->priv, 0, sizeof(EMAC_DEVICE));
+		/* place net_device handle in private structure */
+		pEmacDevice->hNetDev = gNetDevice[devNo];
+		/* Initialize private data structure */
+		Initialize_private(pEmacDevice);
+
+		/* MDIO operation Supported and MDIO(PHY) address unknown */
+		if ((pEmacDevice->uMDIO_support) && (pEmacDevice->mii_if.phy_id == 0xFFFFFFFF)) {
+			/* Detecting the PHY */
+			if (phy_detect(gNetDevice[devNo])) {
+				EMACDBG("Unable to detect the PHY\n");
+				/* Free the allocated memory for emac net_device (free_netdev) */
+				free_netdev(gNetDevice[devNo]);
+				return -ENODEV;
+			}
+#ifdef EMAC_MEDIA_MAINTANANCE
+			/* Selecting Media check function  */
+			select_media_check_function(gNetDevice[devNo]);
+#endif
+		}
+
+		if (pEmacDevice->uMDIO_support) {
+			/* Check the PHY's autonegotiation capabilities */
+			check_autonegotiation(gNetDevice[devNo]);
+		}
+
+		retVal = register_netdev(gNetDevice[devNo]);
+		if (retVal == 0) {
+			EMACDBG("EMAC %d Initialized\n", devNo);
+		} else {
+			EMACDBG("EMAC %d Failed To Initialize code=%d\n", devNo, retVal);
+		}
+	}
+	if (devNo == 0) {
+		EMACDBG("Failed to discover any MAC blocks. Suspicious as they are built-in\n");
+		return -ENODEV;
+	}
+#ifdef EMAC_MEDIA_MAINTANANCE
+	else {
+		gThreadExitReq = 0;
+		init_completion(&gThreadExitComplete);
+		threadID = kernel_thread(emac_media_check, NULL, CLONE_FS);
+		if (threadID < 0)
+			EMACDBG("Failed to start ethernet maintenance thread: %d\n", threadID);
+	}
+#endif
+	return retVal;
+}
+
+static void __exit emacdev_unload(void)
+{
+	/*Unregister the device (unregister_netdev) */
+	int devNo = 0;
+#ifdef EMAC_MEDIA_MAINTANANCE
+	gThreadExitReq = 1;
+#endif
+
+#ifdef CONFIG_CNXT_EMAC0_ENABLE
+#ifdef CONFIG_CNXT_EMAC1_ENABLE
+	for (devNo = 0; devNo < MAX_EMAC; devNo++)
+#else
+	for (devNo = 0; devNo < (MAX_EMAC - 1); devNo++)
+#endif
+#else
+#ifdef CONFIG_CNXT_EMAC1_ENABLE
+	for (devNo = 1; devNo < MAX_EMAC; devNo++)
+#endif
+#endif
+	{
+		if (gNetDevice[devNo]) {
+			unregister_netdev(gNetDevice[devNo]);
+		}
+
+		/*Free the allocated memory for emac net_device (free_netdev) */
+		free_netdev(gNetDevice[devNo]);
+	}
+#ifdef EMAC_MEDIA_MAINTANANCE
+	wait_for_completion(&gThreadExitComplete);
+#endif
+	EMACDBG("emac exit function\n");
+}
+
+module_init(emacdev_load);
+module_exit(emacdev_unload);
+
+/****************************************************************************
+ * Modifications:
+ * $Log:
+ *  3    Linux_SDK 1.2         8/3/07 2:49:05 PM IST  Upakul Barkakaty
+ *       Configurable flags and logic added to enable the Second Ethernet
+ *       interface with 2xMode operation for Emac.
+ *  2    Linux_SDK 1.1         4/16/07 1:25:22 PM IST Rajesha Kini    Updated
+ *       with GPL header.
+ *  1    Linux_SDK 1.0         3/2/07 3:42:22 PM IST  Vineet Seth     
+ * $
+ *
+ ****************************************************************************/
diff --git a/drivers/net/cnxt_emac/emac_prv.c b/drivers/net/cnxt_emac/emac_prv.c
new file mode 100644
index 0000000..1ebe319
--- /dev/null
+++ b/drivers/net/cnxt_emac/emac_prv.c
@@ -0,0 +1,2080 @@
+/****************************************************************************
+ *
+ *  drivers/net/cnxt_emac/emac_prv.c
+ *
+ *  Copyright (C) 2007 Conexant Systems,Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
+ *
+ */
+/****************************************************************************
+ *$Id: emac_prv.c,v 1.6, 2007-08-09 14:21:14Z, Upakul Barkakaty$
+ ****************************************************************************/
+
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>	/* struct device, and other headers */
+#include <linux/etherdevice.h>	/* eth_type_trans */
+#include <linux/if_arp.h>	/* struct tcphdr */
+#include <linux/skbuff.h>
+#include <linux/dma-mapping.h>	/* for clearing the cache */
+#include <asm-arm/delay.h>
+
+#include "net/dst.h"
+#include "net/xfrm.h"
+#include "asm/arch/cx2450x.h"	/* file to get register definitions */
+#include "emac.h"
+#include "emac_prv.h"
+
+#define FLASH_MAC0_ADDRESS
+unsigned char EMAC0_ADDR[6] = { 0x00, 0x30, 0xCD, 0x01, 0x07, 0x0F };
+
+#define FLASH_MAC1_ADDRESS
+unsigned char EMAC1_ADDR[6] = { 0x00, 0x30, 0xCD, 0x01, 0x07, 0x0E };
+
+extern unsigned char mac_address[6];
+/* Value for alignment of ethernet frame field to word boundary */
+#define SKB_PREFIX_LEN 2
+
+extern struct net_device *gNetDevice[MAX_EMAC];
+
+#ifdef EMAC_MEDIA_MAINTANANCE
+extern struct completion gThreadExitComplete;
+extern volatile int gThreadExitReq;
+#endif
+
+static unsigned long crc_bit(unsigned long initialResidue, unsigned long theBit);
+static unsigned long crc_byte(unsigned long initialResidue, unsigned long theByte);
+static unsigned long CaclulateHashBitNumber(unsigned char *uMacAddress);
+static void AddMulticastHash(EMAC_DEVICE * pEmacDevice, unsigned char *uHwAddress, unsigned char uAddrLen);
+static int CreateBufferDescriptorTable(EMAC_DEVICE * pEmacDevice);
+static int DeleteBufferDescriptorTable(EMAC_DEVICE * pEmacDevice);
+static int InitialiseEMAC(EMAC_DEVICE * pEmacDevice);
+static int ResetEMAC(EMAC_DEVICE * pEmacDevice);
+static int EnableISR(EMAC_DEVICE * pEmacDevice);
+static int StartEMAC(EMAC_DEVICE * pEmacDevice);
+static int StopEMAC(EMAC_DEVICE * pEmacDevice);
+static int StartTransmit(EMAC_DEVICE * pEmacDevice);
+static int emac_isr(int irq, void *dev_id);
+static void RxInterruptPostProcessing(unsigned long data);
+static void TxInterruptPostProcessing(unsigned long data);
+
+#if 0
+static void RxBufferRefillHandler(EMAC_DEVICE * pEmacDevice);
+#endif
+
+#ifdef EMAC_MEDIA_MAINTANANCE
+/* Transceivers (PHY) specific function to check changes in mode/speed */
+static void realtek8201_media_check(struct net_device *dev);
+static void ip101_media_check(struct net_device *dev);
+static void lxt972_media_check(struct net_device *dev);
+static void general_media_check(struct net_device *dev);
+
+/* Basic structure which holds specific media (mode/speed) check function */
+struct phy_media_check {
+	unsigned int phy_id;	/* phy_identifier */
+	void (*media_check_func) (struct net_device * dev);	/* media checking function */
+};
+
+/* Structure which holds speed/mode checking function pointers */
+static struct phy_media_check phy_list[] = {
+	{ 0x02430C54, ip101_media_check       },	/* IP101 Plus */
+	{ 0x00008201, realtek8201_media_check },	/* RealTek 8201 */
+	{ 0x001378e2, lxt972_media_check      },	/* Intel LXT 972 */
+	{ 0x00000000, general_media_check     }	        /* Generic, must be last */
+};
+#endif
+
+/*Tasklet for ISR TX and Rx post processing function*/
+struct tasklet_struct gRxTasklet[MAX_EMAC];
+struct tasklet_struct gTxTasklet[MAX_EMAC];
+
+#ifdef SKB_CLONE		/* sk buffer reuse logic enable */
+static int refill_queue_len = 0;
+struct sk_buff_head refillQueue[MAX_EMAC];
+#endif
+
+
+/* Open the EMAC for the operation */
+int emac_open(unsigned short uInterfaceNumber, struct net_device *dev)
+{
+	int retVal;
+	EMAC_DEVICE *pEmacDevice;
+	unsigned long flags;
+#ifdef SKB_CLONE		/*sk buffer reuse logic enable */
+	unsigned long count;
+	struct sk_buff *pBuf;
+#endif
+
+	pEmacDevice = (EMAC_DEVICE *) netdev_priv(dev);
+
+	retVal = 0;
+
+	/* If interface is already in use return error else mark it as in use */
+	if (0 == pEmacDevice->uInUse) {
+		memcpy(pEmacDevice->mac, dev->dev_addr, MAC_ADDR_LEN);
+		if (0 == uInterfaceNumber) {
+			pEmacDevice->uInUse = 1;
+		} else if (1 == uInterfaceNumber) {
+			pEmacDevice->uInUse = 1;
+		}
+		/* Initialize no Transmit buffer pending */
+		pEmacDevice->TxQDepth = 0;
+		skb_queue_head_init(&pEmacDevice->TxQueue);	/* Tx sk buffer Queue */
+
+#ifdef SKB_CLONE		/* sk buffer reuse logic enable */
+		skb_queue_head_init(&refillQueue[pEmacDevice->uInterfaceNo]);	/* Refill sk buffer Queue */
+		for (count = 0; count < MIN_REFILL_QUEUE_LEN; count++) {
+			pBuf = dev_alloc_skb(EMAC_FRAMESIZE_MAX);
+			if (NULL != pBuf) {
+				__skb_queue_tail(&refillQueue[pEmacDevice->uInterfaceNo], pBuf);
+			}
+		}
+		refill_queue_len = MIN_REFILL_QUEUE_LEN;
+#endif
+
+		/* Allocate memory for TX RX descriptor table and corresponding buffer */
+		CreateBufferDescriptorTable(pEmacDevice);
+
+		spin_lock_irqsave(&pEmacDevice->lock, flags);
+		/* Initialise EMAC registers with proper values */
+		InitialiseEMAC(pEmacDevice);
+
+		/*  Initialise the tasklet for TX and RX operation */
+		EnableISR(pEmacDevice);
+		spin_unlock_irqrestore(&pEmacDevice->lock, flags);
+		/* request isr */
+		retVal = request_irq(pEmacDevice->iIrq, emac_isr, 0, pEmacDevice->hNetDev->name, pEmacDevice);
+		spin_lock_irqsave(&pEmacDevice->lock, flags);
+		/*Start EMAC operation */
+		StartEMAC(pEmacDevice);
+		spin_unlock_irqrestore(&pEmacDevice->lock, flags);
+
+	} else {
+		retVal = 1;
+		EMACDBG("Device already opened\n");
+	}
+	return retVal;
+}
+
+/*Close the EMAC instance*/
+int emac_close(struct net_device *dev)
+{
+	int retVal;
+	EMAC_DEVICE *pEmacDevice;
+	unsigned long flags;
+
+	pEmacDevice = (EMAC_DEVICE *) netdev_priv(dev);
+
+	retVal = 0;
+	if (1 == pEmacDevice->uInUse) {
+		spin_lock_irqsave(&pEmacDevice->lock, flags);
+		/*Stop operation */
+		StopEMAC(pEmacDevice);
+
+		/*Reset registers */
+		ResetEMAC(pEmacDevice);
+		spin_unlock_irqrestore(&pEmacDevice->lock, flags);
+		/*Deallocate memory for TX RX descriptor table and corresponding buffer */
+		DeleteBufferDescriptorTable(pEmacDevice);
+
+		/*Mark the interface as free */
+		pEmacDevice->uInUse = 0;
+	}
+
+	return retVal;
+}
+
+
+static unsigned long crc_bit(unsigned long initialResidue, unsigned long theBit)
+{
+	/* Uses the given bit to continue a CRC calculation */
+	unsigned long residue = initialResidue;
+
+	if (((residue >> 31) & 1) ^ theBit) {
+		residue <<= 1;
+		residue ^= 0x04c11db7;
+	} else {
+		residue <<= 1;
+	}
+
+	return (residue);
+}
+
+
+static unsigned long crc_byte(unsigned long initialResidue, unsigned long theByte)
+{
+	/* Submits each bit of the given byte to have CRC calculated, LS Bit first */
+	int loop;
+	unsigned long residue = initialResidue;
+
+	for (loop = 0; loop < 8; loop++) {
+		residue = crc_bit(residue, theByte & 1);
+		theByte >>= 1;
+	}
+
+	return (residue);
+}
+
+
+static unsigned long CaclulateHashBitNumber(unsigned char *uMacAddress)
+{
+	unsigned long residue = 0xffffffff;
+	unsigned long a;
+	unsigned long b = 0;
+	unsigned long i;
+
+	for (i = 0; i < 6; i++) {
+		unsigned long my_byte = uMacAddress[i];
+		residue = crc_byte(residue, my_byte);
+	}
+
+	/* The ARC block is different to other ethernet blocks :
+	 * The LS 6 bits of the CRC are used, and they must
+	 * be bit reversed
+	 */
+
+	/* Get LS 6 bits */
+	a = residue & 0x3f;
+
+	/* Bit reverse these 6 bits */
+	for (i = 0; i < 6; i++) {
+		if (a & (1 << i)) {
+			b |= (1 << (5 - i));
+		}
+	}
+
+	return (b);
+}
+
+static void AddMulticastHash(EMAC_DEVICE * pEmacDevice, unsigned char *uHwAddress, unsigned char uAddrLen)
+{
+	unsigned long maskbit = 0;
+	unsigned long hashbit = 0;
+
+	hashbit = CaclulateHashBitNumber(uHwAddress);
+
+	/* set the hash registers high or low depending on the hashbit. */
+	if (hashbit < (2 * 32)) {
+		if (hashbit <= 31) {
+			/* set the bit in the lower hash register */
+			maskbit = 1 << hashbit;
+			/* set the bit in the hashlow register */
+			pEmacDevice->uHashLow = (pEmacDevice->uHashLow | maskbit);
+			(*((volatile unsigned long *) EMAC_LAFL_REG(pEmacDevice->uInterfaceNo))) = pEmacDevice->uHashLow;
+		} else {
+			maskbit = 1 << (hashbit - 32);
+			pEmacDevice->uHashHigh = (pEmacDevice->uHashHigh | maskbit);
+			(*((volatile unsigned long *) EMAC_LAFH_REG(pEmacDevice->uInterfaceNo))) = pEmacDevice->uHashHigh;
+		}
+	}
+}
+
+int emac_set_multicast_list(struct net_device *dev)
+{
+	EMAC_DEVICE *pEmacDevice;
+	unsigned long tmpVal;
+	struct dev_mc_list *mcList;
+	int retVal;
+
+	pEmacDevice = (EMAC_DEVICE *) netdev_priv(dev);
+
+	retVal = 0;
+
+	pEmacDevice->uHashHigh = 0;
+	pEmacDevice->uHashLow = 0;
+	pEmacDevice->uMulticastEnable = 0;
+	pEmacDevice->uPromiscousEnable = 0;
+	/* Clear (set 0) hash filter values (to accept or reject the 64 group of 
+	   logical address) to LAF  registers (LAFL, LAFH). */
+	(*((volatile unsigned long *) EMAC_LAFL_REG(pEmacDevice->uInterfaceNo))) = 0;
+	(*((volatile unsigned long *) EMAC_LAFH_REG(pEmacDevice->uInterfaceNo))) = 0;
+	tmpVal = (*((volatile unsigned long *) EMAC_CONTROL_REG(pEmacDevice->uInterfaceNo))) & (~(1UL << 11));
+	(*((volatile unsigned long *) EMAC_CONTROL_REG(pEmacDevice->uInterfaceNo))) = tmpVal;
+
+	if ((dev->flags & IFF_PROMISC)) {	/*Promiscous enable */
+		tmpVal = (*((volatile unsigned long *) EMAC_CONTROL_REG(pEmacDevice->uInterfaceNo)));
+		tmpVal |= (1UL << 11);
+		(*((volatile unsigned long *) EMAC_CONTROL_REG(pEmacDevice->uInterfaceNo))) = tmpVal;
+		pEmacDevice->uPromiscousEnable = 1;
+	} else if (dev->flags & IFF_ALLMULTI) {	/* All multi cast enable */
+		(*((volatile unsigned long *) EMAC_LAFL_REG(pEmacDevice->uInterfaceNo))) = 0xFFFFFFFF;
+		(*((volatile unsigned long *) EMAC_LAFH_REG(pEmacDevice->uInterfaceNo))) = 0xFFFFFFFF;
+		pEmacDevice->uMulticastEnable = 1;
+
+	} else {
+		if (0 != dev->mc_count) {	/*Multiast enabled */
+			for (mcList = dev->mc_list; (NULL != mcList); mcList = mcList->next) {
+				AddMulticastHash(pEmacDevice, mcList->dmi_addr, mcList->dmi_addrlen);
+				pEmacDevice->uMulticastEnable = 1;
+			}
+		}
+	}
+
+	return retVal;
+}
+
+/* Update the BDT to transmit the frame, if queue length is 1. else update the queue */
+int emac_start_transmit(struct net_device *dev, void *pData, unsigned long uDataLen)
+{
+	EMAC_DEVICE *pEmacDevice;
+	int retVal;
+	struct sk_buff *pBuf = (struct sk_buff *) pData;
+
+	pEmacDevice = (EMAC_DEVICE *) netdev_priv(dev);
+
+	retVal = 0;
+	/* Non Transmitted sk buffers numbers crossed maximum limit? */
+	if (pEmacDevice->TxQDepth < pEmacDevice->uMaxTxQDepth) {
+
+		__skb_queue_tail(&pEmacDevice->TxQueue, pBuf);	/* Update latest received sk buffer to queue */
+		pEmacDevice->TxQDepth++;	/* increment Non Transmitted sk buffers number */
+
+		/* Transmit sk buffer immediately, if number of Tx sk buffer is 1 */
+		if (pEmacDevice->TxQDepth == 1) {
+			retVal = StartTransmit(pEmacDevice);
+		}
+
+	} else {
+		netif_stop_queue(dev);	/* CR 30348 */
+		retVal = -1;	/* return driver busy condition */
+	}
+
+	return retVal;
+}
+
+int emac_get_device_attribute(struct net_device *dev, EMAC_ATTRIBUTES * pAttributes)
+{
+	int retVal;
+	unsigned long tmpVal;
+	EMAC_DEVICE *pEmacDevice;
+
+	pEmacDevice = (EMAC_DEVICE *) netdev_priv(dev);
+	retVal = 0;
+	pAttributes->uInterfaceNo = pEmacDevice->uInterfaceNo;
+	memcpy(pAttributes->uMACaddress, pEmacDevice->mac, 6);
+	tmpVal = EmacReadReg_PHY(dev, pEmacDevice->mii_if.phy_id, PHY_IDENTIFIER_REG1);
+	tmpVal = (tmpVal << 16);
+	tmpVal |= EmacReadReg_PHY(dev, pEmacDevice->mii_if.phy_id, PHY_IDENTIFIER_REG2);
+	pAttributes->uPHYIndentifier = tmpVal;
+	tmpVal = EmacReadReg_PHY(dev, pEmacDevice->mii_if.phy_id, PHY_STATUS_REG);
+	if (PHY_STATUS_100BASE_T4 == (PHY_STATUS_100BASE_T4 & tmpVal)) {
+		pAttributes->u100BaseT4Ability = 1;
+	} else {
+		pAttributes->u100BaseT4Ability = 0;
+	}
+
+	if (PHY_STATUS_100BASEX_FULLDUPLEX == (PHY_STATUS_100BASEX_FULLDUPLEX & tmpVal)) {
+		pAttributes->u100BaseXFullDuplexAbility = 1;
+	} else {
+		pAttributes->u100BaseXFullDuplexAbility = 0;
+	}
+
+	if (PHY_STATUS_100BASEX_HALFDUPLEX == (PHY_STATUS_100BASEX_HALFDUPLEX & tmpVal)) {
+		pAttributes->u100BaseXHalfDuplexAbility = 1;
+	} else {
+		pAttributes->u100BaseXHalfDuplexAbility = 0;
+	}
+
+	if (PHY_STATUS_10MBPS_FULLDUPLEX == (PHY_STATUS_10MBPS_FULLDUPLEX & tmpVal)) {
+		pAttributes->u10MbsFullDuplexAbility = 1;
+	} else {
+		pAttributes->u10MbsFullDuplexAbility = 0;
+	}
+
+	if (PHY_STATUS_10MBPS_HALFDUPLEX == (PHY_STATUS_10MBPS_HALFDUPLEX & tmpVal)) {
+		pAttributes->u10MbsHalfDuplexAbility = 1;
+	} else {
+		pAttributes->u10MbsHalfDuplexAbility = 0;
+	}
+
+	if (PHY_STATUS_MF_PREAMBLE_SUPRESSION == (PHY_STATUS_MF_PREAMBLE_SUPRESSION & tmpVal)) {
+		pAttributes->uMFPreambleSuppression = 1;
+	} else {
+		pAttributes->uMFPreambleSuppression = 0;
+	}
+
+	if (PHY_STATUS_AUTONEGOTIATION_ABILITY == (PHY_STATUS_AUTONEGOTIATION_ABILITY & tmpVal)) {
+		pAttributes->uAutoNegotiationCap = 1;
+	} else {
+		pAttributes->uAutoNegotiationCap = 0;
+	}
+
+
+	if (PHY_STATUS_LINK_STATUS == (PHY_STATUS_LINK_STATUS & tmpVal)) {
+		pAttributes->uLinkStatus = 1;
+	} else {
+		pAttributes->uLinkStatus = 0;
+	}
+
+
+	if (PHY_STATUS_EXTENDED_CAPABILITY == (PHY_STATUS_EXTENDED_CAPABILITY & tmpVal)) {
+		pAttributes->uExtendedPHYRegisterSet = 1;
+	} else {
+		pAttributes->uExtendedPHYRegisterSet = 0;
+	}
+
+	return retVal;
+}
+
+int emac_get_device_statistics(struct net_device *dev, EMAC_STATS * emacStats)
+{
+	int retVal;
+	unsigned long tmpVal;
+	EMAC_DEVICE *pEmacDevice;
+
+	pEmacDevice = (EMAC_DEVICE *) netdev_priv(dev);
+	retVal = 0;
+	/*Read the Missed Packet Counter register */
+	tmpVal = (*((volatile unsigned long *) EMAC_MISS_REG(pEmacDevice->uInterfaceNo)));
+	pEmacDevice->Stats.uBDMissPktCnt += ((1UL << 19) & tmpVal);
+	/*Read the Missed Receive Error Counter register */
+	tmpVal = (*((volatile unsigned long *) EMAC_RXERR_REG(pEmacDevice->uInterfaceNo)));
+	pEmacDevice->Stats.uRxCRCErrDropCnt += (0x000000FF & tmpVal);
+	pEmacDevice->Stats.uRxFrameErrDropCnt += ((0x0000FF00 & tmpVal) >> 8);
+	pEmacDevice->Stats.uRxFifoOverflowDropCnt += ((0x00FF0000 & tmpVal) >> 16);
+	*emacStats = pEmacDevice->Stats;
+
+	return retVal;
+}
+
+
+
+
+/*Allocate memory for the Tx and Rx Buffer Descriptor Tables, Also allocate memory for Receive buffer*/
+static int CreateBufferDescriptorTable(EMAC_DEVICE * pEmacDevice)
+{
+	unsigned long sizeBDT;
+	EMAC_BUF_DESCR *bufDescr;
+	EMAC_LOCAL_BUF *localBuf;
+	int i;
+	unsigned long tmpAddr;
+	unsigned long lenBuf;
+	struct sk_buff *pBuf;
+
+	int retVal;
+	retVal = 0;
+
+
+	if (NULL != pEmacDevice->puDescriptorBase) {
+
+		pEmacDevice->puDescriptorBase = NULL;
+		/* return error: unexpected path */
+		return -1;
+	}
+#ifdef PECOS_ETH_TESTPRINT
+	EMACDBG("CNXT_DMA_ALLOC_MEM \n");
+#endif
+
+	sizeBDT = ((pEmacDevice->uTxDescCount + pEmacDevice->uRxDescCount) * sizeof(EMAC_BUF_DESCR)) + ((pEmacDevice->uTxDescCount + pEmacDevice->uRxDescCount) * sizeof(EMAC_LOCAL_BUF)) + 32;
+
+	pEmacDevice->puDescriptorBase = (unsigned char *) dma_alloc_coherent(NULL, sizeBDT, &pEmacDevice->uDmaAddr, GFP_KERNEL);
+
+#ifdef PECOS_ETH_TESTPRINT
+	EMACDBG("pEmacDevice->puDescriptorBase  = %lx, sizeBDT = %lx,pEmacDevice->uDmaAddr = %lx \n", (unsigned long) pEmacDevice->puDescriptorBase, sizeBDT, (unsigned long) pEmacDevice->uDmaAddr);
+#endif
+
+
+	if (NULL != pEmacDevice->puDescriptorBase) {
+		pEmacDevice->uDescriptorSize = sizeBDT;
+		tmpAddr = (unsigned long) (pEmacDevice->puDescriptorBase);
+		tmpAddr += 0x7;
+		tmpAddr &= ~(0x7);
+		/*TX Buffer Descriptor Table Information */
+		pEmacDevice->tx_first_desc = (EMAC_BUF_DESCR *) tmpAddr;
+		pEmacDevice->tx_last_desc = pEmacDevice->tx_first_desc + (pEmacDevice->uTxDescCount - 1);
+		pEmacDevice->tx_first_local = (EMAC_LOCAL_BUF *) (pEmacDevice->tx_last_desc + 1);
+		pEmacDevice->tx_refil_local = pEmacDevice->tx_first_local;
+		/*TX BDT ptr field initialization */
+		bufDescr = pEmacDevice->tx_first_desc;
+		localBuf = pEmacDevice->tx_first_local;
+		for (i = 0; i < pEmacDevice->uTxDescCount; i++) {
+			/* Prepare the descriptor */
+			localBuf->puData = NULL;
+			bufDescr->puData = NULL;
+			bufDescr->uInfo = ENET_TX_CTL_INFO_CPU_FIRST | ENET_TX_CTL_INFO_CPU_LAST;
+			bufDescr++;
+			localBuf++;
+		}
+		/*TX Buffer Descriptor Table Information */
+		pEmacDevice->tx_curr = pEmacDevice->tx_first_desc;
+		pEmacDevice->tx_curr_local = pEmacDevice->tx_first_local;
+		pEmacDevice->tx_refil = pEmacDevice->tx_first_desc;
+
+		/* First round up base pointer */
+		tmpAddr = (unsigned long) (pEmacDevice->tx_first_local + pEmacDevice->uTxDescCount);
+		tmpAddr += 0x7;
+		tmpAddr &= ~(0x7);
+		pEmacDevice->rx_first_desc = (EMAC_BUF_DESCR *) tmpAddr;
+		pEmacDevice->rx_last_desc = pEmacDevice->rx_first_desc + (pEmacDevice->uRxDescCount - 1);
+		pEmacDevice->rx_first_local = (EMAC_LOCAL_BUF *) (pEmacDevice->rx_last_desc + 1);
+		pEmacDevice->rx_refil_local = pEmacDevice->rx_first_local;
+
+		/* Fill them in */
+		bufDescr = pEmacDevice->rx_first_desc;
+		localBuf = pEmacDevice->rx_first_local;
+		for (i = 0; i < pEmacDevice->uRxDescCount; i++) {
+			lenBuf = EMAC_FRAMESIZE_MAX;
+			pBuf = dev_alloc_skb(lenBuf);
+			skb_reserve(pBuf, SKB_PREFIX_LEN);
+			localBuf->puData = pBuf;
+			bufDescr->puData = (unsigned char *) dma_map_single(NULL, pBuf->tail, EMAC_RX_FRAMESIZE_MAX, DMA_FROM_DEVICE);
+			/* To prevent Rx buffer chaining the value should be greater than max frame size expected */
+			bufDescr->uInfo = ENET_RX_CTL_INFO_OWN | EMAC_RX_FRAMESIZE_MAX;
+			bufDescr++;
+			localBuf++;
+		}
+		pEmacDevice->rx_refil = pEmacDevice->rx_first_desc;
+		pEmacDevice->rx_curr = pEmacDevice->rx_first_desc;
+		pEmacDevice->rx_curr_local = pEmacDevice->rx_first_local;
+	} else {
+		EMACDBG("EMAC: Failed to allocate memory for buffer descriptor table\n");
+		retVal = 1;
+	}
+
+	return retVal;
+}
+
+/*Free memory allocated earlier for the Tx and Rx Buffer Descriptor Tables, Also free memory for Receive buffer*/
+static int DeleteBufferDescriptorTable(EMAC_DEVICE * pEmacDevice)
+{
+	EMAC_BUF_DESCR *bufDescr;
+	EMAC_LOCAL_BUF *localBuf;
+	unsigned long i;
+	struct sk_buff *pBuf;
+	int retVal = 0;
+
+	bufDescr = pEmacDevice->rx_first_desc;
+	localBuf = pEmacDevice->rx_first_local;
+	/* Free all Rx SK buff's */
+	for (i = 0; i < pEmacDevice->uRxDescCount; i++) {
+		if (NULL != localBuf->puData) {
+			pBuf = (struct sk_buff *) (localBuf->puData);
+			dev_kfree_skb(pBuf);
+			bufDescr->puData = NULL;
+			localBuf->puData = NULL;
+		}
+
+		bufDescr++;
+		localBuf++;
+	}
+	/* Free all Tx SK buff's */
+	bufDescr = pEmacDevice->tx_first_desc;
+	localBuf = pEmacDevice->tx_first_local;
+	for (i = 0; i < pEmacDevice->uTxDescCount; i++) {
+		if (NULL != localBuf->puData) {
+			pBuf = (struct sk_buff *) (localBuf->puData);
+			dev_kfree_skb(pBuf);
+			bufDescr->puData = NULL;
+			localBuf->puData = NULL;
+		}
+		bufDescr++;
+		localBuf++;
+	}
+
+	/* Delete all non transmitted SK buff */
+	while (0 != skb_queue_len(&pEmacDevice->TxQueue)) {
+		pBuf = __skb_dequeue(&pEmacDevice->TxQueue);
+		dev_kfree_skb(pBuf);
+	}
+#ifdef SKB_CLONE
+	/* Delete all non used refil SK buff */
+	while (0 != skb_queue_len(&refillQueue[pEmacDevice->uInterfaceNo])) {
+		pBuf = __skb_dequeue(&refillQueue[pEmacDevice->uInterfaceNo]);
+		dev_kfree_skb(pBuf);
+	}
+#endif
+#ifdef PECOS_ETH_TESTPRINT
+	EMACDBG("Free CNXT_DMA_ALLOC_MEM\n");
+#endif
+	/*Free the memory allocated for Tx and Rx BDT */
+	dma_free_coherent(NULL, pEmacDevice->uDescriptorSize, pEmacDevice->puDescriptorBase, pEmacDevice->uDmaAddr);
+	pEmacDevice->puDescriptorBase = NULL;
+
+	return retVal;
+}
+
+
+/*Initialise registers with proper values. Values are written into the registers
+  by using the memory base address for EMAC and the register offset*/
+static int InitialiseEMAC(EMAC_DEVICE * pEmacDevice)
+{
+	unsigned long tmpVal;
+	unsigned long tmpAddr;
+	unsigned long AddHi, AddLw;
+	int retVal = 0;
+
+	/*Read the ID register and verify the revision of the EMAC hardware. */
+	tmpVal = (*((volatile unsigned long *) EMAC_ID_REG(pEmacDevice->uInterfaceNo)));
+	if (tmpVal == 0x0007FD02) {
+		/*Write the Ethernet MAC address to ADDR registers (ADDRL, ADDRS). */
+		tmpVal = (pEmacDevice->mac[3] << 24) | (pEmacDevice->mac[2] << 16) | (pEmacDevice->mac[1] << 8) | (pEmacDevice->mac[0] << 0);
+		(*((volatile unsigned long *) EMAC_ADDRL_REG(pEmacDevice->uInterfaceNo))) = tmpVal;
+		tmpVal = (pEmacDevice->mac[5] << 8) | (pEmacDevice->mac[4] << 0);
+		(*((volatile unsigned long *) EMAC_ADDRH_REG(pEmacDevice->uInterfaceNo))) = tmpVal;
+		/*Clear (set 0) hash filter values (to accept or reject the 64 group of 
+		   logical address) to LAF  registers (LAFL, LAFH). */
+		(*((volatile unsigned long *) EMAC_LAFL_REG(pEmacDevice->uInterfaceNo))) = 0;
+		(*((volatile unsigned long *) EMAC_LAFH_REG(pEmacDevice->uInterfaceNo))) = 0;
+
+		AddLw = (unsigned long) pEmacDevice->puDescriptorBase;
+		AddHi = (unsigned long) pEmacDevice->tx_first_desc;
+
+		/*Write address of the start of transmit buffer descriptor table to TXRINGPTR register. */
+		tmpVal = AddHi - AddLw;
+
+#ifdef PECOS_ETH_TESTPRINT
+		EMACDBG("AddHi  = %lx, AddLw = %lx,tmpVal = %lx \n", AddHi, AddLw, tmpVal);
+#endif
+		tmpAddr = ((unsigned long) (pEmacDevice->uDmaAddr) + tmpVal);
+
+#ifdef PECOS_ETH_TESTPRINT
+		EMACDBG("pEmacDevice->uDmaAddr  = %lx, tmpAddr = %lx \n", (unsigned long) pEmacDevice->uDmaAddr, tmpAddr);
+#endif
+
+		(*((volatile unsigned long *) EMAC_TXRINGPTR_REG(pEmacDevice->uInterfaceNo))) = tmpAddr;
+
+#ifdef PECOS_ETH_TESTPRINT
+		EMACDBG("TXRINGPTR_REG = %lx \n", tmpAddr);
+#endif
+
+
+		AddLw = (unsigned long) pEmacDevice->puDescriptorBase;
+		AddHi = (unsigned long) pEmacDevice->rx_first_desc;
+
+		/*Write address of the start of transmit buffer descriptor table to TXRINGPTR register. */
+		tmpVal = AddHi - AddLw;
+
+#ifdef PECOS_ETH_TESTPRINT
+		EMACDBG("AddHi  = %lx, AddLw = %lx,tmpVal = %lx \n", AddHi, AddLw, tmpVal);
+#endif
+
+		tmpAddr = ((unsigned long) (pEmacDevice->uDmaAddr) + tmpVal);
+
+#ifdef PECOS_ETH_TESTPRINT
+		EMACDBG("pEmacDevice->uDmaAddr  = %lx, tmpAddr = %lx \n", (unsigned long) pEmacDevice->uDmaAddr, tmpAddr);
+#endif
+
+		(*((volatile unsigned long *) EMAC_RXRINGPTR_REG(pEmacDevice->uInterfaceNo))) = tmpAddr;
+
+#ifdef PECOS_ETH_TESTPRINT
+		EMACDBG("RXRINGPTR_REG = %lx \n", tmpAddr);
+#endif
+
+		/*Right the poll rate value to POOLRATE register. */
+		(*((volatile unsigned long *) EMAC_POLLRATE_REG(pEmacDevice->uInterfaceNo))) = EMAC_POLLRATE_VALUE;
+		/*Write No of descriptor in TX and RX BDT to CONTROL register.
+		   Depending on the value supplied in pCaps Set  the Mode 
+		   (Full duplex, half duplex) and promiscous flag by writing into MDIO register. */
+		tmpVal = pEmacDevice->uTxDescCount << 16;
+		tmpVal |= pEmacDevice->uRxDescCount << 24;
+		if (FULL_DUPLEX == pEmacDevice->uMode) {
+			tmpVal |= (1UL << 10);
+
+		}
+		if (1 == pEmacDevice->uPromiscousEnable) {
+			tmpVal |= (1UL << 11);
+		}
+
+		(*((volatile unsigned long *) EMAC_CONTROL_REG(pEmacDevice->uInterfaceNo))) = tmpVal;
+
+		if (pEmacDevice->uInterfaceNo) {
+			/* Change the default tx fifo threshold */
+			tmpVal = ((*((volatile unsigned long *) EMAC_XTRACTRL_REG(pEmacDevice->uInterfaceNo))) | (0x000003FF)) & EMAC1_TX_FIFO_THRESHOLD;
+			tmpVal |= (1UL << 19) | (1UL << 18) | (1UL << 17) | (1UL << 16) | (1UL << 22) | (1UL << 23);
+			(*((volatile unsigned long *) EMAC_XTRACTRL_REG(pEmacDevice->uInterfaceNo))) = tmpVal;
+		} else {
+			/* Change the default tx fifo threshold */
+			tmpVal = ((*((volatile unsigned long *) EMAC_XTRACTRL_REG(pEmacDevice->uInterfaceNo))) | (0x000003FF)) & EMAC0_TX_FIFO_THRESHOLD;
+			tmpVal |= (1UL << 19) | (1UL << 18) | (1UL << 17) | (1UL << 16) | (1UL << 22) | (1UL << 23);
+			(*((volatile unsigned long *) EMAC_XTRACTRL_REG(pEmacDevice->uInterfaceNo))) = tmpVal;
+
+		}
+
+		/*Set all member in Status to 0 */
+		memset(&pEmacDevice->Stats, 0, sizeof(EMAC_STATS));
+	} else {
+		retVal = 1;
+	}
+
+	return retVal;
+}
+
+
+static int ResetEMAC(EMAC_DEVICE * pEmacDevice)
+{
+	unsigned long count, tmpVal;
+	int retVal = 0;
+
+	/*Disable the EMAC by writing 0 to Control Register */
+	(*((volatile unsigned long *) EMAC_CONTROL_REG(pEmacDevice->uInterfaceNo))) = 0;
+	/*Disable All Interrupt */
+	(*((volatile unsigned long *) EMAC_ENABLE_REG(pEmacDevice->uInterfaceNo))) = 0;
+	/* Clear Tx/RX and ERR Interrupt Status bits */
+	(*((volatile unsigned long *) EMAC_STAT_REG(pEmacDevice->uInterfaceNo))) = ((1UL << 1) + 1 + (1UL << 2));
+	free_irq(pEmacDevice->iIrq, pEmacDevice);
+	(*((volatile unsigned long *) EMAC_LAFL_REG(pEmacDevice->uInterfaceNo))) = 0;
+	(*((volatile unsigned long *) EMAC_LAFH_REG(pEmacDevice->uInterfaceNo))) = 0;
+	(*((volatile unsigned long *) EMAC_TXRINGPTR_REG(pEmacDevice->uInterfaceNo))) = 0;
+	(*((volatile unsigned long *) EMAC_RXRINGPTR_REG(pEmacDevice->uInterfaceNo))) = 0;
+	/* Clear the Error counters */
+	(*((volatile unsigned long *) EMAC_RXERR_REG(pEmacDevice->uInterfaceNo)));
+	(*((volatile unsigned long *) EMAC_MISS_REG(pEmacDevice->uInterfaceNo)));
+	/* Wait till 0 is written into Ring pointer registers */
+	count = 0;
+	do {
+		count++;
+		tmpVal = (*((volatile unsigned long *) EMAC_TXPTRREAD_REG(pEmacDevice->uInterfaceNo)));
+		tmpVal |= (*((volatile unsigned long *) EMAC_RXPTRREAD_REG(pEmacDevice->uInterfaceNo)));
+		udelay(EMAC_DELAY);
+		if (count > EMAC_LOCKUP_WAIT) {
+			break;
+		}
+	}
+	while (tmpVal != 0);
+#ifdef PECOS_ETH_TESTPRINT
+	EMACDBG("Reset_EMAC time count = %lu \n", count);
+#endif
+	/*Set all member in Status to 0 */
+	memset(&pEmacDevice->Stats, 0, sizeof(EMAC_STATS));
+
+	return retVal;
+}
+
+/* Register the ISR, Initialise the tasklet for TX and RX operation */
+static int EnableISR(EMAC_DEVICE * pEmacDevice)
+{
+	int retVal = 0;
+//	unsigned long flags;
+
+	/* Initialise the tasklet for the ISR Tx and RX post processing function */
+	tasklet_init(&gRxTasklet[pEmacDevice->uInterfaceNo], RxInterruptPostProcessing, (long) pEmacDevice);
+	tasklet_init(&gTxTasklet[pEmacDevice->uInterfaceNo], TxInterruptPostProcessing, (long) pEmacDevice);
+
+	if (0 == retVal) {
+		/* Initialise the tasklet for the ISR Tx and RX post processing function */
+		/* Clear all Interrupt Status bits */
+		(*((volatile unsigned long *) EMAC_STAT_REG(pEmacDevice->uInterfaceNo))) = INTERRUPT_STATUS_CLEAR;
+		/* Enable all Interrupts */
+		(*((volatile unsigned long *) EMAC_ENABLE_REG(pEmacDevice->uInterfaceNo))) = (1 | (1UL << 1) | (1UL << 2));
+	}
+
+	return retVal;
+}
+
+
+
+/*Start EMAC operation*/
+static int StartEMAC(EMAC_DEVICE * pEmacDevice)
+{
+	unsigned long tmpVal;
+	int retVal = 0;
+
+	/*Write No of descriptor in TX and RX BDT to CONTROL register.
+	   Full duplex/half duplex and promiscous flag. */
+	tmpVal = pEmacDevice->uTxDescCount << 16;
+	tmpVal |= pEmacDevice->uRxDescCount << 24;
+
+	if (FULL_DUPLEX == pEmacDevice->uMode) {
+		tmpVal |= (1UL << 10);
+	}
+	if (1 == pEmacDevice->uPromiscousEnable) {
+		tmpVal |= (1UL << 11);
+	}
+
+	/*Start Emac operation */
+	tmpVal |= (1 | (1UL << 3) | (1UL << 4));
+	(*((volatile unsigned long *) EMAC_CONTROL_REG(pEmacDevice->uInterfaceNo))) = tmpVal;
+
+	return retVal;
+}
+
+
+
+/*Stop EMAC operation*/
+static int StopEMAC(EMAC_DEVICE * pEmacDevice)
+{
+	unsigned long tmpVal;
+	int retVal = 0;
+
+	/* Stop the EMAC operation */
+	tmpVal = (*((volatile unsigned long *) EMAC_CONTROL_REG(pEmacDevice->uInterfaceNo)));
+	tmpVal &= (~(1 | (1UL << 3) | (1UL << 4)));
+	(*((volatile unsigned long *) EMAC_CONTROL_REG(pEmacDevice->uInterfaceNo))) = tmpVal;
+
+	return retVal;
+}
+
+/* Get the mac address from the uMacDest */
+void Get_mac_Address(unsigned char *uMacDest, unsigned short uInterfaceNo, unsigned short uAddrlen)
+{
+	unsigned short tmpVal;
+	unsigned char *uMacSource = NULL;
+
+	if (0 == uInterfaceNo) {
+		if ((mac_address[0] == 0) && (mac_address[1] == 0) && (mac_address[2] == 0) && (mac_address[3] == 0) && (mac_address[4] == 0) && (mac_address[5] == 0)) {
+			uMacSource = (char *) EMAC0_ADDR;
+		} else {
+			uMacSource = (char *) mac_address;
+		}
+	} else if (1 == uInterfaceNo) {
+		uMacSource = (char *) EMAC1_ADDR;
+	}
+
+	for (tmpVal = 0; tmpVal < uAddrlen; tmpVal++) {
+		*uMacDest = *uMacSource;
+		uMacDest++;
+		uMacSource++;
+	}
+
+}
+
+static int StartTransmit(EMAC_DEVICE * pEmacDevice)
+{
+	struct sk_buff *puDataBuf;
+	EMAC_BUF_DESCR *tx_desc_ptr;
+	EMAC_LOCAL_BUF *tx_local_ptr;
+	int done = 0;
+	int retVal = 0;
+
+	tx_desc_ptr = pEmacDevice->tx_curr;
+	tx_local_ptr = pEmacDevice->tx_curr_local;
+	while (0 != skb_queue_len(&pEmacDevice->TxQueue)) {	/* loop till no sk buffers are in queue */
+		/* Is the descriptor owned by us, and empty? */
+		if (!(tx_desc_ptr->uInfo & ENET_TX_CTL_INFO_OWN)) {
+			/* Is the buffer 0?, whether previous transmission complete? */
+			if (NULL == tx_desc_ptr->puData) {
+				done = 1;
+				{
+					puDataBuf = __skb_dequeue(&pEmacDevice->TxQueue);
+					/* update data pointer(puData)field before control(uInfo)field */
+					/* synchronize cached area */
+					tx_desc_ptr->puData = (unsigned char *) dma_map_single(NULL, puDataBuf->data, puDataBuf->len, DMA_TO_DEVICE);
+					tx_desc_ptr->uInfo = ENET_TX_CTL_INFO_CPU_FIRST | ENET_TX_CTL_INFO_CPU_LAST | ENET_TX_CTL_INFO_OWN | puDataBuf->len;
+
+				}
+				/* Keep copy so we can free the buffer after transmission complete */
+				tx_local_ptr->puData = puDataBuf;
+				tx_desc_ptr++;
+				tx_local_ptr++;
+				/* Update the BDT polling pointers to start point, if it crosses end point */
+				if (tx_desc_ptr > pEmacDevice->tx_last_desc) {
+					tx_desc_ptr = pEmacDevice->tx_first_desc;
+					tx_local_ptr = pEmacDevice->tx_first_local;
+				}
+			} else {
+				/* Come out if BDT is not processed by the Tx ISR process */
+				break;
+			}
+			pEmacDevice->hNetDev->trans_start = jiffies;
+		} else {
+			/* No TX BD entry available, droping packet */
+			pEmacDevice->Stats.uTxBDEntryNotAvailable++;
+			break;	/* come out if EMAC has control of the BDT */
+		}
+	}
+	/* Update the EMAC current ring pointer */
+	if (1 == done) {
+		pEmacDevice->tx_curr = tx_desc_ptr;
+		pEmacDevice->tx_curr_local = tx_local_ptr;
+		(*((volatile unsigned long *) EMAC_STAT_REG(pEmacDevice->uInterfaceNo))) = (1UL << 31);
+	}
+
+	return retVal;
+}
+
+/* ISR routine handles Rx/Tx and Error processing */
+static irqreturn_t emac_isr(int irq, void *dev_id)
+{
+	unsigned long uIrq;
+	EMAC_DEVICE *pEmacDevice;
+	irqreturn_t retVal = IRQ_HANDLED;
+
+	pEmacDevice = (EMAC_DEVICE *) dev_id;
+	uIrq = (*((volatile unsigned long *) EMAC_STAT_REG(pEmacDevice->uInterfaceNo))) & ~(1UL << 12);
+
+	/*Clear the interrupt */
+	(*((volatile unsigned long *) EMAC_STAT_REG(pEmacDevice->uInterfaceNo))) = uIrq;
+
+	/*If Receive Interrupt has come */
+	if ((1UL << 1) & uIrq) {
+		/* Schedule Rx interrupt processing routine */
+		tasklet_schedule(&gRxTasklet[pEmacDevice->uInterfaceNo]);
+	}
+	if (1 & uIrq) {
+		/* Schedule Tx interrupt processing routine */
+		tasklet_schedule(&gTxTasklet[pEmacDevice->uInterfaceNo]);
+	}
+	/* Update error counter */
+	if ((1UL << 2) & uIrq) {
+		if ((1UL << 3) & uIrq) {
+			pEmacDevice->Stats.uTxChainingErrCnt++;
+		}
+		if ((1UL << 4) & uIrq) {
+			pEmacDevice->Stats.uBDMissPktCnt += ERROR_OVERFLOW_COUNTER;
+		}
+		if ((1UL << 8) & uIrq) {
+			pEmacDevice->Stats.uRxCRCErrDropCnt += ERROR_OVERFLOW_COUNTER;
+		}
+		if ((1UL << 9) & uIrq) {
+			pEmacDevice->Stats.uRxFrameErrDropCnt += ERROR_OVERFLOW_COUNTER;
+		}
+		if ((1UL << 10) & uIrq) {
+			pEmacDevice->Stats.uRxFifoOverflowDropCnt += ERROR_OVERFLOW_COUNTER;
+		}
+	}
+
+	return retVal;
+}
+
+/* Tasklet handler for TXINT post processing . Traverse through the TX buffer 
+ * descriptors. If OWN bit is 0 for a descriptor, then free its buffer memory. 
+ */
+static void TxInterruptPostProcessing(unsigned long data)
+{
+	EMAC_BUF_DESCR *tx_desc_ptr;
+	EMAC_LOCAL_BUF *tx_refil_local_ptr;
+	register unsigned long info;
+	register unsigned char *ptr;
+	unsigned long status;
+	unsigned long lenBuf;
+	unsigned short pktSent;
+
+	EMAC_DEVICE *pEmacDevice = (EMAC_DEVICE *) data;
+
+	local_irq_disable();
+	status = (*((volatile unsigned long *) EMAC_ENABLE_REG(pEmacDevice->uInterfaceNo))) & (~1);
+	(*((volatile unsigned long *) EMAC_ENABLE_REG(pEmacDevice->uInterfaceNo))) = status;
+	local_irq_enable();
+
+	tx_desc_ptr = pEmacDevice->tx_refil;
+	tx_refil_local_ptr = pEmacDevice->tx_refil_local;
+
+	/* Ensure info and ptr has updated value */
+	info = tx_desc_ptr->uInfo;
+	ptr = tx_desc_ptr->puData;
+	/* Check we own the buffer, and it is valid */
+	while ((!(info & ENET_TX_CTL_INFO_OWN)) && (ptr != NULL)) {
+		struct sk_buff *pBuf;
+		pBuf = (struct sk_buff *) (tx_refil_local_ptr->puData);
+		lenBuf = pBuf->len;
+
+#ifdef SKB_CLONE
+		if ((pBuf->end - pBuf->head >= EMAC_RX_FRAMESIZE_MAX) && (skb_queue_len(&refillQueue[pEmacDevice->uInterfaceNo]) < refill_queue_len) && (!pBuf->cloned)
+		    && (atomic_read(&pBuf->users) == 1)
+		    && (atomic_read(&(skb_shinfo(pBuf)->dataref)) == 1)
+		    && ((skb_shinfo(pBuf)->nr_frags == 0))
+		    && (skb_shinfo(pBuf)->frag_list == NULL)) {
+			dst_release(pBuf->dst);
+
+#ifdef CONFIG_XFRM
+			secpath_put(pBuf->sp);
+#endif
+
+			if (pBuf->destructor) {
+				pBuf->destructor(pBuf);
+			}
+#ifdef CONFIG_NETFILTER
+			nf_conntrack_put(pBuf->nfct);
+#ifdef CONFIG_BRIDGE_NETFILTER
+			nf_bridge_put(pBuf->nf_bridge);
+#endif
+#endif
+
+			__skb_queue_tail(&refillQueue[pEmacDevice->uInterfaceNo], pBuf);
+		} else
+#endif
+		{
+			dev_kfree_skb(pBuf);	/*  delete sk buffer */
+		}
+		pktSent = 1;
+
+		if (ENET_TX_CTL_INFO_CARR_LOSS == (ENET_TX_CTL_INFO_CARR_LOSS & info)) {
+			pEmacDevice->Stats.uTxCarrLossCnt++;
+			pktSent = 0;
+		}
+		if (ENET_TX_CTL_INFO_DEFER == (ENET_TX_CTL_INFO_DEFER & info)) {
+			pEmacDevice->Stats.uTxDeferredCnt++;
+		}
+		if (ENET_TX_CTL_INFO_DROPPED == (ENET_TX_CTL_INFO_DROPPED & info)) {
+			pEmacDevice->Stats.uTxDropCnt++;
+			pktSent = 0;
+		}
+		pEmacDevice->Stats.uTxRetryCnt += ((ENET_TX_CTL_INFO_RETRY & info) >> ENET_TX_CTL_INFO_RETRY_SHIFT);
+		if (ENET_TX_CTL_INFO_LATE_COLL == (ENET_TX_CTL_INFO_LATE_COLL & info)) {
+			pEmacDevice->Stats.uTxLateCollisionDropCnt++;
+			pktSent = 0;
+		}
+		if (ENET_TX_CTL_INFO_UFLO == (ENET_TX_CTL_INFO_UFLO & info)) {
+			pEmacDevice->Stats.uTxUnderflowErrCnt++;
+			pktSent = 0;
+		}
+		if (1 == pktSent) {
+			pEmacDevice->Stats.uTxPktCnt++;
+			if (lenBuf < (EMAC_FRAMESIZE_MIN - FRAME_CHECKSUM_SIZE)) {
+				pEmacDevice->Stats.uTxByteCnt += (EMAC_FRAMESIZE_MIN - FRAME_CHECKSUM_SIZE);	/* Auto Pad included */
+			} else {
+				pEmacDevice->Stats.uTxByteCnt += lenBuf;
+			}
+		}
+		/* Clear the descriptor */
+		tx_desc_ptr->puData = NULL;
+		tx_refil_local_ptr->puData = NULL;
+		tx_desc_ptr++;
+		tx_refil_local_ptr++;
+
+		/* Update the BDT polling pointers to start point, if it crosses end point */
+		if (tx_desc_ptr > pEmacDevice->tx_last_desc) {
+			tx_desc_ptr = pEmacDevice->tx_first_desc;
+			tx_refil_local_ptr = pEmacDevice->tx_first_local;
+		}
+		/* decrement sk buffers transmission pending counter */
+		pEmacDevice->TxQDepth--;
+
+		if (pEmacDevice->TxQDepth < EMAC_WAKE_QUEUE_THRESHHOLD) {
+			netif_wake_queue(pEmacDevice->hNetDev);
+		}
+
+		/* Ensure info and ptr has updated value */
+		info = tx_desc_ptr->uInfo;
+		ptr = tx_desc_ptr->puData;
+	}
+
+	pEmacDevice->tx_refil = tx_desc_ptr;
+	pEmacDevice->tx_refil_local = tx_refil_local_ptr;
+	/* Fill the Tx Descriptor which are empty */
+	StartTransmit(pEmacDevice);
+
+	local_irq_disable();
+	status = (*((volatile unsigned long *) EMAC_ENABLE_REG(pEmacDevice->uInterfaceNo))) | 1;
+	(*((volatile unsigned long *) EMAC_ENABLE_REG(pEmacDevice->uInterfaceNo))) = status;
+	local_irq_enable();
+
+}
+
+
+/* Tasklet handler for RXINT post processing. Traverse through the RX buffer 
+ * descriptors.  If OWN bit is 0 and LAST bit is 1 in INFO field of the buffer 
+ * descriptor, then call netif_rx(Buf) to pass the buffer to higher protocol 
+ * layer.
+ */
+static void RxInterruptPostProcessing(unsigned long data)
+{
+	EMAC_BUF_DESCR *rx_desc_ptr;
+	EMAC_LOCAL_BUF *rx_local_ptr;
+	register unsigned long info;
+	register unsigned char *ptr;
+	unsigned long status;
+	struct sk_buff *pBuf, *rpBuf;
+	unsigned long lenBuf = 0;
+	EMAC_DEVICE *pEmacDevice = (EMAC_DEVICE *) data;
+	lenBuf = EMAC_FRAMESIZE_MAX;
+	local_irq_disable();
+	status = (*((volatile unsigned long *) EMAC_ENABLE_REG(pEmacDevice->uInterfaceNo))) & (~(1UL << 1));
+	(*((volatile unsigned long *) EMAC_ENABLE_REG(pEmacDevice->uInterfaceNo))) = status;
+	local_irq_enable();
+
+	rx_desc_ptr = pEmacDevice->rx_curr;
+	rx_local_ptr = pEmacDevice->rx_curr_local;
+
+	/* Ensure info and ptr has updated value */
+	info = rx_desc_ptr->uInfo;
+	ptr = rx_desc_ptr->puData;
+	/* Check we own the buffer */
+	while (!(info & ENET_RX_CTL_INFO_OWN)) {
+		pBuf = (struct sk_buff *) (rx_local_ptr->puData);
+		rpBuf = dev_alloc_skb(lenBuf);
+		if (rpBuf != NULL) {
+			/* Confirm packet is stored in single BDT's */
+			if ((info & ENET_RX_CTL_INFO_FIRST) && (info & ENET_RX_CTL_INFO_LAST)) {
+				unsigned long len;
+				len = info & ENET_RX_CTL_INFO_CPU_RX_LEN;
+				/* Valid Ethernet Packet */
+				if ((len >= EMAC_FRAMESIZE_MIN) && (len <= EMAC_FRAMESIZE_MAX)) {
+					skb_reserve(rpBuf, SKB_PREFIX_LEN);
+					rx_desc_ptr->puData = (unsigned char *) dma_map_single(NULL, rpBuf->tail, EMAC_RX_FRAMESIZE_MAX, DMA_FROM_DEVICE);
+					rx_local_ptr->puData = rpBuf;
+					pEmacDevice->Stats.uRxPktCnt++;
+					pEmacDevice->Stats.uRxByteCnt += (len - FRAME_CHECKSUM_SIZE);	/* Remove FCS */
+					skb_put(pBuf, len);
+					pBuf->dev = pEmacDevice->hNetDev;
+					pBuf->dev->last_rx = jiffies;
+					/* find the frame protocol */
+					pBuf->protocol = eth_type_trans(pBuf, pBuf->dev);
+					if (pBuf->pkt_type == PACKET_MULTICAST) {
+						pEmacDevice->Stats.uRxMulticastPktCnt++;
+					}
+					pBuf->ip_summed = CHECKSUM_NONE;
+					/* Pass packet to upper layer */
+					netif_rx(pBuf);
+				} else {
+					if ((len < EMAC_FRAMESIZE_MIN)) {
+						pEmacDevice->Stats.uRxShortPktErrCnt++;
+						dev_kfree_skb(rpBuf);	/*  delete sk buffer */
+#ifdef PECOS_ETH_TESTPRINT
+						EMACDBG("Rx Short PKT ignored \n");
+#endif
+					} else {
+						pEmacDevice->Stats.uRxLongPktErrCnt++;
+						dev_kfree_skb(rpBuf);	/*  delete sk buffer */
+#ifdef PECOS_ETH_TESTPRINT
+						EMACDBG("Rx Long PKT ignored \n");
+#endif
+					}
+				}
+			} else {
+				pEmacDevice->Stats.uRxChainErrCnt++;
+				dev_kfree_skb(rpBuf);	/*  delete sk buffer */
+#ifdef PECOS_ETH_TESTPRINT
+				EMACDBG("Receive Interrupt but not the last bit set PKT ignored\n");
+#endif
+
+			}
+		} else {
+			pEmacDevice->Stats.uRxBuffDropCnt++;
+#ifdef PECOS_ETH_TESTPRINT
+			EMACDBG("No SKBUFF PKT ignored\n");
+#endif
+		}
+		/* Update the BDT to receive packet */
+		rx_desc_ptr->uInfo = EMAC_RX_FRAMESIZE_MAX | ENET_RX_CTL_INFO_OWN;
+
+		/* Update descriptor */
+		rx_desc_ptr++;
+		rx_local_ptr++;
+		/* Update the BDT polling pointers to start point, if it crosses end point */
+		if (rx_desc_ptr > pEmacDevice->rx_last_desc) {
+			rx_desc_ptr = pEmacDevice->rx_first_desc;
+			rx_local_ptr = pEmacDevice->rx_first_local;
+		}
+		info = rx_desc_ptr->uInfo;
+		ptr = rx_desc_ptr->puData;
+	}
+
+	pEmacDevice->rx_curr = rx_desc_ptr;
+	pEmacDevice->rx_curr_local = rx_local_ptr;
+
+	local_irq_disable();
+	status = (*((volatile unsigned long *) EMAC_ENABLE_REG(pEmacDevice->uInterfaceNo))) | (1UL << 1);
+	(*((volatile unsigned long *) EMAC_ENABLE_REG(pEmacDevice->uInterfaceNo))) = status;
+	local_irq_enable();
+
+}
+
+#if 0
+/* Allocate buffer for the Rx buffer descriptors for whom the buffer ptr is 
+ * marked as NULL
+ */
+static void RxBufferRefillHandler(EMAC_DEVICE * pEmacDevice)
+{
+	EMAC_BUF_DESCR *rx_refil_ptr;
+	EMAC_LOCAL_BUF *rx_refil_local_ptr;
+	unsigned char *ptr;
+	unsigned char *puData;
+	unsigned long lenBuf = 0;
+	struct sk_buff *pBuf = NULL;
+
+#ifdef SKB_CLONE
+	unsigned long trueSize = 0;
+#endif
+
+	lenBuf = EMAC_FRAMESIZE_MAX;
+	rx_refil_ptr = pEmacDevice->rx_refil;
+	rx_refil_local_ptr = pEmacDevice->rx_refil_local;
+	ptr = rx_refil_ptr->puData;
+	/*refillTime_stamp[pEmacDevice->PhysicalPort]=jiffies; */
+	while (ptr == NULL) {
+#ifdef SKB_CLONE
+		pBuf = 0;
+		if (refillQueue[pEmacDevice->uInterfaceNo].qlen != 0) {
+			pBuf = __skb_dequeue(&refillQueue[pEmacDevice->uInterfaceNo]);
+		}
+		if (pBuf) {
+			trueSize = pBuf->truesize;
+			memset(pBuf, 0, offsetof(struct sk_buff, truesize));
+			pBuf->truesize = trueSize;
+			pBuf->data = pBuf->head;
+			pBuf->tail = pBuf->head;
+			/* pBuf->end = pBuf->head + EMAC_FRAMESIZE_MAX; */
+			atomic_set(&(pBuf->users), 1);
+			atomic_set(&(skb_shinfo(pBuf)->dataref), 1);
+			skb_shinfo(pBuf)->nr_frags = 0;
+			skb_shinfo(pBuf)->tso_size = 0;
+			skb_shinfo(pBuf)->tso_segs = 0;
+			skb_shinfo(pBuf)->frag_list = 0;
+		}
+#if 0
+		else if (refill_queue_len < pEmacDevice->uRxDescCount) {
+			refill_queue_len = pEmacDevice->uMaxTxQDepth;
+		}
+#endif
+
+#endif
+
+#ifdef SKB_CLONE
+		if (!pBuf) {
+#endif
+			pBuf = dev_alloc_skb(lenBuf);
+
+#ifdef SKB_CLONE
+		}
+#endif
+
+		skb_reserve(pBuf, SKB_PREFIX_LEN);
+		puData = pBuf->data;
+
+		/* Fill in the descriptor, and give to mac */
+		if (pBuf) {
+			rx_refil_local_ptr->puData = pBuf;
+			/* The compiler would turn the write of info and ptr into
+			 * a stm, but if it did not (eg optimization was not possible),
+			 * the driver might fail as ptr must be updated at the same
+			 * time as info
+			 * So we manually stm it
+			 */
+			{
+				rx_refil_ptr->puData = (unsigned char *) dma_map_single(NULL, pBuf->tail, EMAC_RX_FRAMESIZE_MAX, DMA_FROM_DEVICE);
+				/* To prevent Rx buffer chaining the value should be greater than max frame size expected */
+				rx_refil_ptr->uInfo = EMAC_RX_FRAMESIZE_MAX | ENET_RX_CTL_INFO_OWN;
+			}
+
+			rx_refil_ptr++;
+			rx_refil_local_ptr++;
+			if (rx_refil_ptr > pEmacDevice->rx_last_desc) {
+				rx_refil_ptr = pEmacDevice->rx_first_desc;
+				rx_refil_local_ptr = pEmacDevice->rx_first_local;
+			}
+			ptr = rx_refil_ptr->puData;
+		} else {
+			break;
+		}
+	}
+
+	pEmacDevice->rx_refil = rx_refil_ptr;
+	pEmacDevice->rx_refil_local = rx_refil_local_ptr;
+
+}
+#endif
+
+/* Enables autonegotiation and sets the advertise parameter as per set values */
+void emac_media_autonegotiate(struct net_device *dev)
+{
+	unsigned long uData;
+	EMAC_DEVICE *pEmacDevice;
+
+	pEmacDevice = (EMAC_DEVICE *) netdev_priv(dev);
+	/* Get current MII_ADVERTISE value */
+	uData = EmacReadReg_PHY(dev, pEmacDevice->mii_if.phy_id, PHY_AUTONEG_ADV_REG);
+	/* Discard old speed and duplex settings */
+	uData &= ~(ADVERTISE_100HALF | ADVERTISE_100FULL | ADVERTISE_10HALF | ADVERTISE_10FULL);
+
+	switch (pEmacDevice->uCurrent_speed_select) {
+		/* Advertising Speed set for 10 Mbps,check mode of operation as below */
+	case SPEED_10MBPS:
+		if (pEmacDevice->uCurrent_duplex_select == FULL_DUPLEX) {
+			uData |= ADVERTISE_10FULL;
+		} else if (pEmacDevice->uCurrent_duplex_select == HALF_DUPLEX) {
+			uData |= ADVERTISE_10HALF;
+		} else {
+			uData |= ADVERTISE_10HALF | ADVERTISE_10FULL;
+		}
+
+		break;
+		/* Advertising Speed set for 100 Mbps,check mode of operation as below */
+	case SPEED_100MBPS:	/* 100 Mbps */
+		if (pEmacDevice->uCurrent_duplex_select == FULL_DUPLEX) {
+			uData |= ADVERTISE_100FULL;
+		} else if (pEmacDevice->uCurrent_duplex_select == HALF_DUPLEX) {
+			uData |= ADVERTISE_100HALF;
+		} else {
+			uData |= ADVERTISE_100HALF | ADVERTISE_100FULL;
+		}
+
+		break;
+		/* Advertising Speed set for autoneg default,check mode of operation as below */
+	case AUTO_SPEED:	/* Auto */
+		if (pEmacDevice->uCurrent_duplex_select == FULL_DUPLEX) {
+			uData |= ADVERTISE_100FULL | ADVERTISE_10FULL;
+		} else if (pEmacDevice->uCurrent_duplex_select == HALF_DUPLEX) {
+			uData |= ADVERTISE_100HALF | ADVERTISE_10HALF;
+		} else {
+			uData |= ADVERTISE_10HALF | ADVERTISE_10FULL | ADVERTISE_100HALF | ADVERTISE_100FULL;
+		}
+
+		break;
+
+	default:		/* assume autoneg default speed and duplex */
+		uData |= ADVERTISE_10HALF | ADVERTISE_10FULL | ADVERTISE_100HALF | ADVERTISE_100FULL;
+	}
+
+	EmacWriteReg_PHY(dev, pEmacDevice->mii_if.phy_id, PHY_AUTONEG_ADV_REG, uData);
+	/* Renegotiate with link partner */
+	uData = EmacReadReg_PHY(dev, pEmacDevice->mii_if.phy_id, PHY_CTRL_REG);
+	uData |= BMCR_ANENABLE | BMCR_ANRESTART;
+	EmacWriteReg_PHY(dev, pEmacDevice->mii_if.phy_id, PHY_CTRL_REG, uData);
+	pEmacDevice->mii_if.force_media = 0;
+}
+
+/* Disables autonegotiation and forces the speed/duplex */
+void emac_media_force(struct net_device *dev, EMAC_SPEED uSpeed, EMAC_DUPLEX uDuplex)
+{
+	EMAC_DEVICE *pEmacDevice;
+	int uData;
+
+	pEmacDevice = (EMAC_DEVICE *) netdev_priv(dev);
+	uData = EmacReadReg_PHY(dev, pEmacDevice->mii_if.phy_id, PHY_CTRL_REG);
+	/* Disable autonegotiation and set default speed 10Mbps and Half duplex */
+	uData &= ~(PHY_CTRL_AUTONEG + PHY_CTRL_SPEED + PHY_CTRL_DUPLEX);
+	pEmacDevice->uSpeed = SPEED_10MBPS;
+	pEmacDevice->uMode = HALF_DUPLEX;
+	if (uSpeed == SPEED_100MBPS) {
+		pEmacDevice->uSpeed = SPEED_100MBPS;
+		uData |= PHY_CTRL_SPEED;	/* 100Mbps */
+	}
+	if (uDuplex == FULL_DUPLEX) {
+		pEmacDevice->uMode = FULL_DUPLEX;
+		uData |= PHY_CTRL_DUPLEX;	/* Full duplex */
+	}
+	EmacWriteReg_PHY(dev, pEmacDevice->mii_if.phy_id, PHY_CTRL_REG, uData);
+	/* Duplex changed, Update EMAC */
+	uData = (*((volatile unsigned long *) EMAC_CONTROL_REG(pEmacDevice->uInterfaceNo)));
+	if (FULL_DUPLEX == pEmacDevice->uMode) {
+		uData |= (1UL << 10);
+	} else {
+		uData &= (~(1UL << 10));
+	}
+	(*((volatile unsigned long *) EMAC_CONTROL_REG(pEmacDevice->uInterfaceNo))) = uData;
+	pEmacDevice->mii_if.force_media = 1;
+}
+
+#ifdef EMAC_MEDIA_MAINTANANCE
+/* Thread to update Media condition */
+int emac_media_check(void *dev)
+{
+	int devNo;
+	unsigned int uTmpVal;
+	EMAC_DUPLEX old_duplex;
+	EMAC_DEVICE *pEmacDevice;
+
+	while (1) {
+
+#ifdef CONFIG_CNXT_EMAC0_ENABLE
+#ifdef CONFIG_CNXT_EMAC1_ENABLE
+		for (devNo = 0; devNo < MAX_EMAC; devNo++)
+#else
+		for (devNo = 0; devNo < (MAX_EMAC - 1); devNo++)
+#endif
+#else
+#ifdef CONFIG_CNXT_EMAC1_ENABLE
+		for (devNo = 1; devNo < MAX_EMAC; devNo++)
+#endif
+#endif
+		{
+
+			pEmacDevice = (EMAC_DEVICE *) netdev_priv(gNetDevice[devNo]);
+			old_duplex = pEmacDevice->uMode;
+			if (pEmacDevice->uMDIO_support) {
+				/* Check media changes */
+				pEmacDevice->media_check_func(gNetDevice[devNo]);
+				if (old_duplex != pEmacDevice->uMode) {
+					/* Duplex changed, Update EMAC */
+					uTmpVal = (*((volatile unsigned long *) EMAC_CONTROL_REG(pEmacDevice->uInterfaceNo)));
+					if (FULL_DUPLEX == pEmacDevice->uMode) {
+						uTmpVal |= (1UL << 10);
+					} else {
+						uTmpVal &= (~(1UL << 10));
+					}
+					(*((volatile unsigned long *) EMAC_CONTROL_REG(pEmacDevice->uInterfaceNo))) = uTmpVal;
+				}
+				pEmacDevice->mii_if.full_duplex = pEmacDevice->uMode;
+			}
+
+		}
+
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(1 * HZ);
+		if (gThreadExitReq) {
+			break;
+		}
+	}
+	complete_and_exit(&gThreadExitComplete, 0);
+	return 0;
+}
+#endif
+
+#ifdef EMAC_MEDIA_MAINTANANCE
+
+/* Function which check media speed and mode for realtek8201 */
+static void realtek8201_media_check(struct net_device *dev)
+{
+	unsigned long uData, old_carrier, new_carrier;
+	EMAC_DEVICE *pEmacDevice;
+	pEmacDevice = (EMAC_DEVICE *) netdev_priv(dev);
+	/* Check current link speed / mode */
+	uData = EmacReadReg_PHY(dev, pEmacDevice->mii_if.phy_id, REALTEK8201_MEDIACHEK_REG);
+	/* Realtek8201 Speed check bit */
+	if (uData & REALTEK8201_PHY_SPEED) {
+		pEmacDevice->uSpeed = SPEED_100MBPS;
+	} else {
+		pEmacDevice->uSpeed = SPEED_10MBPS;
+	}
+	/* Realtek8201 Mode check bit */
+	if (uData & REALTEK8201_PHY_MODE) {
+		pEmacDevice->uMode = FULL_DUPLEX;
+	} else {
+		pEmacDevice->uMode = HALF_DUPLEX;
+	}
+	/* previous link status */
+	old_carrier = netif_carrier_ok(pEmacDevice->mii_if.dev) ? 1 : 0;
+	/* get link status from PHY */
+	uData = EmacReadReg_PHY(dev, pEmacDevice->mii_if.phy_id, PHY_STATUS_REG);
+	/* Current link status */
+	new_carrier = (uData & PHY_STATUS_LINK_STATUS) ? 1 : 0;
+
+	/* Changes in Link status */
+	if (old_carrier != new_carrier) {
+		/* Link is Up */
+		if (new_carrier) {
+			netif_carrier_on(pEmacDevice->mii_if.dev);
+//#ifdef PECOS_ETH_TESTPRINT
+			EMACDBG("RealTek 8201 PHY %s: Link Up %d Mbps %s \n", dev->name, ((pEmacDevice->uSpeed == SPEED_100MBPS) ? 100 : 10), ((pEmacDevice->uMode == FULL_DUPLEX) ? "Full Duplex" : "Half Duplex"));
+//#endif
+		} else {
+			netif_carrier_off(pEmacDevice->mii_if.dev);
+//#ifdef PECOS_ETH_TESTPRINT
+			EMACDBG("RealTek 8201 PHY %s: Link down\n", dev->name);
+//#endif
+		}
+	}
+
+	return;
+}
+
+/* IP101 is compatible with the 8201 */
+static void ip101_media_check(struct net_device *dev)
+{
+	realtek8201_media_check(dev);
+}
+
+/* Function which check media speed and mode for Lxt972 */
+static void lxt972_media_check(struct net_device *dev)
+{
+
+	unsigned long uData, old_carrier, new_carrier;
+	EMAC_DEVICE *pEmacDevice;
+	pEmacDevice = (EMAC_DEVICE *) netdev_priv(dev);
+	/* Check current link speed / mode */
+	uData = EmacReadReg_PHY(dev, pEmacDevice->mii_if.phy_id, LXT972_MEDIACHEK_REG);
+
+	/* Lxt972 Speed check bit */
+	if (uData & LXT972_PHY_SPEED) {
+		pEmacDevice->uSpeed = SPEED_100MBPS;
+	} else {
+		pEmacDevice->uSpeed = SPEED_10MBPS;
+	}
+	/* Lxt972 Mode check bit */
+	if (uData & LXT972_PHY_MODE) {
+		pEmacDevice->uMode = FULL_DUPLEX;
+	} else {
+		pEmacDevice->uMode = HALF_DUPLEX;
+	}
+
+	/* previous link status */
+	old_carrier = netif_carrier_ok(pEmacDevice->mii_if.dev) ? 1 : 0;
+	/* get link status from PHY */
+	uData = EmacReadReg_PHY(dev, pEmacDevice->mii_if.phy_id, PHY_STATUS_REG);
+	/* Current link status */
+	new_carrier = (uData & PHY_STATUS_LINK_STATUS) ? 1 : 0;
+	/* Changes in Link status */
+	if (old_carrier != new_carrier) {
+		/* Link is Up */
+		if (new_carrier) {
+			netif_carrier_on(pEmacDevice->mii_if.dev);
+#ifdef PECOS_ETH_TESTPRINT
+			EMACDBG("LXT 972 PHY %s: Link Up %d Mbps %s \n", dev->name, ((pEmacDevice->uSpeed == SPEED_100MBPS) ? 100 : 10), ((pEmacDevice->uMode == FULL_DUPLEX) ? "Full Duplex" : "Half Duplex"));
+#endif
+		} else {
+			netif_carrier_off(pEmacDevice->mii_if.dev);
+#ifdef PECOS_ETH_TESTPRINT
+			EMACDBG("LXT 972 PHY %s: Link down\n", dev->name);
+#endif
+		}
+	}
+
+	return;
+}
+
+/* Function which check link condition is for general devices,
+ where speed/mode is fixed */
+static void general_media_check(struct net_device *dev)
+{
+	unsigned long uData, old_carrier, new_carrier;
+	EMAC_DEVICE *pEmacDevice;
+	pEmacDevice = (EMAC_DEVICE *) netdev_priv(dev);
+
+	/* previous link status */
+	old_carrier = netif_carrier_ok(pEmacDevice->mii_if.dev) ? 1 : 0;
+	/* get link status from PHY */
+	uData = EmacReadReg_PHY(dev, pEmacDevice->mii_if.phy_id, PHY_STATUS_REG);
+	/* Current link status */
+	new_carrier = (uData & PHY_STATUS_LINK_STATUS) ? 1 : 0;
+	/* Changes in Link status */
+	if (old_carrier != new_carrier) {
+		/* Link is Up */
+		if (new_carrier) {
+			netif_carrier_on(pEmacDevice->mii_if.dev);
+#ifdef PECOS_ETH_TESTPRINT
+			EMACDBG("General PHY %s: Link Up %d Mbps %s \n", dev->name, ((pEmacDevice->uSpeed == SPEED_100MBPS) ? 100 : 10), ((pEmacDevice->uMode == FULL_DUPLEX) ? "Full Duplex" : "Half Duplex"));
+#endif
+		} else {
+			netif_carrier_off(pEmacDevice->mii_if.dev);
+#ifdef PECOS_ETH_TESTPRINT
+			EMACDBG("General PHY %s: Link down\n", dev->name);
+#endif
+		}
+	}
+
+	return;
+}
+#endif
+
+int EmacReadReg_PHY(struct net_device *dev, int PhyAddr, int RegNo)
+{
+	unsigned long readData;
+	unsigned long mdio_reg;
+	unsigned long count;
+	EMAC_DEVICE *pEmacDevice;
+
+	pEmacDevice = (EMAC_DEVICE *) netdev_priv(dev);
+
+	mdio_reg = (1UL << 30) | (2UL << 28) | (1UL << 17);
+	mdio_reg |= ((PhyAddr << 23) & 0x0F800000);
+	mdio_reg |= ((RegNo << 18) & 0x007C0000);
+
+	/* Lock the hardware */
+	down(&pEmacDevice->mutex);
+	/* Start read */
+	(*((volatile unsigned long *) EMAC_MDIO_REG(pEmacDevice->uInterfaceNo))) = mdio_reg;
+	/* Wait for completion */
+	count = 0;
+	while (!((*((volatile unsigned long *) EMAC_STAT_REG(pEmacDevice->uInterfaceNo))) & (1UL << 12))) {
+		count++;
+		udelay(EMAC_DELAY);
+		if (count > EMAC_LOCKUP_WAIT) {
+			break;
+		}
+	}
+	/* Read data */
+	mdio_reg = (*((volatile unsigned long *) EMAC_MDIO_REG(pEmacDevice->uInterfaceNo)));
+	/* Ack irq */
+	(*((volatile unsigned long *) EMAC_STAT_REG(pEmacDevice->uInterfaceNo))) = (1UL << 12);
+	/* unlock */
+	up(&pEmacDevice->mutex);
+	readData = mdio_reg & 0x0000FFFF;
+
+	return readData;
+}
+
+void EmacWriteReg_PHY(struct net_device *dev, int PhyAddr, int RegNo, int Data)
+{
+	unsigned long mdio_reg;
+	unsigned long count;
+	EMAC_DEVICE *pEmacDevice;
+
+	pEmacDevice = (EMAC_DEVICE *) netdev_priv(dev);
+
+	mdio_reg = (1UL << 30) | (1UL << 28) | (1UL << 17);
+	mdio_reg |= ((PhyAddr << 23) & 0x0F800000);
+	mdio_reg |= ((RegNo << 18) & 0x007C0000);
+	mdio_reg |= (Data & 0x0000FFFF);
+
+	/* Lock the hardware */
+	down(&pEmacDevice->mutex);
+	/* Start read */
+	(*((volatile unsigned long *) EMAC_MDIO_REG(pEmacDevice->uInterfaceNo))) = mdio_reg;
+	/* Wait for completion */
+	count = 0;
+	while (!((*((volatile unsigned long *) EMAC_STAT_REG(pEmacDevice->uInterfaceNo))) & (1UL << 12))) {
+		count++;
+		udelay(EMAC_DELAY);
+		if (count > EMAC_LOCKUP_WAIT) {
+			break;
+		}
+	}
+
+	/* Ack irq */
+	(*((volatile unsigned long *) EMAC_STAT_REG(pEmacDevice->uInterfaceNo))) = (1UL << 12);
+	/* unlock */
+	up(&pEmacDevice->mutex);
+}
+
+/* EMAC CONTROL/STATUS FUNCTIONS */
+int emac_set_activity(struct net_device *dev, unsigned short uEnable)
+{
+	int retVal;
+	unsigned long tmpVal;
+	EMAC_DEVICE *pEmacDevice;
+
+	pEmacDevice = (EMAC_DEVICE *) netdev_priv(dev);
+	retVal = 0;
+	tmpVal = (*((volatile unsigned long *) EMAC_CONTROL_REG(pEmacDevice->uInterfaceNo)));
+	if (1 == uEnable) {
+		tmpVal |= 1;
+	} else {
+		tmpVal &= (~1);
+	}
+	(*((volatile unsigned long *) EMAC_CONTROL_REG(pEmacDevice->uInterfaceNo))) = tmpVal;
+
+	return retVal;
+}
+
+int emac_set_transmit_activity(struct net_device *dev, unsigned short uEnable)
+{
+	int retVal;
+	unsigned long tmpVal;
+	EMAC_DEVICE *pEmacDevice;
+
+	pEmacDevice = (EMAC_DEVICE *) netdev_priv(dev);
+	retVal = 0;
+	tmpVal = (*((volatile unsigned long *) EMAC_CONTROL_REG(pEmacDevice->uInterfaceNo)));
+	if (1 == uEnable) {
+		tmpVal |= (1UL << 3);
+	} else {
+		tmpVal &= (~(1UL << 3));
+	}
+	(*((volatile unsigned long *) EMAC_CONTROL_REG(pEmacDevice->uInterfaceNo))) = tmpVal;
+
+	return retVal;
+}
+
+int emac_set_receive_activity(struct net_device *dev, unsigned short uEnable)
+{
+	unsigned long tmpVal;
+	EMAC_DEVICE *pEmacDevice;
+
+	pEmacDevice = (EMAC_DEVICE *) netdev_priv(dev);
+	tmpVal = (*((volatile unsigned long *) EMAC_CONTROL_REG(pEmacDevice->uInterfaceNo)));
+	if (1 == uEnable) {
+		tmpVal |= (1UL << 4);
+	} else {
+		tmpVal &= (~(1UL << 4));
+	}
+	(*((volatile unsigned long *) EMAC_CONTROL_REG(pEmacDevice->uInterfaceNo))) = tmpVal;
+
+	return 0;
+}
+
+int emac_set_broadcast(struct net_device *dev, unsigned short uEnable)
+{
+	unsigned long tmpVal;
+	EMAC_DEVICE *pEmacDevice;
+
+	pEmacDevice = (EMAC_DEVICE *) netdev_priv(dev);
+	tmpVal = (*((volatile unsigned long *) EMAC_CONTROL_REG(pEmacDevice->uInterfaceNo)));
+	if (1 == uEnable) {
+		tmpVal &= (~(1UL << 8));
+	} else {
+		tmpVal |= (1UL << 8);
+	}
+	(*((volatile unsigned long *) EMAC_CONTROL_REG(pEmacDevice->uInterfaceNo))) = tmpVal;
+
+	return 0;
+}
+
+int emac_set_promiscuous(struct net_device *dev, unsigned short uEnable)
+{
+	unsigned long tmpVal;
+	EMAC_DEVICE *pEmacDevice;
+
+	pEmacDevice = (EMAC_DEVICE *) netdev_priv(dev);
+	tmpVal = (*((volatile unsigned long *) EMAC_CONTROL_REG(pEmacDevice->uInterfaceNo)));
+	if (1 == uEnable) {
+		tmpVal |= (1UL << 11);
+	} else {
+		tmpVal &= (~(1UL << 11));
+	}
+	(*((volatile unsigned long *) EMAC_CONTROL_REG(pEmacDevice->uInterfaceNo))) = tmpVal;
+
+	return 0;
+}
+
+int emac_set_bdt_poolrate(struct net_device *dev, unsigned long uRate)
+{
+	EMAC_DEVICE *pEmacDevice;
+
+	pEmacDevice = (EMAC_DEVICE *) netdev_priv(dev);
+	(*((volatile unsigned long *) EMAC_POLLRATE_REG(pEmacDevice->uInterfaceNo))) = uRate;
+
+	return 0;
+}
+
+int emac_get_bdt_poolrate(struct net_device *dev, unsigned long *puRate)
+{
+	EMAC_DEVICE *pEmacDevice;
+
+	pEmacDevice = (EMAC_DEVICE *) netdev_priv(dev);
+	*puRate = (*((volatile unsigned long *) EMAC_POLLRATE_REG(pEmacDevice->uInterfaceNo)));
+
+	return 0;
+}
+
+unsigned long emac_get_transmit_bdt_length(struct net_device *dev)
+{
+	int retVal;
+	EMAC_DEVICE *pEmacDevice;
+
+	pEmacDevice = (EMAC_DEVICE *) netdev_priv(dev);
+
+	retVal = 0;
+
+	retVal = (*((volatile unsigned long *) EMAC_CONTROL_REG(pEmacDevice->uInterfaceNo)));
+	retVal &= 0x00FF0000;
+	retVal >>= 16;
+
+	return retVal;
+}
+
+unsigned long emac_get_receive_bdt_length(struct net_device *dev)
+{
+	int retVal;
+	EMAC_DEVICE *pEmacDevice;
+
+	pEmacDevice = (EMAC_DEVICE *) netdev_priv(dev);
+
+	retVal = 0;
+	retVal = (*((volatile unsigned long *) EMAC_CONTROL_REG(pEmacDevice->uInterfaceNo)));
+	retVal &= 0xFF000000;
+	retVal >>= 24;
+
+	return retVal;
+}
+
+/* PHY DETECT FUNCTION */
+int phy_detect(struct net_device *dev)
+{
+
+	unsigned int count;
+	EMAC_DEVICE *pEmacDevice;
+
+	pEmacDevice = (EMAC_DEVICE *) netdev_priv(dev);
+
+	/* Probe MDIO physical address */
+	for (count = 0; count < PHY_ADDR_MAX; count++) {
+		if (EmacReadReg_PHY(dev, count, PHY_STATUS_REG) != 0xffff) {
+			break;
+		}
+	}
+
+	if (count == PHY_ADDR_MAX) {
+		return -1;	/*ENODEV */
+	}
+
+	/* Asign MDIO address */
+	pEmacDevice->mii_if.phy_id = count;
+
+	return 0;
+}
+
+#ifdef EMAC_MEDIA_MAINTANANCE
+void select_media_check_function(struct net_device *dev)
+{
+	unsigned int phyid_high;
+	unsigned int phyid_low;
+	unsigned int phyid;
+	struct phy_media_check *phy = NULL;
+	EMAC_DEVICE *pEmacDevice;
+
+	pEmacDevice = (EMAC_DEVICE *) netdev_priv(dev);
+
+	/* Get Phy ID */
+	phyid_high = EmacReadReg_PHY(dev, pEmacDevice->mii_if.phy_id, PHY_IDENTIFIER_REG1);
+	phyid_low = EmacReadReg_PHY(dev, pEmacDevice->mii_if.phy_id, PHY_IDENTIFIER_REG2);
+	phyid = (phyid_high << 16) | phyid_low;	/* Get PHY ID */
+
+	for (phy = &phy_list[0]; phy->phy_id; phy++) {
+		if (phy->phy_id == phyid) {	/* Is read phyid matches with phy_id in function table */
+			/* Phy media check function */
+			pEmacDevice->media_check_func = phy->media_check_func;
+			return;
+		}
+	}
+
+	pEmacDevice->media_check_func = phy->media_check_func;
+	return;
+
+}
+#endif
+/* PHY CONTROLLING / STATUS FUNCTIONS */
+
+void phy_reset(struct net_device *dev)
+{
+	unsigned long tmpVal;
+	EMAC_DEVICE *pEmacDevice;
+
+	pEmacDevice = (EMAC_DEVICE *) netdev_priv(dev);
+	tmpVal = EmacReadReg_PHY(dev, pEmacDevice->mii_if.phy_id, PHY_CTRL_REG);
+	tmpVal |= PHY_CTRL_RESET;
+	EmacWriteReg_PHY(dev, pEmacDevice->mii_if.phy_id, PHY_CTRL_REG, tmpVal);
+}
+
+/* Depending on the EMAC setting for Duplex mode set the PHY */
+void phy_set_mode(struct net_device *dev, EMAC_DUPLEX uMode)
+{
+	unsigned long tmpVal;
+	EMAC_DEVICE *pEmacDevice;
+
+	pEmacDevice = (EMAC_DEVICE *) netdev_priv(dev);
+	tmpVal = EmacReadReg_PHY(dev, pEmacDevice->mii_if.phy_id, PHY_CTRL_REG);
+	if (FULL_DUPLEX == uMode) {
+		tmpVal |= PHY_CTRL_DUPLEX;
+	} else {
+		tmpVal &= (~PHY_CTRL_DUPLEX);
+	}
+	EmacWriteReg_PHY(dev, pEmacDevice->mii_if.phy_id, PHY_CTRL_REG, tmpVal);
+	pEmacDevice->uMode = uMode;
+}
+
+
+void phy_set_speed(struct net_device *dev, EMAC_SPEED uSpeed)
+{
+	unsigned long tmpVal;
+	EMAC_DEVICE *pEmacDevice;
+
+	pEmacDevice = (EMAC_DEVICE *) netdev_priv(dev);
+	tmpVal = EmacReadReg_PHY(dev, pEmacDevice->mii_if.phy_id, PHY_CTRL_REG);
+	if (SPEED_100MBPS == uSpeed) {
+		tmpVal |= PHY_CTRL_SPEED;
+	} else {
+		tmpVal &= (~PHY_CTRL_SPEED);
+	}
+	EmacWriteReg_PHY(dev, pEmacDevice->mii_if.phy_id, PHY_CTRL_REG, tmpVal);
+	pEmacDevice->uSpeed = uSpeed;
+}
+
+
+/* Depending on the EMAC setting for Duplex mode set the PHY */
+void phy_loopback(struct net_device *dev, unsigned short uMode)
+{
+	unsigned long tmpVal;
+	EMAC_DEVICE *pEmacDevice;
+
+	pEmacDevice = (EMAC_DEVICE *) netdev_priv(dev);
+	tmpVal = EmacReadReg_PHY(dev, pEmacDevice->mii_if.phy_id, PHY_CTRL_REG);
+	if (1 == uMode) {
+		tmpVal |= PHY_CTRL_LOOPBACK;
+	} else {
+		tmpVal &= (~PHY_CTRL_LOOPBACK);
+	}
+	EmacWriteReg_PHY(dev, pEmacDevice->mii_if.phy_id, PHY_CTRL_REG, tmpVal);
+}
+
+/* Set the PHY into powerdwn mode */
+void phy_powerdown(struct net_device *dev, unsigned short uMode)
+{
+	unsigned long tmpVal;
+	EMAC_DEVICE *pEmacDevice;
+
+	pEmacDevice = (EMAC_DEVICE *) netdev_priv(dev);
+	tmpVal = EmacReadReg_PHY(dev, pEmacDevice->mii_if.phy_id, PHY_CTRL_REG);
+	if (1 == uMode) {
+		tmpVal |= PHY_CTRL_POWERDOWN;
+	} else {
+		tmpVal &= (~PHY_CTRL_POWERDOWN);
+	}
+	EmacWriteReg_PHY(dev, pEmacDevice->mii_if.phy_id, PHY_CTRL_REG, tmpVal);
+}
+
+/* Isolate PHY */
+void phy_isolate(struct net_device *dev, unsigned short uMode)
+{
+	unsigned long tmpVal;
+	EMAC_DEVICE *pEmacDevice;
+
+	pEmacDevice = (EMAC_DEVICE *) netdev_priv(dev);
+	tmpVal = EmacReadReg_PHY(dev, pEmacDevice->mii_if.phy_id, PHY_CTRL_REG);
+	if (1 == uMode) {
+		tmpVal |= PHY_CTRL_ISOLATE;
+	} else {
+		tmpVal &= (~PHY_CTRL_ISOLATE);
+	}
+	EmacWriteReg_PHY(dev, pEmacDevice->mii_if.phy_id, PHY_CTRL_REG, tmpVal);
+}
+
+
+/* Enable collosion test */
+void phy_collisiontest(struct net_device *dev, unsigned short uMode)
+{
+	unsigned long tmpVal;
+	EMAC_DEVICE *pEmacDevice;
+
+	pEmacDevice = (EMAC_DEVICE *) netdev_priv(dev);
+	tmpVal = EmacReadReg_PHY(dev, pEmacDevice->mii_if.phy_id, PHY_CTRL_REG);
+	if (1 == uMode) {
+		tmpVal |= PHY_CTRL_COLL;
+	} else {
+		tmpVal &= (~PHY_CTRL_COLL);
+	}
+	EmacWriteReg_PHY(dev, pEmacDevice->mii_if.phy_id, PHY_CTRL_REG, tmpVal);
+}
+
+void phy_set_autonegotiation(struct net_device *dev, unsigned short uValue)
+{
+	unsigned long tmpVal;
+	EMAC_DEVICE *pEmacDevice;
+
+	pEmacDevice = (EMAC_DEVICE *) netdev_priv(dev);
+	tmpVal = EmacReadReg_PHY(dev, pEmacDevice->mii_if.phy_id, PHY_CTRL_REG);
+	if (1 == uValue) {
+		tmpVal |= PHY_CTRL_AUTONEG;
+	} else {
+		tmpVal &= (~PHY_CTRL_AUTONEG);
+	}
+	EmacWriteReg_PHY(dev, pEmacDevice->mii_if.phy_id, PHY_CTRL_REG, tmpVal);
+}
+
+void phy_restart_autonegotiation(struct net_device *dev)
+{
+	unsigned long tmpVal;
+	EMAC_DEVICE *pEmacDevice;
+
+	pEmacDevice = (EMAC_DEVICE *) netdev_priv(dev);
+	tmpVal = EmacReadReg_PHY(dev, pEmacDevice->mii_if.phy_id, PHY_CTRL_REG);
+	tmpVal |= PHY_CTRL_RESTART_AUTO;
+	EmacWriteReg_PHY(dev, pEmacDevice->mii_if.phy_id, PHY_CTRL_REG, tmpVal);
+}
+
+
+unsigned short phy_is_autonegotiation_completed(struct net_device *dev)
+{
+	unsigned short retVal;
+	unsigned long tmpVal;
+	EMAC_DEVICE *pEmacDevice;
+
+	pEmacDevice = (EMAC_DEVICE *) netdev_priv(dev);
+	retVal = 1;
+	tmpVal = EmacReadReg_PHY(dev, pEmacDevice->mii_if.phy_id, PHY_STATUS_REG);
+	tmpVal &= PHY_STATUS_AUTONEGOTIATION_COMPLETE;
+	if (PHY_STATUS_AUTONEGOTIATION_COMPLETE == tmpVal) {
+		retVal = 0;
+	}
+
+	return retVal;
+}
+
+unsigned short phy_autonegotiation_supported(struct net_device *dev)
+{
+	unsigned short retVal;
+	unsigned long tmpVal;
+	EMAC_DEVICE *pEmacDevice;
+
+
+	pEmacDevice = (EMAC_DEVICE *) netdev_priv(dev);
+	retVal = 0;
+	tmpVal = EmacReadReg_PHY(dev, pEmacDevice->mii_if.phy_id, PHY_STATUS_REG);
+	tmpVal &= PHY_STATUS_AUTONEGOTIATION_ABILITY;
+	if (PHY_STATUS_AUTONEGOTIATION_ABILITY == tmpVal) {
+		retVal = 1;
+	}
+
+	return retVal;
+}
+
+#ifdef EMAC_DRIVER_STATISTICS
+void emac_stats_clear(struct net_device *dev)
+{
+	EMAC_DEVICE *pEmacDevice;
+	EMAC_STATS emacStats;
+	pEmacDevice = (EMAC_DEVICE *) netdev_priv(dev);
+	emac_get_device_statistics(dev, &emacStats);
+
+	/*Set all member in Status to 0 */
+	memset(&pEmacDevice->Stats, 0, sizeof(EMAC_STATS));
+	EMACDBG("Tx Packet Count %lu\n", pEmacDevice->Stats.uTxPktCnt);
+	EMACDBG("Tx Byte Count %lu\n", pEmacDevice->Stats.uTxByteCnt);
+	EMACDBG("Rx Packet Count %lu\n", pEmacDevice->Stats.uRxPktCnt);
+	EMACDBG("Rx Byte Count %lu\n", pEmacDevice->Stats.uRxByteCnt);
+	EMACDBG("Rx Multicast Pkts %lu\n", pEmacDevice->Stats.uRxMulticastPktCnt);
+	EMACDBG("Tx Carrier Lost Count %lu\n", pEmacDevice->Stats.uTxCarrLossCnt);
+	EMACDBG("Tx Deferred Count %lu\n", pEmacDevice->Stats.uTxDeferredCnt);
+	EMACDBG("Tx Retry Count %lu\n", pEmacDevice->Stats.uTxRetryCnt);
+	EMACDBG("Tx drop Count %lu\n", pEmacDevice->Stats.uTxDropCnt);
+	EMACDBG("Tx Latecollision Count %lu\n", pEmacDevice->Stats.uTxLateCollisionDropCnt);
+
+	EMACDBG("Tx Underflow error Count %lu\n", pEmacDevice->Stats.uTxUnderflowErrCnt);
+	EMACDBG("Tx Chaining error Count %lu\n", pEmacDevice->Stats.uTxChainingErrCnt);
+	EMACDBG("Tx BDT not available %lu\n", pEmacDevice->Stats.uTxBDEntryNotAvailable);
+
+	EMACDBG("Rx CRC ERR %lu\n", pEmacDevice->Stats.uRxCRCErrDropCnt);
+	EMACDBG("Rx Frame ERR %lu\n", pEmacDevice->Stats.uRxFrameErrDropCnt);
+	EMACDBG("Rx FIFO ERR %lu\n", pEmacDevice->Stats.uRxFifoOverflowDropCnt);
+	EMACDBG("Rx BDT MISS ERR %lu\n", pEmacDevice->Stats.uBDMissPktCnt);
+	EMACDBG("Rx SHORT PKT %lu\n", pEmacDevice->Stats.uRxShortPktErrCnt);
+	EMACDBG("Rx LONG PKT %lu\n", pEmacDevice->Stats.uRxLongPktErrCnt);
+	EMACDBG("Rx Chain ERR %lu\n", pEmacDevice->Stats.uRxChainErrCnt);
+	EMACDBG("Rx Drop No SKBUFF %lu\n", pEmacDevice->Stats.uRxBuffDropCnt);
+}
+
+void emac_stats_display(struct net_device *dev)
+{
+	EMAC_DEVICE *pEmacDevice;
+	EMAC_STATS emacStats;
+	pEmacDevice = (EMAC_DEVICE *) netdev_priv(dev);
+	emac_get_device_statistics(dev, &emacStats);
+	EMACDBG("Tx Packet Count %lu\n", pEmacDevice->Stats.uTxPktCnt);
+	EMACDBG("Tx Byte Count %lu\n", pEmacDevice->Stats.uTxByteCnt);
+	EMACDBG("Rx Packet Count %lu\n", pEmacDevice->Stats.uRxPktCnt);
+	EMACDBG("Rx Byte Count %lu\n", pEmacDevice->Stats.uRxByteCnt);
+	EMACDBG("Rx Multicast Pkts %lu\n", pEmacDevice->Stats.uRxMulticastPktCnt);
+	EMACDBG("Tx Carrier Lost Count %lu\n", pEmacDevice->Stats.uTxCarrLossCnt);
+	EMACDBG("Tx Deferred Count %lu\n", pEmacDevice->Stats.uTxDeferredCnt);
+	EMACDBG("Tx Retry Count %lu\n", pEmacDevice->Stats.uTxRetryCnt);
+	EMACDBG("Tx drop Count %lu\n", pEmacDevice->Stats.uTxDropCnt);
+	EMACDBG("Tx Latecollision Count %lu\n", pEmacDevice->Stats.uTxLateCollisionDropCnt);
+
+	EMACDBG("Tx Underflow error Count %lu\n", pEmacDevice->Stats.uTxUnderflowErrCnt);
+	EMACDBG("Tx Chaining error Count %lu\n", pEmacDevice->Stats.uTxChainingErrCnt);
+	EMACDBG("Tx BDT not available %lu\n", pEmacDevice->Stats.uTxBDEntryNotAvailable);
+	EMACDBG("Rx CRC ERR %lu\n", pEmacDevice->Stats.uRxCRCErrDropCnt);
+	EMACDBG("Rx Frame ERR %lu\n", pEmacDevice->Stats.uRxFrameErrDropCnt);
+	EMACDBG("Rx FIFO ERR %lu\n", pEmacDevice->Stats.uRxFifoOverflowDropCnt);
+	EMACDBG("Rx BDT MISS ERR %lu\n", pEmacDevice->Stats.uBDMissPktCnt);
+	EMACDBG("Rx SHORT PKT %lu\n", pEmacDevice->Stats.uRxShortPktErrCnt);
+	EMACDBG("Rx LONG PKT %lu\n", pEmacDevice->Stats.uRxLongPktErrCnt);
+	EMACDBG("Rx Chain ERR %lu\n", pEmacDevice->Stats.uRxChainErrCnt);
+	EMACDBG("Rx Drop No SKBUFF %lu\n", pEmacDevice->Stats.uRxBuffDropCnt);
+}
+
+#endif
+
+/****************************************************************************
+ * Modifications:
+ * $Log:
+ *  7    Linux_SDK 1.6         8/9/07 7:51:14 PM IST  Upakul Barkakaty
+ *       Implement network stop and wake routine to avoid continuous polling
+ *       by the networking system under Hardware BDTs unavailable condition.
+ *  6    Linux_SDK 1.5         8/3/07 2:49:56 PM IST  Upakul Barkakaty
+ *       Configurable flags and logic added to enable the Second Ethernet
+ *       interface with 2xMode operation for Emac.
+ *  5    Linux_SDK 1.4         4/16/07 1:25:55 PM IST Rajesha Kini    Updated
+ *       with GPL header.
+ *  4    Linux_SDK 1.3         4/10/07 8:52:17 PM IST Rajesha Kini    Updated
+ *       emac driver to get MAC address from EEPROM for the first
+ *       interface(eth0).
+ *  3    Linux_SDK 1.2         3/20/07 4:14:26 PM IST Har Yash Bahadur For NFS
+ *  2    Linux_SDK 1.1         3/15/07 11:58:45 AM ISTHar Yash Bahadur Apply
+ *       memory alignment
+ *  1    Linux_SDK 1.0         3/2/07 3:42:24 PM IST  Vineet Seth     
+ * $
+ *
+ ****************************************************************************/
diff --git a/drivers/net/cnxt_emac/emac_prv.h b/drivers/net/cnxt_emac/emac_prv.h
new file mode 100644
index 0000000..7b0411b
--- /dev/null
+++ b/drivers/net/cnxt_emac/emac_prv.h
@@ -0,0 +1,476 @@
+/****************************************************************************
+ *
+ *  drivers/net/cnxt_emac/emac_prv.h
+ *
+ *  Copyright (C) 2007 Conexant Systems,Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License, Version 2, as 
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or 
+ *  NONINFRINGEMENT.See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
+ *
+ */
+/****************************************************************************
+ *$Id: emac_prv.h,v 1.3, 2007-08-09 14:21:38Z, Upakul Barkakaty$
+ ****************************************************************************/
+
+#ifndef __emac_prv_h
+#define __emac_prv_h
+
+#include <linux/mii.h>		/* MII structure */
+#include <linux/sockios.h>	/* SIOCDEVPRIVATE */
+
+		       /* #define SKB_CLONE *//* sk buffer reuse logic enable */
+/* maximum emac supported */
+#define MAX_EMAC 2
+
+/* ToDo: below feature, need to be provided as configuration element */
+/*Total number of descriptos on the TX Descriptor Table in EMAC0 */
+#define EMAC0_TX_DESCRIPTOR_CNT         32
+/*Total number of descriptos on the RX Descriptor Table in EMAC0 */
+#define EMAC0_RX_DESCRIPTOR_CNT         32
+/*Total number of descriptos on the TX Descriptor Table in EMAC1 */
+#define EMAC1_TX_DESCRIPTOR_CNT         32
+/*Total number of descriptos on the RX Descriptor Table in EMAC1 */
+#define EMAC1_RX_DESCRIPTOR_CNT         32
+/* Default speed/mode etc  */
+#define EMAC0_DEFAULT_MODE              FULL_DUPLEX	/*Full Duplex */
+#define EMAC0_DEFAULT_SPEED             SPEED_100MBPS	/*100 Mbps */
+#define EMAC1_DEFAULT_MODE              FULL_DUPLEX	/*Full Duplex */
+#define EMAC1_DEFAULT_SPEED             SPEED_100MBPS	/*100 Mbps */
+#define EMAC0_DEFAULT_MULTICAST         0	/*Multicast Enable */
+#define EMAC0_DEFAULT_PROMISCOUS        0	/* Promiscous enable */
+#define EMAC1_DEFAULT_MULTICAST         0	/*Multicast Enable */
+#define EMAC1_DEFAULT_PROMISCOUS        0	/* Promiscous enable */
+/* Tx FIFO threshold -start sending after 64 bytes are accumulated in FIFO, 
+ * note that fifo depth is 512 bytes 
+ */
+#define EMAC0_TX_FIFO_THRESHOLD 0xFFFFFC40
+#define EMAC1_TX_FIFO_THRESHOLD 0xFFFFFC40
+
+
+#define MAC_ADDR_LEN              6
+#define FRAME_CHECKSUM_SIZE       4
+#define MULTICAST_BIT_SET         0x01
+/* Transmit sk_buf queue length  */
+#define MAX_TRANSMIT_QUEUE_LEN    256
+
+#ifdef SKB_CLONE		/* sk buffer reuse logic enable */
+#define MIN_REFILL_QUEUE_LEN      100
+#endif
+#define EMAC_FRAMESIZE_MIN        64
+#define EMAC_FRAMESIZE_MAX        1518	/* Maximum size of the ethernet frame */
+#define EMAC_RX_FRAMESIZE_MAX     1520	/* Keep the size more than maximum frame size */
+#define EMAC_POLLRATE_VALUE       1
+/* Counter value results in overflow interrupt */
+#define ERROR_OVERFLOW_COUNTER    0x100
+#define EMAC_FRAMESIZE_NIBBLE_MAX 3072	/* Keep it to maximum value possible */
+#define EMAC_DELAY                 25	/* in us */
+#define EMAC_LOCKUP_WAIT          (100)	/* worst case delay 2.5ms = EMAC_LOCKUP_WAIT * EMAC_DELAY */
+#define EMAC_WAKE_QUEUE_THRESHHOLD 64	/* If secondary buffer below the threshold wake the stopped network queue */
+/* maximum allowed multicast filter size */
+/* #define MULTICAST_FILTER_LIMIT    64 */
+
+#define INTERRUPT_STATUS_CLEAR    0x171F
+#ifdef EMAC_DRIVER_STATISTICS
+#define EMAC_STATISTICS_DISPLAY  SIOCDEVPRIVATE	/* 89F0 */
+#define EMAC_STATISTICS_CLEAR    SIOCDEVPRIVATE+1	/* 89F1 */
+#endif
+
+/* EMAC capability and data structure */
+typedef struct {
+	/* 0 for eth0, 1 for eth1 */
+	unsigned short uInterfaceNo;
+
+	/* MAC address of the interface */
+	unsigned char uMACaddress[6];
+	unsigned long uPHYIndentifier;
+
+	/* 1= PHY has the ability to perform link transmission and reception using 
+	 * the 100BASE-T4 signaling specification.0 = Lack the ability 
+	 */
+	unsigned short u100BaseT4Ability;
+
+	/* 1= PHY has the ability to perform full-duplex link transmission and 
+	 * reception using the 100BASE-X signaling specification.0 = Lack the ability 
+	 */
+	unsigned short u100BaseXFullDuplexAbility;
+
+	/* 1= PHY has the ability to perform half-duplex link transmission and 
+	 * reception using the 100BASE-X signaling specification.0 = Lack the ability 
+	 */
+	unsigned short u100BaseXHalfDuplexAbility;
+
+	/* 1= PHY has the ability to perform full duplex link transmission and 
+	 * reception while operating at 10 Mb/s.0 = Lack the ability 
+	 */
+	unsigned short u10MbsFullDuplexAbility;
+
+	/* 1= PHY has the ability to perform half duplex link transmission and 
+	 * reception while operating at 10 Mb/s.0 = Lack the ability 
+	 */
+	unsigned short u10MbsHalfDuplexAbility;
+
+	/* 1 = PHY will accept management frames with preamble suppressed.
+	 * 0 = Lack the ability 
+	 */
+	unsigned short uMFPreambleSuppression;
+
+	/* Interface is on or off */
+	unsigned short uLinkStatus;
+
+	/* 0-Support base regsiter set, 1-support extended register set */
+	unsigned short uExtendedPHYRegisterSet;
+
+	/* how often BDT state machine poll the BDT */
+	unsigned short uBDTPoolRate;
+
+	/* PHY Autonegotiation Capability */
+	unsigned short uAutoNegotiationCap;
+
+	/* PHY Autonegotiation Advertisement Capability */
+	unsigned short uAutoNegotiationAdvertisementCap;
+
+	/*Additional PHY register information */
+} EMAC_ATTRIBUTES;
+
+
+/* EMAC Statistic data structure */
+typedef struct {
+	/* Total number of packets successfully transmitted by the interface. */
+	unsigned long uTxPktCnt;
+
+	/* Total number of bytes successfully transmitted by the interface. */
+	unsigned long uTxByteCnt;
+
+	/* Total number of packets received by the interface. */
+	unsigned long uRxPktCnt;
+
+	/* Total number of bytes received by the interface. */
+	unsigned long uRxByteCnt;
+
+	/* Total number of Multicast Packets received by the interface. */
+	unsigned long uRxMulticastPktCnt;
+
+	/* CARLOSS Count i.e. Total No of time Carrier Sense was lost during 
+	 * transmission. 
+	 */
+	unsigned long uTxCarrLossCnt;
+
+	/* Defer Count i.e. Total No of time transmission was deferred due to 
+	 * traffic on the wire. 
+	 */
+	unsigned long uTxDeferredCnt;
+
+	/* Total Retry count i.e. Number of times the packet was retired because it 
+	 * was not successfully transmitted in the last try. 
+	 */
+	unsigned long uTxRetryCnt;
+
+
+	/* Drop Count value i.e. No of time packet was dropped because even after 
+	 * retying maximum no(16) of times packet was not transmitted successfully.
+	 */
+	unsigned long uTxDropCnt;
+
+	/* Late collision error count, i.e. No of time Packet dropped due to late 
+	 * collision. 
+	 */
+	unsigned long uTxLateCollisionDropCnt;
+
+	/* Underflow Error Count i.e. Total no of Packet data corrupted and dropped 
+	 * because data was not available in time. 
+	 */
+	unsigned long uTxUnderflowErrCnt;
+
+	/* TX Chaining Error Count i.e. A bad combination of FIRST and LAST bits has
+	 * been encountered. 
+	 */
+	unsigned long uTxChainingErrCnt;
+
+	/* No of time packet was dropped because there was no free Tx Buffer Descriptor
+	 * to accomodate this data 
+	 */
+	unsigned long uTxBDEntryNotAvailable;
+
+	/* CRC Errors i.e. Total No of receive packets dropped due to CRC errors */
+	unsigned long uRxCRCErrDropCnt;
+
+	/* FRAME Errors i.e. Total Number of receive packets dropped due to framing 
+	 * errors 
+	 */
+	unsigned long uRxFrameErrDropCnt;
+
+	/* Overflow Errors i.e. Total Number of receive packets dropped due to FIFO 
+	 * overflows 
+	 */
+	unsigned long uRxFifoOverflowDropCnt;
+
+	/* Missed packet counter i.e. Total Number of packets that were dropped 
+	 * because a BD was not available. 
+	 */
+	unsigned long uBDMissPktCnt;
+
+	/* Short Packet Error Count i.e. Total Receive Short Packet Error (Packet 
+	 * less than 64 bytes). 
+	 */
+	unsigned long uRxShortPktErrCnt;
+	/* Larger Packet Count i.e. Total Receive Larger Packet count (Packet 
+	 * greater than standard ethernet supported). 
+	 */
+	unsigned long uRxLongPktErrCnt;
+
+	/* Larger Packet Count i.e. Total Receive Larger Packet count (Packet 
+	 * greater than standard ethernet supported). 
+	 */
+	unsigned long uRxChainErrCnt;
+
+	/* Packet droppped due non availability of network buffers */
+	unsigned long uRxBuffDropCnt;
+
+
+} EMAC_STATS;
+
+/*Hardware Buffer Descriptor data structure*/
+typedef struct {
+	unsigned long uInfo;	/* Info field of the Buffer Descriptor */
+	unsigned char *puData;	/* Pointer (to the data) field of the Buffer Descriptor */
+
+	/* dma_addr_t puData; */
+} EMAC_BUF_DESCR;
+
+/* Buffer contains Hardware buffer descriptor's Pointer field */
+typedef struct {
+	struct sk_buff *puData;
+} EMAC_LOCAL_BUF;
+
+typedef enum {
+	HALF_DUPLEX = 0,
+	FULL_DUPLEX,
+	AUTO_DUPLEX
+} EMAC_DUPLEX;
+
+typedef enum {
+	SPEED_10MBPS = 10,
+	SPEED_100MBPS = 100,
+	SPEED_200MBPS = 200,	/* Over clocked MII */
+	AUTO_SPEED
+} EMAC_SPEED;
+
+/* EMAC private Data structure */
+typedef struct {
+	/* Handle of net_device this private structure is attached to */
+	struct net_device *hNetDev;
+
+	/* 0 for eth0, 1 for eth1 */
+	unsigned short uInterfaceNo;
+
+	/* 0 = Interface Not In Use, 1 = In Use */
+	unsigned short uInUse;
+
+	/* I/O Base address of the EMAC */
+	unsigned long uBaseAddress;
+
+	/* 0 = 10 Mbps, 100 = 100 Mbps, 200=200 Mbps */
+	EMAC_SPEED uSpeed;
+
+	/* 0 = Half Duplex, 1 = Full Duplex */
+	EMAC_DUPLEX uMode;
+
+	/* 0 = Disabled, 1 = Enabled */
+	unsigned short uMulticastEnable;
+
+	/* 0 = Disabled, 1 = Enabled */
+	unsigned short uPromiscousEnable;
+
+	/* The MAC address of this port */
+	unsigned char mac[6];
+
+	/* The return value from mac_Claim */
+	unsigned long uMacIndex;	/* ToDo: need to be removed */
+
+	/* Total no of Tx Buffer Descriptors in the Tx BDT */
+	unsigned long uTxDescCount;
+
+	/* Total no of Rx Buffer Descriptors in the Rx BDT */
+	unsigned long uRxDescCount;
+
+	/* Start of Memory block from where Tx and Rx BDT memory are allocated */
+	unsigned char *puDescriptorBase;
+
+	/* Size of Memory block allocated for Tx and Rx BDT */
+	unsigned long uDescriptorSize;
+
+	/* Points to the Buffer Descriptor in Tx BDT which will be used to store the
+	 * upper layer supplied transmission buffer in the next Transmit call 
+	 */
+	EMAC_BUF_DESCR *tx_curr;
+
+	/* Pointer to buffer which will be scheduled for transmission, when TXINT 
+	 * will come this buffer will be freed. Corresponds to tx_curr 
+	 */
+	EMAC_LOCAL_BUF *tx_curr_local;
+
+	/* Points to the Buffer Descriptor in Tx BDT from where we will start 
+	 * checking for BD for which transmission has been completed during TXINT 
+	 * processing 
+	 */
+	EMAC_BUF_DESCR *tx_refil;
+
+	/* Pointer to buffer ,Corresponds to tx_refil */
+	EMAC_LOCAL_BUF *tx_refil_local;
+
+	/* Address of the First Buffer Descriptor in the Tx BDT */
+	EMAC_BUF_DESCR *tx_first_desc;
+
+	/* Address of the last Buffer Descriptor in the Tx BDT */
+	EMAC_BUF_DESCR *tx_last_desc;
+
+	/* Address of the First Buffer Corresponding to the first Buffer Descriptor 
+	 * of Tx BDT 
+	 */
+	EMAC_LOCAL_BUF *tx_first_local;
+
+	/* Points to the Buffer Descriptor in Rx BDT from which we will start 
+	 * checking for BD which contains valid data 
+	 */
+	EMAC_BUF_DESCR *rx_curr;
+
+	/* Pointer to received buffer ,Corresponds to rx_curr */
+	EMAC_LOCAL_BUF *rx_curr_local;
+
+	/* Points to the Buffer Descriptor in Rx BDT from which we will add buffer 
+	 * which will be used to hold receive data by EMAC 
+	 */
+	EMAC_BUF_DESCR *rx_refil;
+
+	/* Pointer to supplied buffer ,Corresponds to rx_refil */
+	EMAC_LOCAL_BUF *rx_refil_local;
+
+	/* Address of the First Buffer Descriptor in the Rx BDT */
+	EMAC_BUF_DESCR *rx_first_desc;
+
+	/* Address of the Last Buffer Descriptor in the Rx BDT */
+	EMAC_BUF_DESCR *rx_last_desc;
+
+	/* Address of the First Buffer Corresponding to the first Buffer Descriptor of Rx BDT */
+	EMAC_LOCAL_BUF *rx_first_local;
+
+	/* Interface Statistics */
+	EMAC_STATS Stats;
+
+	/* IRQ number for this interface */
+	long iIrq;
+
+	/* Maximum number of Buffer Descriptor that can be processed in one TX 
+	 * Interrupt processing 
+	 */
+	unsigned short uTxIntBDProcessCnt;	/* ToDo: may required for Tx max processing in Tasklet */
+
+	/* Maximum number of Buffer Descriptor that can be processed in one RX 
+	 * Interrupt processing 
+	 */
+	unsigned short uRxIntBDProcessCnt;	/* ToDo: may required for Tx max processing in Tasklet */
+
+	/* Queue for storing the data that has to be transmitted */
+	struct sk_buff_head TxQueue;
+
+	/* Number of currently available Tx buffer  */
+	unsigned long TxQDepth;
+	/* Maximum number of buffer that we can store locally for transmission */
+	unsigned long uMaxTxQDepth;
+
+	unsigned long uBufLen;	/* ToDo: need to be removed */
+
+	spinlock_t lock;
+	struct semaphore mutex;
+
+	/* Logical filter setting value */
+	unsigned long uHashLow;
+	unsigned long uHashHigh;
+
+	/* 0 for disable, 1 for enable */
+	unsigned short uAutoneg_enable;
+	EMAC_SPEED uCurrent_speed_select;
+	EMAC_DUPLEX uCurrent_duplex_select;
+
+#ifdef EMAC_MEDIA_MAINTANANCE
+	void (*media_check_func) (struct net_device * dev);
+#endif
+	/* 0 MDIO operation not supported,1 MDIO operation supported */
+	unsigned short uMDIO_support;
+
+	struct mii_if_info mii_if;
+	dma_addr_t uDmaAddr;
+
+} EMAC_DEVICE;
+
+unsigned short phy_autonegotiation_supported(struct net_device *dev);
+int emac_open(unsigned short uInterfaceNumber, struct net_device *dev);
+int emac_close(struct net_device *dev);
+int emac_set_multicast_list(struct net_device *dev);
+int emac_start_transmit(struct net_device *dev, void *pData, unsigned long uDataLen);
+int emac_get_device_statistics(struct net_device *dev, EMAC_STATS * emacStats);
+void emac_media_autonegotiate(struct net_device *dev);
+void emac_media_force(struct net_device *dev, EMAC_SPEED uSpeed, EMAC_DUPLEX uDuplex);
+int EmacReadReg_PHY(struct net_device *dev, int PhyAddr, int RegNo);
+void EmacWriteReg_PHY(struct net_device *dev, int PhyAddr, int RegNo, int Data);
+int emac_set_transmit_activity(struct net_device *dev, unsigned short uEnable);
+/* function to read mac address */
+void Get_mac_Address(unsigned char *uMacDest, unsigned short uInterfaceNo, unsigned short uAddrlen);
+int phy_detect(struct net_device *dev);
+
+#ifdef EMAC_MEDIA_MAINTANANCE
+void select_media_check_function(struct net_device *dev);
+int emac_media_check(void *);
+#endif
+
+int emac_get_device_attribute(struct net_device *dev, EMAC_ATTRIBUTES * pAttributes);
+int emac_set_activity(struct net_device *dev, unsigned short uEnable);
+int emac_set_receive_activity(struct net_device *dev, unsigned short uEnable);
+int emac_set_broadcast(struct net_device *dev, unsigned short uEnable);
+int emac_set_promiscuous(struct net_device *dev, unsigned short uEnable);
+int emac_set_bdt_poolrate(struct net_device *dev, unsigned long uRate);
+int emac_get_bdt_poolrate(struct net_device *dev, unsigned long *puRate);
+unsigned long emac_get_transmit_bdt_length(struct net_device *dev);
+unsigned long emac_get_receive_bdt_length(struct net_device *dev);
+void phy_reset(struct net_device *dev);
+void phy_set_mode(struct net_device *dev, EMAC_DUPLEX uMode);
+void phy_set_speed(struct net_device *dev, EMAC_SPEED uSpeed);
+void phy_loopback(struct net_device *dev, unsigned short uMode);
+void phy_powerdown(struct net_device *dev, unsigned short uMode);
+void phy_isolate(struct net_device *dev, unsigned short uMode);
+void phy_collisiontest(struct net_device *dev, unsigned short uMode);
+void phy_set_autonegotiation(struct net_device *dev, unsigned short uValue);
+void phy_restart_autonegotiation(struct net_device *dev);
+unsigned short phy_is_autonegotiation_completed(struct net_device *dev);
+
+#ifdef EMAC_DRIVER_STATISTICS
+void emac_stats_display(struct net_device *dev);
+void emac_stats_clear(struct net_device *dev);
+#endif
+#endif
+
+/****************************************************************************
+ * Modifications:
+ * $Log:
+ *  4    Linux_SDK 1.3         8/9/07 7:51:38 PM IST  Upakul Barkakaty
+ *       Implement network stop and wake routine to avoid continuous polling
+ *       by the networking system under Hardware BDTs unavailable condition.
+ *  3    Linux_SDK 1.2         8/3/07 2:49:58 PM IST  Upakul Barkakaty
+ *       Configurable flags and logic added to enable the Second Ethernet
+ *       interface with 2xMode operation for Emac.
+ *  2    Linux_SDK 1.1         4/16/07 1:26:15 PM IST Rajesha Kini    Updated
+ *       with GPL header.
+ *  1    Linux_SDK 1.0         3/2/07 3:42:25 PM IST  Vineet Seth     
+ * $
+ *
+ ****************************************************************************/
diff --git a/drivers/serial/Kconfig b/drivers/serial/Kconfig
index 9bc4276..cb60b66 100644
--- a/drivers/serial/Kconfig
+++ b/drivers/serial/Kconfig
@@ -1255,6 +1255,85 @@ config SERIAL_TXX9_STDSERIAL
 	bool "TX39XX/49XX SIO act as standard serial"
 	depends on !SERIAL_8250 && SERIAL_TXX9
 
+config SERIAL_CX2450X
+	bool "Conexant CX2450x SoC UART support"
+	depends on ARCH_NEVIS
+	select SERIAL_CORE
+	default y
+	help
+	  The Conexant CX2450x SoC has three 16550 style UARTs. Each of them 
+	  can be routed to various pins, but note that the pin routing must 
+	  be correctly setup by the Bootloader/BIOS. 
+	  
+	  This driver reads the pin config and enables all configured ports.
+	  
+	  If you enable the serial console support for this driver, the 
+	  lowest configured port is used as the system console
+
+choice
+	prompt "Default Baud Rate for CX2450x SoC UATR's"
+	depends on SERIAL_CX2450X
+	default SERIAL_CX2450X_BAUD_RATE_115200
+
+config SERIAL_CX2450X_BAUD_RATE_230400
+	bool "230400 Baud"
+
+config SERIAL_CX2450X_BAUD_RATE_115200
+	bool "115200 Baud"
+
+config SERIAL_CX2450X_BAUD_RATE_57600
+	bool "57600 Baud"
+
+config SERIAL_CX2450X_BAUD_RATE_38400
+	bool "38400 Baud"
+
+config SERIAL_CX2450X_BAUD_RATE_19200
+	bool "19200 Baud"
+
+config SERIAL_CX2450X_BAUD_RATE_9600
+	bool "9600 Baud"
+
+endchoice
+
+config CX2450X_BAUD_RATE
+	int
+	depends on SERIAL_CX2450X
+	default 115200 if (SERIAL_CX2450X_BAUD_RATE_115200)
+	default 57600 if (SERIAL_CX2450X_BAUD_RATE_57600)
+	default 38400 if (SERIAL_CX2450X_BAUD_RATE_38400)
+	default 19200 if (SERIAL_CX2450X_BAUD_RATE_19200)
+	default 9600 if (SERIAL_CX2450X_BAUD_RATE_9600)
+
+config SERIAL_CX2450X_UART1_ENABLE
+	bool "Enable UART-1"
+	depends on SERIAL_CX2450X=y
+
+config SERIAL_CX2450X_UART2_ENABLE
+	bool "Enable UART-2"
+	depends on SERIAL_CX2450X=y
+
+config SERIAL_CX2450X_UART3_ENABLE
+	bool "Enable UART-3"
+	depends on SERIAL_CX2450X=y
+	default y
+
+config SERIAL_CX2450X_CONSOLE
+	bool "Conexant CX2450x SoC UART console support"
+	depends on SERIAL_CX2450X=y
+	select SERIAL_CORE_CONSOLE
+	default y
+	help
+	  Provides support for serial console.
+	  The lowest configured port is used for the system console.
+
+config SERIAL_CX2450X_BOOTMSG
+	bool "Print early boot messages on Conexant CX2450x SoC UART's"
+	depends on SERIAL_CX2450X=y
+	default y
+	help
+	  Enable this option to see the the full boot message. If disabled
+	  you will see the bootmessage from late the UART-init stage.
+
 config SERIAL_VR41XX
 	tristate "NEC VR4100 series Serial Interface Unit support"
 	depends on CPU_VR41XX
diff --git a/drivers/serial/Makefile b/drivers/serial/Makefile
index 0d9c09b..b4fa937 100644
--- a/drivers/serial/Makefile
+++ b/drivers/serial/Makefile
@@ -3,7 +3,7 @@
 #
 #  $Id: Makefile,v 1.8 2002/07/21 21:32:30 rmk Exp $
 #
-
+obj-$(CONFIG_SERIAL_CX2450X) += cx2450x_uart.o
 obj-$(CONFIG_SERIAL_CORE) += serial_core.o
 obj-$(CONFIG_SERIAL_21285) += 21285.o
 obj-$(CONFIG_SERIAL_8250) += 8250.o
diff --git a/drivers/serial/cx2450x_uart.c b/drivers/serial/cx2450x_uart.c
new file mode 100644
index 0000000..efacd94
--- /dev/null
+++ b/drivers/serial/cx2450x_uart.c
@@ -0,0 +1,985 @@
+/*
+ *  linux/drivers/serial/cx2450x_uart.c
+ *
+ *  Driver for Conexant CX2450x SoC serial ports
+ *
+ *  Based on drivers/serial/cnxt.c, by Deep Blue Solutions which was 
+ *    based on drivers/char/serial.c, by Linus Torvalds, Theodore Ts'o.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/autoconf.h>
+
+#if defined(CONFIG_SERIAL_CX2450X_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+#define SUPPORT_SYSRQ
+#endif
+
+#include <linux/module.h>
+#include <linux/tty.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/serial.h>
+#include <linux/console.h>
+#include <linux/sysrq.h>
+#include <linux/delay.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/arch/memmap.h>
+#include <asm/arch/cx2450x.h>
+#include <asm/arch/irqs.h>
+
+#include <linux/serial_core.h>
+#include <asm/hardware/serial_cnxt.h>
+
+#if defined(CONFIG_ARCH_PECOS) || defined(CONFIG_ARCH_NEVIS)
+#define CNXT_SET(reg,mask,val)	(*(LPREG)(reg)) =  ((*(LPREG)(reg) & ~(mask)) | ((val) & (mask)))
+#endif
+
+#define CNXT_ISR_PASS_LIMIT	256
+
+/* Access macros for the CNXT UARTs */
+#define UART_GET_INT_STATUS(p)	readl((p)->membase + CNXT_IRLVL)
+
+#define UART_PUT_BRDL(p, c)     writel((c), (p)->membase + CNXT_BRDL)
+#define UART_PUT_BRDH(p, c)     writel((c), (p)->membase + CNXT_BRDH)
+
+#define UART_GET_CHAR(p)	readl((p)->membase + CNXT_FIFO)
+#define UART_PUT_CHAR(p, c)	writel((c), (p)->membase + CNXT_FIFO)
+
+#define UART_GET_STAT(p)	readl((p)->membase + CNXT_STAT)
+
+#define UART_GET_IRQE(p)	readl((p)->membase + CNXT_IRQE)
+#define UART_PUT_IRQE(p,c)	writel((c), (p)->membase + CNXT_IRQE)
+
+#define UART_GET_FIFC(p)	readl((p)->membase + CNXT_FIFC)
+#define UART_PUT_FIFC(p,c)	writel((c), (p)->membase + CNXT_FIFC)
+
+#define UART_GET_FRMC(p)	readl((p)->membase + CNXT_FRMC)
+#define UART_PUT_FRMC(p,c)	writel((c), (p)->membase + CNXT_FRMC)
+
+#define UART_RX_NUMCHARS(p)	readl((p)->membase + CNXT_RXSTA)
+
+#define UART_TX_READY(s)	(((s) & CNXT_STAT_TID) != 0)
+
+#define UART_TX_EMPTY(p)	((UART_GET_STAT(p) & CNXT_STAT_TID) != 0)
+
+#define UART_PUT_EXP(p, c)    writel((c), (p)->membase + CNXT_EXP)
+
+#define UART_DUMMY_RSR_RX	256
+#define UART_PORT_SIZE		0x34
+
+/* On the CNXT boards, we're not going to implement RTS/CTS flow control
+ * (not yet anyway).  These would be GPIO's however.
+ */
+#define SC_CTRLC	(while (0);)
+#define SC_CTRLS	(while (0);)
+
+/* We wrap our port structure around the generic uart_port. */
+
+struct uart_cnxt_port 
+{
+    struct uart_port port;
+    u32 	     num;
+    u32		     dtr_enable;
+    u32		     rts_enable;
+    u32		     old_status;
+};
+
+static u32 have_uart[3];
+
+#ifdef CONFIG_GDB_STUB_FOR_ARM
+/* Added by harsh for GDB kernel debugging support */
+int irq2_status = 0;
+/* Added for GDB kernel debugging support */
+/* Serial port has to be initialized */
+static volatile unsigned char *port = NULL;
+
+#define GDB_UART_BASE			IO_ADDRESS(CNXT_PORT0_BASE)
+#define GDB_UART_GET_CHAR(p)		readl((p) + CNXT_FIFO)
+#define GDB_UART_PUT_CHAR(p, c)		writel((c), (p) + CNXT_FIFO)
+#define GDB_UART_GET_STAT(p)		readl((p) + CNXT_STAT)
+
+/* Get a character from serial port */
+int debug_getc(void)
+{
+	unsigned int status;
+	int c;
+
+	port = (unsigned char *) GDB_UART_BASE;
+
+	status = GDB_UART_GET_STAT(port);
+
+	while (!(status & CNXT_STAT_RSR)) {
+		status = GDB_UART_GET_STAT(port);
+	}
+	c = GDB_UART_GET_CHAR(port);
+
+	c = c & 0x7f;
+
+	return c;
+}
+
+EXPORT_SYMBOL(debug_getc);
+/* Put a character to the serial port */
+int debug_putc(int c)
+{
+	unsigned int status;
+
+	port = (unsigned char *) GDB_UART_BASE;
+
+	status = GDB_UART_GET_STAT(port);
+
+	while (!(status & CNXT_STAT_TSR)) {
+		status = GDB_UART_GET_STAT(port);
+	}
+
+	GDB_UART_PUT_CHAR(port, (c | 0x80));
+	return c;
+}
+
+EXPORT_SYMBOL(debug_putc);
+#endif
+
+static void cnxtuart_stop_tx(struct uart_port *port)
+{
+	unsigned int cr;
+
+	cr = UART_GET_IRQE(port);
+	/* turn off fifo threshold interrupt and transmitter idle interrupt */
+	/* TODO: Check if this is appropriate.  Only one may need to go off */
+	cr &= ~(CNXT_IRQE_TIDE | CNXT_IRQE_TSRE);
+	UART_PUT_IRQE(port, cr);
+}
+
+static void cnxtuart_start_tx(struct uart_port *port)
+{
+	unsigned int cr;
+
+	cr = UART_GET_IRQE(port);
+	cr |= (CNXT_IRQE_TIDE);
+	UART_PUT_IRQE(port, cr);
+}
+
+static void cnxtuart_stop_rx(struct uart_port *port)
+{
+	unsigned int cr;
+
+	cr = UART_GET_IRQE(port);
+	cr &= ~(CNXT_IRQE_RSRE);
+	UART_PUT_IRQE(port, cr);
+}
+
+/* CNXT doesn't really have modem status */
+static void cnxtuart_enable_ms(struct uart_port *port)
+{
+
+}
+
+static void cnxtuart_rx_chars(struct uart_port *port)
+{
+	struct tty_struct *tty = port->info->tty;
+	unsigned int ch, rsr, max_count = 256;
+	unsigned int rxchars;
+	char flag;
+
+	rxchars = UART_RX_NUMCHARS(port);
+	while (rxchars && max_count--) {
+		/* Status bits on CNXT refer to the bottom character
+		 * on the FIFO.   If we read the character before the status 
+		 * register, the status won't apply to the current character.
+		 */
+		rsr = UART_GET_STAT(port) | UART_DUMMY_RSR_RX;
+		ch = UART_GET_CHAR(port);
+
+		tty_flip_buffer_push(tty);
+
+		flag = TTY_NORMAL;
+		port->icount.rx++;
+
+		if (rsr & CNXT_STAT_ANY) {
+			if (rsr & CNXT_STAT_RBK) {
+				rsr &= ~(CNXT_STAT_FRE | CNXT_STAT_PAE);
+				port->icount.brk++;
+				if (uart_handle_break(port)) {
+					goto ignore_char;
+				}
+			} else if (rsr & CNXT_STAT_PAE)
+				port->icount.parity++;
+			else if (rsr & CNXT_STAT_FRE)
+				port->icount.frame++;
+			if (rsr & CNXT_STAT_RFO)
+				port->icount.overrun++;
+
+			rsr &= port->read_status_mask;
+
+			if (rsr & CNXT_STAT_RBK)
+				flag = TTY_BREAK;
+
+			else if (rsr & CNXT_STAT_PAE)
+				flag = TTY_PARITY;
+			else if (rsr & CNXT_STAT_FRE)
+				flag = TTY_FRAME;
+		}
+
+		if (uart_handle_sysrq_char(port, ch))
+			goto ignore_char;
+
+		uart_insert_char(port, rsr, CNXT_STAT_RFO, ch, flag);
+
+	      ignore_char:
+		rxchars = UART_RX_NUMCHARS(port);
+	}
+	/*
+	 * Drop the lock here since it might end up calling
+	 * uart_start(), which takes the lock.
+	 */
+
+	tty_flip_buffer_push(tty);
+	return;
+}
+
+static void cnxtuart_tx_chars(struct uart_port *port)
+{
+	/* This funciton is called from the UART ISR if the transmitter
+	 * empty interrupt fired */
+	struct circ_buf *xmit = &port->info->xmit;
+	int count;
+	unsigned int status;
+
+	if (port->x_char)
+	{
+		do {
+			status = UART_GET_STAT(port);
+			if (UART_TX_READY(status))
+				break;
+			cpu_relax();
+		} while (1);
+
+		UART_PUT_CHAR(port, port->x_char);
+		port->icount.tx++;
+		port->x_char = 0;
+		return;
+	}
+	if (uart_circ_empty(xmit) || uart_tx_stopped(port)) 
+	{
+		cnxtuart_stop_tx(port);
+		return;
+	}
+
+	count = port->fifosize >> 1;
+	do 
+	{
+		do 
+		{
+			status = UART_GET_STAT(port);
+			if (UART_TX_READY(status))
+				break;
+			cpu_relax();
+		} while (1);
+
+		UART_PUT_CHAR(port, xmit->buf[xmit->tail]);
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		port->icount.tx++;
+		if (uart_circ_empty(xmit))
+			break;
+	} while (--count > 0);
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(port);
+
+	if (uart_circ_empty(xmit))
+		cnxtuart_stop_tx(port);
+}
+
+static irqreturn_t cnxtuart_int(int irq, void *dev_id)
+{
+	struct uart_port *port = dev_id;
+	unsigned int status, pass_counter = CNXT_ISR_PASS_LIMIT;
+
+	/* there should really be a need to read the interrupt level register.
+	 * In either of the interruptable cases below, they will be handled
+	 * quickly.  Furthermore, the framing and parity errors will be handled
+	 * in the rx() routine
+	 */
+	status = UART_GET_STAT(port);
+	do {
+		if (status & (CNXT_STAT_RSR))
+			cnxtuart_rx_chars(port);
+		if (status & CNXT_STAT_TSR)
+			cnxtuart_tx_chars(port);
+
+		if (pass_counter-- == 0)
+			break;
+
+		status = UART_GET_STAT(port);
+	} while (status & (CNXT_STAT_RSR | CNXT_STAT_TSR));
+
+	return IRQ_HANDLED;
+}
+
+static unsigned int cnxtuart_tx_empty(struct uart_port *port)
+{
+	return UART_GET_STAT(port) & CNXT_STAT_TID ? 0 : TIOCSER_TEMT;
+}
+
+static unsigned int cnxtuart_get_mctrl(struct uart_port *port)
+{
+	unsigned int result = 0;
+
+	/* TODO: This may need changing in the future.
+	 *
+	 * Lie and say we're good to go for apps that are picky about 
+	 * hardware flow control
+	 */
+	result = TIOCM_CAR | TIOCM_DSR | TIOCM_CTS;
+
+	return result;
+}
+
+static void cnxtuart_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+	/* No modem control stuff on CNXT for now... */
+}
+
+static void cnxtuart_break_ctl(struct uart_port *port, int break_state)
+{
+	/* Dummy */
+}
+
+static int cnxtuart_startup(struct uart_port *port)
+{
+	struct uart_cnxt_port *uap = (struct uart_cnxt_port *) port;
+	int retval;
+
+	/*  Allocate the IRQ */
+	retval = request_irq(port->irq, cnxtuart_int, /*IRQF_DISABLED | */IRQF_SHARED, "CX2450x UART", port);
+	if (retval)
+		return retval;
+
+	/*  initialise the old status of the modem signals */
+	uap->old_status = 0;
+
+	UART_PUT_FIFC(port, CNXT_FIFC_RFT_EIGHT | CNXT_FIFC_TFT_SXTN | CNXT_FIFC_TFC | CNXT_FIFC_RFC);
+
+	/* Finally, enable interrupts */
+	UART_PUT_IRQE(port, CNXT_IRQE_TIDE | CNXT_IRQE_TSRE | CNXT_IRQE_RSRE);
+
+#ifdef CONFIG_GDB_STUB_FOR_ARM
+	/* Set that IRQ2 is allocated :to be used by GDB */
+	irq2_status = 1;
+#endif
+	return 0;
+}
+
+static void cnxtuart_shutdown(struct uart_port *port)
+{
+	/* Free the interrupt */
+	free_irq(port->irq, port);
+	/* disable all interrupts, disable the port */
+	UART_PUT_IRQE(port, 0);
+	UART_PUT_FIFC(port, CNXT_FIFC_TFC | CNXT_FIFC_RFC);
+}
+
+static void cnxtuart_set_termios(struct uart_port *port, struct ktermios *new1, struct ktermios *old)
+{
+#warning check baudrate setup
+	unsigned long flags;
+	int baud = uart_get_baud_rate(port, new1, old, 9600, 115200);
+	unsigned int fcr, old_cr, quot;
+	unsigned int cflag = new1->c_cflag;
+
+	quot = (port->uartclk / (16 * baud));
+	switch (cflag & CSIZE) {
+	case CS7:
+		fcr = 0;
+		break;
+	default:		// CS8
+		fcr = CNXT_FRMC_FRS;
+		break;
+	}
+
+	if (cflag & CSTOPB)
+		fcr |= CNXT_FRMC_SBS;
+
+	if (cflag & PARENB) {
+		fcr |= CNXT_FRMC_PEN;
+
+		if (!(cflag & PARODD))
+			fcr |= CNXT_FRMC_EOP;
+	}
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	uart_update_timeout(port, cflag, baud);
+	/*  Ignore all characters if CREAD is not set.  */
+	if ((cflag & CREAD) == 0)
+		port->ignore_status_mask |= UART_DUMMY_RSR_RX;
+
+	old_cr = UART_GET_FRMC(port);
+
+	UART_PUT_FRMC(port, 0x80);
+
+	/* Set baud rate */
+	/*
+	 * Set the fractional part, based on the fact that we shifted the
+	 * uartclk by 2, to allow 2 bits of fraction to be carried in the
+	 * quotient value passed into this routine
+	 */
+	UART_PUT_EXP(port, (quot & 0x00003));
+	quot = quot >> 2;
+
+	quot -= 1;
+	UART_PUT_BRDH(port, ((quot & 0xff00) >> 8));
+	UART_PUT_BRDL(port, (quot & 0xff));
+
+	/*
+	 * ----------v----------v----------v----------v-----
+	 * NOTE: MUST BE WRITTEN AFTER UARTLCR_M & UARTLCR_L
+	 * ----------^----------^----------^----------^-----
+	 */
+	UART_PUT_FRMC(port, fcr);
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static const char *cnxtuart_type(struct uart_port *port)
+{
+	return port->type == PORT_CNXT ? "CX2450x UART" : NULL;
+}
+
+/* Release the memory region(s) being used by 'port' */
+static void cnxtuart_release_port(struct uart_port *port)
+{
+    release_mem_region(port->mapbase, UART_PORT_SIZE);
+}
+
+/* Request the memory region(s) being used by 'port' */
+static int cnxtuart_request_port(struct uart_port *port)
+{
+    return request_mem_region(port->mapbase, UART_PORT_SIZE,  "CX2450x UART") != NULL ? 0 : -EBUSY;
+}
+
+/* Configure/autoconfigure the port.  */
+static void cnxtuart_config_port(struct uart_port *port, int flags)
+{
+    if (flags & UART_CONFIG_TYPE) 
+    {
+	port->type = PORT_CNXT;
+	cnxtuart_request_port(port);
+    }
+}
+
+/* verify the new serial_struct (for TIOCSSERIAL).  */
+static int cnxtuart_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	int ret;
+	/* TODO:  MFB - evaluate if this is really necessary later */
+	ret = 0;
+	return ret;
+}
+
+static struct uart_ops cnxt_pops = 
+{
+    .tx_empty	  = cnxtuart_tx_empty,
+    .set_mctrl	  = cnxtuart_set_mctrl,
+    .get_mctrl	  = cnxtuart_get_mctrl,
+    .stop_tx	  = cnxtuart_stop_tx,
+    .start_tx	  = cnxtuart_start_tx,
+    .stop_rx	  = cnxtuart_stop_rx,
+    .enable_ms	  = cnxtuart_enable_ms,
+    .break_ctl	  = cnxtuart_break_ctl,
+    .startup	  = cnxtuart_startup,
+    .shutdown	  = cnxtuart_shutdown,
+    .set_termios  = cnxtuart_set_termios,
+    .type 	  = cnxtuart_type,
+    .release_port = cnxtuart_release_port,
+    .request_port = cnxtuart_request_port,
+    .config_port  = cnxtuart_config_port,
+    .verify_port  = cnxtuart_verify_port
+};
+
+/*******************************************************************************/
+
+/* note, addresses and interrupts here are only valid placeholders. They are 
+   overwritten in the init routine for proper sorting (to have the system 
+   console while boot identical to the working console) */
+static struct uart_cnxt_port cnxt_ports[3] =
+{
+    {
+	.port = 
+	{
+	    .membase  = (void *) IO_ADDRESS(UART_FIFO_BRDL_REG(0)),
+	    .mapbase  = UART_FIFO_BRDL_REG(0),
+	    .iotype   = UPIO_MEM,
+	    .irq      = IRQ_UART1,
+	    .uartclk  = (54000000 << 2),
+	    .fifosize = 16,
+	    .ops      = &cnxt_pops,
+	    .flags    = UPF_BOOT_AUTOCONF,
+	    .line     = 2,
+	},
+	.dtr_enable = 0,
+	.rts_enable = 0,
+    },
+    {
+	.port = 
+	{
+	    .membase  = (void *) IO_ADDRESS(UART_FIFO_BRDL_REG(1)),
+	    .mapbase  = UART_FIFO_BRDL_REG(1),
+	    .iotype   = UPIO_MEM,
+	    .irq      = IRQ_UART2,
+	    .uartclk  = (54000000 << 2),
+	    .fifosize = 16,
+	    .ops      = &cnxt_pops,
+	    .flags    = UPF_BOOT_AUTOCONF,
+	    .line     = 1,
+	},
+	.dtr_enable = 0,
+	.rts_enable = 0,
+    },
+    {
+	.port = 
+	{
+	    .membase  = (void *) IO_ADDRESS(UART_FIFO_BRDL_REG(2)),
+	    .mapbase  = UART_FIFO_BRDL_REG(2),
+	    .iotype   = UPIO_MEM,
+	    .irq      = IRQ_UART3,
+	    .uartclk  = (54000000 << 2),
+	    .fifosize = 16,
+	    .ops      = &cnxt_pops,
+	    .flags    = UPF_BOOT_AUTOCONF,
+	    .line     = 0,
+	},
+	.dtr_enable = 0,
+	.rts_enable = 0,
+    },
+};
+
+/*******************************************************************************/
+
+#ifdef CONFIG_SERIAL_CX2450X_CONSOLE
+
+static void cnxtuart_console_write(struct console *co, const char *s, unsigned int count)
+{
+	struct uart_port *port = &cnxt_ports[co->index].port;
+	unsigned int status, old_cr;
+	int i;
+
+	/* First save the CR then disable the interrupts */
+	old_cr = UART_GET_IRQE(port);
+	UART_PUT_IRQE(port, 0);
+
+	/* Now, do each character */
+	for (i = 0; i < count; i++) {
+		do {
+			status = UART_GET_STAT(port);
+			if (UART_TX_READY(status))
+				break;
+			cpu_relax();
+		}
+		while (1);
+		UART_PUT_CHAR(port, s[i]);
+		if (s[i] == '\n') {
+			do {
+				status = UART_GET_STAT(port);
+				if (UART_TX_READY(status))
+					break;
+				cpu_relax();
+			} while (1);
+			UART_PUT_CHAR(port, '\r');
+		}
+	}
+
+	/* Finally, wait for transmitter to become empty and restore the TCR */
+	do {
+		status = UART_GET_STAT(port);
+	}
+	while ((status & CNXT_STAT_TID) == 0);
+	UART_PUT_IRQE(port, old_cr);
+}
+
+struct tty_driver *cnxtuart_console_device(struct console *co, int *index)
+{
+	struct uart_driver *p = co->data;
+
+	*index = co->index;
+	return p->tty_driver;
+}
+
+/*
+static void __init cnxtuart_console_get_options(struct uart_port *port, int *baud, int *parity, int *bits)
+{
+#warning report correct settings
+	*baud = 115200;
+	*parity = 'n';
+	*bits = 8;
+}
+*/
+/*******************************************************************************/
+
+static int __init cnxtuart_console_setup(struct console *co, char *options)
+{
+    struct uart_port *port;
+    int baud = 115200;
+    int bits = 8;
+    int parity = 'n';
+    int flow = 'n';
+
+    /* get default baudrate from Kernel config */
+    #ifdef CONFIG_SERIAL_CX2450X_BAUDRATE_230400
+    baud = 230400;
+    #else
+    #ifdef CONFIG_SERIAL_CX2450X_BAUDRATE_115200
+    baud = 115200;
+    #else
+    #ifdef  CONFIG_SERIAL_CX2450X_BAUDRATE_57600
+    baud = 57600;
+    #else
+    #ifdef  CONFIG_SERIAL_CX2450X_BAUDRATE_38400
+    baud = 38400;
+    #else
+    #ifdef  CONFIG_SERIAL_CX2450X_BAUDRATE_19200
+    baud = 19200;
+    #else
+    #ifdef  CONFIG_SERIAL_CX2450X_BAUDRATE_9600
+    baud = 9600;
+    #endif  /* CONFIG_SERIAL_CX2450X_BAUDRATE_9600   */
+    #endif  /* CONFIG_SERIAL_CX2450X_BAUDRATE_19200  */
+    #endif  /* CONFIG_SERIAL_CX2450X_BAUDRATE_38400  */
+    #endif  /* CONFIG_SERIAL_CX2450X_BAUDRATE_57600  */
+    #endif  /* CONFIG_SERIAL_CX2450X_BAUDRATE_115200 */
+    #endif  /* CONFIG_SERIAL_CX2450X_BAUDRATE_230400 */
+
+    /* Check whether an invalid uart number has been specified, and if so, 
+       search for the first available port that does have console support. */
+    if (co->index > 2)
+	co->index = 0;
+    port = &cnxt_ports[co->index].port;
+
+    if (options)
+	uart_parse_options(options, &baud, &parity, &bits, &flow);
+
+    return uart_set_options(port, co, baud, parity, bits, flow);
+}
+
+/*******************************************************************************/
+
+static struct console cnxt_console;
+static struct uart_driver cnxt_reg;
+
+/*******************************************************************************/
+
+static struct console cnxt_console = 
+{
+    .name   = "ttyRI",
+    .write  = cnxtuart_console_write,
+    .device = cnxtuart_console_device,
+    .setup  = cnxtuart_console_setup,
+    .flags  = CON_PRINTBUFFER,
+    .index  = -1,
+    .data   = &cnxt_reg,
+};
+
+static int __init cnxtuart_console_init(void)
+{
+    u32 val;
+    u32 num = 0;
+    u32 irqtab[3] = {IRQ_UART1, IRQ_UART2, IRQ_UART3};
+    volatile u32 *reg;
+
+    #ifdef CONFIG_SERIAL_CX2450X_BOOTMSG
+
+    /* check for available UART's (enabled by the Bootloader/BIOS).
+       You may think, this is stupid, yes I think so too, but to have the early 
+       bootmessages on the specified console, we have to detect the ports and to 
+       sort the addresses and interrupts. */
+#ifdef CONFIG_SERIAL_CX2450X_UART1_ENABLE
+    /* UART 1 (PIO 1 (TX), PIO 2 (RX)) */
+    have_uart[0] = 0xFF;
+    reg = (volatile u32*) SREG_SEC_MUX_REG_BASE(0);
+    if ((*reg & 0x00000006) == 0)
+    {
+        reg = (volatile u32*) SREG_PRI_MUX_REG_BASE(0);
+        if ((*reg & 0x00000006) == 0x00000006)
+        {
+	    have_uart[0] = num;
+	    num++;
+	}
+    }
+
+#endif
+#ifdef CONFIG_SERIAL_CX2450X_UART2_ENABLE
+    /* check for UART 2 (can be configured on various pins) */
+    have_uart[1] = 0xFF;
+    reg = (volatile u32*) SREG_ALT_PIN_FUNC_REG;
+    val = (*reg >> 4) & 0x03;
+    if (val == 0)       /* PIO 3 (TX), 4 (RX) */
+    {
+	reg = (volatile u32*) SREG_SEC_MUX_REG_BASE(0);
+	if ((*reg & 0x00000018) == 0)
+	{
+	    reg = (volatile u32*) SREG_PRI_MUX_REG_BASE(0);
+	    if ((*reg & 0x00000018) == 0x00000018)
+	    {
+	        have_uart[1] = num;
+	        num++;
+	    }
+	}
+    }
+    else if (val == 1)  /* PIO 71 (RX), 72 (TX) */
+    {
+	reg = (volatile u32*) SREG_SEC_MUX_REG_BASE(2);
+	if ((*reg & 0x00000018) == 0)
+	{
+	    reg = (volatile u32*) SREG_PRI_MUX_REG_BASE(2);
+	    if ((*reg & 0x00000018) == 0x00000018)
+	    {
+	        have_uart[1] = num;
+		num++;
+	    }
+	}
+    }
+    else if (val == 2)  /* PIO 11 (RX), 73 (TX) */
+    {
+	reg = (volatile u32*) SREG_SEC_MUX_REG_BASE(2);
+	if ((*reg & 0x00000020) == 0)
+	{
+	    reg = (volatile u32*) SREG_PRI_MUX_REG_BASE(2);
+	    if ((*reg & 0x00000020) == 0x00000020)
+	    {
+	        reg = (volatile u32*) SREG_SEC_MUX_REG_BASE(0);
+	        if ((*reg & 0x00000800) == 0)
+	        {
+	            reg = (volatile u32*) SREG_PRI_MUX_REG_BASE(0);
+	            if ((*reg & 0x00000800) == 0x00000800)
+		    {
+	                have_uart[1] = num;
+			num++;
+		    }
+	        }
+	    }
+	}
+    }
+#endif
+#ifdef CONFIG_SERIAL_CX2450X_UART3_ENABLE
+    /* check for UART 3 (PIO 14 (TX), PIO 15 (RX)) */
+    have_uart[2] = 0xFF;
+    reg = (volatile u32*) SREG_SEC_MUX_REG_BASE(0);
+    if ((*reg & 0x0000C000) == 0)
+    {
+	reg = (volatile u32*) SREG_PRI_MUX_REG_BASE(0);
+    	if ((*reg & 0x0000C000) == 0x0000C000)
+    	    have_uart[2] = num;
+    }
+
+    /* finally register the detected ports */
+    for (val = 0; val < 3; val++)
+    {
+	if (have_uart[val] < 3)
+	{
+	    cnxt_ports[have_uart[val]].port.membase = (void *) IO_ADDRESS(UART_FIFO_BRDL_REG(val));
+	    cnxt_ports[have_uart[val]].port.mapbase = UART_FIFO_BRDL_REG(val);
+	    cnxt_ports[have_uart[val]].port.irq     = irqtab[val];
+	    cnxt_ports[have_uart[val]].port.line    = have_uart[val];
+	}
+    }
+#endif
+#endif /* CONFIG_SERIAL_CX2450X_BOOTMSG */
+
+    register_console(&cnxt_console);
+    return 0;
+}
+
+/*******************************************************************************/
+
+console_initcall(cnxtuart_console_init);
+#define CNXT_CONSOLE	&cnxt_console
+#else
+/* no console support enabled */
+#define CNXT_CONSOLE	NULL
+#endif	/* CONFIG_SERIAL_CX2450X_CONSOLE */
+
+/*******************************************************************************/
+
+static struct uart_driver cnxt_reg = 
+{
+    .owner	 = THIS_MODULE,
+    .driver_name = "CX2450X UART",
+    .dev_name	 = "ttyRI",
+    .major	 = 204,
+    .minor	 = 16,
+    .nr		 = 3,		/* max count of supported ports */
+    .cons	 = CNXT_CONSOLE,
+    .state	 = NULL,
+    .tty_driver	 = NULL,
+};
+
+/*******************************************************************************/
+
+static int __init cnxtuart_init(void)
+{
+    int ret;
+    u32 val;
+    #ifndef CONFIG_SERIAL_CX2450X_BOOTMSG
+    u32 num = 0;
+    u32 irqtab[3] = {IRQ_UART1, IRQ_UART2, IRQ_UART3};
+    volatile u32 *reg;
+    #endif
+
+    ret = uart_register_driver(&cnxt_reg);
+
+    if (ret == 0)
+    {
+	#ifndef CONFIG_SERIAL_CX2450X_BOOTMSG
+
+#ifdef CONFIG_SERIAL_CX2450X_UART1_ENABLE
+	/* if early boot messages are enabled, the detection is done in the console 
+	   init. In that case the kernel calls that function before. */
+
+	/* check for available UART's (enabled by the Bootloader/BIOS) */
+
+	/* UART 1 (PIO 1 (TX), PIO 2 (RX)) */
+	have_uart[0] = 0xFF;
+	reg = (volatile u32*) SREG_SEC_MUX_REG_BASE(0);
+	if ((*reg & 0x00000006) == 0)
+	{
+    	    reg = (volatile u32*) SREG_PRI_MUX_REG_BASE(0);
+    	    if ((*reg & 0x00000006) == 0x00000006)
+	    {
+        	have_uart[0] = num;
+		num++;
+	    }
+	}
+#endif
+#ifdef CONFIG_SERIAL_CX2450X_UART2_ENABLE							    
+	/* check for UART 2 (can be configured on various pins) */
+	have_uart[1] = 0xFF;
+	reg = (volatile u32*) SREG_ALT_PIN_FUNC_REG;
+	val = (*reg >> 4) & 0x03;
+	if (val == 0)       /* PIO 3 (TX), 4 (RX) */
+	{
+	    reg = (volatile u32*) SREG_SEC_MUX_REG_BASE(0);
+	    if ((*reg & 0x00000018) == 0)
+	    {
+	        reg = (volatile u32*) SREG_PRI_MUX_REG_BASE(0);
+	        if ((*reg & 0x00000018) == 0x00000018)
+		{
+	    	    have_uart[1] = num;
+		    num++;
+		}
+	    }
+	}
+	else if (val == 1)  /* PIO 71 (RX), 72 (TX) */
+        {
+	    reg = (volatile u32*) SREG_SEC_MUX_REG_BASE(2);
+	    if ((*reg & 0x00000018) == 0)
+	    {
+	        reg = (volatile u32*) SREG_PRI_MUX_REG_BASE(2);
+	        if ((*reg & 0x00000018) == 0x00000018)
+		{
+	            have_uart[1] = num;
+		    num++;
+		}
+	    }
+	}
+	else if (val == 2)  /* PIO 11 (RX), 73 (TX) */
+        {
+	    reg = (volatile u32*) SREG_SEC_MUX_REG_BASE(2);
+	    if ((*reg & 0x00000020) == 0)
+	    {
+	        reg = (volatile u32*) SREG_PRI_MUX_REG_BASE(2);
+	        if ((*reg & 0x00000020) == 0x00000020)
+	        {
+	            reg = (volatile u32*) SREG_SEC_MUX_REG_BASE(0);
+	            if ((*reg & 0x00000800) == 0)
+	            {
+	                reg = (volatile u32*) SREG_PRI_MUX_REG_BASE(0);
+	                if ((*reg & 0x00000800) == 0x00000800)
+			{
+	                    have_uart[1] = num;
+			    num++;
+			}
+	            }
+		}
+	    }
+	}
+#endif
+#ifdef CONFIG_SERIAL_CX2450X_UART3_ENABLE
+	/* check for UART 3 (PIO 14 (TX), PIO 15 (RX)) */
+        have_uart[2] = 0xFF;
+        reg = (volatile u32*) SREG_SEC_MUX_REG_BASE(0);
+	if ((*reg & 0x0000C000) == 0)
+        {
+	    reg = (volatile u32*) SREG_PRI_MUX_REG_BASE(0);
+    	    if ((*reg & 0x0000C000) == 0x0000C000)
+        	have_uart[2] = num;
+        }
+#endif
+	#endif /* CONFIG_SERIAL_CX2450X_BOOTMSG */
+
+	/* finally register the detected ports */
+	for (val = 0; val < 3; val++)
+	{
+	    if (have_uart[val] < 3)
+	    {
+		#ifndef CONFIG_SERIAL_CX2450X_BOOTMSG
+	        cnxt_ports[have_uart[val]].port.membase = (void *) IO_ADDRESS(UART_FIFO_BRDL_REG(val));
+	        cnxt_ports[have_uart[val]].port.mapbase = UART_FIFO_BRDL_REG(val);
+	        cnxt_ports[have_uart[val]].port.irq     = irqtab[val];
+	        cnxt_ports[have_uart[val]].port.line    = have_uart[val];
+		#endif /* CONFIG_SERIAL_CX2450X_BOOTMSG */
+    	        uart_add_one_port(&cnxt_reg, &cnxt_ports[have_uart[val]].port);
+	    }
+	}
+    }
+
+    return ret;
+}
+
+/*******************************************************************************/
+
+static void __exit cnxtuart_exit(void)
+{
+    if (have_uart[0] != 0xFF)
+    {
+	uart_remove_one_port(&cnxt_reg, &cnxt_ports[have_uart[0]].port);
+	have_uart[0] = 0xFF;
+    }
+
+    if (have_uart[1] != 0xFF)
+    {
+	uart_remove_one_port(&cnxt_reg, &cnxt_ports[have_uart[1]].port);
+	have_uart[1] = 0xFF;
+    }
+
+    if (have_uart[2] != 0xFF)
+    {
+	uart_remove_one_port(&cnxt_reg, &cnxt_ports[have_uart[2]].port);
+	have_uart[2] = 0xFF;
+    }
+
+    uart_unregister_driver(&cnxt_reg);
+}
+
+/*******************************************************************************/
+
+module_init(cnxtuart_init);
+module_exit(cnxtuart_exit);
+
+MODULE_AUTHOR("Conexant Systems, Inc. & Coolstream International Ltd.");
+MODULE_DESCRIPTION("Conexant CX2450x UART driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/usb/Kconfig b/drivers/usb/Kconfig
index 755823c..b9cb691 100644
--- a/drivers/usb/Kconfig
+++ b/drivers/usb/Kconfig
@@ -55,6 +55,7 @@ config USB_ARCH_HAS_EHCI
 	default y if PPC_83xx
 	default y if SOC_AU1200
 	default y if ARCH_IXP4XX
+	default y if ARCH_NEVIS
 	default PCI
 
 # ARM SA1111 chips have a non-PCI based "OHCI-compatible" USB host interface.
diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index 228797e..d1959bc 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -17,6 +17,33 @@ config USB_C67X00_HCD
 	  To compile this driver as a module, choose M here: the
 	  module will be called c67x00.
 
+config CX2450X_USB
+	bool "Conexant CX2450x (Nevis) USB support"
+	depends on USB && USB_ARCH_HAS_EHCI && ARCH_NEVIS
+	select USB_EHCI_HCD
+	select USB_EHCI_ROOT_HUB_TT
+	select USB_EHCI_SPLIT_ISO
+	---help---
+	  Enable this option to support the EHCI USB-Controller(s) included in
+	  the Conexant CX2450x (Nevis) SoC.
+
+config CX2450X_USB0
+	bool "enable USB port 1 on CX2450x"
+	depends on CX2450X_USB
+	default y
+
+config CX2450X_USB1
+	bool "enable USB port 2 on CX2450x"
+	depends on CX2450X_USB
+	default n
+	---help---
+	If you enable this option, the second USB-Controller available in
+	Chip revision C and later. Note that this controller needs the correct
+	GPIO-Setup from a bootloader or the init process, because this USB-port
+	can be routed to various GPIO-pins.
+
+if !ARCH_NEVIS
+
 config USB_EHCI_HCD
 	tristate "EHCI HCD (USB 2.0) support"
 	depends on USB && USB_ARCH_HAS_EHCI
@@ -236,6 +263,7 @@ config USB_UHCI_HCD
 
 	  To compile this driver as a module, choose M here: the
 	  module will be called uhci-hcd.
+endif
 
 config USB_U132_HCD
 	tristate "Elan U132 Adapter Host Controller"
diff --git a/drivers/usb/host/ehci-cx2450x.c b/drivers/usb/host/ehci-cx2450x.c
new file mode 100644
index 0000000..ac30d09
--- /dev/null
+++ b/drivers/usb/host/ehci-cx2450x.c
@@ -0,0 +1,259 @@
+/*
+ * EHCI HCD (Host Controller Driver) for USB.
+ *
+ * Bus Glue for Conexant CX2450X (Nevis) SoC
+ * (C) Copyright 2008 CoolStream Ltd.
+ *
+ * Based on "ehci-fsl.c"
+ * (C) Copyright 2005 MontaVista Software
+ *
+ * Based on "ehci-au1xxx.c" Bus Glue for AMD Alchemy Au1xxx
+ * (C) Copyright 2000-2004 David Brownell <dbrownell@users.sourceforge.net>
+ *
+ * This file is licenced under the GPL.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/version.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/cx2450x.h>
+
+#define PORTSC_REG_OFS	0x00000084
+
+/*******************************************************************************/
+
+/*
+ * configure so an HC device and id are always called with process context; 
+ * sleeping is OK
+ *
+ */
+
+/* usb_ehci_cx2450x_probe - initialize cx2450x-based HCDs
+ * Context: !in_interrupt()
+ *
+ * Allocates basic resources for this USB host controller, and then invokes the 
+ * start() method for the HCD associated with it through the hotplug entry's 
+ * driver_data.
+ */
+
+int usb_ehci_cx2450x_probe(const struct hc_driver *driver, struct platform_device *pdev)
+{
+    int retval;
+    struct usb_hcd *hcd;
+    struct resource *res;
+    int irq;
+
+    res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+    if (!res) 
+    {
+	dev_err(&pdev->dev, "%s: found hostcontroller with no IRQ. Check your setup!\n", pdev->dev.bus_id);
+	return -ENODEV;
+    }
+    irq = res->start;
+
+    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+    if (!res) 
+    {
+	dev_err(&pdev->dev, "%s: found hostcontroller with no register address. Check your setup!\n", pdev->dev.bus_id);
+	return -ENODEV;
+    }
+
+    hcd = usb_create_hcd(driver, &pdev->dev, pdev->dev.bus_id);
+
+    if (!hcd)
+	return -ENOMEM;
+
+    hcd->rsrc_start = res->start;
+    hcd->rsrc_len = res->end - res->start + 1;
+
+    if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) 
+    {
+	usb_put_hcd(hcd);
+	return -EBUSY;
+    }
+
+    hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
+
+    if (!hcd->regs) 
+    {
+	printk(KERN_ERR "failed to ioremap USB driver\n");
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+	usb_put_hcd(hcd);
+	return -ENOMEM;
+    }
+
+    retval = usb_add_hcd(hcd, irq, IRQF_SHARED | IRQF_DISABLED);
+    if (!retval) 
+	return retval;
+
+    iounmap(hcd->regs);
+    release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+    usb_put_hcd(hcd);
+
+    return retval;
+}
+
+/*******************************************************************************/
+
+/* may be called without controller electrically present */
+/* may be called with controller, bus, and devices active */
+
+/*
+ * usb_ehci_hcd_cx2450x_remove - shutdown processing for cx2450x-based HCDs
+ * @dev: USB Host Controller being removed
+ * Context: !in_interrupt()
+ *
+ * Reverses the effect of usb_ehci_hcd_cx2450x_probe(), first invoking
+ * the HCD's stop() method.  It is always called from a thread
+ * context, normally "rmmod", "apmd", or something similar.
+ *
+ */
+
+void usb_ehci_cx2450x_remove(struct usb_hcd *hcd, struct platform_device *pdev)
+{
+    usb_remove_hcd(hcd);
+    iounmap(hcd->regs);
+    release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+    usb_put_hcd(hcd);
+}
+
+/*******************************************************************************/
+
+static int ehci_cx2450x_reinit(struct ehci_hcd *ehci)
+{
+    volatile u32 *usb_enable = (volatile u32*) SREG_USB_ENABLE_REG;
+
+    *usb_enable |= 0x00000703;	/* datasheet is wrong. For "active low" power control bit 6 and 7 must be leave at 0 */
+    msleep(200);
+
+    ehci_port_power(ehci, 0);
+
+    return 0;
+}
+
+/*******************************************************************************/
+
+static int ehci_cx2450x_setup(struct usb_hcd *hcd)
+{
+    struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+    int retval;
+
+    /* Conexant EHCI capability registers start at 0x100 */
+    ehci->caps = hcd->regs;
+    ehci->regs = hcd->regs + HC_LENGTH(readl(&ehci->caps->hc_capbase));
+
+    /* Conexant USB controller has a TT. */
+    hcd->has_tt = 1;
+
+    dbg_hcs_params(ehci, "reset");
+    dbg_hcc_params(ehci, "reset");
+		
+    /* cache this readonly data; minimize chip reads */
+    ehci->hcs_params = readl(&ehci->caps->hcs_params);
+
+    ehci_reset(ehci);
+    retval = ehci_halt(ehci);
+    if (retval)
+	return retval;
+
+    /* data structure init */
+    retval = ehci_init(hcd);
+    if (retval)
+	return retval;
+
+#if 0
+    temp = HCS_N_CC(ehci->hcs_params) * HCS_N_PCC(ehci->hcs_params);
+    temp &= 0x0F;
+    if (temp && HCS_N_PORTS(ehci->hcs_params) > temp) 
+    {
+	printk("bogus port configuration: "
+	       "cc=%d x pcc=%d < ports=%d\n",
+	       HCS_N_CC(ehci->hcs_params),
+	       HCS_N_PCC(ehci->hcs_params),
+	       HCS_N_PORTS(ehci->hcs_params));
+    }
+#endif
+
+    retval = ehci_cx2450x_reinit(ehci);
+    return retval;
+}
+
+/*******************************************************************************/
+
+static const struct hc_driver ehci_cx2450x_hc_driver = 
+{
+    .description   = hcd_name,
+    .product_desc  = "Conexant CX2450X EHCI USB-Controller",
+    .hcd_priv_size = sizeof(struct ehci_hcd),
+
+    /* generic hardware linkage */
+    .irq   = ehci_irq,
+    .flags = HCD_MEMORY | HCD_USB2,
+
+    /* basic lifecycle operations */
+    .reset    = ehci_cx2450x_setup,
+    .start    = ehci_run,
+    .stop     = ehci_stop,
+    .shutdown = ehci_shutdown,
+
+    /* managing i/o requests and associated device resources */
+    .urb_enqueue      = ehci_urb_enqueue,
+    .urb_dequeue      = ehci_urb_dequeue,
+    .endpoint_disable = ehci_endpoint_disable,
+
+    /* scheduling support */
+    .get_frame_number = ehci_get_frame,
+
+    /* root hub support */
+    .hub_status_data = ehci_hub_status_data,
+    .hub_control     = ehci_hub_control,
+
+    .relinquish_port  = ehci_relinquish_port,
+    .port_handed_over = ehci_port_handed_over,
+
+    .bus_suspend = ehci_bus_suspend,
+    .bus_resume  = ehci_bus_resume
+
+    #ifdef	CONFIG_PM
+    .hub_suspend = NULL,
+    .hub_resume  = NULL,
+    #endif
+};
+
+/*******************************************************************************/
+
+static int ehci_hcd_cx2450x_drv_probe(struct platform_device *pdev)
+{
+    if (usb_disabled())
+	return -ENODEV;
+
+    return usb_ehci_cx2450x_probe(&ehci_cx2450x_hc_driver, pdev);
+}
+
+/*******************************************************************************/
+
+static int ehci_hcd_cx2450x_drv_remove(struct platform_device *pdev)
+{
+    struct usb_hcd *hcd = platform_get_drvdata(pdev);
+
+    usb_ehci_cx2450x_remove(hcd, pdev);
+    return 0;
+}
+
+/*******************************************************************************/
+
+MODULE_ALIAS("platform:cx2450x-ehci");
+
+static struct platform_driver ehci_cx2450x_driver = 
+{
+    .probe    = ehci_hcd_cx2450x_drv_probe,
+    .remove   = ehci_hcd_cx2450x_drv_remove,
+    .shutdown = usb_hcd_platform_shutdown,
+    .driver   = 
+    {
+	.name = "cx2450x-ehci",
+	.bus = &platform_bus_type
+    }
+};
+
+/*******************************************************************************/
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 369a8a5..8c7199b 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1034,6 +1034,11 @@ MODULE_LICENSE ("GPL");
 #define	PLATFORM_DRIVER		ixp4xx_ehci_driver
 #endif
 
+#ifdef CONFIG_CX2450X_USB
+#include "ehci-cx2450x.c"
+#define PLATFORM_DRIVER		ehci_cx2450x_driver
+#endif
+
 #if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER) && \
     !defined(PS3_SYSTEM_BUS_DRIVER) && !defined(OF_PLATFORM_DRIVER)
 #error "missing bus glue for ehci-hcd"
diff --git a/fs/direct-io.c b/fs/direct-io.c
index 9e81add..435b310 100644
--- a/fs/direct-io.c
+++ b/fs/direct-io.c
@@ -1000,7 +1000,16 @@ direct_io_worker(int rw, struct kiocb *iocb, struct inode *inode,
 		}
 		dio->total_pages += (bytes + PAGE_SIZE - 1) / PAGE_SIZE;
 		dio->curr_user_address = user_addr;
-	
+#if defined(CONFIG_ARCH_NEVIS)
+		/*.
+		 * Invalidate user address for read requests (can corrupt data
+		 * in case of non-page color aligned user pages)..
+		 */
+		if(rw == READ) {
+			if (dmac_inv_range)
+				dmac_inv_range((void *) user_addr, (void *) user_addr + bytes);
+		}
+#endif
 		ret = do_direct_IO(dio);
 
 		dio->result += iov[seg].iov_len -
diff --git a/fs/proc/proc_misc.c b/fs/proc/proc_misc.c
index 7e277f2..277cbe5 100644
--- a/fs/proc/proc_misc.c
+++ b/fs/proc/proc_misc.c
@@ -68,7 +68,9 @@ extern int get_hardware_list(char *);
 extern int get_stram_list(char *);
 extern int get_exec_domain_list(char *);
 extern int get_dma_list(char *);
-
+#ifdef CONFIG_ARCH_NEVIS
+extern int get_idle_list(char *);
+#endif
 static int proc_calc_metrics(char *page, char **start, off_t off,
 				 int count, int *eof, int len)
 {
@@ -80,6 +82,15 @@ static int proc_calc_metrics(char *page, char **start, off_t off,
 	return len;
 }
 
+#ifdef CONFIG_ARCH_NEVIS
+static int mipidle_read_proc(char *page, char **start, off_t off,
+		int count, int *eof, void *data)
+{
+	int len = get_idle_list(page);
+	return proc_calc_metrics(page, start, off, count, eof, len);
+}
+#endif
+
 static int loadavg_read_proc(char *page, char **start, off_t off,
 				 int count, int *eof, void *data)
 {
@@ -837,6 +848,9 @@ void __init proc_misc_init(void)
 		{"loadavg",     loadavg_read_proc},
 		{"uptime",	uptime_read_proc},
 		{"meminfo",	meminfo_read_proc},
+#ifdef CONFIG_ARCH_NEVIS
+		{"mipidle",     mipidle_read_proc},
+#endif
 		{"version",	version_read_proc},
 #ifdef CONFIG_PROC_HARDWARE
 		{"hardware",	hardware_read_proc},
diff --git a/include/asm-arm/arch-nevis/cx2450x.h b/include/asm-arm/arch-nevis/cx2450x.h
new file mode 100644
index 0000000..50438fc8
--- /dev/null
+++ b/include/asm-arm/arch-nevis/cx2450x.h
@@ -0,0 +1,159 @@
+/************************************************************************************
+ * linux/include/asm-arm/arch-nevis/cx2450x.h
+ *
+ * global register definitions
+ *
+ *  Copyright (C) 2008 Coolstream International Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License Version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02111-1307  USA
+ *************************************************************************************/
+
+#ifndef __CX2450X_H
+#define __CX2450X_H
+
+/* CX2450X Base clock frequency */
+#define NEVIS_XTAL_FREQUENCY		UL(60000000)
+
+//#define HSX_BASE                	(0xE0000000)
+#define HSX_PIT_GENERAL_REG		(0xE0000100)
+#define HSX_PIT_DATA_REG		(0xE0000104)
+#define HSX_PIT_INSTR_REG		(0xE0000108)
+
+/* ISA Aperture */
+#define ISA_IO_BASE_ADDR		(0xE1000000)
+#define ISA_IO_BANK_SIZE		(0x00100000)
+
+/* ROM/ISA Mapping */
+#define ROM_DESC_REG_BASE(x)		(0xE0010000 + ((x) * 4))	/* ROM descriptor base (x = 0 ... 7) */
+#define ROM_MAP_REG_BASE(x)		(0xE0010020 + ((x) * 4))	/* ROM mapping register base (x = 0 ... 7) */
+#define ROM_EXT_DESC_REG_BASE(x)	(0xE0010080 + ((x) * 4))	/* ROM ext. descriptor base (x = 0 ... 7) */
+/* PCI Interface */
+//#define PCI_BASE			(0xE0010000)
+#define PCI_ROM_DESC0_REG		(0xE0010000)
+#define PCI_ISAROM_DESC1_REG		(0xE0010004)
+#define PCI_ROM_DESC0_REG2		(0xE0010080)
+#define PCI_CFG_ADDR_REG		(0xE0010040)
+#define PCI_CFG_DATA_REG		(0xE0010044)
+#define PCI_INTSTAT_REG			(0xE0010054)			/* PCI Controller Interrupt Status Register */
+/* System controller */
+#define SYS_SOFTRESET_REG		(0xE040001C)			/* writing anything causes a reset */
+
+/* UART's 
+   (16550 compatible except: FIFOs allways on, no DMA mode select, 
+   no support for 5 and 6 bit data frames, no scratch register) */
+#define	UART_FIFO_BRDL_REG(x)		(0xE0410000 + ((x) * 0x1000))	/* FIFO (BDS=0) or lower baud rate divisor (BDS=1) register (x = 0 ... 3) */
+#define	UART_IRQE_BRDU_REG(x)		(0xE0410004 + ((x) * 0x1000))	/* Interrupt enable (BDS=0) or upper baud rate divisor (BDS=1) register (x = 0 ... 3) */
+#define	UART_FIFC_REG(x)		(0xE0410008 + ((x) * 0x1000))	/* FIFO control register (x = 0 ... 3) */
+#define	UART_FRMC_REG(x)		(0xE041000C + ((x) * 0x1000))	/* Frame control register (x = 0 ... 3) */
+#define	UART_STAT_REG(x)		(0xE0410014 + ((x) * 0x1000))	/* Status register (x = 0 ... 3) */
+#define	UART_IRLVL_REG(x)		(0xE0410018 + ((x) * 0x1000))	/* Interrupt level register (x = 0 ... 3) */
+#define	UART_IRDC_REG(x)		(0xE0410020 + ((x) * 0x1000))	/* IrDA control register (x = 0 ... 3) */
+#define	UART_TXSTA_REG(x)		(0xE0410028 + ((x) * 0x1000))	/* Transmit FIFO status register (x = 0 ... 3) */
+#define	UART_RXSTA_REG(x)		(0xE041002C + ((x) * 0x1000))	/* Receive FIFO status register (x = 0 ... 3) */
+#define	UART_EXP_REG(x)			(0xE0410030 + ((x) * 0x1000))	/* Expansion register (x = 0 ... 3) */
+
+/* General Purpos Timers */
+#define TIMER_VALUE_REG_BASE(x)		(0xE0430000 + ((x) * 0x10))	/* the current timer value (x = 0 ... 15) */
+#define TIMER_LIMIT_REG_BASE(x)		(0xE0430004 + ((x) * 0x10))	/* the timer limit value (x = 0 ... 15) */
+#define TIMER_MODE_REG_BASE(x)		(0xE0430008 + ((x) * 0x10))	/* the mode bits (x = 0 ... 15) */
+#define TIMER_BASE_REG_BASE(x)		(0xE043000C + ((x) * 0x10))	/* the clock base (x = 0 ... 15) */
+#define TIMER_INT_STAT_REG		(0xE0430100)			/* the interrupt status */
+
+/* PLL */
+#define PLL_BASE			(0xE0440000)
+#define PLL_MPG0_INTFRAC_REG		(0xE0440000)
+#define PLL_MPG0_CTRL_REG		(0xE0440004)
+#define PLL_FENRUS_CTRL_REG		(0xE0440048)
+#define PLL_DIV_MUX_CTRL1_REG		(0xE0440054)
+#define PLL_DIV_MUX_CTRL10_REG		(0xE0440078)
+
+#define PLL_CONFIG0_REG			(0xE0440100)
+
+/* System Registers */
+#define SREG_ALT_PIN_FUNC_REG		(0xE0440110)			/* alternate pin function register */
+#define	SREG_USB_ENABLE_REG		(0xE0440138)
+#define SREG_PRI_MUX_REG_BASE(x)	(0xE0440180 + ((x) * 4))	/* Primary PIO multiplex select register (x = 0 ... 6) */
+#define SREG_SEC_MUX_REG_BASE(x)	(0xE04401C0 + ((x) * 4))	/* Secondary PIO multiplex select register (x = 0 ... 6) */
+
+/* Interrupt Controller */
+#define ITC_DEST_REG_BASE(x)		(0xE0450000 + ((x) * 0x20))	/* Interrupt Destination Registers (x = 0 ... 3) */
+#define ITC_ENABLE_REG_BASE(x)		(0xE0450004 + ((x) * 0x20))	/* Interrupt Enable Registers (x = 0 ... 3) */
+#define ITC_IRQREQ_REG_BASE(x)		(0xE0450008 + ((x) * 0x20))	/* Interrupt Enable Registers (x = 0 ... 3) */
+#define ITC_STATCLR_REG_BASE(x)		(0xE0450010 + ((x) * 0x20))	/* Interrupt Status/Clear Registers (x = 0 ... 3) */
+#define ITC_STATSET_REG_BASE(x)		(0xE0450014 + ((x) * 0x20))	/* Interrupt Status/Set Registers (x = 0 ... 3) */
+
+/* Infrared Remote Controllers */
+#define IR_CTRL_REG_BASE(x)		(0xE0460000 + ((x) * 0x1000))	/* Control register (x = 0 ... 1) */
+#define IR_TXCLK_REG_BASE(x)		(0xE0460004 + ((x) * 0x1000))	/* TX-clock divider register (x = 0 ... 1) */
+#define IR_RXCLK_REG_BASE(x)		(0xE0460008 + ((x) * 0x1000))	/* RX-clock divider register (x = 0 ... 1) */
+#define IR_CDUTY_REG_BASE(x)		(0xE046000C + ((x) * 0x1000))	/* TX-carrier duty cycle register (x = 0 ... 1) */
+#define IR_STAT_REG_BASE(x)		(0xE0460010 + ((x) * 0x1000))	/* Status register (x = 0 ... 1) */
+#define IR_IRQEN_REG_BASE(x)		(0xE0460014 + ((x) * 0x1000))	/* Interrupt enable register (x = 0 ... 1) */
+#define IR_FILTER_REG_BASE(x)		(0xE0460018 + ((x) * 0x1000))	/* Low pass filter register (x = 0 ... 1) */
+#define IR_FIFO_REG_BASE(x)		(0xE0460040 + ((x) * 0x1000))	/* FIFO register (x = 0 ... 1) */
+
+/* General Purpose I/O Controller */
+#define GPIO_READ_REG_BASE(x)		(0xE0470000 + ((x) * 0x40))	/* Read registers (x = 0 ... 6) */
+#define GPIO_DRIVE_HIGH_REG_BASE(x)	(0xE0470004 + ((x) * 0x40))	/* Drive high registers (x = 0 ... 6) */
+#define GPIO_DRIVE_LOW_REG_BASE(x)	(0xE0470008 + ((x) * 0x40))	/* Drive low registers (x = 0 ... 6) */
+#define GPIO_DRIVE_OFF_REG_BASE(x)	(0xE047000C + ((x) * 0x40))	/* Drive off registers (x = 0 ... 6) */
+#define GPIO_INTSTAT_REG_BASE(x)	(0xE0470010 + ((x) * 0x40))	/* Interrupt Status Registers (x = 0 ... 6) */
+#define GPIO_INTENA_REG_BASE(x)		(0xE0470014 + ((x) * 0x40))	/* Interrupt Enable Registers (x = 0 ... 6 ) */
+#define GPIO_POS_EDGE_REG_BASE(x)	(0xE0470018 + ((x) * 0x40))	/* positive edge trigger register (x = 0 ... 6) */
+#define GPIO_NEG_EDGE_REG_BASE(x)	(0xE047001C + ((x) * 0x40))	/* negative trigger registers (x = 0 ... 6) */
+#define GPIO_LEVEL_REG_BASE(x)		(0xE0470020 + ((x) * 0x40))	/* level trigger registers (x = 0 ... 6) */
+
+/* memory controller */
+//#define MEM_PLL_CTRL0_REG		0xE0500800
+#define MEM_PLL_CTRL1_REG		0xE0500804
+#define MEM_PLL_CTRL2_REG		0xE0500808
+//#define MEM_PLL_CTRL3_REG		0xE050080C
+
+/* Network controller(s) */
+#define EMAC0_BASE			(0xE8003000)
+#define EMAC1_BASE			(0xE8004000)
+
+#define EMAC_ID_REG(x)			(0xE8003000 + ((x) * 0x1000))
+#define EMAC_STAT_REG(x)		(0xE8003004 + ((x) * 0x1000))
+#define EMAC_ENABLE_REG(x)		(0xE8003008 + ((x) * 0x1000))
+#define EMAC_CONTROL_REG(x)		(0xE800300C + ((x) * 0x1000))
+#define EMAC_POLLRATE_REG(x)		(0xE8003010 + ((x) * 0x1000))
+#define EMAC_RXERR_REG(x)		(0xE8003014 + ((x) * 0x1000))
+#define EMAC_MISS_REG(x)		(0xE8003018 + ((x) * 0x1000))
+#define EMAC_TXRINGPTR_REG(x)		(0xE800301C + ((x) * 0x1000))
+#define EMAC_RXRINGPTR_REG(x)		(0xE8003020 + ((x) * 0x1000))
+#define EMAC_ADDRL_REG(x)		(0xE8003024 + ((x) * 0x1000))
+#define EMAC_ADDRH_REG(x)		(0xE8003028 + ((x) * 0x1000))
+#define EMAC_LAFL_REG(x)		(0xE800302C + ((x) * 0x1000))
+#define EMAC_LAFH_REG(x)		(0xE8003030 + ((x) * 0x1000))
+#define EMAC_MDIO_REG(x)		(0xE8003034 + ((x) * 0x1000))
+#define EMAC_TXPTRREAD_REG(x)		(0xE8003038 + ((x) * 0x1000))
+#define EMAC_RXPTRREAD_REG(x)		(0xE800303C + ((x) * 0x1000))
+#define EMAC_XTRACTRL_REG(x)		(0xE8003040 + ((x) * 0x1000))
+
+/* vaious definitions */
+#define CHIP_CRYSTAL_FREQUENCY		60000000			/* SoC is clocked by a 60.000 MHz crystal */
+#define XTAL_PRESCALE_FACTOR		1
+
+#define MPG0PLL				0x00
+#define MPG1PLL				0x01
+#define HDPLL				0x02
+#define AUDPLL				0x03
+//#define MEMPLL				0x04
+#define PLL0				0x05
+#define PLL1				0x06
+#define PLL2				0x07
+#define FENRUSPLL			0x08
+
+#endif /* __CX2450X_H */
diff --git a/include/asm-arm/arch-nevis/debug-macro.S b/include/asm-arm/arch-nevis/debug-macro.S
new file mode 100644
index 0000000..42b10a0
--- /dev/null
+++ b/include/asm-arm/arch-nevis/debug-macro.S
@@ -0,0 +1,51 @@
+/****************************************************************************
+ *
+ *  include/asm-arm/arch-pecos/debug-macro.S
+ *
+ *  Copyright (C) 2007 Conexant Systems Inc, USA.
+ *  Copyright (C) 2008 CoolStream International Limited.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License Version 2 as published by
+ *  the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02111-1307  USA
+ *
+ ****************************************************************************/
+		/* .equ	io_virt, ASX_VADDR_BASE @ 0xFD00.0000 */
+		/* .equ	io_phys, ASX_PHYS_BASE  @ 0xE000.0000 */
+		.equ	io_virt, 0xE0000000 @ 0xFD00.0000  
+		.equ	io_phys, 0xE0000000 @ 0xE000.0000
+
+		.macro	addruart,rx
+		mrc     p15, 0, \rx, c1, c0
+		tst     \rx, #1			@ MMU enabled?
+		mov     \rx, #0x2000
+		orr	\rx, #0x410000
+		orreq   \rx, \rx, #io_phys	@ ASX physical base address
+		orrne   \rx, \rx, #io_virt	@ ASX virtual address
+		.endm
+
+		.macro	senduart,rd,rx
+		strb	\rd, [\rx]		@ SER_DATA_REG
+		.endm
+
+		.macro	waituart,rd,rx
+1001:		ldrb	\rd,    [\rx, #0x14]    @ SER_STATUS_REG
+		tst     \rd, #(1 << 6)            @ SER_STATUS_TXIDLE
+		beq     1001b
+		.endm
+
+		.macro	busyuart,rd,rx
+1002:           ldrb     \rd,[\rx, #0x14]	@ SER_STATUS_REG
+                tst     \rd, #(1 << 6)		@ SER_STATUS_TXIDLE
+		bne	1002b
+		.endm
+
diff --git a/include/asm-arm/arch-nevis/dma.h b/include/asm-arm/arch-nevis/dma.h
new file mode 100644
index 0000000..16bb898
--- /dev/null
+++ b/include/asm-arm/arch-nevis/dma.h
@@ -0,0 +1,27 @@
+/***********************************************************************************
+ *  linux/include/asm-arm/arch-nevis/dma.h
+ *
+ *  Copyright 2007 Conexant Systems Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License Version 2 as published by
+ *  the Free Software Foundation.
+ * 
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ * 
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02111-1307  USA
+ *
+ **************************************************************************************/
+
+#ifndef __ASM_ARCH_DMA_H
+#define __ASM_ARCH_DMA_H
+
+#define MAX_DMA_ADDRESS		0xffffffff
+#define MAX_DMA_CHANNELS	0
+
+#endif /* _ASM_ARCH_DMA_H */
diff --git a/include/asm-arm/arch-nevis/drivers.h b/include/asm-arm/arch-nevis/drivers.h
new file mode 100644
index 0000000..9a4bfc9
--- /dev/null
+++ b/include/asm-arm/arch-nevis/drivers.h
@@ -0,0 +1,17 @@
+#ifndef __DRIVERS_H
+#define __DRIVERS_H
+
+
+
+#ifdef CONEXANT_DRIVERS
+
+//#define __ASM_ARCH_NEVIS_GPIO_H__
+#define __ASM_ARCH_NEVIS_HARDWARE_H
+#define __ASM_ARCH_NEVIS_INTID_H
+#define __ASM_ARCH_NEVIS_IRQ_H
+#define __ASM_ARCH_NEVIS_IRQS_H
+#define __ASM_ARCH_NEVIS_H_
+
+#endif
+
+#endif
diff --git a/include/asm-arm/arch-nevis/entry-macro.S b/include/asm-arm/arch-nevis/entry-macro.S
new file mode 100644
index 0000000..43bdeb2
--- /dev/null
+++ b/include/asm-arm/arch-nevis/entry-macro.S
@@ -0,0 +1,109 @@
+/******************************************************************************
+ * include/asm-arm/arch-nevis/entry-macro.S
+ *
+ *  Copyright (C) 2007 Conexant Systems Inc, USA.
+ *  Copyright (C) 2010 CoolStream Int Ltd.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License Version 2 as published by
+ *  the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02111-1307  USA
+ *
+ ****************************************************************************/
+
+#include <asm/arch/cx2450x.h>
+#define MAXIRQNUM 32
+
+		.equ itc_intstatset_1   , ITC_STATSET_REG_BASE(0)
+		.equ itc_intstatenable_1, ITC_ENABLE_REG_BASE(0)
+		.equ itc_intstatset_2   , ITC_STATSET_REG_BASE(1)
+		.equ itc_intstatenable_2, ITC_ENABLE_REG_BASE(1)
+		.equ itc_intstatset_3   , ITC_STATSET_REG_BASE(2)
+		.equ itc_intstatenable_3, ITC_ENABLE_REG_BASE(2)
+		.equ itc_intstatset_4   , ITC_STATSET_REG_BASE(3)
+		.equ itc_intstatenable_4, ITC_ENABLE_REG_BASE(3)
+
+		.macro  disable_fiq
+		.endm
+
+		.macro  get_irqnr_preamble, base, tmp
+		.endm
+
+		.macro  arch_ret_to_user, tmp1, tmp2
+		.endm
+
+		.macro  get_irqnr_and_base, irqnr, irqstat, base, tmp
+		/* Check IRQ controller #0 */
+		ldr	\tmp, =itc_intstatset_1
+		ldr	\irqstat, [\tmp]
+		ldr	\tmp, =itc_intstatenable_1
+		ldr	\tmp, [\tmp]
+		ands	\irqstat, \irqstat, \tmp	@ Any IRQ set ?
+		beq	1001f				@ No IRQ set, check IRQ block 1
+
+		mov	\irqnr, #0			@ IRQ nr = 0
+1100:		movs	\irqstat, \irqstat, lsr #1	@ Shift bit into carry
+		bcs	1004f				@ IRQ found, get out of here.
+		add	\irqnr, \irqnr, #1		@ Increase irqnr
+		bne	1100b				@ Check next IRQ
+		b	1005f				@ Uhhh...
+
+1001:		/* Check IRQ controller #1 */
+		ldr	\tmp, =itc_intstatset_2
+		ldr	\irqstat, [\tmp]
+		ldr	\tmp, =itc_intstatenable_2
+		ldr	\tmp, [\tmp]
+		ands	\irqstat, \irqstat, \tmp	@ Any IRQ set ?
+		beq	1002f				@ No IRQ set, check IRQ block 2
+
+		mov	\irqnr, #32			@ IRQ nr = 32
+1200:		movs	\irqstat, \irqstat, lsr #1	@ Shift bit into carry
+		bcs	1004f				@ IRQ found, get out of here.
+		add	\irqnr, \irqnr, #1		@ Increase irqnr
+		bne	1200b				@ Check next IRQ
+		b	1005f				@ Uhhh...
+
+1002:		/* Check IRQ controller #2 */
+		ldr	\tmp, =itc_intstatset_3	
+		ldr	\irqstat, [\tmp]
+		ldr	\tmp, =itc_intstatenable_3
+		ldr	\tmp, [\tmp]
+		ands	\irqstat, \irqstat, \tmp	@ Any IRQ set ?
+		beq	1003f				@ No IRQ set, check IRQ block 3
+		mov	\irqnr, #64			@ IRQ nr = 64
+
+1300:		movs	\irqstat,\irqstat,lsr #1	@ Shift bit into carry
+		bcs	1004f				@ IRQ found, get out of here.
+		add	\irqnr, \irqnr, #1		@ Increase irqnr
+		bne	1300b				@ Check next IRQ
+		b	1005f				@ Uhhh...
+
+1003:		/* Check IRQ controller #3 */
+		ldr	\tmp, =itc_intstatset_4
+		ldr	\irqstat, [\tmp]
+		ldr	\tmp, =itc_intstatenable_4
+		ldr	\tmp, [\tmp]
+		ands	\irqstat, \irqstat, \tmp	@ Any IRQ set ?
+		beq	1005f				@ No IRQ set, get out of here
+		mov	\irqnr, #96			@ IRQ nr = 96
+
+1400:		movs	\irqstat, \irqstat, lsr #1	@ Shift bit into carry
+		bcs	1004f				@ IRQ found, get out of here.
+		add	\irqnr, \irqnr, #1		@ Increase irqnr
+		bne	1400b				@ Check next IRQ
+		b	1005f				@ No IRQs set, hmm
+		/* IRQ found */
+1004:		movs	\irqstat, #1			@ Force !Z 
+1005:		/* If No IRQ are set */
+		.endm
+
+		.macro  irq_prio_table
+		.endm
diff --git a/include/asm-arm/arch-nevis/gpio.h b/include/asm-arm/arch-nevis/gpio.h
new file mode 100644
index 0000000..7f9c296
--- /dev/null
+++ b/include/asm-arm/arch-nevis/gpio.h
@@ -0,0 +1,83 @@
+/*
+ * (C) Copyright 2008
+ * Coolstream Internation Limited
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __ASM_ARCH_NEVIS_GPIO_H__
+#define __ASM_ARCH_NEVIS_GPIO_H__
+
+#ifdef __KERNEL__
+
+#include <linux/types.h>
+#include <asm/irq.h>
+#include <asm-generic/gpio.h>
+#include <asm/hardware.h>
+
+#define PIO_READ_REG		0xE0470000
+#define PIO_DRIVE_HIGH_REG	0xE0470004
+#define PIO_DRIVE_LOW_REG	0xE0470008
+#define PIO_DRIVE_OFF_REG	0xE047000C
+
+#define PIO_HIGH		PIO_DRIVE_HIGH_REG	/* drive PIO HIGH */
+#define PIO_LOW			PIO_DRIVE_LOW_REG	/* drive PIO LOW */
+#define PIO_OFF			PIO_DRIVE_OFF_REG	/* switch PIO into input mode */
+
+#define GPIO_MAX		224
+#define GPIO_bit(_n)		(1 << ((_n) & 0x1F))
+#define GPLR(_n)		(*((u32*)(PIO_READ_REG       + ((_n) * 0x40))))
+#define GPSR(_n)		(*((u32*)(PIO_DRIVE_HIGH_REG + ((_n) * 0x40))))
+#define GPCR(_n)		(*((u32*)(PIO_DRIVE_LOW_REG  + ((_n) * 0x40))))
+
+void gpio_drive(u32 pio, u32 state);
+u32 gpio_read(u32 pio);
+
+static inline int gpio_get_value(unsigned gpio)
+{
+	if (__builtin_constant_p(gpio) && (gpio < GPIO_MAX))
+		return GPLR(gpio) & GPIO_bit(gpio);
+	else
+		return __gpio_get_value(gpio);
+}
+
+static inline void gpio_set_value(unsigned gpio, int value)
+{
+	if (__builtin_constant_p(gpio) && (gpio < GPIO_MAX))
+		if (value)
+			GPSR(gpio) = GPIO_bit(gpio);
+		else
+			GPCR(gpio) = GPIO_bit(gpio);
+	else
+		__gpio_set_value(gpio, value);
+}
+
+#define gpio_cansleep   __gpio_cansleep
+
+static inline unsigned gpio_to_irq(unsigned gpio)
+{
+	return gpio + 128;
+}
+
+static inline unsigned irq_to_gpio(unsigned irq)
+{
+	return irq - 128;
+}
+
+
+#endif /* __KERNEL__ */
+
+#endif /* __ASM_ARCH_NEVIS_GPIO_H__ */
diff --git a/include/asm-arm/arch-nevis/hardware.h b/include/asm-arm/arch-nevis/hardware.h
new file mode 100644
index 0000000..4adbab6
--- /dev/null
+++ b/include/asm-arm/arch-nevis/hardware.h
@@ -0,0 +1,41 @@
+/************************************************************************************
+ *  include/asm-arm/arch-nevis/hardware.h
+ *
+ * Copyright (C) 2007 Conexant Systems Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License Version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02111-1307  USA
+ *************************************************************************************/
+#ifndef __ASM_ARCH_NEVIS_HARDWARE_H
+#define __ASM_ARCH_NEVIS_HARDWARE_H
+
+#include <asm/sizes.h>
+#include <asm/arch/platform.h>
+#include <asm/arch/memmap.h>
+
+/*
+ * Conversion from Phys to Virt
+ */
+#define ASX_TO_VIRT(x)		(((unsigned int)(x) - (unsigned int)ASX_PHYS_BASE ) + (unsigned int)ASX_VADDR_BASE)
+#define EXT_IO_TO_VIRT(x)	(((unsigned int)(x) - (unsigned int)EXT_IO_PHYS_BASE ) + (unsigned int)EXT_IO_VADDR_BASE )
+//#define PCI_MEM_TO_VIRT(x)	(unsigned int)(x)
+#define PCIBIOS_MIN_IO		0x6000
+#define PCIBIOS_MIN_MEM		0x10000
+
+/*
+ * Override the logic in pci_scan_bus
+ * for skipping already-configured bus numbers.
+ */
+#define pcibios_assign_all_busses() 1
+
+#endif /* __ASM_ARCH_HARDWARE_H */
diff --git a/include/asm-arm/arch-nevis/ide.h b/include/asm-arm/arch-nevis/ide.h
new file mode 100644
index 0000000..d95c70a
--- /dev/null
+++ b/include/asm-arm/arch-nevis/ide.h
@@ -0,0 +1,30 @@
+/*
+ * linux/include/asm-arm/arch-shark/ide.h
+ *
+ * derived from:
+ * linux/include/asm-arm/arch-ebsa285/ide.h
+ * Copyright (c) 1998 Russell King
+ */
+
+#include <asm/irq.h>
+
+
+static __inline__ int ide_default_irq(ide_ioreg_t base)
+{
+	return 0;
+}
+
+static __inline__ ide_ioreg_t ide_default_io_base(int index)
+{
+	return 0;
+}
+
+
+static __inline__ void
+ide_init_hwif_ports(hw_regs_t * hw, int data_port, int ctrl_port, int *irq)
+{
+}
+
+static __inline__ void ide_init_default_hwifs(void)
+{
+}
diff --git a/include/asm-arm/arch-nevis/io.h b/include/asm-arm/arch-nevis/io.h
new file mode 100644
index 0000000..e729a44
--- /dev/null
+++ b/include/asm-arm/arch-nevis/io.h
@@ -0,0 +1,53 @@
+/*******************************************************************************
+ *  linux/include/asm-arm/arch-bronco/io.h
+ *
+ *  Copyright (C) 2004 Conexant Systems Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License Version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02111-1307  USA
+ ********************************************************************************/
+
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+/*
+ * Generic virtual read/write
+ */
+#define IO_SPACE_LIMIT		0xffffffff
+
+/*
+ * Generic function to handle IO addresses. In case
+ * we have special handling we could add this here.
+ */
+static inline void __iomem *__io(unsigned long addr)
+{
+	return (void __iomem *) addr;
+}
+
+#define __io(a)                 __io((a))
+#define __mem_pci(a)		(a)
+#define __mem_isa(a)		(a)
+
+/*
+ * Validate the pci memory address for ioremap.
+ * WARNING: address are now always assumed correct.
+ */
+#define iomem_valid_addr(iomem,size)	(1)
+
+/*
+ * Convert PCI memory space to a CPU physical address
+ * WARNING: this is only true if we have a 1:1 mapping.
+ */
+#define iomem_to_phys(iomem)		(iomem)
+
+#endif /* __ASM_ARM_ARCH_IO_H */
diff --git a/include/asm-arm/arch-nevis/irq.h b/include/asm-arm/arch-nevis/irq.h
new file mode 100644
index 0000000..5b904f8
--- /dev/null
+++ b/include/asm-arm/arch-nevis/irq.h
@@ -0,0 +1,37 @@
+/*********************************************************************************
+ *  linux/include/asm-arm/arch-nevis/irq.h
+ *
+ *  Copyright (C) 2007 Conexant Systems Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License Version 2  as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02111-1307  USA
+ ***********************************************************************************/
+/* $Id$
+ ***********************************************************************************/
+#ifndef __ASM_ARCH_NEVIS_IRQ_H
+#define __ASM_ARCH_NEVIS_IRQ_H
+
+#define LATENCY_COUNT	1000
+
+struct s_latency {
+	unsigned int delta[LATENCY_COUNT];
+	unsigned int duration[LATENCY_COUNT];
+	unsigned int count;
+	unsigned int dur_count;
+};
+
+extern void __init cx2450x_init_irq(void);
+
+/* #define fixup_irq(i)  (edwards_cascade_irq(i)) */
+
+#endif /* __ASM_ARCH_IRQ_H */
diff --git a/include/asm-arm/arch-nevis/irqs.h b/include/asm-arm/arch-nevis/irqs.h
new file mode 100644
index 0000000..5d8ef84
--- /dev/null
+++ b/include/asm-arm/arch-nevis/irqs.h
@@ -0,0 +1,55 @@
+/************************************************************************************
+ *  linux/include/asm-arm/arch-nevis/irqs.h
+ *
+ *  Copyright (C) 2007 Conexant Systems Inc.
+ *  Copyright (C) 2008 Coolstream International Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License Version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02111-1307  USA
+ *************************************************************************************/
+
+#ifndef __ASM_ARCH_NEVIS_IRQS_H
+#define __ASM_ARCH_NEVIS_IRQS_H
+
+/* Use the architecture-specific definitions */
+#include <asm/arch/platform.h>
+
+/* Misc. interrupt definitions */
+#define NR_IRQS			352
+#define VALID_PRI_INT_SRC	0x0000FFFF	/* non-reserved bits in primary pic */
+#define VALID_SEC_INT_SRC	0xFFFFC3FF	/* non-reserved bits in secondary pic */
+
+#define IRQ_UART1		 0		/* first UART */
+#define IRQ_UART2		 1		/* second UART */
+#define IRQ_UART3		 2		/* third UART */
+#define IRQ_I2C0		 6		/* first I2C bus */
+#define IRQ_I2C1		 7		/* second I2C bus */
+#define IRQ_IR0			 9		/* first Infrared receiver */
+#define IRQ_IR1			10		/* second Infrared receiver */
+#define IRQ_USB0		13		/* first USB interface */
+#define IRQ_GPIOC		14		/* GPIO controller (global interrupt for chained handler) */
+#define IRQ_USB1		17		/* second USB interface */
+#define IRQ_I2C2		19		/* third I2C bus */
+#define IRQ_USB2		20		/* third USB interface */
+#define IRQ_EMAC0		24		/* first Media Access Controller */
+#define IRQ_EMAC1		25		/* second Media Access Controller */
+#define IRQ_I2C3		27		/* fourth I2C bus */
+#define IRQ_SATA1		35		/* second SATA controller */
+#define IRQ_PCI			37		/* PCI controller */
+#define IRQ_SATA0		42		/* first SATA controller */
+#define IRQ_SC(x)		(  3 + (x))	/* first of the two smardcard interface controllers */
+#define IRQ_IR(x)		(  9 + (x))	/* first of the two Infrared remote controllers */
+#define IRQ_TIMER(x)		( 64 + (x))	/* first of the 16 hardware timer starts at IRQ 64 (count 0 to 15) */
+#define IRQ_GPIO(x)		(128 + (x))	/* first of the 224 GPIO's starts at IRQ 128 (count 0 to 223) */
+
+#endif /* __ASM_ARCH_IRQS_H */
diff --git a/include/asm-arm/arch-nevis/memmap.h b/include/asm-arm/arch-nevis/memmap.h
new file mode 100644
index 0000000..ad93730
--- /dev/null
+++ b/include/asm-arm/arch-nevis/memmap.h
@@ -0,0 +1,60 @@
+/************************************************************************************
+ * linux/include/asm-arm/arch-nevis/cx2450x.h
+ *
+ * global memory map
+ *
+ *  Copyright (C) 2008 Coolstream International Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License Version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02111-1307  USA
+ *************************************************************************************/
+
+#ifndef __MEMMAP_H
+#define __MEMMAP_H
+
+#include <asm/sizes.h>
+
+/*
+ * Fixed Mappings
+ */
+
+/* Virtual Addresses */
+/* #define PCI_MEM_VADDR_BASE	0x80000000  8000.0000 - 9FFF.FFFF */
+#define ASX_VADDR_BASE		0xE0000000 /* E000.0000 - E07F.FFFF */
+#define EXT_IO_VADDR_BASE	0xE1000000 /* E100.0000 - E17F.FFFF */
+#define TEMPEST_VADDR_BASE	0xE4000000 /* E400.0000 - E407.FFFF */
+#define APP_VADDR_BASE		0xE8000000 /* 8000.0000 - 9FFF.FFFF */
+/* #define FLASH_VADDR_BASE	0xF0000000  FC00.0000 - FCFF.FFFF */
+
+/* MFB: TODO: remove me */
+#define IO_BASE			(ASX_VADDR_BASE)
+#define IO_ADDRESS(x)		(((x) & 0x00ffffff) | IO_BASE)
+
+/* Mapping Range */
+#define PCI_MEM_SIZE		0x20000000
+#define PCI_IO_SIZE		0x00100000
+#define ASX_IO_SIZE		0x01000000
+#define EXT_IO_SIZE     	0x01000000	/* EXT IO ecompases PCI IO and ISA IO */
+#define TEMPEST_IO_SIZE		0x01000000
+#define APP_IO_SIZE		0x00040000 // SZ_64K
+#define FLASH_IO_SIZE		SZ_32M
+
+/* Physical Addresses */
+#define FLASH_PHYS_BASE		0xF0000000
+#define ASX_PHYS_BASE		0xE0000000
+#define EXT_IO_PHYS_BASE	0xE1000000	/* Include PCI IO and ISA IO */
+#define TEMPEST_PHYS_BASE	0xE4000000
+#define PCI_MEM_PHYS_BASE	0x80000000
+#define APP_PHYS_BASE		0xE8000000
+
+#endif /*__MEMMAP_H */
diff --git a/include/asm-arm/arch-nevis/memory.h b/include/asm-arm/arch-nevis/memory.h
new file mode 100644
index 0000000..e974f8b
--- /dev/null
+++ b/include/asm-arm/arch-nevis/memory.h
@@ -0,0 +1,103 @@
+/********************************************************************************
+ *  linux/include/asm-arm/arch-nevis/memory.h
+ *
+ *  Copyright (C) 2007 Conexant Systems Inc.
+ *  Copyright (C) 2008 Coolstream International Limited.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License Version 2 as published by
+ *  the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02111-1307  USA
+ *
+ *********************************************************************************/
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+/* for PAGE_SHIFT */
+#include <asm/page.h>
+#include <asm/memory.h>
+
+/*
+ * Physical start address of the RAM
+ */
+#define PHYS_OFFSET		UL(0x00000000)
+
+/*
+ * Page offset of the kernel memory
+ */
+#define PAGE_OFFSET		UL(0x80000000)
+
+/*
+ * Task size: 1GB
+ */
+#define TASK_SIZE       	UL(0x7F000000)
+#define TASK_UNMAPPED_BASE	(PAGE_ALIGN((TASK_SIZE + 0x10000000) / 3))
+
+/*
+ * On brazos and trinity, the dram is contiguous
+ */
+#define __virt_to_phys__is_a_macro
+#define __virt_to_phys(vpage) ((vpage) - PAGE_OFFSET + PHYS_OFFSET)
+#define __phys_to_virt__is_a_macro
+#define __phys_to_virt(ppage) ((ppage) + PAGE_OFFSET - PHYS_OFFSET)
+
+#define __virt_to_bus__is_a_macro
+#define __virt_to_bus(x)	__virt_to_phys(x)
+#define __bus_to_virt__is_a_macro
+#define __bus_to_virt(x)	__phys_to_virt(x)
+
+#if 0
+/*
+ * For now we disable this. This might be needed in the future when
+ * we have our own driver code.
+ */
+
+#ifndef __ASSEMBLY__
+/*
+ * Restrict DMA-able region to workaround silicon bug.  The bug
+ * restricts buffers available for DMA to video hardware to be
+ * below 128M
+ */
+static inline void
+__arch_adjust_zones(int node, unsigned long *size, unsigned long *holes)
+{
+        unsigned int sz = (x << 20) >> PAGE_SHIFT;
+
+        if (node != 0)
+                sz = 0;
+
+        size[1] = size[0] - sz;
+        size[0] = sz;
+}
+
+#define arch_adjust_zones(node, zone_size, holes) \
+		__arch_adjust_zones(node, zone_size, holes)
+
+#define ISA_DMA_THRESHOLD	(PHYS_OFFSET + (x<<20) - 1)
+#endif
+
+#endif
+
+/*
+ * Given a physical address, convert it to a node id.
+ * WARNING: HACK! this might be causing issues when we don't
+ *	    have contiguous memory.
+ */
+#define PHYS_TO_NID(addr)	(0)
+
+/*
+ * Needed for discontiguous memory. Defines the maximum nr of bits
+ * that one node needs to define one bank.
+ */
+/*#define NODE_MEM_SIZE_BITS	27*/
+
+#endif /* __ASM_ARCH_MEMORY_H */
diff --git a/include/asm-arm/arch-nevis/param.h b/include/asm-arm/arch-nevis/param.h
new file mode 100644
index 0000000..ef44e54
--- /dev/null
+++ b/include/asm-arm/arch-nevis/param.h
@@ -0,0 +1,34 @@
+/**************************************************************************************
+ *  linux/include/asm-arm/arch-nevis/param.h
+ *
+ *  Copyright (C) 2007 Conexant Systems Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License Version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02111-1307  USA
+ ***************************************************************************************/
+
+/* FIXME: can we get rid of this file ? */
+
+/* tick rate */
+/* FIXME: take this from kernel configuration. */
+#define HZ	100
+
+#if HZ != 100
+#define hz_to_std(a) (((a)*HZ)/100)
+#endif
+
+/**************************************************************************************
+ * Modifications:
+ * $Log$
+ *
+ ***************************************************************************************/
diff --git a/include/asm-arm/arch-nevis/platform.h b/include/asm-arm/arch-nevis/platform.h
new file mode 100644
index 0000000..0cc0390
--- /dev/null
+++ b/include/asm-arm/arch-nevis/platform.h
@@ -0,0 +1,40 @@
+/************************************************************************************
+ * include/asm-arm/arch-nevis/platform.h
+ *
+ * Copyright (C) 2008 CoolStream International Limited.
+ * Copyright (C) 2007 Conexant Systems Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License Version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02111-1307  USA
+ **************************************************************************************/
+
+#ifndef __PLATFORM_H
+#define __PLATFORM_H
+
+#include <asm/arch/hardware.h>
+#include <asm/types.h>
+
+typedef enum _PLL_SOURCE {
+        ARM_PLL_SOURCE = 0,
+        MEM_PLL_SOURCE,
+        MPG0_PLL_SOURCE,
+        FENRUS_PLL_SOURCE
+} PLL_SOURCE;
+
+extern void CalcClkFreqAndPeriod(unsigned int *frequency,
+                                 unsigned int *period,
+                                 unsigned int pll_source,
+                                 unsigned int xtal_freq);
+
+
+#endif /* __PLATFORM_H */
diff --git a/include/asm-arm/arch-nevis/startup.h b/include/asm-arm/arch-nevis/startup.h
new file mode 100644
index 0000000..39ed303
--- /dev/null
+++ b/include/asm-arm/arch-nevis/startup.h
@@ -0,0 +1,84 @@
+/****************************************************************************
+ * include/asm-arm/arch-nevis/startup.h
+ *
+ * Copyright (C) 2007 Conexant Systems Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License Version 2as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02111-1307  USA
+
+ ****************************************************************************/
+/* $Id $
+ ****************************************************************************/
+
+
+/* GET RID OFF */
+
+#ifndef _STARTUP_H
+#define _STARTUP_H
+
+/*****************/
+/* Include Files */
+/*****************/
+#include <asm/arch/hardware.h>
+
+/****************************************************************************/
+/*                                                                          */
+/* Hardware register access macros                                          */
+/*                                                                          */
+/****************************************************************************/
+
+#define RMO(y)                   ( ((y) & 0x00000001) ?  0 : \
+                                   ( ((y) & 0x00000002) ?  1 : \
+                                     ( ((y) & 0x00000004) ?  2 : \
+                                       ( ((y) & 0x00000008) ?  3 : \
+                                         ( ((y) & 0x00000010) ?  4 : \
+                                           ( ((y) & 0x00000020) ?  5 : \
+                                             ( ((y) & 0x00000040) ?  6 : \
+                                               ( ((y) & 0x00000080) ?  7 : \
+                                                 ( ((y) & 0x00000100) ?  8 : \
+                                                   ( ((y) & 0x00000200) ?  9 : \
+                                                     ( ((y) & 0x00000400) ? 10 : \
+                                                       ( ((y) & 0x00000800) ? 11 : \
+                                                         ( ((y) & 0x00001000) ? 12 : \
+                                                           ( ((y) & 0x00002000) ? 13 : \
+                                                             ( ((y) & 0x00004000) ? 14 : \
+                                                               ( ((y) & 0x00008000) ? 15 : \
+                                                                 ( ((y) & 0x00010000) ? 16 : \
+                                                                   ( ((y) & 0x00020000) ? 17 : \
+                                                                     ( ((y) & 0x00040000) ? 18 : \
+                                                                       ( ((y) & 0x00080000) ? 19 : \
+                                                                         ( ((y) & 0x00100000) ? 20 : \
+                                                                           ( ((y) & 0x00200000) ? 21 : \
+                                                                             ( ((y) & 0x00400000) ? 22 : \
+                                                                               ( ((y) & 0x00800000) ? 23 : \
+                                                                                 ( ((y) & 0x01000000) ? 24 : \
+                                                                                   ( ((y) & 0x02000000) ? 25 : \
+                                                                                     ( ((y) & 0x04000000) ? 26 : \
+                                                                                       ( ((y) & 0x08000000) ? 27 : \
+                                                                                         ( ((y) & 0x10000000) ? 28 : \
+                                                                                           ( ((y) & 0x20000000) ? 29 : \
+                                                                                             ( ((y) & 0x40000000) ? 30 : \
+                                                                                               ( ((y) & 0x80000000) ? 31 : 0 ))))))))))))))))))))))))))))))))
+
+#endif
+
+/****************************************************************************
+ * Modifications:
+ * $Log:
+ *  3    Linux_SDK 1.2         6/14/07 6:25:34 PM IST Debashish Rath  Header
+ *       file include which was not needed is removed
+ *  2    Linux_SDK 1.1         3/27/07 5:43:24 PM IST Satpal Parmar   GPL
+ *       header and Starteam footer addition.
+ *  1    Linux_SDK 1.0         3/1/07 11:47:20 PM IST Vineet Seth     
+ * $
+ ****************************************************************************/
diff --git a/include/asm-arm/arch-nevis/system.h b/include/asm-arm/arch-nevis/system.h
new file mode 100644
index 0000000..d30a881
--- /dev/null
+++ b/include/asm-arm/arch-nevis/system.h
@@ -0,0 +1,47 @@
+/***********************************************************************************
+ *  linux/include/asm-arm/arch-nevis/system.h
+ *
+ *  Copyright (C) 2007 Conexant Systems Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02111-1307  USA
+ *************************************************************************************/
+
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+#include <asm/io.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/cx2450x.h>
+
+void cnxt_mip_idle(void);
+
+static inline void arch_idle(void)
+{
+	/* The 'normal' thing is to call cpu_do_idle();     */
+	/* which puts the cpu in 'wait for interrupt' mode. */
+
+	/* FIXME! Implement mipidle stuff from here - DAVEM */
+	/* cpu_do_idle(); */
+	cnxt_mip_idle();	/* noida  neeraj */
+
+}
+
+static inline void arch_reset(char mode)
+{
+	/* Any write to this register resets the IRD! */
+	writel(0x0, (void *) ASX_TO_VIRT(SYS_SOFTRESET_REG));
+	while (1); /* not-reached */
+}
+
+#endif /* __ASM_ARCH_SYSTEM_H */
diff --git a/include/asm-arm/arch-nevis/time.h b/include/asm-arm/arch-nevis/time.h
new file mode 100644
index 0000000..3d281fc
--- /dev/null
+++ b/include/asm-arm/arch-nevis/time.h
@@ -0,0 +1,37 @@
+/***********************************************************************************
+ *  linux/include/asm-arm/arch-nevis/time.h
+ *
+ *  Copyright (C) 2007 Conexant Systems Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License Version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02111-1307  USA
+ ************************************************************************************/
+
+#ifndef __LINUX_ARCH_TIME_H__
+#define __LINUX_ARCH_TIME_H__
+
+#include <asm/system.h>
+#include <asm/irq.h>
+#include <asm-arm/io.h>
+#include <linux/interrupt.h>
+
+
+/* Clock ticks at 54 Mhz, giving maximum 79.5sec count */
+#define uSEC_1 54
+#define TIMER_INTERVAL	((uSEC_1 * 1000000) / HZ)
+
+void cx2450x_unlock_timer(u32 timer_number);
+s32 cx2450x_lock_timer(u32 timer_number);
+s32 cx2450x_softlock_timer(u32 timer_number);
+
+#endif	/* __LINUX_ARCH_TIME_H__ */
diff --git a/include/asm-arm/arch-nevis/timex.h b/include/asm-arm/arch-nevis/timex.h
new file mode 100644
index 0000000..b438f62
--- /dev/null
+++ b/include/asm-arm/arch-nevis/timex.h
@@ -0,0 +1,24 @@
+/**************************************************************************************
+ *  linux/include/asm-arm/arch-nevis/timex.h
+ *  
+ *  Copyright (C) 2007 Conexant Systems Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License Version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,51 Franklin St, Fifth Floor, Boston, MA  02111-1307  USA
+ ***************************************************************************************/
+#ifndef __ASM_ARCH_TIMEX_H
+#define __ASM_ARCH_TIMEX_H
+
+#define CLOCK_TICK_RATE		1000000
+
+#endif /* __ASM_ARCH_TIMEX_H */
diff --git a/include/asm-arm/arch-nevis/uncompress.h b/include/asm-arm/arch-nevis/uncompress.h
new file mode 100644
index 0000000..7d64872
--- /dev/null
+++ b/include/asm-arm/arch-nevis/uncompress.h
@@ -0,0 +1,184 @@
+/* linux/include/asm-arm/arch-nevis/uncompress.h
+ *
+ *  Copyright (C) 2008 Coolstream International Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ *(at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_UNCOMPRESS_H
+#define __ASM_ARCH_UNCOMPRESS_H
+
+/* This code is only necessary if:
+ *  - you use a zImage 
+ *  - your architecture can only talk to you via serial ports
+ *  - you wanna see the "Uncompressing Linux..." on the serial port
+ */
+
+#include <linux/autoconf.h>
+#include <asm/arch/cx2450x.h>
+
+#ifdef CONFIG_SERIAL_CX2450X_BOOTMSG
+#define BAUDRATE	CONFIG_CX2450X_BAUD_RATE
+
+static int have_uart[3];
+
+#endif	/* CONFIG_SERIAL_CX2450X_BOOTMSG */
+
+/*******************************************************************************/
+
+static inline void putc(char c)
+{
+#ifdef CONFIG_SERIAL_CX2450X_BOOTMSG
+    u32 val;
+    volatile u8 *FIFO;
+    volatile u8 *TXST;
+
+    for (val = 0; val < 3; val++)
+    {
+	if (have_uart[val])
+	{
+	    FIFO = (volatile u8*)(UART_FIFO_BRDL_REG(val));
+	    TXST = (volatile u8*)(UART_TXSTA_REG(val));
+
+	    while (*TXST & 0x1F);
+	    *FIFO = c;
+
+	    if (c == '\n')
+	    {
+		while (*TXST & 0x1F);
+		*FIFO = '\r';
+	    }
+	}
+    }
+#endif	/* CONFIG_SERIAL_CX2450X_BOOTMSG */
+}
+
+/*******************************************************************************/
+
+static inline void flush(void)
+{
+	/* nothing to do here */
+}
+
+/*******************************************************************************/
+
+static __inline__ void arch_decomp_setup(void)
+{
+#ifdef CONFIG_SERIAL_CX2450X_BOOTMSG
+    volatile u32 *reg;
+    volatile u8 *FIFO;
+    volatile u8 *IRQE;
+    volatile u8 *FIFC;
+    volatile u8 *FRMC;
+    u32 val;
+    u32 brdiv = (54000000 / (16 * BAUDRATE)) - 1;
+
+#ifdef CONFIG_SERIAL_CX2450X_UART1_ENABLE
+    /* check for UART 1 (PIO 1 (TX), PIO 2 (RX)) */
+    have_uart[0] = 0;
+    reg = (volatile u32*) SREG_SEC_MUX_REG_BASE(0);
+    if ((*reg & 0x00000006) == 0)
+    {
+	reg = (volatile u32*) SREG_PRI_MUX_REG_BASE(0);
+	if ((*reg & 0x00000006) == 0x00000006)
+	    have_uart[0] = 1;
+    }
+#endif
+
+#ifdef CONFIG_SERIAL_CX2450X_UART2_ENABLE
+    /* check for UART 2 (can be configured on various pins) */
+    have_uart[1] = 0;
+    reg = (volatile u32*) SREG_ALT_PIN_FUNC_REG;
+    val = (*reg >> 4) & 0x03;
+    if (val == 0)	/* PIO 3 (TX), 4 (RX) */
+    {
+	reg = (volatile u32*) SREG_SEC_MUX_REG_BASE(0);
+	if ((*reg & 0x00000018) == 0)
+	{
+	    reg = (volatile u32*) SREG_PRI_MUX_REG_BASE(0);
+	    if ((*reg & 0x00000018) == 0x00000018)
+		have_uart[1] = 1;
+	}
+    
+    }
+    else if (val == 1)	/* PIO 71 (RX), 72 (TX) */
+    {
+	reg = (volatile u32*) SREG_SEC_MUX_REG_BASE(2);
+	if ((*reg & 0x00000018) == 0)
+	{
+	    reg = (volatile u32*) SREG_PRI_MUX_REG_BASE(2);
+	    if ((*reg & 0x00000018) == 0x00000018)
+		have_uart[1] = 1;
+	}
+    }
+    else if (val == 2)	/* PIO 11 (RX), 73 (TX) */
+    {
+	reg = (volatile u32*) SREG_SEC_MUX_REG_BASE(2);
+	if ((*reg & 0x00000020) == 0)
+	{
+	    reg = (volatile u32*) SREG_PRI_MUX_REG_BASE(2);
+	    if ((*reg & 0x00000020) == 0x00000020)
+	    {
+		reg = (volatile u32*) SREG_SEC_MUX_REG_BASE(0);
+		if ((*reg & 0x00000800) == 0)
+		{
+		    reg = (volatile u32*) SREG_PRI_MUX_REG_BASE(0);
+		    if ((*reg & 0x00000800) == 0x00000800)
+			have_uart[1] = 1;
+		}
+	    }
+	}
+    }
+#endif
+
+#ifdef CONFIG_SERIAL_CX2450X_UART3_ENABLE
+    /* check for UART 3 (PIO 14 (TX), PIO 15 (RX)) */
+    have_uart[2] = 0;
+    reg = (volatile u32*) SREG_SEC_MUX_REG_BASE(0);
+    if ((*reg & 0x0000C000) == 0)
+    {
+	reg = (volatile u32*) SREG_PRI_MUX_REG_BASE(0);
+	if ((*reg & 0x0000C000) == 0x0000C000)
+	    have_uart[2] = 1;
+    }
+
+    for (val = 0; val < 3; val++)
+    {
+	if (have_uart[val])
+	{
+	    FIFO = (volatile u8*)(UART_FIFO_BRDL_REG(val));
+	    IRQE = (volatile u8*)(UART_IRQE_BRDU_REG(val));
+	    FIFC = (volatile u8*)(UART_FIFC_REG(val));
+	    FRMC = (volatile u8*)(UART_FRMC_REG(val));
+
+    	    /* setup Baudradte */
+    	    *FRMC |= 0x80;		/* set BDS to access FIFO and IRQE as baudrate registers */
+    	    *FIFO = brdiv & 0xFF;
+    	    *IRQE = (brdiv >> 8) & 0xFF;
+    	    *FRMC &= 0x7F;
+    	    *IRQE = 0x00;
+    	    *FRMC = 0x01;		/* 8 databits, 1 stopbit, no parity */
+    	    *FIFC = 0x03;		/* clear RX-RX-FIFO */
+	}
+    }
+#endif
+#endif	/* CONFIG_SERIAL_CX2450X_BOOTMSG */
+}
+
+/*******************************************************************************/
+
+#define arch_decomp_wdog()
+
+#endif /* __ASM_ARCH_UNCOMPRESS_H */
diff --git a/include/asm-arm/arch-nevis/vmalloc.h b/include/asm-arm/arch-nevis/vmalloc.h
new file mode 100644
index 0000000..eeb4459
--- /dev/null
+++ b/include/asm-arm/arch-nevis/vmalloc.h
@@ -0,0 +1,34 @@
+/*******************************************************************************************
+ *  linux/include/asm-arm/arch-nevis/vmalloc.h
+ *
+ *  Copyright (C) 2008 CoolStream International Limited.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License Version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02111-1307  USA
+ *********************************************************************************************/
+
+#ifndef __ASM_ARCH_VMALLOC_H
+#define __ASM_ARCH_VMALLOC_H
+/*
+ * The maximum addressable memory on Nevis is 512MB, so we need to put the kernel virtual
+ * memory above at least 512MB to be able to address the whole range. Also we have an hole
+ * of 8 MB to detect out of bound ranges. So pick a number here that is at least above 512 MB 
+ * and the 8MB hole. WARNING: Make sure we don't overlap with 0x80000000 PCI memory! In case
+ * we have a 1:1 mapping and put this inside the static mapping table, it will be overwritten
+ * by the vm.
+ *
+ */
+#define VMALLOC_OFFSET    (8*1024*1024)
+#define VMALLOC_START     (MODULE_END + VMALLOC_OFFSET)
+#define VMALLOC_END       (VMALLOC_START + CONFIG_CNXT_VMALLOC_SIZE)
+#endif
diff --git a/include/asm-arm/arm11jmp.h b/include/asm-arm/arm11jmp.h
new file mode 100644
index 0000000..627c291
--- /dev/null
+++ b/include/asm-arm/arm11jmp.h
@@ -0,0 +1,35 @@
+/* linux/include/asm-arm/arm11jmp.h
+ *
+ * prototypes for setjmp and longjump on Trident CX2450x (ARM11)
+ *
+ * Copyright (C) 2010 CoolStream International Limited.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef __ARM11JMP__
+#define __ARM11JMP__
+
+typedef int    __jmp_buf[64];
+typedef struct __jmp_buf_tag
+{
+   __jmp_buf __jmpbuf;
+} jmp_buf[1];
+
+int  _setjmp (jmp_buf __env);
+void longjmp (jmp_buf __env, int __val);
+
+#endif /* __ARM11JMP__ */
+
diff --git a/include/asm-arm/cacheflush.h b/include/asm-arm/cacheflush.h
index 759a97b..a2660d2bf 100644
--- a/include/asm-arm/cacheflush.h
+++ b/include/asm-arm/cacheflush.h
@@ -300,16 +300,6 @@ static inline void outer_flush_range(unsigned long start, unsigned long end)
 #endif
 
 /*
- * flush_cache_vmap() is used when creating mappings (eg, via vmap,
- * vmalloc, ioremap etc) in kernel space for pages.  Since the
- * direct-mappings of these pages may contain cached data, we need
- * to do a full cache flush to ensure that writebacks don't corrupt
- * data placed into these pages via the new mappings.
- */
-#define flush_cache_vmap(start, end)		flush_cache_all()
-#define flush_cache_vunmap(start, end)		flush_cache_all()
-
-/*
  * Copy user data from/to a page which is mapped into a different
  * processes address space.  Really, we want to allow our "user
  * space" model to handle this.
@@ -410,6 +400,20 @@ extern void flush_dcache_page(struct page *);
 
 extern void __flush_dcache_page(struct address_space *mapping, struct page *page);
 
+static inline void __flush_icache_all(void)
+{
+	asm(
+#ifndef CONFIG_ARM_ERRATA_411920
+	    "mcr	p15, 0, %0, c7, c5, 0	@ invalidate I-cache\n"
+#else
+	    "bl		v6_icache_inval_all\n"
+#endif
+	    "mcr	p15, 0, %0, c7, c5, 6	@ flush BTAC/BTB\n"
+	    :
+	    : "r" (0)
+	    : "r0", "r1", "lr", "cc");
+}
+
 #define ARCH_HAS_FLUSH_ANON_PAGE
 static inline void flush_anon_page(struct vm_area_struct *vma,
 			 struct page *page, unsigned long vmaddr)
@@ -522,4 +526,29 @@ static inline void flush_ioremap_region(unsigned long phys, void __iomem *virt,
 
 #endif
 
+/*
+ * flush_cache_vmap() is used when creating mappings (eg, via vmap,
+ * vmalloc, ioremap etc) in kernel space for pages.  Since the
+ * direct-mappings of these pages may contain cached data, we need
+ * to do a full cache flush to ensure that writebacks don't corrupt
+ * data placed into these pages via the new mappings.
+ */
+static inline void flush_cache_vmap(unsigned long start, unsigned long end)
+{
+	if (!cache_is_vipt_nonaliasing())
+		flush_cache_all();
+	else
+		/*
+		 * set_pte_at() called from vmap_pte_range() does not
+		 * have a DSB after cleaning the cache line.
+		 */
+		dsb();
+}
+
+static inline void flush_cache_vunmap(unsigned long start, unsigned long end)
+{
+	if (!cache_is_vipt_nonaliasing())
+		flush_cache_all();
+}
+
 #endif
diff --git a/include/asm-arm/hardware/serial_cnxt.h b/include/asm-arm/hardware/serial_cnxt.h
new file mode 100644
index 0000000..6a23d3c
--- /dev/null
+++ b/include/asm-arm/hardware/serial_cnxt.h
@@ -0,0 +1,97 @@
+/*
+ *  linux/include/asm-arm/hardware/serial_rio.h
+ *
+ *  Internal header file for CNXT  serial ports
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef ASM_ARM_HARDWARE_SERIAL_CNXT_H
+#define ASM_ARM_HARDWARE_SERIAL_CNXT_H
+
+/*
+ *  UART Register Offsets.
+ */
+#define CNXT_BRDL                       0x0   /* lower byte of baud rate  divisor */
+#define CNXT_BRDH                       0x4   /* lower byte of baud rate  divisor */
+#define CNXT_FIFO                       0x0
+#define CNXT_IRQE                       0x4
+#define CNXT_FIFC                       0x8
+#define CNXT_FRMC                       0xc
+#define CNXT_STAT                       0x14
+#define CNXT_IRLVL                      0x18
+#define CNXT_TXSTA                      0x28
+#define CNXT_RXSTA                      0x2c
+
+#define CNXT_EXP                        0x30  /* Fractional Baud Rate Divisor */
+                                              /* 2-bit for regular UART */
+                                              /* 6-bit for HS UART */
+
+#define CNXT_EXCTL                      0x3C  /* Expanded Control Register */
+                                              /* HS UART */
+
+#define CNXT_IRQE_ERFE   0x80
+#define CNXT_IRQE_TIDE   0x40
+#define CNXT_IRQE_TSRE   0x20
+#define CNXT_IRQE_RBKE   0x10
+#define CNXT_IRQE_FREE   0x08
+#define CNXT_IRQE_PAEE   0x04
+#define CNXT_IRQE_RFOE   0x02
+#define CNXT_IRQE_RSRE   0x01
+
+#define CNXT_FIFC_RFT_ONE  0x00
+#define CNXT_FIFC_RFT_FOUR 0x40
+#define CNXT_FIFC_RFT_EIGHT 0x80
+#define CNXT_FIFC_RFT_TWLV  0xc0
+#define CNXT_FIFC_TFT_FOUR  0x00
+#define CNXT_FIFC_TFT_EIGHT 0x10
+#define CNXT_FIFC_TFT_TWLV  0x20
+#define CNXT_FIFC_TFT_SXTN  0x30
+#define CNXT_FIFC_TFC       0x04
+#define CNXT_FIFC_RFC       0x02
+
+#define CNXT_FRMC_BDS    0x80
+#define CNXT_FRMC_TBK    0x40
+#define CNXT_FRMC_POR    0x20
+#define CNXT_FRMC_EOP    0x10
+#define CNXT_FRMC_PEN    0x08
+#define CNXT_FRMC_SBS    0x04
+#define CNXT_FRMC_LBM    0x02
+#define CNXT_FRMC_FRS    0x01
+
+#define CNXT_STAT_ERF    0x80
+#define CNXT_STAT_TID    0x40
+#define CNXT_STAT_TSR    0x20
+#define CNXT_STAT_RBK    0x10
+#define CNXT_STAT_FRE    0x08
+#define CNXT_STAT_PAE    0x04
+#define CNXT_STAT_RFO    0x02
+#define CNXT_STAT_RSR    0x01
+
+#define CNXT_EXCTL_HSM   0x80
+#define CNXT_EXCTL_OSP   0x40
+#define CNXT_EXCTL_RTS   0x20
+#define CNXT_EXCTL_DMATX 0x10
+#define CNXT_EXCTL_DMARX 0x08
+#define CNXT_EXCTL_FCEN  0x04
+#define CNXT_EXCTL_RXFC_ONE   0x00
+#define CNXT_EXCTL_RXFC_FOUR  0x01
+#define CNXT_EXCTL_RXFC_EIGHT 0x02
+#define CNXT_EXCTL_RXFC_FRTN  0x03
+
+#define CNXT_STAT_ANY    (CNXT_STAT_RBK | CNXT_STAT_FRE | \
+                         CNXT_STAT_PAE | CNXT_STAT_RFO)
+
+
+#endif
diff --git a/include/asm-arm/memory.h b/include/asm-arm/memory.h
index 9ba4d71..ff3785c 100644
--- a/include/asm-arm/memory.h
+++ b/include/asm-arm/memory.h
@@ -54,8 +54,14 @@
  * The module space lives between the addresses given by TASK_SIZE
  * and PAGE_OFFSET - it must be within 32MB of the kernel text.
  */
-#define MODULE_END		(PAGE_OFFSET)
-#define MODULE_START		(MODULE_END - 16*1048576)
+
+#if (defined(CONFIG_ARCH_PECOS) || defined(CONFIG_ARCH_NEVIS))
+#define MODULE_START            (PAGE_OFFSET + TEXT_OFFSET + CONFIG_CNXT_MODULE_START_OFFSET)
+#define MODULE_END              (MODULE_START + CONFIG_CNXT_MODULE_ADDRESS_SPACE_SIZE)
+#else
+#define MODULE_END              (PAGE_OFFSET)
+#define MODULE_START            (MODULE_END - 16*1048576)
+#endif
 
 #if TASK_SIZE > MODULE_START
 #error Top of user space clashes with start of module space
diff --git a/include/asm-arm/mmu_context.h b/include/asm-arm/mmu_context.h
index 6913d02..91b9dfd 100644
--- a/include/asm-arm/mmu_context.h
+++ b/include/asm-arm/mmu_context.h
@@ -97,6 +97,11 @@ switch_mm(struct mm_struct *prev, struct mm_struct *next,
 #ifdef CONFIG_MMU
 	unsigned int cpu = smp_processor_id();
 
+#ifdef CONFIG_SMP
+	/* check for possible thread migration */
+	if (!cpus_empty(next->cpu_vm_mask) && !cpu_isset(cpu, next->cpu_vm_mask))
+		__flush_icache_all();
+#endif
 	if (!cpu_test_and_set(cpu, next->cpu_vm_mask) || prev != next) {
 		check_context(next);
 		cpu_switch_mm(next->pgd, next);
diff --git a/include/asm-arm/processor.h b/include/asm-arm/processor.h
index bd8029e..140a14b 100644
--- a/include/asm-arm/processor.h
+++ b/include/asm-arm/processor.h
@@ -23,8 +23,10 @@
 #include <asm/types.h>
 
 #ifdef __KERNEL__
-#define STACK_TOP	((current->personality == PER_LINUX_32BIT) ? \
+#define STACK_TOP	((current->personality & ADDR_LIMIT_32BIT) ? \
 			 TASK_SIZE : TASK_SIZE_26)
+/*#define STACK_TOP	((current->personality == PER_LINUX_32BIT) ? \
+			 TASK_SIZE : TASK_SIZE_26) */
 #define STACK_TOP_MAX	TASK_SIZE
 #endif
 
@@ -112,9 +114,9 @@ extern int kernel_thread(int (*fn)(void *), void *arg, unsigned long flags);
 static inline void prefetch(const void *ptr)
 {
 	__asm__ __volatile__(
-		"pld\t%0"
+		"pld\t%a0"
 		:
-		: "o" (*(char *)ptr)
+		: "p" (ptr)
 		: "cc");
 }
 
diff --git a/include/asm-arm/setup.h b/include/asm-arm/setup.h
index 7bbf105..5fdffbc 100644
--- a/include/asm-arm/setup.h
+++ b/include/asm-arm/setup.h
@@ -136,6 +136,26 @@ struct tag_acorn {
 	__u8 adfsdrives;
 };
 
+/* conexant pecos/nevis specific for reading the MAC address */
+#define	ATAG_MAC	0x5441000A
+
+struct tag_mac {
+          __u8 mac_addr[6];
+};
+
+/* conexant pecos/nevis specific for specifying the reserved memory
+ * locations.
+ * see arch/arm/mach-nevis/mach.c
+ */
+#define	ATAG_DECARM	0x5441000B
+
+struct tag_decarm {
+	__u32 uSize;
+	__u32 uStart;
+	__u32 uSharedRAMSize;
+	__u32 uSharedRAMStart;
+};
+
 /* footbridge memory clock, see arch/arm/mach-footbridge/arch.c */
 #define ATAG_MEMCLK	0x41000402
 
@@ -162,6 +182,12 @@ struct tag {
 		struct tag_acorn	acorn;
 
 		/*
+		 * Conexant Nevis / Pecos specific
+		 */
+		struct tag_mac mac;
+		struct tag_decarm decarm;
+
+		/*
 		 * DC21285 specific
 		 */
 		struct tag_memclk	memclk;
diff --git a/include/linux/kernel.h b/include/linux/kernel.h
index 2e70006..146306b 100644
--- a/include/linux/kernel.h
+++ b/include/linux/kernel.h
@@ -355,17 +355,21 @@ static inline char *pack_hex_byte(char *buf, u8 byte)
  * strict type-checking.. See the
  * "unnecessary" pointer comparison.
  */
+#ifndef min
 #define min(x, y) ({				\
 	typeof(x) _min1 = (x);			\
 	typeof(y) _min2 = (y);			\
 	(void) (&_min1 == &_min2);		\
 	_min1 < _min2 ? _min1 : _min2; })
+#endif
 
+#ifndef max
 #define max(x, y) ({				\
 	typeof(x) _max1 = (x);			\
 	typeof(y) _max2 = (y);			\
 	(void) (&_max1 == &_max2);		\
 	_max1 > _max2 ? _max1 : _max2; })
+#endif
 
 /**
  * clamp - return a value clamped to a given range with strict typechecking
diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index d8f31de..80f6291 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -158,6 +158,9 @@
 
 #define PORT_SC26XX	82
 
+/* Conexant CX2450X */
+#define PORT_CNXT	83
+
 #ifdef __KERNEL__
 
 #include <linux/compiler.h>
-- 
1.7.10.4

